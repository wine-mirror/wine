#! /usr/bin/perl -w
#
# Build the server protocol definitions
# from the contents of server/protocol.def.
#
# Copyright (C) 1998 Alexandre Julliard
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
#
use strict;

my %formats =
(                     # size align format
    "int"           => [  4,   4,  "%d" ],
    "short int"     => [  2,   2,  "%d" ],
    "char"          => [  1,   1,  "%c" ],
    "unsigned char" => [  1,   1,  "%02x" ],
    "unsigned short"=> [  2,   2,  "%04x" ],
    "unsigned int"  => [  4,   4,  "%08x" ],
    "data_size_t"   => [  4,   4,  "%u" ],
    "obj_handle_t"  => [  4,   4,  "%04x" ],
    "atom_t"        => [  4,   4,  "%04x" ],
    "process_id_t"  => [  4,   4,  "%04x" ],
    "thread_id_t"   => [  4,   4,  "%04x" ],
    "d3dkmt_handle_t"=>[  4,   4,  "%08x" ],
    "unsigned __int64" => [ 8, 8,  "&uint64" ],
    "timeout_t"     => [  8,   8 ],
    "abstime_t"     => [  8,   8 ],
    "ioctl_code_t"  => [  4,   4 ],
    # structures and unions
    "union apc_call"           => [ 64, 8 ],
    "union apc_result"         => [ 40, 8 ],
    "struct async_data"        => [ 40, 8 ],
    "struct context_data"      => [ 1720, 8 ],
    "struct cursor_pos"        => [ 24, 8 ],
    "union debug_event_data"   => [ 160, 8 ],
    "struct filesystem_event"  => [ 12, 4 ],
    "struct generic_map"       => [ 16, 4 ],
    "struct handle_info"       => [ 20, 4 ],
    "union hw_input"           => [ 40, 8 ],
    "union irp_params"         => [ 32, 8 ],
    "struct luid"              => [  8, 4 ],
    "struct luid_attr"         => [ 12, 4 ],
    "union message_data"       => [ 48, 8 ],
    "struct object_attributes" => [ 16, 4 ],
    "struct object_type_info"  => [ 44, 4 ],
    "struct obj_locator"       => [ 16, 8 ],
    "struct pe_image_info"     => [ 96, 8 ],
    "struct process_info"      => [ 40, 8 ],
    "struct property_data"     => [ 16, 8 ],
    "struct rawinput_device"   => [ 12, 4 ],
    "struct rectangle"         => [ 16, 4 ],
    "union select_op"          => [ 264, 8 ],
    "struct startup_info_data" => [ 96, 4 ],
    "union tcp_connection"     => [ 60, 4 ],
    "struct thread_info"       => [ 40, 8 ],
    "union udp_endpoint"       => [ 32, 4 ],
    "struct user_apc"          => [ 40, 8 ],
);

my $file_header =
    "/*\n * Wine server protocol definitions\n *\n" .
    " * This file is automatically generated; DO NO EDIT!\n" .
    " * Edit server/protocol.def instead and re-run tools/make_requests\n" .
    " */\n\n";

my @requests = ();
my %replies = ();
my %dump_funcs = ();
my @asserts = ();

my @protocol_lines = ();
my @trace_lines = ();

my $max_req_size = 64;

my $warnings = scalar(@ARGV) && $ARGV[0] eq "-w";

sub add_padding($$)
{
    my ($offset, $padding) = @_;
    if ($offset % $padding)
    {
        my $count = $padding - ($offset % $padding);
        push @protocol_lines,  "    char __pad_$offset\[$count\];\n";
        $offset += $count;
    }
    return $offset;
}

### Generate a dumping function

sub DO_DUMP_FUNC($$@)
{
    my $name = shift;
    my $req = shift;
    my $prefix = " ";
    push @trace_lines, "static void dump_${name}_$req( const struct ${name}_$req *req )\n{\n";
    while ($#_ >= 0)
    {
	my $type = shift;
	my $var = shift;
        next if $var =~ /^__pad/;
	if (defined($formats{$type}))
	{
            my $fmt = ${$formats{$type}}[2];
            while ($fmt && $fmt !~ /^[%&]/)
            {
                $type = $fmt;
                $fmt = ${$formats{$type}}[2];
            }
            if (!$fmt)
            {
                my $func = $type;
                $func =~ s/^(struct|union)\s+//;
                $func =~ s/_t$//;
                push @trace_lines, "    dump_$func( \"$prefix$var=\", &req->$var );\n";
                $dump_funcs{$func} = $type;
            }
            elsif ($fmt =~ /^&(.*)/)
            {
                my $func = $1;
                push @trace_lines, "    dump_$func( \"$prefix$var=\", &req->$var );\n";
                $dump_funcs{$func} = $type;
            }
            elsif ($fmt =~ /^(%.*)\s+\((.*)\)/)
            {
                my ($format, $cast) = ($1, $2);
                push @trace_lines, "    fprintf( stderr, \"$prefix$var=$format\", ($cast)req->$var );\n";
            }
            else
            {
                push @trace_lines, "    fprintf( stderr, \"$prefix$var=$fmt\", req->$var );\n";
            }
	}
	else  # must be some varargs format
	{
            push @trace_lines, "    " . sprintf($type, "$prefix$var=") . ";\n";
        }
        $prefix = ", ";
    }
    push @trace_lines, "}\n\n";
}

### Parse the request definitions

sub PARSE_REQUESTS()
{
    # states: 0 = header 1 = declarations 2 = inside @REQ 3 = inside @REPLY
    my $state = 0;
    my $offset = 0;
    my $name = "";
    my @in_struct = ();
    my @out_struct = ();

    open(PROTOCOL,"server/protocol.def") or die "Can't open server/protocol.def";

    while (<PROTOCOL>)
    {
        my ($type, $var);
        # strip comments
	s!/\*.*\*/!!g;
        # strip white space at end of line
        s/\s+$//;

        if (/^\@HEADER/)
        {
            die "Misplaced \@HEADER" unless $state == 0;
            $state++;
            next;
        }

        # ignore everything while in state 0
        next if $state == 0;

        if (/^\@REQ\(\s*(\w+)\s*\)/)
        {
            $name = $1;
            die "Misplaced \@REQ" unless $state == 1;
            # start a new request
            @in_struct = ();
            @out_struct = ();
            $offset = 12;
            push @protocol_lines,  "struct ${name}_request\n{\n";
            push @protocol_lines,  "    struct request_header __header;\n";
            $state++;
            next;
        }

        if (/^\@REPLY/)
        {
            die "Misplaced \@REPLY" unless $state == 2;
            $offset = add_padding( $offset, 8 ); # all requests should be 8-byte aligned
            die "request $name too large ($offset)" if ($offset > $max_req_size);
            push @asserts, "C_ASSERT( sizeof(struct ${name}_request) == $offset );\n";
            push @protocol_lines,  "};\n";
            push @protocol_lines,  "struct ${name}_reply\n{\n";
            push @protocol_lines,  "    struct reply_header __header;\n";
            $offset = 8;
            $state++;
            next;
        }

        if (/^\@END/)
        {
            die "Misplaced \@END" unless ($state == 2 || $state == 3);

            $offset = add_padding( $offset, 8 ); # all requests should be 8-byte aligned
            push @protocol_lines,  "};\n";
            if ($state == 2)  # build dummy reply struct
            {
                die "request $name too large ($offset)" if ($offset > $max_req_size);
                push @asserts, "C_ASSERT( sizeof(struct ${name}_request) == $offset );\n";
                push @protocol_lines,  "struct ${name}_reply\n{\n";
                push @protocol_lines,  "    struct reply_header __header;\n";
                push @protocol_lines,  "};\n";
            }
            else
            {
                die "reply $name too large ($offset)" if ($offset > $max_req_size);
                push @asserts, "C_ASSERT( sizeof(struct ${name}_reply) == $offset );\n";
            }
            # got a complete request
            push @requests, $name;
            DO_DUMP_FUNC( $name, "request", @in_struct);
            if ($#out_struct >= 0)
            {
                $replies{$name} = 1;
                DO_DUMP_FUNC( $name, "reply", @out_struct);
            }
            $state = 1;
            next;
        }

        if ($state != 1)
        {
            # skip empty lines (but keep them in output file)
            if (/^$/)
            {
                push @protocol_lines,  "\n";
                next;
            }

            if (/^\s*VARARG\((\w+),(\w+),(\w+)\)/)
            {
                $var = $1;
                $type = "dump_varargs_$2( \"%s\", min( cur_size, req->" . $3 . " ))";
                $dump_funcs{"varargs_$2"} = $2;
                s!(VARARG\(.*\)\s*;)!/* $1 */!;
            }
            elsif (/^\s*VARARG\((\w+),(\w+)\)/)
            {
                $var = $1;
                $type = "dump_varargs_$2( \"%s\", cur_size )";
                $dump_funcs{"varargs_$2"} = $2;
                s!(VARARG\(.*\)\s*;)!/* $1 */!;
            }
            elsif (/^\s*(\w+\**(\s+\w+\**)*)\s+(\w+);/)
            {
                $type = $1;
                $var = $3;
                die "Unrecognized type $type" unless defined($formats{$type});
                my @fmt = @{$formats{$type}};
                if ($offset & ($fmt[1] - 1))
                {
                    my $count = $fmt[1] - ($offset & ($fmt[1] - 1));
                    print "protocol.def:$.: warning: $name $offset $type $var needs padding\n" if $warnings;
                    push @protocol_lines,  "    char __pad_$offset\[$count\];\n";
                    $offset += $count;
                }
                if ($state == 2)
                {
                    push @asserts, "C_ASSERT( offsetof(struct ${name}_request, $var) == $offset );\n";
                }
                else
                {
                    push @asserts, "C_ASSERT( offsetof(struct ${name}_reply, $var) == $offset );\n";
                }
                $offset += $fmt[0];
            }
            else
            {
                die "Unrecognized syntax $_";
            }
            if ($state == 2) { push @in_struct, $type, $var; }
            if ($state == 3) { push @out_struct, $type, $var; }
        }
        elsif (/^typedef\s+(.*)\s+(\w+_t);$/)
        {
            if (defined $formats{$1} && !defined $formats{$2})
            {
                @{$formats{$2}} = @{$formats{$1}};
                $formats{$2}->[2] = $1;
            }
        }


        # Pass it through into the output file
        push @protocol_lines,  $_ . "\n";
    }
    close PROTOCOL;
}

### Retrieve the server protocol version from the existing server_protocol.h file

sub GET_PROTOCOL_VERSION()
{
    my $protocol = 0;
    open SERVER_PROT, "include/wine/server_protocol.h" or return 0;
    while (<SERVER_PROT>)
    {
        if (/^\#define SERVER_PROTOCOL_VERSION (\d+)/) { $protocol = $1; last; }
    }
    close SERVER_PROT;
    return $protocol;
}

### Retrieve the list of status and errors used in the server

sub GET_ERROR_NAMES()
{
    my %errors = ();
    foreach my $f (glob "server/*.c")
    {
        next if $f eq "server/trace.c";
        open FILE, $f or die "Can't open $f";
        while (<FILE>)
        {
            while (/\bSTATUS_(\w+)/g)
            {
                $errors{$1} = "STATUS_$1" unless ($1 eq "SUCCESS" || $1 eq "WAIT_0");
            }
            while (/\bset_win32_error\s*\(\s*(\w+)\s*\)/g)
            {
                $errors{$1} = "0xc0010000 | $1";
            }
            while (/\breturn\s+(WSA\w+)/g)
            {
                $errors{$1} = "0xc0010000 | $1";
            }
        }
        close FILE;
    }
    return %errors;
}

# update a file if changed
sub update_file($@)
{
    my ($file, @lines) = @_;

    open OUTPUT, ">$file.new" or die "Cannot create $file.new";
    print OUTPUT $file_header;
    print OUTPUT @lines;
    close OUTPUT;

    my $ret = !(-f $file) || system "cmp $file $file.new >/dev/null";
    if (!$ret)
    {
        unlink "$file.new";
    }
    else
    {
        rename "$file.new", "$file";
        print "$file updated\n";
    }
    return $ret;
}

### Main

# Get the server protocol version
my $protocol = GET_PROTOCOL_VERSION();

my %errors = GET_ERROR_NAMES();

### Create server_protocol.h and print header

push @protocol_lines,  "#ifndef __WINE_WINE_SERVER_PROTOCOL_H\n";
push @protocol_lines,  "#define __WINE_WINE_SERVER_PROTOCOL_H\n";

### Parse requests to find request/reply structure definitions

PARSE_REQUESTS();

### Build the request list and structures

push @protocol_lines,  "\n\nenum request\n{\n";
foreach my $req (@requests) { push @protocol_lines,  "    REQ_$req,\n"; }
push @protocol_lines,  "    REQ_NB_REQUESTS\n};\n\n";

push @protocol_lines,  "union generic_request\n{\n";
push @protocol_lines,  "    struct request_max_size max_size;\n";
push @protocol_lines,  "    struct request_header request_header;\n";
foreach my $req (@requests) { push @protocol_lines,  "    struct ${req}_request ${req}_request;\n"; }
push @protocol_lines,  "};\n";

push @protocol_lines,  "union generic_reply\n{\n";
push @protocol_lines,  "    struct request_max_size max_size;\n";
push @protocol_lines,  "    struct reply_header reply_header;\n";
foreach my $req (@requests) { push @protocol_lines,  "    struct ${req}_reply ${req}_reply;\n"; }
push @protocol_lines,  "};\n\n";

push @protocol_lines, sprintf "#define SERVER_PROTOCOL_VERSION %d\n\n", $protocol;
push @protocol_lines,  "#endif /* __WINE_WINE_SERVER_PROTOCOL_H */\n";

open SERVER_PROT, ">include/wine/server_protocol.h.new" or die "Cannot create include/wine/server_protocol.h.new";
print SERVER_PROT @protocol_lines;
close SERVER_PROT;

if (update_file( "include/wine/server_protocol.h", @protocol_lines ))
{
    $protocol_lines[$#protocol_lines - 1] = sprintf "#define SERVER_PROTOCOL_VERSION %d\n\n", $protocol + 1;
    update_file( "include/wine/server_protocol.h", @protocol_lines );
}

### Output the dumping function tables

push @trace_lines, "typedef void (*dump_func)( const void *req );\n\n";
push @trace_lines, "static const dump_func req_dumpers[REQ_NB_REQUESTS] =\n{\n";
foreach my $req (@requests)
{
    push @trace_lines, "    (dump_func)dump_${req}_request,\n";
}
push @trace_lines, "};\n\n";

push @trace_lines, "static const dump_func reply_dumpers[REQ_NB_REQUESTS] =\n{\n";
foreach my $req (@requests)
{
    push @trace_lines, "    ", $replies{$req} ? "(dump_func)dump_${req}_reply,\n" : "NULL,\n";
}
push @trace_lines, "};\n\n";

push @trace_lines, "static const char * const req_names[REQ_NB_REQUESTS] =\n{\n";
foreach my $req (@requests)
{
    push @trace_lines, "    \"$req\",\n";
}
push @trace_lines, "};\n\n";

push @trace_lines, "static const struct\n{\n";
push @trace_lines, "    const char  *name;\n";
push @trace_lines, "    unsigned int value;\n";
push @trace_lines, "} status_names[] =\n{\n";

foreach my $err (sort keys %errors)
{
    push @trace_lines, sprintf("    { %-30s %s },\n", "\"$err\",", $errors{$err});
}
push @trace_lines, "    { NULL, 0 }\n";
push @trace_lines, "};\n";


my @trace_header = ();

foreach my $func (sort keys %dump_funcs)
{
    if ($func =~ /^varargs_/)
    {
        push @trace_header, "static void dump_$func( const char *prefix, data_size_t size );\n";
    }
    else
    {
        push @trace_header, "static void dump_$func( const char *prefix, const $dump_funcs{$func} *val );\n";
    }
}

push @trace_header, "\nstatic const void *cur_data;\n";
push @trace_header, "static data_size_t cur_size;\n\n";

update_file( "server/request_trace.h", @trace_header, @trace_lines);

### Output the request handlers list

my @request_lines = ( "#include \"request.h\"\n\n" );

foreach my $req (@requests) { push @request_lines, "DECL_HANDLER($req);\n"; }
push @request_lines, "\ntypedef void (*req_handler)( const void *req, void *reply );\n";
push @request_lines, "static const req_handler req_handlers[REQ_NB_REQUESTS] =\n{\n";
foreach my $req (@requests)
{
    push @request_lines, "    (req_handler)req_$req,\n";
}
push @request_lines, "};\n\n";

foreach my $type (sort keys %formats)
{
    my ($size, $align) = @{$formats{$type}};
    die "$type: invalid size $size for alignment $align" if $size % $align;
    push @request_lines, "C_ASSERT( sizeof($type) == $size );\n";
}

update_file( "server/request_handlers.h", @request_lines, @asserts );
