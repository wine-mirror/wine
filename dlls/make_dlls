#!/usr/bin/perl -w
#
# Update the dll dependencies in the dlls main Makefile.in.
# Must be run in the dlls/ directory of the Wine tree.
#
# Copyright 2001 Alexandre Julliard
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

use strict;

my $makefiles = `find . -name Makefile.in -print`;

my %imports = ();
my %directories = ();
my %altnames = ();
my %linked_dlls = ();

# list of special dlls that can be switched on or off by configure
my %special_dlls =
(
  "ddraw"    => "XFILES",
  "glu32"    => "GLU32FILES",
  "opengl32" => "OPENGLFILES",
  "d3d8"     => "OPENGLFILES",
  "d3dx8"    => "OPENGLFILES",
  "x11drv"   => "XFILES"
);

foreach my $i (split(/\s/,$makefiles))
{
    my $module;

    next if $i =~ /\/tests\/Makefile.in/;

    open MAKE,$i;

    $module = undef;
    while (<MAKE>)
    {
        chop;
        # EPP hack to disable this DLL... the MKDLL_SKIP comment must appear
        # at the very top of the Makefile.in
        last if (/^\#\s*MKDLL_SKIP/);

        if (/^MODULE\s*=\s*([a-zA-Z0-9_.]+)/)
        {
            $module = $1;
            $imports{$module} = [ ];
            ($directories{$module} = $i) =~ s/^\.\/(.*)\/[^\/]+$/$1/;
            next;
        }
        if (/^ALTNAMES\s*=\s*(.*)/)
        {
            my @list = split(/\s/,$1);
            $altnames{$module} = \@list;
            next;
        }
        if (/^(DELAYIMPORTS|IMPORTS)\s*=\s*(.*)/)
        {
            my @list = map { /\./ ? $_ : $_ . ".dll"; } split(/\s/,$2);
            push @{$imports{$module}}, @list;
            next;
        }
        if (/^LDIMPORTS\s*=\s*(.*)/)
        {
            my @list = map { /\./ ? $_ : $_ . ".dll"; } split(/\s/,$1);
            $linked_dlls{$module} = \@list;
            next;
        }
    }
    close MAKE;
    push @{$imports{$module}}, "kernel32.dll" unless !defined($module) || @{$imports{$module}} || $module eq "ntdll.dll";
}

open NEWMAKE,">Makefile.in.new" or die "cannot create Makefile.in.new";

################################################################
# makefile header

print NEWMAKE <<EOF;
# Automatically generated by make_dlls; DO NOT EDIT!!

TOPSRCDIR = \@top_srcdir\@
TOPOBJDIR = ..
SRCDIR    = \@srcdir\@
VPATH     = \@srcdir\@

EOF

################################################################
# output special dlls configure definitions

printf NEWMAKE "# special configure-dependent targets\n\n";
my %specials = ();
foreach my $mod (sort keys %special_dlls)
{
    $specials{$special_dlls{$mod}} .= " " . $mod;
}
foreach my $i (sort keys %specials)
{
    printf NEWMAKE "%s =%s\n", $i, $specials{$i};
}
printf NEWMAKE "EXTRADIRS =";
foreach my $i (sort keys %specials) { printf NEWMAKE " \@%s\@", $i; }
printf NEWMAKE "\n\n";


################################################################
# output the subdirs list

print NEWMAKE "# Subdir list\n\nBASEDIRS =";
foreach my $dir (sort values %directories)
{
    next if defined($special_dlls{$dir});  # skip special dlls
    printf NEWMAKE " \\\n\t%s", $dir;
}

printf NEWMAKE "\n\nSUBDIRS = \\\n\t\$(BASEDIRS)";
foreach my $dir (sort keys %special_dlls)
{
    printf NEWMAKE " \\\n\t%s", $dir;
}
printf NEWMAKE <<EOF;


BUILDSUBDIRS = \$(BASEDIRS) \$(EXTRADIRS)

INSTALLSUBDIRS = \$(BUILDSUBDIRS)
EOF

################################################################
# output the all: target

my %targets = ();  # use a hash to get rid of duplicate target names
my %targets16 = ();
foreach my $mod (sort keys %directories)
{
    next if defined($special_dlls{$directories{$mod}});  # skip special dlls
    $targets{sprintf("%s\$(DLLEXT)",$mod)} = 1;
    next unless defined $altnames{$mod};
    foreach my $i (sort @{$altnames{$mod}})
    {
        $targets16{sprintf("%s\$(DLLEXT)",$i)} = 1;
    }
}
print NEWMAKE <<EOF;

\@MAKE_RULES\@

# Symbolic links

WIN16_FILES = \\
EOF
printf NEWMAKE "\t%s\n", join( " \\\n\t", sort keys %targets16 );

print NEWMAKE <<EOF;

SYMLINKS = \\
	\$(EXTRADIRS:%=%.dll\$(DLLEXT)) \\
	\@WIN16_FILES\@ \\
EOF
printf NEWMAKE "\t%s\n", join( " \\\n\t", sort keys %targets );

print NEWMAKE <<EOF;

# Main target

all: \$(SYMLINKS)
EOF

################################################################
# output the lib name -> directory rules

print NEWMAKE <<EOF;

# Map symlink name to the corresponding library

EOF

foreach my $mod (sort keys %directories)
{
    printf NEWMAKE "%s\$(DLLEXT)", $mod;
    if (defined $altnames{$mod})
    {
        my $count = 1;
        foreach my $i (sort @{$altnames{$mod}})
        {
            if (!($count++ % 3)) { printf NEWMAKE " \\\n "; }
            printf NEWMAKE " %s\$(DLLEXT)", $i;
        }
    }
    printf NEWMAKE ": %s/%s\$(DLLEXT)\n", $directories{$mod}, $mod;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s\$(DLLEXT) \$@\n\n", $directories{$mod}, $mod;
}


################################################################
# output the import libraries rules

my @implibs = grep /\.dll$/, keys %directories;
push @implibs, "winspool.drv";

print NEWMAKE "\n# Import libraries\n\nIMPORT_LIBS =";
foreach my $mod (sort @implibs)
{
    my $def = $mod;
    $def =~ s/\.(dll|drv)$//;
    printf NEWMAKE " \\\n\tlib%s", $def;
}
print NEWMAKE "\n\n";

foreach my $mod (sort @implibs)
{
    my $dir = $directories{$mod};
    my $def = $mod;
    my $spec = $mod;
    $spec =~ s/\.dll$//;
    $def =~ s/\.(dll|drv)$//;
    printf NEWMAKE "lib%s.def: %s/%s.spec.def\n", $def, $dir, $spec;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s.spec.def \$@\n", $dir, $spec;
    printf NEWMAKE "lib%s.a: %s/%s.spec.def\n", $def, $dir, $spec;
    printf NEWMAKE "\t\$(DLLTOOL) -k -l \$@ -d %s/%s.spec.def\n\n", $dir, $spec;
}
foreach my $mod (sort @implibs)
{
    my $dir = $directories{$mod};
    my $spec = $mod;
    $spec =~ s/\.dll$//;
    printf NEWMAKE "%s/%s.spec.def: \$(WINEBUILD)\n", $dir, $spec;
}


print NEWMAKE <<EOF;

\$(SUBDIRS): \$(IMPORT_LIBS:%=%.\$(IMPLIBEXT))
\$(SUBDIRS:%=%/__crosstest__): \$(IMPORT_LIBS:%=%.a)

EOF

################################################################
# output the inter-dll dependencies and rules

print NEWMAKE "# Map library name to the corresponding directory\n\n";

foreach my $mod (sort keys %directories)
{
    printf NEWMAKE "%s/%s\$(DLLEXT): %s\n", $directories{$mod}, $mod, $directories{$mod};
}

################################################################
# output the linkable dlls special links

my %linkable_dlls = ();
foreach my $mod (keys %imports)
{
    foreach my $i (@{$linked_dlls{$mod}}) { $linkable_dlls{$i} = 1; }
}

print NEWMAKE "\n# Special targets for dlls that we need to link to\n\n";
printf NEWMAKE "LINKABLE_DLLS = %s\n\n", join( " ", keys %linkable_dlls );

foreach my $mod (keys %linkable_dlls)
{
    printf NEWMAKE "lib%s.\$(LIBEXT): %s/%s\$(DLLEXT)\n", $mod, $directories{$mod}, $mod;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s\$(DLLEXT) \$@\n\n", $directories{$mod}, $mod;
}

foreach my $mod (keys %imports)
{
    my $deps = "";
    foreach my $i (@{$linked_dlls{$mod}}) { $deps .= " lib$i.\$(LIBEXT)"; }
    if ($deps) { printf NEWMAKE "%s:%s\n", $directories{$mod}, $deps; }
}

print NEWMAKE <<EOF;

uninstall::
	\$(RM) \$(LINKABLE_DLLS:%=\$(libdir)/lib%.\$(LIBEXT))

install install-lib:: \$(INSTALLSUBDIRS:%=%/__install__)
	\$(RM) \$(LINKABLE_DLLS:%=\$(libdir)/lib%.\$(LIBEXT))
	cd \$(libdir) && if [ "\$(dlldir)" = "\$(libdir)/wine" ]; \\
	then \\
EOF
foreach my $mod (keys %linkable_dlls)
{
    printf NEWMAKE "\t  \$(LN_S) wine/%s\$(DLLEXT) lib%s.\$(LIBEXT); \\\n", $mod, $mod;
}
print NEWMAKE "\telse \\\n";
foreach my $mod (keys %linkable_dlls)
{
    printf NEWMAKE "\t  \$(LN_S) \$(dlldir)/%s\$(DLLEXT) lib%s.\$(LIBEXT); \\\n", $mod, $mod;
}
print NEWMAKE "\tfi\n\n";

################################################################
# makefile trailer

print NEWMAKE <<EOF;
# Rules for auto documentation

\$(SUBDIRS:%=%/__man__): dummy
	cd `dirname \$@` && \$(MAKE) man

man: \$(SUBDIRS:%=%/__man__)

\$(SUBDIRS:%=%/__doc_html__): dummy
	cd `dirname \$@` && \$(MAKE) doc-html

doc-html: \$(SUBDIRS:%=%/__doc_html__)

\$(SUBDIRS:%=%/__doc_sgml__): dummy
	cd `dirname \$@` && \$(MAKE) doc-sgml

doc-sgml: \$(SUBDIRS:%=%/__doc_sgml__)

.PHONY: man doc-html doc-sgml \$(SUBDIRS:%=%/__man__) \$(SUBDIRS:%=%/__doc_html__) \$(SUBDIRS:%=%/__doc_sgml__)

# Misc rules

install install-dev:: \$(IMPORT_LIBS:%=%.\$(IMPLIBEXT))
	\$(MKINSTALLDIRS) \$(dlldir)
	for f in \$(IMPORT_LIBS:%=%.\$(IMPLIBEXT)); do \$(INSTALL_DATA) \$\$f \$(dlldir)/\$\$f; done

uninstall::
	\$(RM) \$(IMPORT_LIBS:%=\$(dlldir)/%.\$(IMPLIBEXT))
	-rmdir \$(dlldir)

clean::
	\$(RM) \$(IMPORT_LIBS:%=%.a) \$(IMPORT_LIBS:%=%.def) \$(SYMLINKS)

check test:: \$(BUILDSUBDIRS:%=%/__test__)

crosstest:: \$(BUILDSUBDIRS:%=%/__crosstest__)

checklink:: \$(BUILDSUBDIRS:%=%/__checklink__)

### Dependencies:
EOF

close NEWMAKE;
rename "Makefile.in.new", "Makefile.in";
printf "Successfully updated Makefile.in\n";
