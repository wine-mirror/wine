#!/usr/bin/perl -w
#
# Update the dll dependencies in the dlls main Makefile.in.
# Must be run in the dlls/ directory of the Wine tree.
#
# Copyright 2001 Alexandre Julliard
#

$makefiles = `find . -name Makefile.in -print`;

%imports = ();
%directories = ();
%altnames = ();

# list of special dlls that can be switched on or off by configure
%special_dlls =
(
  "ddraw"    => "XFILES",
  "glu32"    => "GLU32FILES",
  "opengl32" => "OPENGLFILES",
  "x11drv"   => "XFILES"
);

foreach $i (split(/\s/,$makefiles))
{
    open MAKE,$i;
    while (<MAKE>)
    {
        chop;
        if (/^MODULE\s*=\s*([a-zA-Z0-9_.]+)/)
        {
            $module = $1;
            ($directories{$module} = $i) =~ s/^\.\/(.*)\/[^\/]+$/$1/;
            next;
        }
        if (/^ALTNAMES\s*=\s*(.*)/)
        {
            my @list = split(/\s/,$1);
            $altnames{$module} = \@list;
            next;
        }
    }
}

foreach $mod (sort keys %directories)
{
    my $spec = sprintf("%s/%s.spec", $directories{$mod}, $mod);
    open SPEC,$spec or die "cannot open $spec";
    $imports{$mod} = [ ];
    while (<SPEC>)
    {
        if (/^\#?import\s+(-delay\s+)?([a-zA-Z0-9_]+)\.dll/)
        {
            my $imp = $2;
            push @{$imports{$mod}}, $imp;
            next;
        }
        if (/^\#?import\s+(-delay\s+)?([a-zA-Z0-9_.]+)/)
        {
            my $imp = $2;
            push @{$imports{$mod}}, $imp;
            next;
        }
    }
}

open NEWMAKE,">Makefile.in.new" or die "cannot create Makefile.in.new";

################################################################
# makefile header

print NEWMAKE <<EOF;
# Automatically generated by make_dlls; DO NOT EDIT!!

TOPSRCDIR = \@top_srcdir\@
TOPOBJDIR = ..
SRCDIR    = \@srcdir\@
VPATH     = \@srcdir\@
LIBEXT    = \@LIBEXT\@

EOF

################################################################
# output special dlls configure definitions

printf NEWMAKE "# special configure-dependent targets\n\n";
my %specials = ();
foreach $mod (sort keys %special_dlls)
{
    $specials{$special_dlls{$mod}} .= " " . $mod;
}
foreach $i (sort keys %specials)
{
    printf NEWMAKE "%s =%s\n", $i, $specials{$i};
}
printf NEWMAKE "EXTRADIRS =";
foreach $i (sort keys %specials) { printf NEWMAKE " \@%s\@", $i; }
printf NEWMAKE "\n\n";


################################################################
# output the subdirs list

print NEWMAKE <<EOF;
# Subdir list

SUBDIRS = \\
EOF
printf NEWMAKE "\t\$(EXTRADIRS)";
foreach $dir (sort values %directories)
{
    next if defined($special_dlls{$dir});  # skip special dlls
    printf NEWMAKE " \\\n\t%s", $dir;
}
printf NEWMAKE "\n";


################################################################
# output the all: target

my %targets = ();  # use a hash to get rid of duplicate target names
foreach $mod (sort keys %directories)
{
    next if defined($special_dlls{$mod});  # skip special dlls
    $targets{sprintf("lib%s.\$(LIBEXT)",$mod)} = 1;
    next unless defined $altnames{$mod};
    foreach $i (sort @{$altnames{$mod}})
    {
        $targets{sprintf("lib%s.\$(LIBEXT)",$i)} = 1;
    }
}
print NEWMAKE <<EOF;

# Main target

all: \\
	\$(EXTRADIRS:%=lib%.\$(LIBEXT)) \\
EOF
printf NEWMAKE "\t%s\n", join( " \\\n\t", sort keys %targets );


################################################################
# output the lib name -> directory rules

print NEWMAKE <<EOF;

\@MAKE_RULES\@

# Map library name to directory

EOF

foreach $mod (sort keys %directories)
{
    printf NEWMAKE "lib%s.\$(LIBEXT)", $mod;
    if (defined $altnames{$mod})
    {
        my $count = 1;
        foreach $i (sort @{$altnames{$mod}})
        {
            if (!($count++ % 3)) { printf NEWMAKE " \\\n "; }
            printf NEWMAKE " lib%s.\$(LIBEXT)", $i;
        }
    }
    printf NEWMAKE ": %s/lib%s.\$(LIBEXT)\n", $directories{$mod}, $mod;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/lib%s.\$(LIBEXT) \$@\n\n", $directories{$mod}, $mod;
}


################################################################
# output the inter-dll dependencies and rules

print NEWMAKE "# Inter-dll dependencies\n\n";

my @depends = ();
foreach $mod (sort keys %imports)
{
    my $count = 1;
    my $dep = sprintf("%s/lib%s.\$(LIBEXT): dummy", $directories{$mod}, $mod);
    foreach $i (@{$imports{$mod}})
    {
        if ($count++ >= 3)
        {
            $count = 0;
            $dep .= " \\\n ";
        }
        $dep .= sprintf(" lib%s.\$(LIBEXT)", $i);
    }
    $dep .= sprintf("\n\t\@cd %s && \$(MAKE) lib%s.\$(LIBEXT)\n\n",$directories{$mod}, $mod);
    push @depends, $dep;
}
print NEWMAKE sort @depends;


################################################################
# makefile trailer

print NEWMAKE <<EOF;
# Misc rules

\$(SUBDIRS:%=%/__checklink__): dummy
	\@cd `dirname \$\@` && \$(MAKE) checklink

\$(SUBDIRS:%=%/__debug_channels__): dummy
	\@cd `dirname \$\@` && \$(MAKE) debug_channels

install:: \$(SUBDIRS:%=%/__install__)

uninstall:: \$(SUBDIRS:%=%/__uninstall__)

checklink:: \$(SUBDIRS:%=%/__checklink__)

debug_channels:: \$(SUBDIRS:%=%/__debug_channels__)
EOF

close NEWMAKE;
rename "Makefile.in.new", "Makefile.in";
printf "Successfully updated Makefile.in\n";
