/* Automatically generated from Vulkan vk.xml and video.xml; DO NOT EDIT!
 *
 * This file is generated from Vulkan vk.xml file covered
 * by the following copyright and permission notice:
 *
 * Copyright 2015-2025 The Khronos Group Inc.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 * and from Vulkan video.xml file covered
 * by the following copyright and permission notice:
 *
 * Copyright 2021-2025 The Khronos Group Inc.
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#if 0
#pragma makedep unix
#endif

#include "config.h"

#include <stdlib.h>

#include "vulkan_private.h"

WINE_DEFAULT_DEBUG_CHANNEL(vulkan);

typedef struct VkGeometryAABBNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) aabbData;
    uint32_t numAABBs;
    uint32_t stride;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
} VkGeometryAABBNV32;

typedef struct VkGeometryTrianglesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) vertexData;
    VkDeviceSize DECLSPEC_ALIGN(8) vertexOffset;
    uint32_t vertexCount;
    VkDeviceSize DECLSPEC_ALIGN(8) vertexStride;
    VkFormat vertexFormat;
    VkBuffer DECLSPEC_ALIGN(8) indexData;
    VkDeviceSize DECLSPEC_ALIGN(8) indexOffset;
    uint32_t indexCount;
    VkIndexType indexType;
    VkBuffer DECLSPEC_ALIGN(8) transformData;
    VkDeviceSize DECLSPEC_ALIGN(8) transformOffset;
} VkGeometryTrianglesNV32;

typedef struct VkSpecializationMapEntry32
{
    uint32_t constantID;
    uint32_t offset;
    PTR32 size;
} VkSpecializationMapEntry32;

typedef struct StdVideoH264SequenceParameterSetVui32
{
    StdVideoH264SpsVuiFlags flags;
    StdVideoH264AspectRatioIdc aspect_ratio_idc;
    uint16_t sar_width;
    uint16_t sar_height;
    uint8_t video_format;
    uint8_t colour_primaries;
    uint8_t transfer_characteristics;
    uint8_t matrix_coefficients;
    uint32_t num_units_in_tick;
    uint32_t time_scale;
    uint8_t max_num_reorder_frames;
    uint8_t max_dec_frame_buffering;
    uint8_t chroma_sample_loc_type_top_field;
    uint8_t chroma_sample_loc_type_bottom_field;
    uint32_t reserved1;
    PTR32 pHrdParameters;
} StdVideoH264SequenceParameterSetVui32;

typedef struct VkAccelerationStructureGeometryAabbsDataKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) data;
    VkDeviceSize DECLSPEC_ALIGN(8) stride;
} VkAccelerationStructureGeometryAabbsDataKHR32;

typedef struct VkAccelerationStructureGeometryInstancesDataKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 arrayOfPointers;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) data;
} VkAccelerationStructureGeometryInstancesDataKHR32;

typedef struct VkAccelerationStructureGeometryTrianglesDataKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat vertexFormat;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) vertexData;
    VkDeviceSize DECLSPEC_ALIGN(8) vertexStride;
    uint32_t maxVertex;
    VkIndexType indexType;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) indexData;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) transformData;
} VkAccelerationStructureGeometryTrianglesDataKHR32;

typedef struct VkClusterAccelerationStructureClustersBottomLevelInputNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxTotalClusterCount;
    uint32_t maxClusterCountPerAccelerationStructure;
} VkClusterAccelerationStructureClustersBottomLevelInputNV32;

typedef struct VkClusterAccelerationStructureMoveObjectsInputNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkClusterAccelerationStructureTypeNV type;
    VkBool32 noMoveOverlap;
    VkDeviceSize DECLSPEC_ALIGN(8) maxMovedBytes;
} VkClusterAccelerationStructureMoveObjectsInputNV32;

typedef struct VkClusterAccelerationStructureTriangleClusterInputNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat vertexFormat;
    uint32_t maxGeometryIndexValue;
    uint32_t maxClusterUniqueGeometryCount;
    uint32_t maxClusterTriangleCount;
    uint32_t maxClusterVertexCount;
    uint32_t maxTotalTriangleCount;
    uint32_t maxTotalVertexCount;
    uint32_t minPositionTruncateBitCount;
} VkClusterAccelerationStructureTriangleClusterInputNV32;

typedef struct VkGeometryDataNV32
{
    VkGeometryTrianglesNV32 DECLSPEC_ALIGN(8) triangles;
    VkGeometryAABBNV32 DECLSPEC_ALIGN(8) aabbs;
} VkGeometryDataNV32;

typedef struct VkIndirectExecutionSetShaderLayoutInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t setLayoutCount;
    PTR32 pSetLayouts;
} VkIndirectExecutionSetShaderLayoutInfoEXT32;

typedef struct VkPhysicalDeviceLimits32
{
    uint32_t maxImageDimension1D;
    uint32_t maxImageDimension2D;
    uint32_t maxImageDimension3D;
    uint32_t maxImageDimensionCube;
    uint32_t maxImageArrayLayers;
    uint32_t maxTexelBufferElements;
    uint32_t maxUniformBufferRange;
    uint32_t maxStorageBufferRange;
    uint32_t maxPushConstantsSize;
    uint32_t maxMemoryAllocationCount;
    uint32_t maxSamplerAllocationCount;
    VkDeviceSize DECLSPEC_ALIGN(8) bufferImageGranularity;
    VkDeviceSize DECLSPEC_ALIGN(8) sparseAddressSpaceSize;
    uint32_t maxBoundDescriptorSets;
    uint32_t maxPerStageDescriptorSamplers;
    uint32_t maxPerStageDescriptorUniformBuffers;
    uint32_t maxPerStageDescriptorStorageBuffers;
    uint32_t maxPerStageDescriptorSampledImages;
    uint32_t maxPerStageDescriptorStorageImages;
    uint32_t maxPerStageDescriptorInputAttachments;
    uint32_t maxPerStageResources;
    uint32_t maxDescriptorSetSamplers;
    uint32_t maxDescriptorSetUniformBuffers;
    uint32_t maxDescriptorSetUniformBuffersDynamic;
    uint32_t maxDescriptorSetStorageBuffers;
    uint32_t maxDescriptorSetStorageBuffersDynamic;
    uint32_t maxDescriptorSetSampledImages;
    uint32_t maxDescriptorSetStorageImages;
    uint32_t maxDescriptorSetInputAttachments;
    uint32_t maxVertexInputAttributes;
    uint32_t maxVertexInputBindings;
    uint32_t maxVertexInputAttributeOffset;
    uint32_t maxVertexInputBindingStride;
    uint32_t maxVertexOutputComponents;
    uint32_t maxTessellationGenerationLevel;
    uint32_t maxTessellationPatchSize;
    uint32_t maxTessellationControlPerVertexInputComponents;
    uint32_t maxTessellationControlPerVertexOutputComponents;
    uint32_t maxTessellationControlPerPatchOutputComponents;
    uint32_t maxTessellationControlTotalOutputComponents;
    uint32_t maxTessellationEvaluationInputComponents;
    uint32_t maxTessellationEvaluationOutputComponents;
    uint32_t maxGeometryShaderInvocations;
    uint32_t maxGeometryInputComponents;
    uint32_t maxGeometryOutputComponents;
    uint32_t maxGeometryOutputVertices;
    uint32_t maxGeometryTotalOutputComponents;
    uint32_t maxFragmentInputComponents;
    uint32_t maxFragmentOutputAttachments;
    uint32_t maxFragmentDualSrcAttachments;
    uint32_t maxFragmentCombinedOutputResources;
    uint32_t maxComputeSharedMemorySize;
    uint32_t maxComputeWorkGroupCount[3];
    uint32_t maxComputeWorkGroupInvocations;
    uint32_t maxComputeWorkGroupSize[3];
    uint32_t subPixelPrecisionBits;
    uint32_t subTexelPrecisionBits;
    uint32_t mipmapPrecisionBits;
    uint32_t maxDrawIndexedIndexValue;
    uint32_t maxDrawIndirectCount;
    float maxSamplerLodBias;
    float maxSamplerAnisotropy;
    uint32_t maxViewports;
    uint32_t maxViewportDimensions[2];
    float viewportBoundsRange[2];
    uint32_t viewportSubPixelBits;
    PTR32 minMemoryMapAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) minTexelBufferOffsetAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) minUniformBufferOffsetAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) minStorageBufferOffsetAlignment;
    int32_t minTexelOffset;
    uint32_t maxTexelOffset;
    int32_t minTexelGatherOffset;
    uint32_t maxTexelGatherOffset;
    float minInterpolationOffset;
    float maxInterpolationOffset;
    uint32_t subPixelInterpolationOffsetBits;
    uint32_t maxFramebufferWidth;
    uint32_t maxFramebufferHeight;
    uint32_t maxFramebufferLayers;
    VkSampleCountFlags framebufferColorSampleCounts;
    VkSampleCountFlags framebufferDepthSampleCounts;
    VkSampleCountFlags framebufferStencilSampleCounts;
    VkSampleCountFlags framebufferNoAttachmentsSampleCounts;
    uint32_t maxColorAttachments;
    VkSampleCountFlags sampledImageColorSampleCounts;
    VkSampleCountFlags sampledImageIntegerSampleCounts;
    VkSampleCountFlags sampledImageDepthSampleCounts;
    VkSampleCountFlags sampledImageStencilSampleCounts;
    VkSampleCountFlags storageImageSampleCounts;
    uint32_t maxSampleMaskWords;
    VkBool32 timestampComputeAndGraphics;
    float timestampPeriod;
    uint32_t maxClipDistances;
    uint32_t maxCullDistances;
    uint32_t maxCombinedClipAndCullDistances;
    uint32_t discreteQueuePriorities;
    float pointSizeRange[2];
    float lineWidthRange[2];
    float pointSizeGranularity;
    float lineWidthGranularity;
    VkBool32 strictLines;
    VkBool32 standardSampleLocations;
    VkDeviceSize DECLSPEC_ALIGN(8) optimalBufferCopyOffsetAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) optimalBufferCopyRowPitchAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) nonCoherentAtomSize;
} VkPhysicalDeviceLimits32;

typedef struct VkSpecializationInfo32
{
    uint32_t mapEntryCount;
    PTR32 pMapEntries;
    PTR32 dataSize;
    PTR32 pData;
} VkSpecializationInfo32;

typedef struct StdVideoAV1TileInfo32
{
    StdVideoAV1TileInfoFlags flags;
    uint8_t TileCols;
    uint8_t TileRows;
    uint16_t context_update_tile_id;
    uint8_t tile_size_bytes_minus_1;
    uint8_t reserved1[7];
    PTR32 pMiColStarts;
    PTR32 pMiRowStarts;
    PTR32 pWidthInSbsMinus1;
    PTR32 pHeightInSbsMinus1;
} StdVideoAV1TileInfo32;

typedef struct StdVideoEncodeH264ReferenceListsInfo32
{
    StdVideoEncodeH264ReferenceListsInfoFlags flags;
    uint8_t num_ref_idx_l0_active_minus1;
    uint8_t num_ref_idx_l1_active_minus1;
    uint8_t RefPicList0[STD_VIDEO_H264_MAX_NUM_LIST_REF];
    uint8_t RefPicList1[STD_VIDEO_H264_MAX_NUM_LIST_REF];
    uint8_t refList0ModOpCount;
    uint8_t refList1ModOpCount;
    uint8_t refPicMarkingOpCount;
    uint8_t reserved1[7];
    PTR32 pRefList0ModOperations;
    PTR32 pRefList1ModOperations;
    PTR32 pRefPicMarkingOperations;
} StdVideoEncodeH264ReferenceListsInfo32;

typedef struct StdVideoEncodeH264SliceHeader32
{
    StdVideoEncodeH264SliceHeaderFlags flags;
    uint32_t first_mb_in_slice;
    StdVideoH264SliceType slice_type;
    int8_t slice_alpha_c0_offset_div2;
    int8_t slice_beta_offset_div2;
    int8_t slice_qp_delta;
    uint8_t reserved1;
    StdVideoH264CabacInitIdc cabac_init_idc;
    StdVideoH264DisableDeblockingFilterIdc disable_deblocking_filter_idc;
    PTR32 pWeightTable;
} StdVideoEncodeH264SliceHeader32;

typedef struct StdVideoH264PictureParameterSet32
{
    StdVideoH264PpsFlags flags;
    uint8_t seq_parameter_set_id;
    uint8_t pic_parameter_set_id;
    uint8_t num_ref_idx_l0_default_active_minus1;
    uint8_t num_ref_idx_l1_default_active_minus1;
    StdVideoH264WeightedBipredIdc weighted_bipred_idc;
    int8_t pic_init_qp_minus26;
    int8_t pic_init_qs_minus26;
    int8_t chroma_qp_index_offset;
    int8_t second_chroma_qp_index_offset;
    PTR32 pScalingLists;
} StdVideoH264PictureParameterSet32;

typedef struct StdVideoH264SequenceParameterSet32
{
    StdVideoH264SpsFlags flags;
    StdVideoH264ProfileIdc profile_idc;
    StdVideoH264LevelIdc level_idc;
    StdVideoH264ChromaFormatIdc chroma_format_idc;
    uint8_t seq_parameter_set_id;
    uint8_t bit_depth_luma_minus8;
    uint8_t bit_depth_chroma_minus8;
    uint8_t log2_max_frame_num_minus4;
    StdVideoH264PocType pic_order_cnt_type;
    int32_t offset_for_non_ref_pic;
    int32_t offset_for_top_to_bottom_field;
    uint8_t log2_max_pic_order_cnt_lsb_minus4;
    uint8_t num_ref_frames_in_pic_order_cnt_cycle;
    uint8_t max_num_ref_frames;
    uint8_t reserved1;
    uint32_t pic_width_in_mbs_minus1;
    uint32_t pic_height_in_map_units_minus1;
    uint32_t frame_crop_left_offset;
    uint32_t frame_crop_right_offset;
    uint32_t frame_crop_top_offset;
    uint32_t frame_crop_bottom_offset;
    uint32_t reserved2;
    PTR32 pOffsetForRefFrame;
    PTR32 pScalingLists;
    PTR32 pSequenceParameterSetVui;
} StdVideoH264SequenceParameterSet32;

typedef union VkAccelerationStructureGeometryDataKHR32
{
    VkAccelerationStructureGeometryTrianglesDataKHR32 DECLSPEC_ALIGN(8) triangles;
    VkAccelerationStructureGeometryAabbsDataKHR32 DECLSPEC_ALIGN(8) aabbs;
    VkAccelerationStructureGeometryInstancesDataKHR32 DECLSPEC_ALIGN(8) instances;
} VkAccelerationStructureGeometryDataKHR32;

typedef struct VkAttachmentReference232
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t attachment;
    VkImageLayout layout;
    VkImageAspectFlags aspectMask;
} VkAttachmentReference232;
typedef VkAttachmentReference232 VkAttachmentReference2KHR32;

typedef union VkClusterAccelerationStructureOpInputNV32
{
    PTR32 pClustersBottomLevel;
    PTR32 pTriangleClusters;
    PTR32 pMoveObjects;
} VkClusterAccelerationStructureOpInputNV32;

typedef struct VkDescriptorAddressInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddress DECLSPEC_ALIGN(8) address;
    VkDeviceSize DECLSPEC_ALIGN(8) range;
    VkFormat format;
} VkDescriptorAddressInfoEXT32;

typedef struct VkDescriptorBufferInfo32
{
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) range;
} VkDescriptorBufferInfo32;

typedef struct VkDescriptorImageInfo32
{
    VkSampler DECLSPEC_ALIGN(8) sampler;
    VkImageView DECLSPEC_ALIGN(8) imageView;
    VkImageLayout imageLayout;
} VkDescriptorImageInfo32;

typedef struct VkGeometryNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkGeometryTypeKHR geometryType;
    VkGeometryDataNV32 DECLSPEC_ALIGN(8) geometry;
    VkGeometryFlagsKHR flags;
} VkGeometryNV32;

typedef struct VkImageCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageCreateFlags flags;
    VkImageType imageType;
    VkFormat format;
    VkExtent3D extent;
    uint32_t mipLevels;
    uint32_t arrayLayers;
    VkSampleCountFlagBits samples;
    VkImageTiling tiling;
    VkImageUsageFlags usage;
    VkSharingMode sharingMode;
    uint32_t queueFamilyIndexCount;
    PTR32 pQueueFamilyIndices;
    VkImageLayout initialLayout;
} VkImageCreateInfo32;

typedef union VkIndirectCommandsTokenDataEXT32
{
    PTR32 pPushConstant;
    PTR32 pVertexBuffer;
    PTR32 pIndexBuffer;
    PTR32 pExecutionSet;
} VkIndirectCommandsTokenDataEXT32;

typedef struct VkIndirectExecutionSetPipelineInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipeline DECLSPEC_ALIGN(8) initialPipeline;
    uint32_t maxPipelineCount;
} VkIndirectExecutionSetPipelineInfoEXT32;

typedef struct VkIndirectExecutionSetShaderInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderCount;
    PTR32 pInitialShaders;
    PTR32 pSetLayoutInfos;
    uint32_t maxShaderCount;
    uint32_t pushConstantRangeCount;
    PTR32 pPushConstantRanges;
} VkIndirectExecutionSetShaderInfoEXT32;

typedef struct VkMemoryHeap32
{
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkMemoryHeapFlags flags;
} VkMemoryHeap32;

typedef struct VkPhysicalDeviceProperties32
{
    uint32_t apiVersion;
    uint32_t driverVersion;
    uint32_t vendorID;
    uint32_t deviceID;
    VkPhysicalDeviceType deviceType;
    char deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
    uint8_t pipelineCacheUUID[VK_UUID_SIZE];
    VkPhysicalDeviceLimits32 DECLSPEC_ALIGN(8) limits;
    VkPhysicalDeviceSparseProperties sparseProperties;
} VkPhysicalDeviceProperties32;

typedef struct VkPipelineBinaryDataKHR32
{
    PTR32 dataSize;
    PTR32 pData;
} VkPipelineBinaryDataKHR32;

typedef struct VkPipelineBinaryKeyKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t keySize;
    uint8_t key[VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR];
} VkPipelineBinaryKeyKHR32;

typedef struct VkPipelineShaderStageCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineShaderStageCreateFlags flags;
    VkShaderStageFlagBits stage;
    VkShaderModule DECLSPEC_ALIGN(8) module;
    PTR32 pName;
    PTR32 pSpecializationInfo;
} VkPipelineShaderStageCreateInfo32;

typedef struct VkPipelineTessellationStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineTessellationStateCreateFlags flags;
    uint32_t patchControlPoints;
} VkPipelineTessellationStateCreateInfo32;

typedef struct VkPipelineVertexInputStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineVertexInputStateCreateFlags flags;
    uint32_t vertexBindingDescriptionCount;
    PTR32 pVertexBindingDescriptions;
    uint32_t vertexAttributeDescriptionCount;
    PTR32 pVertexAttributeDescriptions;
} VkPipelineVertexInputStateCreateInfo32;

typedef struct VkSampleLocationsInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSampleCountFlagBits sampleLocationsPerPixel;
    VkExtent2D sampleLocationGridSize;
    uint32_t sampleLocationsCount;
    PTR32 pSampleLocations;
} VkSampleLocationsInfoEXT32;

typedef struct VkSparseImageMemoryBind32
{
    VkImageSubresource subresource;
    VkOffset3D offset;
    VkExtent3D extent;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
    VkSparseMemoryBindFlags flags;
} VkSparseImageMemoryBind32;

typedef struct VkSparseMemoryBind32
{
    VkDeviceSize DECLSPEC_ALIGN(8) resourceOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
    VkSparseMemoryBindFlags flags;
} VkSparseMemoryBind32;

typedef struct VkTensorDescriptionARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorTilingARM tiling;
    VkFormat format;
    uint32_t dimensionCount;
    PTR32 pDimensions;
    PTR32 pStrides;
    VkTensorUsageFlagsARM DECLSPEC_ALIGN(8) usage;
} VkTensorDescriptionARM32;

typedef struct VkVideoPictureResourceInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOffset2D codedOffset;
    VkExtent2D codedExtent;
    uint32_t baseArrayLayer;
    VkImageView DECLSPEC_ALIGN(8) imageViewBinding;
} VkVideoPictureResourceInfoKHR32;

typedef struct StdVideoAV1SequenceHeader32
{
    StdVideoAV1SequenceHeaderFlags flags;
    StdVideoAV1Profile seq_profile;
    uint8_t frame_width_bits_minus_1;
    uint8_t frame_height_bits_minus_1;
    uint16_t max_frame_width_minus_1;
    uint16_t max_frame_height_minus_1;
    uint8_t delta_frame_id_length_minus_2;
    uint8_t additional_frame_id_length_minus_1;
    uint8_t order_hint_bits_minus_1;
    uint8_t seq_force_integer_mv;
    uint8_t seq_force_screen_content_tools;
    uint8_t reserved1[5];
    PTR32 pColorConfig;
    PTR32 pTimingInfo;
} StdVideoAV1SequenceHeader32;

typedef struct StdVideoDecodeAV1PictureInfo32
{
    StdVideoDecodeAV1PictureInfoFlags flags;
    StdVideoAV1FrameType frame_type;
    uint32_t current_frame_id;
    uint8_t OrderHint;
    uint8_t primary_ref_frame;
    uint8_t refresh_frame_flags;
    uint8_t reserved1;
    StdVideoAV1InterpolationFilter interpolation_filter;
    StdVideoAV1TxMode TxMode;
    uint8_t delta_q_res;
    uint8_t delta_lf_res;
    uint8_t SkipModeFrame[STD_VIDEO_AV1_SKIP_MODE_FRAMES];
    uint8_t coded_denom;
    uint8_t reserved2[3];
    uint8_t OrderHints[STD_VIDEO_AV1_NUM_REF_FRAMES];
    uint32_t expectedFrameId[STD_VIDEO_AV1_NUM_REF_FRAMES];
    PTR32 pTileInfo;
    PTR32 pQuantization;
    PTR32 pSegmentation;
    PTR32 pLoopFilter;
    PTR32 pCDEF;
    PTR32 pLoopRestoration;
    PTR32 pGlobalMotion;
    PTR32 pFilmGrain;
} StdVideoDecodeAV1PictureInfo32;

typedef struct StdVideoDecodeVP9PictureInfo32
{
    StdVideoDecodeVP9PictureInfoFlags flags;
    StdVideoVP9Profile profile;
    StdVideoVP9FrameType frame_type;
    uint8_t frame_context_idx;
    uint8_t reset_frame_context;
    uint8_t refresh_frame_flags;
    uint8_t ref_frame_sign_bias_mask;
    StdVideoVP9InterpolationFilter interpolation_filter;
    uint8_t base_q_idx;
    int8_t delta_q_y_dc;
    int8_t delta_q_uv_dc;
    int8_t delta_q_uv_ac;
    uint8_t tile_cols_log2;
    uint8_t tile_rows_log2;
    uint16_t reserved1[3];
    PTR32 pColorConfig;
    PTR32 pLoopFilter;
    PTR32 pSegmentation;
} StdVideoDecodeVP9PictureInfo32;

typedef struct StdVideoEncodeAV1PictureInfo32
{
    StdVideoEncodeAV1PictureInfoFlags flags;
    StdVideoAV1FrameType frame_type;
    uint32_t frame_presentation_time;
    uint32_t current_frame_id;
    uint8_t order_hint;
    uint8_t primary_ref_frame;
    uint8_t refresh_frame_flags;
    uint8_t coded_denom;
    uint16_t render_width_minus_1;
    uint16_t render_height_minus_1;
    StdVideoAV1InterpolationFilter interpolation_filter;
    StdVideoAV1TxMode TxMode;
    uint8_t delta_q_res;
    uint8_t delta_lf_res;
    uint8_t ref_order_hint[STD_VIDEO_AV1_NUM_REF_FRAMES];
    int8_t ref_frame_idx[STD_VIDEO_AV1_REFS_PER_FRAME];
    uint8_t reserved1[3];
    uint32_t delta_frame_id_minus_1[STD_VIDEO_AV1_REFS_PER_FRAME];
    PTR32 pTileInfo;
    PTR32 pQuantization;
    PTR32 pSegmentation;
    PTR32 pLoopFilter;
    PTR32 pCDEF;
    PTR32 pLoopRestoration;
    PTR32 pGlobalMotion;
    PTR32 pExtensionHeader;
    PTR32 pBufferRemovalTimes;
} StdVideoEncodeAV1PictureInfo32;

typedef struct StdVideoEncodeAV1ReferenceInfo32
{
    StdVideoEncodeAV1ReferenceInfoFlags flags;
    uint32_t RefFrameId;
    StdVideoAV1FrameType frame_type;
    uint8_t OrderHint;
    uint8_t reserved1[3];
    PTR32 pExtensionHeader;
} StdVideoEncodeAV1ReferenceInfo32;

typedef struct StdVideoEncodeH264PictureInfo32
{
    StdVideoEncodeH264PictureInfoFlags flags;
    uint8_t seq_parameter_set_id;
    uint8_t pic_parameter_set_id;
    uint16_t idr_pic_id;
    StdVideoH264PictureType primary_pic_type;
    uint32_t frame_num;
    int32_t PicOrderCnt;
    uint8_t temporal_id;
    uint8_t reserved1[3];
    PTR32 pRefLists;
} StdVideoEncodeH264PictureInfo32;

typedef struct VkAccelerationStructureGeometryKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkGeometryTypeKHR geometryType;
    VkAccelerationStructureGeometryDataKHR32 DECLSPEC_ALIGN(8) geometry;
    VkGeometryFlagsKHR flags;
} VkAccelerationStructureGeometryKHR32;

typedef struct VkAccelerationStructureInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureTypeNV type;
    VkBuildAccelerationStructureFlagsNV flags;
    uint32_t instanceCount;
    uint32_t geometryCount;
    PTR32 pGeometries;
} VkAccelerationStructureInfoNV32;

typedef struct VkAntiLagPresentationInfoAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAntiLagStageAMD stage;
    uint64_t DECLSPEC_ALIGN(8) frameIndex;
} VkAntiLagPresentationInfoAMD32;

typedef struct VkApplicationInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pApplicationName;
    uint32_t applicationVersion;
    PTR32 pEngineName;
    uint32_t engineVersion;
    uint32_t apiVersion;
} VkApplicationInfo32;

typedef struct VkAttachmentDescription232
{
    VkStructureType sType;
    PTR32 pNext;
    VkAttachmentDescriptionFlags flags;
    VkFormat format;
    VkSampleCountFlagBits samples;
    VkAttachmentLoadOp loadOp;
    VkAttachmentStoreOp storeOp;
    VkAttachmentLoadOp stencilLoadOp;
    VkAttachmentStoreOp stencilStoreOp;
    VkImageLayout initialLayout;
    VkImageLayout finalLayout;
} VkAttachmentDescription232;
typedef VkAttachmentDescription232 VkAttachmentDescription2KHR32;

typedef struct VkAttachmentSampleLocationsEXT32
{
    uint32_t attachmentIndex;
    VkSampleLocationsInfoEXT32 sampleLocationsInfo;
} VkAttachmentSampleLocationsEXT32;

typedef struct VkBufferCopy232
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) srcOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkBufferCopy232;
typedef VkBufferCopy232 VkBufferCopy2KHR32;

typedef struct VkBufferCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBufferCreateFlags flags;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkBufferUsageFlags usage;
    VkSharingMode sharingMode;
    uint32_t queueFamilyIndexCount;
    PTR32 pQueueFamilyIndices;
} VkBufferCreateInfo32;

typedef struct VkBufferImageCopy232
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) bufferOffset;
    uint32_t bufferRowLength;
    uint32_t bufferImageHeight;
    VkImageSubresourceLayers imageSubresource;
    VkOffset3D imageOffset;
    VkExtent3D imageExtent;
} VkBufferImageCopy232;
typedef VkBufferImageCopy232 VkBufferImageCopy2KHR32;

typedef struct VkBufferMemoryBarrier232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) srcStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) srcAccessMask;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) dstStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) dstAccessMask;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkBufferMemoryBarrier232;
typedef VkBufferMemoryBarrier232 VkBufferMemoryBarrier2KHR32;

typedef struct VkClusterAccelerationStructureInputInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxAccelerationStructureCount;
    VkBuildAccelerationStructureFlagsKHR flags;
    VkClusterAccelerationStructureOpTypeNV opType;
    VkClusterAccelerationStructureOpModeNV opMode;
    VkClusterAccelerationStructureOpInputNV32 opInput;
} VkClusterAccelerationStructureInputInfoNV32;

typedef struct VkCoarseSampleOrderCustomNV32
{
    VkShadingRatePaletteEntryNV shadingRate;
    uint32_t sampleCount;
    uint32_t sampleLocationCount;
    PTR32 pSampleLocations;
} VkCoarseSampleOrderCustomNV32;

typedef struct VkCommandBufferInheritanceInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderPass DECLSPEC_ALIGN(8) renderPass;
    uint32_t subpass;
    VkFramebuffer DECLSPEC_ALIGN(8) framebuffer;
    VkBool32 occlusionQueryEnable;
    VkQueryControlFlags queryFlags;
    VkQueryPipelineStatisticFlags pipelineStatistics;
} VkCommandBufferInheritanceInfo32;

typedef struct VkCommandBufferSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 commandBuffer;
    uint32_t deviceMask;
} VkCommandBufferSubmitInfo32;
typedef VkCommandBufferSubmitInfo32 VkCommandBufferSubmitInfoKHR32;

typedef struct VkDataGraphPipelineConstantARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t id;
    PTR32 pConstantData;
} VkDataGraphPipelineConstantARM32;

typedef struct VkDataGraphPipelineResourceInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t descriptorSet;
    uint32_t binding;
    uint32_t arrayElement;
} VkDataGraphPipelineResourceInfoARM32;

typedef struct VkDebugUtilsLabelEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pLabelName;
    float color[4];
} VkDebugUtilsLabelEXT32;

typedef struct VkDebugUtilsObjectNameInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkObjectType objectType;
    uint64_t DECLSPEC_ALIGN(8) objectHandle;
    PTR32 pObjectName;
} VkDebugUtilsObjectNameInfoEXT32;

typedef union VkDescriptorDataEXT32
{
    PTR32 pSampler;
    PTR32 pCombinedImageSampler;
    PTR32 pInputAttachmentImage;
    PTR32 pSampledImage;
    PTR32 pStorageImage;
    PTR32 pUniformTexelBuffer;
    PTR32 pStorageTexelBuffer;
    PTR32 pUniformBuffer;
    PTR32 pStorageBuffer;
    VkDeviceAddress DECLSPEC_ALIGN(8) accelerationStructure;
} VkDescriptorDataEXT32;

typedef struct VkDescriptorSetLayoutBinding32
{
    uint32_t binding;
    VkDescriptorType descriptorType;
    uint32_t descriptorCount;
    VkShaderStageFlags stageFlags;
    PTR32 pImmutableSamplers;
} VkDescriptorSetLayoutBinding32;

typedef struct VkDescriptorUpdateTemplateEntry32
{
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
    VkDescriptorType descriptorType;
    PTR32 offset;
    PTR32 stride;
} VkDescriptorUpdateTemplateEntry32;
typedef VkDescriptorUpdateTemplateEntry32 VkDescriptorUpdateTemplateEntryKHR32;

typedef struct VkDeviceFaultAddressInfoEXT32
{
    VkDeviceFaultAddressTypeEXT addressType;
    VkDeviceAddress DECLSPEC_ALIGN(8) reportedAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) addressPrecision;
} VkDeviceFaultAddressInfoEXT32;

typedef struct VkDeviceFaultVendorInfoEXT32
{
    char description[VK_MAX_DESCRIPTION_SIZE];
    uint64_t DECLSPEC_ALIGN(8) vendorFaultCode;
    uint64_t DECLSPEC_ALIGN(8) vendorFaultData;
} VkDeviceFaultVendorInfoEXT32;

typedef struct VkDeviceQueueCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceQueueCreateFlags flags;
    uint32_t queueFamilyIndex;
    uint32_t queueCount;
    PTR32 pQueuePriorities;
} VkDeviceQueueCreateInfo32;

typedef struct VkFramebufferAttachmentImageInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageCreateFlags flags;
    VkImageUsageFlags usage;
    uint32_t width;
    uint32_t height;
    uint32_t layerCount;
    uint32_t viewFormatCount;
    PTR32 pViewFormats;
} VkFramebufferAttachmentImageInfo32;
typedef VkFramebufferAttachmentImageInfo32 VkFramebufferAttachmentImageInfoKHR32;

typedef struct VkGraphicsShaderGroupCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t stageCount;
    PTR32 pStages;
    PTR32 pVertexInputState;
    PTR32 pTessellationState;
} VkGraphicsShaderGroupCreateInfoNV32;

typedef struct VkImageBlit232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageSubresourceLayers srcSubresource;
    VkOffset3D srcOffsets[2];
    VkImageSubresourceLayers dstSubresource;
    VkOffset3D dstOffsets[2];
} VkImageBlit232;
typedef VkImageBlit232 VkImageBlit2KHR32;

typedef struct VkImageCopy232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageSubresourceLayers srcSubresource;
    VkOffset3D srcOffset;
    VkImageSubresourceLayers dstSubresource;
    VkOffset3D dstOffset;
    VkExtent3D extent;
} VkImageCopy232;
typedef VkImageCopy232 VkImageCopy2KHR32;

typedef struct VkImageFormatProperties32
{
    VkExtent3D maxExtent;
    uint32_t maxMipLevels;
    uint32_t maxArrayLayers;
    VkSampleCountFlags sampleCounts;
    VkDeviceSize DECLSPEC_ALIGN(8) maxResourceSize;
} VkImageFormatProperties32;

typedef struct VkImageMemoryBarrier232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) srcStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) srcAccessMask;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) dstStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) dstAccessMask;
    VkImageLayout oldLayout;
    VkImageLayout newLayout;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    VkImage DECLSPEC_ALIGN(8) image;
    VkImageSubresourceRange subresourceRange;
} VkImageMemoryBarrier232;
typedef VkImageMemoryBarrier232 VkImageMemoryBarrier2KHR32;

typedef struct VkImageResolve232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageSubresourceLayers srcSubresource;
    VkOffset3D srcOffset;
    VkImageSubresourceLayers dstSubresource;
    VkOffset3D dstOffset;
    VkExtent3D extent;
} VkImageResolve232;
typedef VkImageResolve232 VkImageResolve2KHR32;

typedef struct VkImageSubresource232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageSubresource imageSubresource;
} VkImageSubresource232;
typedef VkImageSubresource232 VkImageSubresource2KHR32;
typedef VkImageSubresource232 VkImageSubresource2EXT32;

typedef struct VkImageToMemoryCopy32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pHostPointer;
    uint32_t memoryRowLength;
    uint32_t memoryImageHeight;
    VkImageSubresourceLayers imageSubresource;
    VkOffset3D imageOffset;
    VkExtent3D imageExtent;
} VkImageToMemoryCopy32;
typedef VkImageToMemoryCopy32 VkImageToMemoryCopyEXT32;

typedef struct VkIndirectCommandsLayoutTokenEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkIndirectCommandsTokenTypeEXT type;
    VkIndirectCommandsTokenDataEXT32 data;
    uint32_t offset;
} VkIndirectCommandsLayoutTokenEXT32;

typedef struct VkIndirectCommandsLayoutTokenNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkIndirectCommandsTokenTypeNV tokenType;
    uint32_t stream;
    uint32_t offset;
    uint32_t vertexBindingUnit;
    VkBool32 vertexDynamicStride;
    VkPipelineLayout DECLSPEC_ALIGN(8) pushconstantPipelineLayout;
    VkShaderStageFlags pushconstantShaderStageFlags;
    uint32_t pushconstantOffset;
    uint32_t pushconstantSize;
    VkIndirectStateFlagsNV indirectStateFlags;
    uint32_t indexTypeCount;
    PTR32 pIndexTypes;
    PTR32 pIndexTypeValues;
} VkIndirectCommandsLayoutTokenNV32;

typedef struct VkIndirectCommandsStreamNV32
{
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
} VkIndirectCommandsStreamNV32;

typedef union VkIndirectExecutionSetInfoEXT32
{
    PTR32 pPipelineInfo;
    PTR32 pShaderInfo;
} VkIndirectExecutionSetInfoEXT32;

typedef struct VkLatencyTimingsFrameReportNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) presentID;
    uint64_t DECLSPEC_ALIGN(8) inputSampleTimeUs;
    uint64_t DECLSPEC_ALIGN(8) simStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) simEndTimeUs;
    uint64_t DECLSPEC_ALIGN(8) renderSubmitStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) renderSubmitEndTimeUs;
    uint64_t DECLSPEC_ALIGN(8) presentStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) presentEndTimeUs;
    uint64_t DECLSPEC_ALIGN(8) driverStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) driverEndTimeUs;
    uint64_t DECLSPEC_ALIGN(8) osRenderQueueStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) osRenderQueueEndTimeUs;
    uint64_t DECLSPEC_ALIGN(8) gpuRenderStartTimeUs;
    uint64_t DECLSPEC_ALIGN(8) gpuRenderEndTimeUs;
} VkLatencyTimingsFrameReportNV32;

typedef struct VkLayerSettingEXT32
{
    PTR32 pLayerName;
    PTR32 pSettingName;
    VkLayerSettingTypeEXT type;
    uint32_t valueCount;
    PTR32 pValues;
} VkLayerSettingEXT32;

typedef struct VkMemoryBarrier232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) srcStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) srcAccessMask;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) dstStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) dstAccessMask;
} VkMemoryBarrier232;
typedef VkMemoryBarrier232 VkMemoryBarrier2KHR32;

typedef struct VkMemoryRequirements32
{
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkDeviceSize DECLSPEC_ALIGN(8) alignment;
    uint32_t memoryTypeBits;
} VkMemoryRequirements32;

typedef struct VkMemoryToImageCopy32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pHostPointer;
    uint32_t memoryRowLength;
    uint32_t memoryImageHeight;
    VkImageSubresourceLayers imageSubresource;
    VkOffset3D imageOffset;
    VkExtent3D imageExtent;
} VkMemoryToImageCopy32;
typedef VkMemoryToImageCopy32 VkMemoryToImageCopyEXT32;

typedef struct VkMutableDescriptorTypeListEXT32
{
    uint32_t descriptorTypeCount;
    PTR32 pDescriptorTypes;
} VkMutableDescriptorTypeListEXT32;
typedef VkMutableDescriptorTypeListEXT32 VkMutableDescriptorTypeListVALVE32;

typedef struct VkPartitionedAccelerationStructureInstancesInputNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuildAccelerationStructureFlagsKHR flags;
    uint32_t instanceCount;
    uint32_t maxInstancePerPartitionCount;
    uint32_t partitionCount;
    uint32_t maxInstanceInGlobalPartitionCount;
} VkPartitionedAccelerationStructureInstancesInputNV32;

typedef union VkPerformanceValueDataINTEL32
{
    uint32_t value32;
    uint64_t DECLSPEC_ALIGN(8) value64;
    float valueFloat;
    VkBool32 valueBool;
    PTR32 valueString;
} VkPerformanceValueDataINTEL32;

typedef struct VkPhysicalDeviceMemoryProperties32
{
    uint32_t memoryTypeCount;
    VkMemoryType memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t memoryHeapCount;
    VkMemoryHeap32 DECLSPEC_ALIGN(8) memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties32;

typedef struct VkPhysicalDeviceProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPhysicalDeviceProperties32 DECLSPEC_ALIGN(8) properties;
} VkPhysicalDeviceProperties232;
typedef VkPhysicalDeviceProperties232 VkPhysicalDeviceProperties2KHR32;

typedef struct VkPipelineBinaryKeysAndDataKHR32
{
    uint32_t binaryCount;
    PTR32 pPipelineBinaryKeys;
    PTR32 pPipelineBinaryData;
} VkPipelineBinaryKeysAndDataKHR32;

typedef struct VkPipelineCacheCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCacheCreateFlags flags;
    PTR32 initialDataSize;
    PTR32 pInitialData;
} VkPipelineCacheCreateInfo32;

typedef struct VkPipelineColorBlendStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineColorBlendStateCreateFlags flags;
    VkBool32 logicOpEnable;
    VkLogicOp logicOp;
    uint32_t attachmentCount;
    PTR32 pAttachments;
    float blendConstants[4];
} VkPipelineColorBlendStateCreateInfo32;

typedef struct VkPipelineCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
} VkPipelineCreateInfoKHR32;

typedef struct VkPipelineCreationFeedback32
{
    VkPipelineCreationFeedbackFlags flags;
    uint64_t DECLSPEC_ALIGN(8) duration;
} VkPipelineCreationFeedback32;
typedef VkPipelineCreationFeedback32 VkPipelineCreationFeedbackEXT32;

typedef struct VkPipelineDepthStencilStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineDepthStencilStateCreateFlags flags;
    VkBool32 depthTestEnable;
    VkBool32 depthWriteEnable;
    VkCompareOp depthCompareOp;
    VkBool32 depthBoundsTestEnable;
    VkBool32 stencilTestEnable;
    VkStencilOpState front;
    VkStencilOpState back;
    float minDepthBounds;
    float maxDepthBounds;
} VkPipelineDepthStencilStateCreateInfo32;

typedef struct VkPipelineDynamicStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineDynamicStateCreateFlags flags;
    uint32_t dynamicStateCount;
    PTR32 pDynamicStates;
} VkPipelineDynamicStateCreateInfo32;

typedef union VkPipelineExecutableStatisticValueKHR32
{
    VkBool32 b32;
    int64_t i64;
    uint64_t DECLSPEC_ALIGN(8) u64;
    double f64;
} VkPipelineExecutableStatisticValueKHR32;

typedef struct VkPipelineInputAssemblyStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineInputAssemblyStateCreateFlags flags;
    VkPrimitiveTopology topology;
    VkBool32 primitiveRestartEnable;
} VkPipelineInputAssemblyStateCreateInfo32;

typedef struct VkPipelineLibraryCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t libraryCount;
    PTR32 pLibraries;
} VkPipelineLibraryCreateInfoKHR32;

typedef struct VkPipelineMultisampleStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineMultisampleStateCreateFlags flags;
    VkSampleCountFlagBits rasterizationSamples;
    VkBool32 sampleShadingEnable;
    float minSampleShading;
    PTR32 pSampleMask;
    VkBool32 alphaToCoverageEnable;
    VkBool32 alphaToOneEnable;
} VkPipelineMultisampleStateCreateInfo32;

typedef struct VkPipelineRasterizationStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRasterizationStateCreateFlags flags;
    VkBool32 depthClampEnable;
    VkBool32 rasterizerDiscardEnable;
    VkPolygonMode polygonMode;
    VkCullModeFlags cullMode;
    VkFrontFace frontFace;
    VkBool32 depthBiasEnable;
    float depthBiasConstantFactor;
    float depthBiasClamp;
    float depthBiasSlopeFactor;
    float lineWidth;
} VkPipelineRasterizationStateCreateInfo32;

typedef struct VkPipelineViewportStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineViewportStateCreateFlags flags;
    uint32_t viewportCount;
    PTR32 pViewports;
    uint32_t scissorCount;
    PTR32 pScissors;
} VkPipelineViewportStateCreateInfo32;

typedef struct VkPresentRegionKHR32
{
    uint32_t rectangleCount;
    PTR32 pRectangles;
} VkPresentRegionKHR32;

typedef struct VkRayTracingPipelineInterfaceCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxPipelineRayPayloadSize;
    uint32_t maxPipelineRayHitAttributeSize;
} VkRayTracingPipelineInterfaceCreateInfoKHR32;

typedef struct VkRayTracingShaderGroupCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRayTracingShaderGroupTypeKHR type;
    uint32_t generalShader;
    uint32_t closestHitShader;
    uint32_t anyHitShader;
    uint32_t intersectionShader;
    PTR32 pShaderGroupCaptureReplayHandle;
} VkRayTracingShaderGroupCreateInfoKHR32;

typedef struct VkRayTracingShaderGroupCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRayTracingShaderGroupTypeKHR type;
    uint32_t generalShader;
    uint32_t closestHitShader;
    uint32_t anyHitShader;
    uint32_t intersectionShader;
} VkRayTracingShaderGroupCreateInfoNV32;

typedef struct VkRenderPassStripeInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRect2D stripeArea;
} VkRenderPassStripeInfoARM32;

typedef struct VkRenderingAttachmentInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) imageView;
    VkImageLayout imageLayout;
    VkResolveModeFlagBits resolveMode;
    VkImageView DECLSPEC_ALIGN(8) resolveImageView;
    VkImageLayout resolveImageLayout;
    VkAttachmentLoadOp loadOp;
    VkAttachmentStoreOp storeOp;
    VkClearValue clearValue;
} VkRenderingAttachmentInfo32;
typedef VkRenderingAttachmentInfo32 VkRenderingAttachmentInfoKHR32;

typedef struct VkSemaphoreSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    uint64_t DECLSPEC_ALIGN(8) value;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stageMask;
    uint32_t deviceIndex;
} VkSemaphoreSubmitInfo32;
typedef VkSemaphoreSubmitInfo32 VkSemaphoreSubmitInfoKHR32;

typedef struct VkShadingRatePaletteNV32
{
    uint32_t shadingRatePaletteEntryCount;
    PTR32 pShadingRatePaletteEntries;
} VkShadingRatePaletteNV32;

typedef struct VkSparseBufferMemoryBindInfo32
{
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    uint32_t bindCount;
    PTR32 pBinds;
} VkSparseBufferMemoryBindInfo32;

typedef struct VkSparseImageMemoryBindInfo32
{
    VkImage DECLSPEC_ALIGN(8) image;
    uint32_t bindCount;
    PTR32 pBinds;
} VkSparseImageMemoryBindInfo32;

typedef struct VkSparseImageMemoryRequirements32
{
    VkSparseImageFormatProperties formatProperties;
    uint32_t imageMipTailFirstLod;
    VkDeviceSize DECLSPEC_ALIGN(8) imageMipTailSize;
    VkDeviceSize DECLSPEC_ALIGN(8) imageMipTailOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) imageMipTailStride;
} VkSparseImageMemoryRequirements32;

typedef struct VkSparseImageOpaqueMemoryBindInfo32
{
    VkImage DECLSPEC_ALIGN(8) image;
    uint32_t bindCount;
    PTR32 pBinds;
} VkSparseImageOpaqueMemoryBindInfo32;

typedef struct VkStridedDeviceAddressRegionKHR32
{
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) stride;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkStridedDeviceAddressRegionKHR32;

typedef struct VkSubpassDependency232
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t srcSubpass;
    uint32_t dstSubpass;
    VkPipelineStageFlags srcStageMask;
    VkPipelineStageFlags dstStageMask;
    VkAccessFlags srcAccessMask;
    VkAccessFlags dstAccessMask;
    VkDependencyFlags dependencyFlags;
    int32_t viewOffset;
} VkSubpassDependency232;
typedef VkSubpassDependency232 VkSubpassDependency2KHR32;

typedef struct VkSubpassDescription32
{
    VkSubpassDescriptionFlags flags;
    VkPipelineBindPoint pipelineBindPoint;
    uint32_t inputAttachmentCount;
    PTR32 pInputAttachments;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachments;
    PTR32 pResolveAttachments;
    PTR32 pDepthStencilAttachment;
    uint32_t preserveAttachmentCount;
    PTR32 pPreserveAttachments;
} VkSubpassDescription32;

typedef struct VkSubpassDescription232
{
    VkStructureType sType;
    PTR32 pNext;
    VkSubpassDescriptionFlags flags;
    VkPipelineBindPoint pipelineBindPoint;
    uint32_t viewMask;
    uint32_t inputAttachmentCount;
    PTR32 pInputAttachments;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachments;
    PTR32 pResolveAttachments;
    PTR32 pDepthStencilAttachment;
    uint32_t preserveAttachmentCount;
    PTR32 pPreserveAttachments;
} VkSubpassDescription232;
typedef VkSubpassDescription232 VkSubpassDescription2KHR32;

typedef struct VkSubpassSampleLocationsEXT32
{
    uint32_t subpassIndex;
    VkSampleLocationsInfoEXT32 sampleLocationsInfo;
} VkSubpassSampleLocationsEXT32;

typedef struct VkSubresourceLayout32
{
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkDeviceSize DECLSPEC_ALIGN(8) rowPitch;
    VkDeviceSize DECLSPEC_ALIGN(8) arrayPitch;
    VkDeviceSize DECLSPEC_ALIGN(8) depthPitch;
} VkSubresourceLayout32;

typedef struct VkTensorCopyARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t dimensionCount;
    PTR32 pSrcOffset;
    PTR32 pDstOffset;
    PTR32 pExtent;
} VkTensorCopyARM32;

typedef struct VkTensorCreateInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorCreateFlagsARM DECLSPEC_ALIGN(8) flags;
    PTR32 pDescription;
    VkSharingMode sharingMode;
    uint32_t queueFamilyIndexCount;
    PTR32 pQueueFamilyIndices;
} VkTensorCreateInfoARM32;

typedef struct VkTensorMemoryBarrierARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) srcStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) srcAccessMask;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) dstStageMask;
    VkAccessFlags2 DECLSPEC_ALIGN(8) dstAccessMask;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    VkTensorARM DECLSPEC_ALIGN(8) tensor;
} VkTensorMemoryBarrierARM32;

typedef struct VkVideoDecodeH264SessionParametersAddInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t stdSPSCount;
    PTR32 pStdSPSs;
    uint32_t stdPPSCount;
    PTR32 pStdPPSs;
} VkVideoDecodeH264SessionParametersAddInfoKHR32;

typedef struct VkVideoEncodeH264NaluSliceInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    int32_t constantQp;
    PTR32 pStdSliceHeader;
} VkVideoEncodeH264NaluSliceInfoKHR32;

typedef struct VkVideoEncodeH264SessionParametersAddInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t stdSPSCount;
    PTR32 pStdSPSs;
    uint32_t stdPPSCount;
    PTR32 pStdPPSs;
} VkVideoEncodeH264SessionParametersAddInfoKHR32;

typedef struct VkVideoEncodeRateControlLayerInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) averageBitrate;
    uint64_t DECLSPEC_ALIGN(8) maxBitrate;
    uint32_t frameRateNumerator;
    uint32_t frameRateDenominator;
} VkVideoEncodeRateControlLayerInfoKHR32;

typedef struct VkVideoProfileInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoCodecOperationFlagBitsKHR videoCodecOperation;
    VkVideoChromaSubsamplingFlagsKHR chromaSubsampling;
    VkVideoComponentBitDepthFlagsKHR lumaBitDepth;
    VkVideoComponentBitDepthFlagsKHR chromaBitDepth;
} VkVideoProfileInfoKHR32;

typedef struct VkVideoReferenceSlotInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    int32_t slotIndex;
    PTR32 pPictureResource;
} VkVideoReferenceSlotInfoKHR32;

typedef struct VkWriteDescriptorSet32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorSet DECLSPEC_ALIGN(8) dstSet;
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
    VkDescriptorType descriptorType;
    PTR32 pImageInfo;
    PTR32 pBufferInfo;
    PTR32 pTexelBufferView;
} VkWriteDescriptorSet32;

typedef struct VkAccelerationStructureBuildGeometryInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureTypeKHR type;
    VkBuildAccelerationStructureFlagsKHR flags;
    VkBuildAccelerationStructureModeKHR mode;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) srcAccelerationStructure;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) dstAccelerationStructure;
    uint32_t geometryCount;
    PTR32 pGeometries;
    PTR32 ppGeometries;
    VkDeviceOrHostAddressKHR DECLSPEC_ALIGN(8) scratchData;
} VkAccelerationStructureBuildGeometryInfoKHR32;

typedef struct VkAccelerationStructureBuildSizesInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) accelerationStructureSize;
    VkDeviceSize DECLSPEC_ALIGN(8) updateScratchSize;
    VkDeviceSize DECLSPEC_ALIGN(8) buildScratchSize;
} VkAccelerationStructureBuildSizesInfoKHR32;

typedef struct VkAccelerationStructureCaptureDescriptorDataInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) accelerationStructure;
    VkAccelerationStructureNV DECLSPEC_ALIGN(8) accelerationStructureNV;
} VkAccelerationStructureCaptureDescriptorDataInfoEXT32;

typedef struct VkAccelerationStructureCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureCreateFlagsKHR createFlags;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkAccelerationStructureTypeKHR type;
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
} VkAccelerationStructureCreateInfoKHR32;

typedef struct VkAccelerationStructureCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) compactedSize;
    VkAccelerationStructureInfoNV32 info;
} VkAccelerationStructureCreateInfoNV32;

typedef struct VkAccelerationStructureDeviceAddressInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) accelerationStructure;
} VkAccelerationStructureDeviceAddressInfoKHR32;

typedef struct VkAccelerationStructureGeometryLinearSweptSpheresDataNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat vertexFormat;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) vertexData;
    VkDeviceSize DECLSPEC_ALIGN(8) vertexStride;
    VkFormat radiusFormat;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) radiusData;
    VkDeviceSize DECLSPEC_ALIGN(8) radiusStride;
    VkIndexType indexType;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) indexData;
    VkDeviceSize DECLSPEC_ALIGN(8) indexStride;
    VkRayTracingLssIndexingModeNV indexingMode;
    VkRayTracingLssPrimitiveEndCapsModeNV endCapsMode;
} VkAccelerationStructureGeometryLinearSweptSpheresDataNV32;

typedef struct VkAccelerationStructureGeometryMotionTrianglesDataNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) vertexData;
} VkAccelerationStructureGeometryMotionTrianglesDataNV32;

typedef struct VkAccelerationStructureGeometrySpheresDataNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat vertexFormat;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) vertexData;
    VkDeviceSize DECLSPEC_ALIGN(8) vertexStride;
    VkFormat radiusFormat;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) radiusData;
    VkDeviceSize DECLSPEC_ALIGN(8) radiusStride;
    VkIndexType indexType;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) indexData;
    VkDeviceSize DECLSPEC_ALIGN(8) indexStride;
} VkAccelerationStructureGeometrySpheresDataNV32;

typedef struct VkAccelerationStructureMemoryRequirementsInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureMemoryRequirementsTypeNV type;
    VkAccelerationStructureNV DECLSPEC_ALIGN(8) accelerationStructure;
} VkAccelerationStructureMemoryRequirementsInfoNV32;

typedef struct VkAccelerationStructureMotionInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxInstances;
    VkAccelerationStructureMotionInfoFlagsNV flags;
} VkAccelerationStructureMotionInfoNV32;

typedef struct VkAccelerationStructureTrianglesOpacityMicromapEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkIndexType indexType;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) indexBuffer;
    VkDeviceSize DECLSPEC_ALIGN(8) indexStride;
    uint32_t baseTriangle;
    uint32_t usageCountsCount;
    PTR32 pUsageCounts;
    PTR32 ppUsageCounts;
    VkMicromapEXT DECLSPEC_ALIGN(8) micromap;
} VkAccelerationStructureTrianglesOpacityMicromapEXT32;

typedef struct VkAccelerationStructureVersionInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pVersionData;
} VkAccelerationStructureVersionInfoKHR32;

typedef struct VkAcquireNextImageInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
    uint64_t DECLSPEC_ALIGN(8) timeout;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    VkFence DECLSPEC_ALIGN(8) fence;
    uint32_t deviceMask;
} VkAcquireNextImageInfoKHR32;

typedef struct VkAcquireProfilingLockInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAcquireProfilingLockFlagsKHR flags;
    uint64_t DECLSPEC_ALIGN(8) timeout;
} VkAcquireProfilingLockInfoKHR32;

typedef struct VkAntiLagDataAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAntiLagModeAMD mode;
    uint32_t maxFPS;
    PTR32 pPresentationInfo;
} VkAntiLagDataAMD32;

typedef struct VkAttachmentDescriptionStencilLayout32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageLayout stencilInitialLayout;
    VkImageLayout stencilFinalLayout;
} VkAttachmentDescriptionStencilLayout32;
typedef VkAttachmentDescriptionStencilLayout32 VkAttachmentDescriptionStencilLayoutKHR32;

typedef struct VkAttachmentFeedbackLoopInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 feedbackLoopEnable;
} VkAttachmentFeedbackLoopInfoEXT32;

typedef struct VkAttachmentReferenceStencilLayout32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageLayout stencilLayout;
} VkAttachmentReferenceStencilLayout32;
typedef VkAttachmentReferenceStencilLayout32 VkAttachmentReferenceStencilLayoutKHR32;

typedef struct VkAttachmentSampleCountInfoAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachmentSamples;
    VkSampleCountFlagBits depthStencilAttachmentSamples;
} VkAttachmentSampleCountInfoAMD32;
typedef VkAttachmentSampleCountInfoAMD32 VkAttachmentSampleCountInfoNV32;

typedef struct VkBindAccelerationStructureMemoryInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureNV DECLSPEC_ALIGN(8) accelerationStructure;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
    uint32_t deviceIndexCount;
    PTR32 pDeviceIndices;
} VkBindAccelerationStructureMemoryInfoNV32;

typedef struct VkBindBufferMemoryDeviceGroupInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t deviceIndexCount;
    PTR32 pDeviceIndices;
} VkBindBufferMemoryDeviceGroupInfo32;
typedef VkBindBufferMemoryDeviceGroupInfo32 VkBindBufferMemoryDeviceGroupInfoKHR32;

typedef struct VkBindBufferMemoryInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
} VkBindBufferMemoryInfo32;
typedef VkBindBufferMemoryInfo32 VkBindBufferMemoryInfoKHR32;

typedef struct VkBindDataGraphPipelineSessionMemoryInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDataGraphPipelineSessionARM DECLSPEC_ALIGN(8) session;
    VkDataGraphPipelineSessionBindPointARM bindPoint;
    uint32_t objectIndex;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
} VkBindDataGraphPipelineSessionMemoryInfoARM32;

typedef struct VkBindDescriptorBufferEmbeddedSamplersInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags stageFlags;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    uint32_t set;
} VkBindDescriptorBufferEmbeddedSamplersInfoEXT32;

typedef struct VkBindDescriptorSetsInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags stageFlags;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    uint32_t firstSet;
    uint32_t descriptorSetCount;
    PTR32 pDescriptorSets;
    uint32_t dynamicOffsetCount;
    PTR32 pDynamicOffsets;
} VkBindDescriptorSetsInfo32;
typedef VkBindDescriptorSetsInfo32 VkBindDescriptorSetsInfoKHR32;

typedef struct VkBindImageMemoryDeviceGroupInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t deviceIndexCount;
    PTR32 pDeviceIndices;
    uint32_t splitInstanceBindRegionCount;
    PTR32 pSplitInstanceBindRegions;
} VkBindImageMemoryDeviceGroupInfo32;
typedef VkBindImageMemoryDeviceGroupInfo32 VkBindImageMemoryDeviceGroupInfoKHR32;

typedef struct VkBindImageMemoryInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
} VkBindImageMemoryInfo32;
typedef VkBindImageMemoryInfo32 VkBindImageMemoryInfoKHR32;

typedef struct VkBindImageMemorySwapchainInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
    uint32_t imageIndex;
} VkBindImageMemorySwapchainInfoKHR32;

typedef struct VkBindImagePlaneMemoryInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageAspectFlagBits planeAspect;
} VkBindImagePlaneMemoryInfo32;
typedef VkBindImagePlaneMemoryInfo32 VkBindImagePlaneMemoryInfoKHR32;

typedef struct VkBindMemoryStatus32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pResult;
} VkBindMemoryStatus32;
typedef VkBindMemoryStatus32 VkBindMemoryStatusKHR32;

typedef struct VkBindSparseInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreCount;
    PTR32 pWaitSemaphores;
    uint32_t bufferBindCount;
    PTR32 pBufferBinds;
    uint32_t imageOpaqueBindCount;
    PTR32 pImageOpaqueBinds;
    uint32_t imageBindCount;
    PTR32 pImageBinds;
    uint32_t signalSemaphoreCount;
    PTR32 pSignalSemaphores;
} VkBindSparseInfo32;

typedef struct VkBindTensorMemoryInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorARM DECLSPEC_ALIGN(8) tensor;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
} VkBindTensorMemoryInfoARM32;

typedef struct VkBindVideoSessionMemoryInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t memoryBindIndex;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) memorySize;
} VkBindVideoSessionMemoryInfoKHR32;

typedef struct VkBlitImageCubicWeightsInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCubicFilterWeightsQCOM cubicWeights;
} VkBlitImageCubicWeightsInfoQCOM32;

typedef struct VkBlitImageInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
    VkFilter filter;
} VkBlitImageInfo232;
typedef VkBlitImageInfo232 VkBlitImageInfo2KHR32;

typedef struct VkBufferCaptureDescriptorDataInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkBufferCaptureDescriptorDataInfoEXT32;

typedef struct VkBufferCopy32
{
    VkDeviceSize DECLSPEC_ALIGN(8) srcOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkBufferCopy32;

typedef struct VkBufferDeviceAddressCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
} VkBufferDeviceAddressCreateInfoEXT32;

typedef struct VkBufferDeviceAddressInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkBufferDeviceAddressInfo32;
typedef VkBufferDeviceAddressInfo32 VkBufferDeviceAddressInfoKHR32;
typedef VkBufferDeviceAddressInfo32 VkBufferDeviceAddressInfoEXT32;

typedef struct VkBufferImageCopy32
{
    VkDeviceSize DECLSPEC_ALIGN(8) bufferOffset;
    uint32_t bufferRowLength;
    uint32_t bufferImageHeight;
    VkImageSubresourceLayers imageSubresource;
    VkOffset3D imageOffset;
    VkExtent3D imageExtent;
} VkBufferImageCopy32;

typedef struct VkBufferMemoryBarrier32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccessFlags srcAccessMask;
    VkAccessFlags dstAccessMask;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkBufferMemoryBarrier32;

typedef struct VkBufferMemoryRequirementsInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkBufferMemoryRequirementsInfo232;
typedef VkBufferMemoryRequirementsInfo232 VkBufferMemoryRequirementsInfo2KHR32;

typedef struct VkBufferOpaqueCaptureAddressCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) opaqueCaptureAddress;
} VkBufferOpaqueCaptureAddressCreateInfo32;
typedef VkBufferOpaqueCaptureAddressCreateInfo32 VkBufferOpaqueCaptureAddressCreateInfoKHR32;

typedef struct VkBufferUsageFlags2CreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBufferUsageFlags2 DECLSPEC_ALIGN(8) usage;
} VkBufferUsageFlags2CreateInfo32;
typedef VkBufferUsageFlags2CreateInfo32 VkBufferUsageFlags2CreateInfoKHR32;

typedef struct VkBufferViewCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBufferViewCreateFlags flags;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkFormat format;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) range;
} VkBufferViewCreateInfo32;

typedef struct VkBuildPartitionedAccelerationStructureInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPartitionedAccelerationStructureInstancesInputNV32 input;
    VkDeviceAddress DECLSPEC_ALIGN(8) srcAccelerationStructureData;
    VkDeviceAddress DECLSPEC_ALIGN(8) dstAccelerationStructureData;
    VkDeviceAddress DECLSPEC_ALIGN(8) scratchData;
    VkDeviceAddress DECLSPEC_ALIGN(8) srcInfos;
    VkDeviceAddress DECLSPEC_ALIGN(8) srcInfosCount;
} VkBuildPartitionedAccelerationStructureInfoNV32;

typedef struct VkCalibratedTimestampInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTimeDomainKHR timeDomain;
} VkCalibratedTimestampInfoKHR32;
typedef VkCalibratedTimestampInfoKHR32 VkCalibratedTimestampInfoEXT32;

typedef struct VkCheckpointData2NV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stage;
    PTR32 pCheckpointMarker;
} VkCheckpointData2NV32;

typedef struct VkCheckpointDataNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlagBits stage;
    PTR32 pCheckpointMarker;
} VkCheckpointDataNV32;

typedef struct VkClusterAccelerationStructureCommandsInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkClusterAccelerationStructureInputInfoNV32 input;
    VkDeviceAddress DECLSPEC_ALIGN(8) dstImplicitData;
    VkDeviceAddress DECLSPEC_ALIGN(8) scratchData;
    VkStridedDeviceAddressRegionKHR32 DECLSPEC_ALIGN(8) dstAddressesArray;
    VkStridedDeviceAddressRegionKHR32 DECLSPEC_ALIGN(8) dstSizesArray;
    VkStridedDeviceAddressRegionKHR32 DECLSPEC_ALIGN(8) srcInfosArray;
    VkDeviceAddress DECLSPEC_ALIGN(8) srcInfosCount;
    VkClusterAccelerationStructureAddressResolutionFlagsNV addressResolutionFlags;
} VkClusterAccelerationStructureCommandsInfoNV32;

typedef struct VkCommandBufferAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCommandPool DECLSPEC_ALIGN(8) commandPool;
    VkCommandBufferLevel level;
    uint32_t commandBufferCount;
} VkCommandBufferAllocateInfo32;

typedef struct VkCommandBufferBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCommandBufferUsageFlags flags;
    PTR32 pInheritanceInfo;
} VkCommandBufferBeginInfo32;

typedef struct VkCommandBufferInheritanceConditionalRenderingInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 conditionalRenderingEnable;
} VkCommandBufferInheritanceConditionalRenderingInfoEXT32;

typedef struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceTransformFlagBitsKHR transform;
    VkRect2D renderArea;
} VkCommandBufferInheritanceRenderPassTransformInfoQCOM32;

typedef struct VkCommandBufferInheritanceRenderingInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderingFlags flags;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachmentFormats;
    VkFormat depthAttachmentFormat;
    VkFormat stencilAttachmentFormat;
    VkSampleCountFlagBits rasterizationSamples;
} VkCommandBufferInheritanceRenderingInfo32;
typedef VkCommandBufferInheritanceRenderingInfo32 VkCommandBufferInheritanceRenderingInfoKHR32;

typedef struct VkCommandBufferInheritanceViewportScissorInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 viewportScissor2D;
    uint32_t viewportDepthCount;
    PTR32 pViewportDepths;
} VkCommandBufferInheritanceViewportScissorInfoNV32;

typedef struct VkCommandPoolCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCommandPoolCreateFlags flags;
    uint32_t queueFamilyIndex;
} VkCommandPoolCreateInfo32;

typedef struct VkComputePipelineCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags flags;
    VkPipelineShaderStageCreateInfo32 DECLSPEC_ALIGN(8) stage;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    VkPipeline DECLSPEC_ALIGN(8) basePipelineHandle;
    int32_t basePipelineIndex;
} VkComputePipelineCreateInfo32;

typedef struct VkComputePipelineIndirectBufferInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkDeviceAddress DECLSPEC_ALIGN(8) pipelineDeviceAddressCaptureReplay;
} VkComputePipelineIndirectBufferInfoNV32;

typedef struct VkConditionalRenderingBeginInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkConditionalRenderingFlagsEXT flags;
} VkConditionalRenderingBeginInfoEXT32;

typedef struct VkConvertCooperativeVectorMatrixInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 srcSize;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) srcData;
    PTR32 pDstSize;
    VkDeviceOrHostAddressKHR DECLSPEC_ALIGN(8) dstData;
    VkComponentTypeKHR srcComponentType;
    VkComponentTypeKHR dstComponentType;
    uint32_t numRows;
    uint32_t numColumns;
    VkCooperativeVectorMatrixLayoutNV srcLayout;
    PTR32 srcStride;
    VkCooperativeVectorMatrixLayoutNV dstLayout;
    PTR32 dstStride;
} VkConvertCooperativeVectorMatrixInfoNV32;

typedef struct VkCooperativeMatrixFlexibleDimensionsPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t MGranularity;
    uint32_t NGranularity;
    uint32_t KGranularity;
    VkComponentTypeKHR AType;
    VkComponentTypeKHR BType;
    VkComponentTypeKHR CType;
    VkComponentTypeKHR ResultType;
    VkBool32 saturatingAccumulation;
    VkScopeKHR scope;
    uint32_t workgroupInvocations;
} VkCooperativeMatrixFlexibleDimensionsPropertiesNV32;

typedef struct VkCooperativeMatrixPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t MSize;
    uint32_t NSize;
    uint32_t KSize;
    VkComponentTypeKHR AType;
    VkComponentTypeKHR BType;
    VkComponentTypeKHR CType;
    VkComponentTypeKHR ResultType;
    VkBool32 saturatingAccumulation;
    VkScopeKHR scope;
} VkCooperativeMatrixPropertiesKHR32;

typedef struct VkCooperativeMatrixPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t MSize;
    uint32_t NSize;
    uint32_t KSize;
    VkComponentTypeNV AType;
    VkComponentTypeNV BType;
    VkComponentTypeNV CType;
    VkComponentTypeNV DType;
    VkScopeNV scope;
} VkCooperativeMatrixPropertiesNV32;

typedef struct VkCooperativeVectorPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkComponentTypeKHR inputType;
    VkComponentTypeKHR inputInterpretation;
    VkComponentTypeKHR matrixInterpretation;
    VkComponentTypeKHR biasInterpretation;
    VkComponentTypeKHR resultType;
    VkBool32 transpose;
} VkCooperativeVectorPropertiesNV32;

typedef struct VkCopyAccelerationStructureInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) src;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) dst;
    VkCopyAccelerationStructureModeKHR mode;
} VkCopyAccelerationStructureInfoKHR32;

typedef struct VkCopyAccelerationStructureToMemoryInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) src;
    VkDeviceOrHostAddressKHR DECLSPEC_ALIGN(8) dst;
    VkCopyAccelerationStructureModeKHR mode;
} VkCopyAccelerationStructureToMemoryInfoKHR32;

typedef struct VkCopyBufferInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) srcBuffer;
    VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyBufferInfo232;
typedef VkCopyBufferInfo232 VkCopyBufferInfo2KHR32;

typedef struct VkCopyBufferToImageInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) srcBuffer;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyBufferToImageInfo232;
typedef VkCopyBufferToImageInfo232 VkCopyBufferToImageInfo2KHR32;

typedef struct VkCopyCommandTransformInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceTransformFlagBitsKHR transform;
} VkCopyCommandTransformInfoQCOM32;

typedef struct VkCopyDescriptorSet32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorSet DECLSPEC_ALIGN(8) srcSet;
    uint32_t srcBinding;
    uint32_t srcArrayElement;
    VkDescriptorSet DECLSPEC_ALIGN(8) dstSet;
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
} VkCopyDescriptorSet32;

typedef struct VkCopyImageInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyImageInfo232;
typedef VkCopyImageInfo232 VkCopyImageInfo2KHR32;

typedef struct VkCopyImageToBufferInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyImageToBufferInfo232;
typedef VkCopyImageToBufferInfo232 VkCopyImageToBufferInfo2KHR32;

typedef struct VkCopyImageToImageInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkHostImageCopyFlags flags;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyImageToImageInfo32;
typedef VkCopyImageToImageInfo32 VkCopyImageToImageInfoEXT32;

typedef struct VkCopyImageToMemoryInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkHostImageCopyFlags flags;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyImageToMemoryInfo32;
typedef VkCopyImageToMemoryInfo32 VkCopyImageToMemoryInfoEXT32;

typedef struct VkCopyMemoryToAccelerationStructureInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) src;
    VkAccelerationStructureKHR DECLSPEC_ALIGN(8) dst;
    VkCopyAccelerationStructureModeKHR mode;
} VkCopyMemoryToAccelerationStructureInfoKHR32;

typedef struct VkCopyMemoryToImageInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkHostImageCopyFlags flags;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyMemoryToImageInfo32;
typedef VkCopyMemoryToImageInfo32 VkCopyMemoryToImageInfoEXT32;

typedef struct VkCopyMemoryToMicromapInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) src;
    VkMicromapEXT DECLSPEC_ALIGN(8) dst;
    VkCopyMicromapModeEXT mode;
} VkCopyMemoryToMicromapInfoEXT32;

typedef struct VkCopyMicromapInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMicromapEXT DECLSPEC_ALIGN(8) src;
    VkMicromapEXT DECLSPEC_ALIGN(8) dst;
    VkCopyMicromapModeEXT mode;
} VkCopyMicromapInfoEXT32;

typedef struct VkCopyMicromapToMemoryInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMicromapEXT DECLSPEC_ALIGN(8) src;
    VkDeviceOrHostAddressKHR DECLSPEC_ALIGN(8) dst;
    VkCopyMicromapModeEXT mode;
} VkCopyMicromapToMemoryInfoEXT32;

typedef struct VkCopyTensorInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorARM DECLSPEC_ALIGN(8) srcTensor;
    VkTensorARM DECLSPEC_ALIGN(8) dstTensor;
    uint32_t regionCount;
    PTR32 pRegions;
} VkCopyTensorInfoARM32;

typedef struct VkCuFunctionCreateInfoNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCuModuleNVX DECLSPEC_ALIGN(8) module;
    PTR32 pName;
} VkCuFunctionCreateInfoNVX32;

typedef struct VkCuLaunchInfoNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCuFunctionNVX DECLSPEC_ALIGN(8) function;
    uint32_t gridDimX;
    uint32_t gridDimY;
    uint32_t gridDimZ;
    uint32_t blockDimX;
    uint32_t blockDimY;
    uint32_t blockDimZ;
    uint32_t sharedMemBytes;
    PTR32 paramCount;
    PTR32 pParams;
    PTR32 extraCount;
    PTR32 pExtras;
} VkCuLaunchInfoNVX32;

typedef struct VkCuModuleCreateInfoNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 dataSize;
    PTR32 pData;
} VkCuModuleCreateInfoNVX32;

typedef struct VkCuModuleTexturingModeCreateInfoNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 use64bitTexturing;
} VkCuModuleTexturingModeCreateInfoNVX32;

typedef struct VkD3D12FenceSubmitInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreValuesCount;
    PTR32 pWaitSemaphoreValues;
    uint32_t signalSemaphoreValuesCount;
    PTR32 pSignalSemaphoreValues;
} VkD3D12FenceSubmitInfoKHR32;

typedef struct VkDataGraphPipelineCompilerControlCreateInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pVendorOptions;
} VkDataGraphPipelineCompilerControlCreateInfoARM32;

typedef struct VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t dimension;
    uint32_t zeroCount;
    uint32_t groupSize;
} VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM32;

typedef struct VkDataGraphPipelineCreateInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags2KHR flags;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    uint32_t resourceInfoCount;
    PTR32 pResourceInfos;
} VkDataGraphPipelineCreateInfoARM32;

typedef struct VkDataGraphPipelineDispatchInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDataGraphPipelineDispatchFlagsARM DECLSPEC_ALIGN(8) flags;
} VkDataGraphPipelineDispatchInfoARM32;

typedef struct VkDataGraphPipelineIdentifierCreateInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t identifierSize;
    PTR32 pIdentifier;
} VkDataGraphPipelineIdentifierCreateInfoARM32;

typedef struct VkDataGraphPipelineInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipeline DECLSPEC_ALIGN(8) dataGraphPipeline;
} VkDataGraphPipelineInfoARM32;

typedef struct VkDataGraphPipelinePropertyQueryResultARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDataGraphPipelinePropertyARM property;
    VkBool32 isText;
    PTR32 dataSize;
    PTR32 pData;
} VkDataGraphPipelinePropertyQueryResultARM32;

typedef struct VkDataGraphPipelineSessionBindPointRequirementARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDataGraphPipelineSessionBindPointARM bindPoint;
    VkDataGraphPipelineSessionBindPointTypeARM bindPointType;
    uint32_t numObjects;
} VkDataGraphPipelineSessionBindPointRequirementARM32;

typedef struct VkDataGraphPipelineSessionBindPointRequirementsInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDataGraphPipelineSessionARM DECLSPEC_ALIGN(8) session;
} VkDataGraphPipelineSessionBindPointRequirementsInfoARM32;

typedef struct VkDataGraphPipelineSessionCreateInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDataGraphPipelineSessionCreateFlagsARM DECLSPEC_ALIGN(8) flags;
    VkPipeline DECLSPEC_ALIGN(8) dataGraphPipeline;
} VkDataGraphPipelineSessionCreateInfoARM32;

typedef struct VkDataGraphPipelineSessionMemoryRequirementsInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDataGraphPipelineSessionARM DECLSPEC_ALIGN(8) session;
    VkDataGraphPipelineSessionBindPointARM bindPoint;
    uint32_t objectIndex;
} VkDataGraphPipelineSessionMemoryRequirementsInfoARM32;

typedef struct VkDataGraphPipelineShaderModuleCreateInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderModule DECLSPEC_ALIGN(8) module;
    PTR32 pName;
    PTR32 pSpecializationInfo;
    uint32_t constantCount;
    PTR32 pConstants;
} VkDataGraphPipelineShaderModuleCreateInfoARM32;

typedef struct VkDataGraphProcessingEngineCreateInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t processingEngineCount;
    PTR32 pProcessingEngines;
} VkDataGraphProcessingEngineCreateInfoARM32;

typedef struct VkDebugMarkerMarkerInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pMarkerName;
    float color[4];
} VkDebugMarkerMarkerInfoEXT32;

typedef struct VkDebugMarkerObjectNameInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDebugReportObjectTypeEXT objectType;
    uint64_t DECLSPEC_ALIGN(8) object;
    PTR32 pObjectName;
} VkDebugMarkerObjectNameInfoEXT32;

typedef struct VkDebugMarkerObjectTagInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDebugReportObjectTypeEXT objectType;
    uint64_t DECLSPEC_ALIGN(8) object;
    uint64_t DECLSPEC_ALIGN(8) tagName;
    PTR32 tagSize;
    PTR32 pTag;
} VkDebugMarkerObjectTagInfoEXT32;

typedef struct VkDebugReportCallbackCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDebugReportFlagsEXT flags;
    PTR32 pfnCallback;
    PTR32 pUserData;
} VkDebugReportCallbackCreateInfoEXT32;

typedef struct VkDebugUtilsMessengerCallbackDataEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDebugUtilsMessengerCallbackDataFlagsEXT flags;
    PTR32 pMessageIdName;
    int32_t messageIdNumber;
    PTR32 pMessage;
    uint32_t queueLabelCount;
    PTR32 pQueueLabels;
    uint32_t cmdBufLabelCount;
    PTR32 pCmdBufLabels;
    uint32_t objectCount;
    PTR32 pObjects;
} VkDebugUtilsMessengerCallbackDataEXT32;

typedef struct VkDebugUtilsMessengerCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDebugUtilsMessengerCreateFlagsEXT flags;
    VkDebugUtilsMessageSeverityFlagsEXT messageSeverity;
    VkDebugUtilsMessageTypeFlagsEXT messageType;
    PTR32 pfnUserCallback;
    PTR32 pUserData;
} VkDebugUtilsMessengerCreateInfoEXT32;

typedef struct VkDebugUtilsObjectTagInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkObjectType objectType;
    uint64_t DECLSPEC_ALIGN(8) objectHandle;
    uint64_t DECLSPEC_ALIGN(8) tagName;
    PTR32 tagSize;
    PTR32 pTag;
} VkDebugUtilsObjectTagInfoEXT32;

typedef struct VkDecompressMemoryRegionNV32
{
    VkDeviceAddress DECLSPEC_ALIGN(8) srcAddress;
    VkDeviceAddress DECLSPEC_ALIGN(8) dstAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) compressedSize;
    VkDeviceSize DECLSPEC_ALIGN(8) decompressedSize;
    VkMemoryDecompressionMethodFlagsNV DECLSPEC_ALIGN(8) decompressionMethod;
} VkDecompressMemoryRegionNV32;

typedef struct VkDedicatedAllocationBufferCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dedicatedAllocation;
} VkDedicatedAllocationBufferCreateInfoNV32;

typedef struct VkDedicatedAllocationImageCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dedicatedAllocation;
} VkDedicatedAllocationImageCreateInfoNV32;

typedef struct VkDedicatedAllocationMemoryAllocateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkDedicatedAllocationMemoryAllocateInfoNV32;

typedef struct VkDependencyInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDependencyFlags dependencyFlags;
    uint32_t memoryBarrierCount;
    PTR32 pMemoryBarriers;
    uint32_t bufferMemoryBarrierCount;
    PTR32 pBufferMemoryBarriers;
    uint32_t imageMemoryBarrierCount;
    PTR32 pImageMemoryBarriers;
} VkDependencyInfo32;
typedef VkDependencyInfo32 VkDependencyInfoKHR32;

typedef struct VkDepthBiasInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    float depthBiasConstantFactor;
    float depthBiasClamp;
    float depthBiasSlopeFactor;
} VkDepthBiasInfoEXT32;

typedef struct VkDepthBiasRepresentationInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDepthBiasRepresentationEXT depthBiasRepresentation;
    VkBool32 depthBiasExact;
} VkDepthBiasRepresentationInfoEXT32;

typedef struct VkDescriptorBufferBindingInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddress DECLSPEC_ALIGN(8) address;
    VkBufferUsageFlags usage;
} VkDescriptorBufferBindingInfoEXT32;

typedef struct VkDescriptorBufferBindingPushDescriptorBufferHandleEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkDescriptorBufferBindingPushDescriptorBufferHandleEXT32;

typedef struct VkDescriptorGetInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorType type;
    VkDescriptorDataEXT32 DECLSPEC_ALIGN(8) data;
} VkDescriptorGetInfoEXT32;

typedef struct VkDescriptorGetTensorInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorViewARM DECLSPEC_ALIGN(8) tensorView;
} VkDescriptorGetTensorInfoARM32;

typedef struct VkDescriptorPoolCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorPoolCreateFlags flags;
    uint32_t maxSets;
    uint32_t poolSizeCount;
    PTR32 pPoolSizes;
} VkDescriptorPoolCreateInfo32;

typedef struct VkDescriptorPoolInlineUniformBlockCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxInlineUniformBlockBindings;
} VkDescriptorPoolInlineUniformBlockCreateInfo32;
typedef VkDescriptorPoolInlineUniformBlockCreateInfo32 VkDescriptorPoolInlineUniformBlockCreateInfoEXT32;

typedef struct VkDescriptorSetAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorPool DECLSPEC_ALIGN(8) descriptorPool;
    uint32_t descriptorSetCount;
    PTR32 pSetLayouts;
} VkDescriptorSetAllocateInfo32;

typedef struct VkDescriptorSetBindingReferenceVALVE32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorSetLayout DECLSPEC_ALIGN(8) descriptorSetLayout;
    uint32_t binding;
} VkDescriptorSetBindingReferenceVALVE32;

typedef struct VkDescriptorSetLayoutBindingFlagsCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t bindingCount;
    PTR32 pBindingFlags;
} VkDescriptorSetLayoutBindingFlagsCreateInfo32;
typedef VkDescriptorSetLayoutBindingFlagsCreateInfo32 VkDescriptorSetLayoutBindingFlagsCreateInfoEXT32;

typedef struct VkDescriptorSetLayoutCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorSetLayoutCreateFlags flags;
    uint32_t bindingCount;
    PTR32 pBindings;
} VkDescriptorSetLayoutCreateInfo32;

typedef struct VkDescriptorSetLayoutHostMappingInfoVALVE32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 descriptorOffset;
    uint32_t descriptorSize;
} VkDescriptorSetLayoutHostMappingInfoVALVE32;

typedef struct VkDescriptorSetLayoutSupport32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 supported;
} VkDescriptorSetLayoutSupport32;
typedef VkDescriptorSetLayoutSupport32 VkDescriptorSetLayoutSupportKHR32;

typedef struct VkDescriptorSetVariableDescriptorCountAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t descriptorSetCount;
    PTR32 pDescriptorCounts;
} VkDescriptorSetVariableDescriptorCountAllocateInfo32;
typedef VkDescriptorSetVariableDescriptorCountAllocateInfo32 VkDescriptorSetVariableDescriptorCountAllocateInfoEXT32;

typedef struct VkDescriptorSetVariableDescriptorCountLayoutSupport32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxVariableDescriptorCount;
} VkDescriptorSetVariableDescriptorCountLayoutSupport32;
typedef VkDescriptorSetVariableDescriptorCountLayoutSupport32 VkDescriptorSetVariableDescriptorCountLayoutSupportEXT32;

typedef struct VkDescriptorUpdateTemplateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorUpdateTemplateCreateFlags flags;
    uint32_t descriptorUpdateEntryCount;
    PTR32 pDescriptorUpdateEntries;
    VkDescriptorUpdateTemplateType templateType;
    VkDescriptorSetLayout DECLSPEC_ALIGN(8) descriptorSetLayout;
    VkPipelineBindPoint pipelineBindPoint;
    VkPipelineLayout DECLSPEC_ALIGN(8) pipelineLayout;
    uint32_t set;
} VkDescriptorUpdateTemplateCreateInfo32;
typedef VkDescriptorUpdateTemplateCreateInfo32 VkDescriptorUpdateTemplateCreateInfoKHR32;

typedef struct VkDeviceAddressBindingCallbackDataEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddressBindingFlagsEXT flags;
    VkDeviceAddress DECLSPEC_ALIGN(8) baseAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkDeviceAddressBindingTypeEXT bindingType;
} VkDeviceAddressBindingCallbackDataEXT32;

typedef struct VkDeviceBufferMemoryRequirements32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pCreateInfo;
} VkDeviceBufferMemoryRequirements32;
typedef VkDeviceBufferMemoryRequirements32 VkDeviceBufferMemoryRequirementsKHR32;

typedef struct VkDeviceCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceCreateFlags flags;
    uint32_t queueCreateInfoCount;
    PTR32 pQueueCreateInfos;
    uint32_t enabledLayerCount;
    PTR32 ppEnabledLayerNames;
    uint32_t enabledExtensionCount;
    PTR32 ppEnabledExtensionNames;
    PTR32 pEnabledFeatures;
} VkDeviceCreateInfo32;

typedef struct VkDeviceDiagnosticsConfigCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceDiagnosticsConfigFlagsNV flags;
} VkDeviceDiagnosticsConfigCreateInfoNV32;

typedef struct VkDeviceFaultCountsEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t addressInfoCount;
    uint32_t vendorInfoCount;
    VkDeviceSize DECLSPEC_ALIGN(8) vendorBinarySize;
} VkDeviceFaultCountsEXT32;

typedef struct VkDeviceFaultInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    char description[VK_MAX_DESCRIPTION_SIZE];
    PTR32 pAddressInfos;
    PTR32 pVendorInfos;
    PTR32 pVendorBinaryData;
} VkDeviceFaultInfoEXT32;

typedef struct VkDeviceGroupBindSparseInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t resourceDeviceIndex;
    uint32_t memoryDeviceIndex;
} VkDeviceGroupBindSparseInfo32;
typedef VkDeviceGroupBindSparseInfo32 VkDeviceGroupBindSparseInfoKHR32;

typedef struct VkDeviceGroupCommandBufferBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t deviceMask;
} VkDeviceGroupCommandBufferBeginInfo32;
typedef VkDeviceGroupCommandBufferBeginInfo32 VkDeviceGroupCommandBufferBeginInfoKHR32;

typedef struct VkDeviceGroupDeviceCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t physicalDeviceCount;
    PTR32 pPhysicalDevices;
} VkDeviceGroupDeviceCreateInfo32;
typedef VkDeviceGroupDeviceCreateInfo32 VkDeviceGroupDeviceCreateInfoKHR32;

typedef struct VkDeviceGroupPresentCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t presentMask[VK_MAX_DEVICE_GROUP_SIZE];
    VkDeviceGroupPresentModeFlagsKHR modes;
} VkDeviceGroupPresentCapabilitiesKHR32;

typedef struct VkDeviceGroupPresentInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pDeviceMasks;
    VkDeviceGroupPresentModeFlagBitsKHR mode;
} VkDeviceGroupPresentInfoKHR32;

typedef struct VkDeviceGroupRenderPassBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t deviceMask;
    uint32_t deviceRenderAreaCount;
    PTR32 pDeviceRenderAreas;
} VkDeviceGroupRenderPassBeginInfo32;
typedef VkDeviceGroupRenderPassBeginInfo32 VkDeviceGroupRenderPassBeginInfoKHR32;

typedef struct VkDeviceGroupSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreCount;
    PTR32 pWaitSemaphoreDeviceIndices;
    uint32_t commandBufferCount;
    PTR32 pCommandBufferDeviceMasks;
    uint32_t signalSemaphoreCount;
    PTR32 pSignalSemaphoreDeviceIndices;
} VkDeviceGroupSubmitInfo32;
typedef VkDeviceGroupSubmitInfo32 VkDeviceGroupSubmitInfoKHR32;

typedef struct VkDeviceGroupSwapchainCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceGroupPresentModeFlagsKHR modes;
} VkDeviceGroupSwapchainCreateInfoKHR32;

typedef struct VkDeviceImageMemoryRequirements32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pCreateInfo;
    VkImageAspectFlagBits planeAspect;
} VkDeviceImageMemoryRequirements32;
typedef VkDeviceImageMemoryRequirements32 VkDeviceImageMemoryRequirementsKHR32;

typedef struct VkDeviceImageSubresourceInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pCreateInfo;
    PTR32 pSubresource;
} VkDeviceImageSubresourceInfo32;
typedef VkDeviceImageSubresourceInfo32 VkDeviceImageSubresourceInfoKHR32;

typedef struct VkDeviceMemoryOpaqueCaptureAddressInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
} VkDeviceMemoryOpaqueCaptureAddressInfo32;
typedef VkDeviceMemoryOpaqueCaptureAddressInfo32 VkDeviceMemoryOpaqueCaptureAddressInfoKHR32;

typedef struct VkDeviceMemoryOverallocationCreateInfoAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryOverallocationBehaviorAMD overallocationBehavior;
} VkDeviceMemoryOverallocationCreateInfoAMD32;

typedef struct VkDevicePipelineBinaryInternalCacheControlKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 disableInternalCache;
} VkDevicePipelineBinaryInternalCacheControlKHR32;

typedef struct VkDevicePrivateDataCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t privateDataSlotRequestCount;
} VkDevicePrivateDataCreateInfo32;
typedef VkDevicePrivateDataCreateInfo32 VkDevicePrivateDataCreateInfoEXT32;

typedef struct VkDeviceQueueGlobalPriorityCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueueGlobalPriority globalPriority;
} VkDeviceQueueGlobalPriorityCreateInfo32;
typedef VkDeviceQueueGlobalPriorityCreateInfo32 VkDeviceQueueGlobalPriorityCreateInfoKHR32;
typedef VkDeviceQueueGlobalPriorityCreateInfo32 VkDeviceQueueGlobalPriorityCreateInfoEXT32;

typedef struct VkDeviceQueueInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceQueueCreateFlags flags;
    uint32_t queueFamilyIndex;
    uint32_t queueIndex;
} VkDeviceQueueInfo232;

typedef struct VkDeviceQueueShaderCoreControlCreateInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderCoreCount;
} VkDeviceQueueShaderCoreControlCreateInfoARM32;

typedef struct VkDeviceTensorMemoryRequirementsARM32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pCreateInfo;
} VkDeviceTensorMemoryRequirementsARM32;

typedef struct VkDispatchTileInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
} VkDispatchTileInfoQCOM32;

typedef struct VkEventCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkEventCreateFlags flags;
} VkEventCreateInfo32;

typedef struct VkExportFenceCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalFenceHandleTypeFlags handleTypes;
} VkExportFenceCreateInfo32;
typedef VkExportFenceCreateInfo32 VkExportFenceCreateInfoKHR32;

typedef struct VkExportFenceWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pAttributes;
    DWORD dwAccess;
    PTR32 name;
} VkExportFenceWin32HandleInfoKHR32;

typedef struct VkExportMemoryAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlags handleTypes;
} VkExportMemoryAllocateInfo32;
typedef VkExportMemoryAllocateInfo32 VkExportMemoryAllocateInfoKHR32;

typedef struct VkExportMemoryWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pAttributes;
    DWORD dwAccess;
    PTR32 name;
} VkExportMemoryWin32HandleInfoKHR32;

typedef struct VkExportSemaphoreCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalSemaphoreHandleTypeFlags handleTypes;
} VkExportSemaphoreCreateInfo32;
typedef VkExportSemaphoreCreateInfo32 VkExportSemaphoreCreateInfoKHR32;

typedef struct VkExportSemaphoreWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pAttributes;
    DWORD dwAccess;
    PTR32 name;
} VkExportSemaphoreWin32HandleInfoKHR32;

typedef struct VkExternalBufferProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryProperties externalMemoryProperties;
} VkExternalBufferProperties32;
typedef VkExternalBufferProperties32 VkExternalBufferPropertiesKHR32;

typedef struct VkExternalFenceProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes;
    VkExternalFenceHandleTypeFlags compatibleHandleTypes;
    VkExternalFenceFeatureFlags externalFenceFeatures;
} VkExternalFenceProperties32;
typedef VkExternalFenceProperties32 VkExternalFencePropertiesKHR32;

typedef struct VkExternalImageFormatProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryProperties externalMemoryProperties;
} VkExternalImageFormatProperties32;
typedef VkExternalImageFormatProperties32 VkExternalImageFormatPropertiesKHR32;

typedef struct VkExternalMemoryAcquireUnmodifiedEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 acquireUnmodifiedMemory;
} VkExternalMemoryAcquireUnmodifiedEXT32;

typedef struct VkExternalMemoryBufferCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlags handleTypes;
} VkExternalMemoryBufferCreateInfo32;
typedef VkExternalMemoryBufferCreateInfo32 VkExternalMemoryBufferCreateInfoKHR32;

typedef struct VkExternalMemoryImageCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlags handleTypes;
} VkExternalMemoryImageCreateInfo32;
typedef VkExternalMemoryImageCreateInfo32 VkExternalMemoryImageCreateInfoKHR32;

typedef struct VkExternalMemoryTensorCreateInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlags handleTypes;
} VkExternalMemoryTensorCreateInfoARM32;

typedef struct VkExternalSemaphoreProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes;
    VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes;
    VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures;
} VkExternalSemaphoreProperties32;
typedef VkExternalSemaphoreProperties32 VkExternalSemaphorePropertiesKHR32;

typedef struct VkExternalTensorPropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryProperties externalMemoryProperties;
} VkExternalTensorPropertiesARM32;

typedef struct VkFenceCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFenceCreateFlags flags;
} VkFenceCreateInfo32;

typedef struct VkFenceGetWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFence DECLSPEC_ALIGN(8) fence;
    VkExternalFenceHandleTypeFlagBits handleType;
} VkFenceGetWin32HandleInfoKHR32;

typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 filterCubic;
    VkBool32 filterCubicMinmax;
} VkFilterCubicImageViewImageFormatPropertiesEXT32;

typedef struct VkFormatProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormatProperties formatProperties;
} VkFormatProperties232;
typedef VkFormatProperties232 VkFormatProperties2KHR32;

typedef struct VkFormatProperties332
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormatFeatureFlags2 DECLSPEC_ALIGN(8) linearTilingFeatures;
    VkFormatFeatureFlags2 DECLSPEC_ALIGN(8) optimalTilingFeatures;
    VkFormatFeatureFlags2 DECLSPEC_ALIGN(8) bufferFeatures;
} VkFormatProperties332;
typedef VkFormatProperties332 VkFormatProperties3KHR32;

typedef struct VkFragmentShadingRateAttachmentInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pFragmentShadingRateAttachment;
    VkExtent2D shadingRateAttachmentTexelSize;
} VkFragmentShadingRateAttachmentInfoKHR32;

typedef struct VkFrameBoundaryEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFrameBoundaryFlagsEXT flags;
    uint64_t DECLSPEC_ALIGN(8) frameID;
    uint32_t imageCount;
    PTR32 pImages;
    uint32_t bufferCount;
    PTR32 pBuffers;
    uint64_t DECLSPEC_ALIGN(8) tagName;
    PTR32 tagSize;
    PTR32 pTag;
} VkFrameBoundaryEXT32;

typedef struct VkFrameBoundaryTensorsARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t tensorCount;
    PTR32 pTensors;
} VkFrameBoundaryTensorsARM32;

typedef struct VkFramebufferAttachmentsCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t attachmentImageInfoCount;
    PTR32 pAttachmentImageInfos;
} VkFramebufferAttachmentsCreateInfo32;
typedef VkFramebufferAttachmentsCreateInfo32 VkFramebufferAttachmentsCreateInfoKHR32;

typedef struct VkFramebufferCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFramebufferCreateFlags flags;
    VkRenderPass DECLSPEC_ALIGN(8) renderPass;
    uint32_t attachmentCount;
    PTR32 pAttachments;
    uint32_t width;
    uint32_t height;
    uint32_t layers;
} VkFramebufferCreateInfo32;

typedef struct VkFramebufferMixedSamplesCombinationNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCoverageReductionModeNV coverageReductionMode;
    VkSampleCountFlagBits rasterizationSamples;
    VkSampleCountFlags depthStencilSamples;
    VkSampleCountFlags colorSamples;
} VkFramebufferMixedSamplesCombinationNV32;

typedef struct VkGeneratedCommandsInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags shaderStages;
    VkIndirectExecutionSetEXT DECLSPEC_ALIGN(8) indirectExecutionSet;
    VkIndirectCommandsLayoutEXT DECLSPEC_ALIGN(8) indirectCommandsLayout;
    VkDeviceAddress DECLSPEC_ALIGN(8) indirectAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) indirectAddressSize;
    VkDeviceAddress DECLSPEC_ALIGN(8) preprocessAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) preprocessSize;
    uint32_t maxSequenceCount;
    VkDeviceAddress DECLSPEC_ALIGN(8) sequenceCountAddress;
    uint32_t maxDrawCount;
} VkGeneratedCommandsInfoEXT32;

typedef struct VkGeneratedCommandsInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineBindPoint pipelineBindPoint;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
    VkIndirectCommandsLayoutNV DECLSPEC_ALIGN(8) indirectCommandsLayout;
    uint32_t streamCount;
    PTR32 pStreams;
    uint32_t sequencesCount;
    VkBuffer DECLSPEC_ALIGN(8) preprocessBuffer;
    VkDeviceSize DECLSPEC_ALIGN(8) preprocessOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) preprocessSize;
    VkBuffer DECLSPEC_ALIGN(8) sequencesCountBuffer;
    VkDeviceSize DECLSPEC_ALIGN(8) sequencesCountOffset;
    VkBuffer DECLSPEC_ALIGN(8) sequencesIndexBuffer;
    VkDeviceSize DECLSPEC_ALIGN(8) sequencesIndexOffset;
} VkGeneratedCommandsInfoNV32;

typedef struct VkGeneratedCommandsMemoryRequirementsInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkIndirectExecutionSetEXT DECLSPEC_ALIGN(8) indirectExecutionSet;
    VkIndirectCommandsLayoutEXT DECLSPEC_ALIGN(8) indirectCommandsLayout;
    uint32_t maxSequenceCount;
    uint32_t maxDrawCount;
} VkGeneratedCommandsMemoryRequirementsInfoEXT32;

typedef struct VkGeneratedCommandsMemoryRequirementsInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineBindPoint pipelineBindPoint;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
    VkIndirectCommandsLayoutNV DECLSPEC_ALIGN(8) indirectCommandsLayout;
    uint32_t maxSequencesCount;
} VkGeneratedCommandsMemoryRequirementsInfoNV32;

typedef struct VkGeneratedCommandsPipelineInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
} VkGeneratedCommandsPipelineInfoEXT32;

typedef struct VkGeneratedCommandsShaderInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderCount;
    PTR32 pShaders;
} VkGeneratedCommandsShaderInfoEXT32;

typedef struct VkGetLatencyMarkerInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t timingCount;
    PTR32 pTimings;
} VkGetLatencyMarkerInfoNV32;

typedef struct VkGraphicsPipelineCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags flags;
    uint32_t stageCount;
    PTR32 pStages;
    PTR32 pVertexInputState;
    PTR32 pInputAssemblyState;
    PTR32 pTessellationState;
    PTR32 pViewportState;
    PTR32 pRasterizationState;
    PTR32 pMultisampleState;
    PTR32 pDepthStencilState;
    PTR32 pColorBlendState;
    PTR32 pDynamicState;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    VkRenderPass DECLSPEC_ALIGN(8) renderPass;
    uint32_t subpass;
    VkPipeline DECLSPEC_ALIGN(8) basePipelineHandle;
    int32_t basePipelineIndex;
} VkGraphicsPipelineCreateInfo32;

typedef struct VkGraphicsPipelineLibraryCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkGraphicsPipelineLibraryFlagsEXT flags;
} VkGraphicsPipelineLibraryCreateInfoEXT32;

typedef struct VkGraphicsPipelineShaderGroupsCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t groupCount;
    PTR32 pGroups;
    uint32_t pipelineCount;
    PTR32 pPipelines;
} VkGraphicsPipelineShaderGroupsCreateInfoNV32;

typedef struct VkHdrMetadataEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkXYColorEXT displayPrimaryRed;
    VkXYColorEXT displayPrimaryGreen;
    VkXYColorEXT displayPrimaryBlue;
    VkXYColorEXT whitePoint;
    float maxLuminance;
    float minLuminance;
    float maxContentLightLevel;
    float maxFrameAverageLightLevel;
} VkHdrMetadataEXT32;

typedef struct VkHdrVividDynamicMetadataHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 dynamicMetadataSize;
    PTR32 pDynamicMetadata;
} VkHdrVividDynamicMetadataHUAWEI32;

typedef struct VkHostImageCopyDevicePerformanceQuery32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 optimalDeviceAccess;
    VkBool32 identicalMemoryLayout;
} VkHostImageCopyDevicePerformanceQuery32;
typedef VkHostImageCopyDevicePerformanceQuery32 VkHostImageCopyDevicePerformanceQueryEXT32;

typedef struct VkHostImageLayoutTransitionInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
    VkImageLayout oldLayout;
    VkImageLayout newLayout;
    VkImageSubresourceRange subresourceRange;
} VkHostImageLayoutTransitionInfo32;
typedef VkHostImageLayoutTransitionInfo32 VkHostImageLayoutTransitionInfoEXT32;

typedef struct VkImageAlignmentControlCreateInfoMESA32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maximumRequestedAlignment;
} VkImageAlignmentControlCreateInfoMESA32;

typedef struct VkImageCaptureDescriptorDataInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
} VkImageCaptureDescriptorDataInfoEXT32;

typedef struct VkImageCompressionControlEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageCompressionFlagsEXT flags;
    uint32_t compressionControlPlaneCount;
    PTR32 pFixedRateFlags;
} VkImageCompressionControlEXT32;

typedef struct VkImageCompressionPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageCompressionFlagsEXT imageCompressionFlags;
    VkImageCompressionFixedRateFlagsEXT imageCompressionFixedRateFlags;
} VkImageCompressionPropertiesEXT32;

typedef struct VkImageFormatListCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t viewFormatCount;
    PTR32 pViewFormats;
} VkImageFormatListCreateInfo32;
typedef VkImageFormatListCreateInfo32 VkImageFormatListCreateInfoKHR32;

typedef struct VkImageFormatProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageFormatProperties32 DECLSPEC_ALIGN(8) imageFormatProperties;
} VkImageFormatProperties232;
typedef VkImageFormatProperties232 VkImageFormatProperties2KHR32;

typedef struct VkImageMemoryBarrier32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccessFlags srcAccessMask;
    VkAccessFlags dstAccessMask;
    VkImageLayout oldLayout;
    VkImageLayout newLayout;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    VkImage DECLSPEC_ALIGN(8) image;
    VkImageSubresourceRange subresourceRange;
} VkImageMemoryBarrier32;

typedef struct VkImageMemoryRequirementsInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
} VkImageMemoryRequirementsInfo232;
typedef VkImageMemoryRequirementsInfo232 VkImageMemoryRequirementsInfo2KHR32;

typedef struct VkImagePlaneMemoryRequirementsInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageAspectFlagBits planeAspect;
} VkImagePlaneMemoryRequirementsInfo32;
typedef VkImagePlaneMemoryRequirementsInfo32 VkImagePlaneMemoryRequirementsInfoKHR32;

typedef struct VkImageSparseMemoryRequirementsInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
} VkImageSparseMemoryRequirementsInfo232;
typedef VkImageSparseMemoryRequirementsInfo232 VkImageSparseMemoryRequirementsInfo2KHR32;

typedef struct VkImageStencilUsageCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageUsageFlags stencilUsage;
} VkImageStencilUsageCreateInfo32;
typedef VkImageStencilUsageCreateInfo32 VkImageStencilUsageCreateInfoEXT32;

typedef struct VkImageSwapchainCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
} VkImageSwapchainCreateInfoKHR32;

typedef struct VkImageViewASTCDecodeModeEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat decodeMode;
} VkImageViewASTCDecodeModeEXT32;

typedef struct VkImageViewAddressPropertiesNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkImageViewAddressPropertiesNVX32;

typedef struct VkImageViewCaptureDescriptorDataInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) imageView;
} VkImageViewCaptureDescriptorDataInfoEXT32;

typedef struct VkImageViewCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageViewCreateFlags flags;
    VkImage DECLSPEC_ALIGN(8) image;
    VkImageViewType viewType;
    VkFormat format;
    VkComponentMapping components;
    VkImageSubresourceRange subresourceRange;
} VkImageViewCreateInfo32;

typedef struct VkImageViewHandleInfoNVX32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) imageView;
    VkDescriptorType descriptorType;
    VkSampler DECLSPEC_ALIGN(8) sampler;
} VkImageViewHandleInfoNVX32;

typedef struct VkImageViewMinLodCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    float minLod;
} VkImageViewMinLodCreateInfoEXT32;

typedef struct VkImageViewSampleWeightCreateInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOffset2D filterCenter;
    VkExtent2D filterSize;
    uint32_t numPhases;
} VkImageViewSampleWeightCreateInfoQCOM32;

typedef struct VkImageViewSlicedCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t sliceOffset;
    uint32_t sliceCount;
} VkImageViewSlicedCreateInfoEXT32;

typedef struct VkImageViewUsageCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageUsageFlags usage;
} VkImageViewUsageCreateInfo32;
typedef VkImageViewUsageCreateInfo32 VkImageViewUsageCreateInfoKHR32;

typedef struct VkImportFenceWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFence DECLSPEC_ALIGN(8) fence;
    VkFenceImportFlags flags;
    VkExternalFenceHandleTypeFlagBits handleType;
    PTR32 handle;
    PTR32 name;
} VkImportFenceWin32HandleInfoKHR32;

typedef struct VkImportMemoryHostPointerInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlagBits handleType;
    PTR32 pHostPointer;
} VkImportMemoryHostPointerInfoEXT32;

typedef struct VkImportMemoryWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlagBits handleType;
    PTR32 handle;
    PTR32 name;
} VkImportMemoryWin32HandleInfoKHR32;

typedef struct VkImportSemaphoreWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    VkSemaphoreImportFlags flags;
    VkExternalSemaphoreHandleTypeFlagBits handleType;
    PTR32 handle;
    PTR32 name;
} VkImportSemaphoreWin32HandleInfoKHR32;

typedef struct VkIndirectCommandsLayoutCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkIndirectCommandsLayoutUsageFlagsEXT flags;
    VkShaderStageFlags shaderStages;
    uint32_t indirectStride;
    VkPipelineLayout DECLSPEC_ALIGN(8) pipelineLayout;
    uint32_t tokenCount;
    PTR32 pTokens;
} VkIndirectCommandsLayoutCreateInfoEXT32;

typedef struct VkIndirectCommandsLayoutCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkIndirectCommandsLayoutUsageFlagsNV flags;
    VkPipelineBindPoint pipelineBindPoint;
    uint32_t tokenCount;
    PTR32 pTokens;
    uint32_t streamCount;
    PTR32 pStreamStrides;
} VkIndirectCommandsLayoutCreateInfoNV32;

typedef struct VkIndirectExecutionSetCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkIndirectExecutionSetInfoTypeEXT type;
    VkIndirectExecutionSetInfoEXT32 info;
} VkIndirectExecutionSetCreateInfoEXT32;

typedef struct VkInitializePerformanceApiInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pUserData;
} VkInitializePerformanceApiInfoINTEL32;

typedef struct VkInstanceCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkInstanceCreateFlags flags;
    PTR32 pApplicationInfo;
    uint32_t enabledLayerCount;
    PTR32 ppEnabledLayerNames;
    uint32_t enabledExtensionCount;
    PTR32 ppEnabledExtensionNames;
} VkInstanceCreateInfo32;

typedef struct VkLatencySleepInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) signalSemaphore;
    uint64_t DECLSPEC_ALIGN(8) value;
} VkLatencySleepInfoNV32;

typedef struct VkLatencySleepModeInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 lowLatencyMode;
    VkBool32 lowLatencyBoost;
    uint32_t minimumIntervalUs;
} VkLatencySleepModeInfoNV32;

typedef struct VkLatencySubmissionPresentIdNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) presentID;
} VkLatencySubmissionPresentIdNV32;

typedef struct VkLatencySurfaceCapabilitiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t presentModeCount;
    PTR32 pPresentModes;
} VkLatencySurfaceCapabilitiesNV32;

typedef struct VkLayerSettingsCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t settingCount;
    PTR32 pSettings;
} VkLayerSettingsCreateInfoEXT32;

typedef struct VkMappedMemoryRange32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkMappedMemoryRange32;

typedef struct VkMemoryAllocateFlagsInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryAllocateFlags flags;
    uint32_t deviceMask;
} VkMemoryAllocateFlagsInfo32;
typedef VkMemoryAllocateFlagsInfo32 VkMemoryAllocateFlagsInfoKHR32;

typedef struct VkMemoryAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) allocationSize;
    uint32_t memoryTypeIndex;
} VkMemoryAllocateInfo32;

typedef struct VkMemoryBarrier32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccessFlags srcAccessMask;
    VkAccessFlags dstAccessMask;
} VkMemoryBarrier32;

typedef struct VkMemoryBarrierAccessFlags3KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAccessFlags3KHR DECLSPEC_ALIGN(8) srcAccessMask3;
    VkAccessFlags3KHR DECLSPEC_ALIGN(8) dstAccessMask3;
} VkMemoryBarrierAccessFlags3KHR32;

typedef struct VkMemoryDedicatedAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) image;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
} VkMemoryDedicatedAllocateInfo32;
typedef VkMemoryDedicatedAllocateInfo32 VkMemoryDedicatedAllocateInfoKHR32;

typedef struct VkMemoryDedicatedAllocateInfoTensorARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorARM DECLSPEC_ALIGN(8) tensor;
} VkMemoryDedicatedAllocateInfoTensorARM32;

typedef struct VkMemoryDedicatedRequirements32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 prefersDedicatedAllocation;
    VkBool32 requiresDedicatedAllocation;
} VkMemoryDedicatedRequirements32;
typedef VkMemoryDedicatedRequirements32 VkMemoryDedicatedRequirementsKHR32;

typedef struct VkMemoryGetWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkExternalMemoryHandleTypeFlagBits handleType;
} VkMemoryGetWin32HandleInfoKHR32;

typedef struct VkMemoryHostPointerPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t memoryTypeBits;
} VkMemoryHostPointerPropertiesEXT32;

typedef struct VkMemoryMapInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryMapFlags flags;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkMemoryMapInfo32;
typedef VkMemoryMapInfo32 VkMemoryMapInfoKHR32;

typedef struct VkMemoryOpaqueCaptureAddressAllocateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) opaqueCaptureAddress;
} VkMemoryOpaqueCaptureAddressAllocateInfo32;
typedef VkMemoryOpaqueCaptureAddressAllocateInfo32 VkMemoryOpaqueCaptureAddressAllocateInfoKHR32;

typedef struct VkMemoryPriorityAllocateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    float priority;
} VkMemoryPriorityAllocateInfoEXT32;

typedef struct VkMemoryRequirements232
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryRequirements32 DECLSPEC_ALIGN(8) memoryRequirements;
} VkMemoryRequirements232;
typedef VkMemoryRequirements232 VkMemoryRequirements2KHR32;


typedef struct VkMemoryUnmapInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryUnmapFlags flags;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
} VkMemoryUnmapInfo32;
typedef VkMemoryUnmapInfo32 VkMemoryUnmapInfoKHR32;

typedef struct VkMemoryWin32HandlePropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t memoryTypeBits;
} VkMemoryWin32HandlePropertiesKHR32;

typedef struct VkMicromapBuildInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMicromapTypeEXT type;
    VkBuildMicromapFlagsEXT flags;
    VkBuildMicromapModeEXT mode;
    VkMicromapEXT DECLSPEC_ALIGN(8) dstMicromap;
    uint32_t usageCountsCount;
    PTR32 pUsageCounts;
    PTR32 ppUsageCounts;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) data;
    VkDeviceOrHostAddressKHR DECLSPEC_ALIGN(8) scratchData;
    VkDeviceOrHostAddressConstKHR DECLSPEC_ALIGN(8) triangleArray;
    VkDeviceSize DECLSPEC_ALIGN(8) triangleArrayStride;
} VkMicromapBuildInfoEXT32;

typedef struct VkMicromapBuildSizesInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) micromapSize;
    VkDeviceSize DECLSPEC_ALIGN(8) buildScratchSize;
    VkBool32 discardable;
} VkMicromapBuildSizesInfoEXT32;

typedef struct VkMicromapCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMicromapCreateFlagsEXT createFlags;
    VkBuffer DECLSPEC_ALIGN(8) buffer;
    VkDeviceSize DECLSPEC_ALIGN(8) offset;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkMicromapTypeEXT type;
    VkDeviceAddress DECLSPEC_ALIGN(8) deviceAddress;
} VkMicromapCreateInfoEXT32;

typedef struct VkMicromapVersionInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pVersionData;
} VkMicromapVersionInfoEXT32;

typedef struct VkMultisamplePropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D maxSampleLocationGridSize;
} VkMultisamplePropertiesEXT32;

typedef struct VkMultisampledRenderToSingleSampledInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multisampledRenderToSingleSampledEnable;
    VkSampleCountFlagBits rasterizationSamples;
} VkMultisampledRenderToSingleSampledInfoEXT32;

typedef struct VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t perViewRenderAreaCount;
    PTR32 pPerViewRenderAreas;
} VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32;

typedef struct VkMutableDescriptorTypeCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t mutableDescriptorTypeListCount;
    PTR32 pMutableDescriptorTypeLists;
} VkMutableDescriptorTypeCreateInfoEXT32;
typedef VkMutableDescriptorTypeCreateInfoEXT32 VkMutableDescriptorTypeCreateInfoVALVE32;

typedef struct VkOpaqueCaptureDescriptorDataCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 opaqueCaptureDescriptorData;
} VkOpaqueCaptureDescriptorDataCreateInfoEXT32;

typedef struct VkOpticalFlowExecuteInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOpticalFlowExecuteFlagsNV flags;
    uint32_t regionCount;
    PTR32 pRegions;
} VkOpticalFlowExecuteInfoNV32;

typedef struct VkOpticalFlowImageFormatInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOpticalFlowUsageFlagsNV usage;
} VkOpticalFlowImageFormatInfoNV32;

typedef struct VkOpticalFlowImageFormatPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat format;
} VkOpticalFlowImageFormatPropertiesNV32;

typedef struct VkOpticalFlowSessionCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t width;
    uint32_t height;
    VkFormat imageFormat;
    VkFormat flowVectorFormat;
    VkFormat costFormat;
    VkOpticalFlowGridSizeFlagsNV outputGridSize;
    VkOpticalFlowGridSizeFlagsNV hintGridSize;
    VkOpticalFlowPerformanceLevelNV performanceLevel;
    VkOpticalFlowSessionCreateFlagsNV flags;
} VkOpticalFlowSessionCreateInfoNV32;

typedef struct VkOpticalFlowSessionCreatePrivateDataInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t id;
    uint32_t size;
    PTR32 pPrivateData;
} VkOpticalFlowSessionCreatePrivateDataInfoNV32;

typedef struct VkOutOfBandQueueTypeInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOutOfBandQueueTypeNV queueType;
} VkOutOfBandQueueTypeInfoNV32;

typedef struct VkPartitionedAccelerationStructureFlagsNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 enablePartitionTranslation;
} VkPartitionedAccelerationStructureFlagsNV32;

typedef struct VkPerTileBeginInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
} VkPerTileBeginInfoQCOM32;

typedef struct VkPerTileEndInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
} VkPerTileEndInfoQCOM32;

typedef struct VkPerformanceConfigurationAcquireInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPerformanceConfigurationTypeINTEL type;
} VkPerformanceConfigurationAcquireInfoINTEL32;

typedef struct VkPerformanceCounterDescriptionKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPerformanceCounterDescriptionFlagsKHR flags;
    char name[VK_MAX_DESCRIPTION_SIZE];
    char category[VK_MAX_DESCRIPTION_SIZE];
    char description[VK_MAX_DESCRIPTION_SIZE];
} VkPerformanceCounterDescriptionKHR32;

typedef struct VkPerformanceCounterKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPerformanceCounterUnitKHR unit;
    VkPerformanceCounterScopeKHR scope;
    VkPerformanceCounterStorageKHR storage;
    uint8_t uuid[VK_UUID_SIZE];
} VkPerformanceCounterKHR32;

typedef struct VkPerformanceMarkerInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) marker;
} VkPerformanceMarkerInfoINTEL32;

typedef struct VkPerformanceOverrideInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPerformanceOverrideTypeINTEL type;
    VkBool32 enable;
    uint64_t DECLSPEC_ALIGN(8) parameter;
} VkPerformanceOverrideInfoINTEL32;

typedef struct VkPerformanceQueryReservationInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxPerformanceQueriesPerPool;
} VkPerformanceQueryReservationInfoKHR32;

typedef struct VkPerformanceQuerySubmitInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t counterPassIndex;
} VkPerformanceQuerySubmitInfoKHR32;

typedef struct VkPerformanceStreamMarkerInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t marker;
} VkPerformanceStreamMarkerInfoINTEL32;

typedef struct VkPerformanceValueINTEL32
{
    VkPerformanceValueTypeINTEL type;
    VkPerformanceValueDataINTEL32 DECLSPEC_ALIGN(8) data;
} VkPerformanceValueINTEL32;

typedef struct VkPhysicalDevice16BitStorageFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 storageBuffer16BitAccess;
    VkBool32 uniformAndStorageBuffer16BitAccess;
    VkBool32 storagePushConstant16;
    VkBool32 storageInputOutput16;
} VkPhysicalDevice16BitStorageFeatures32;
typedef VkPhysicalDevice16BitStorageFeatures32 VkPhysicalDevice16BitStorageFeaturesKHR32;

typedef struct VkPhysicalDevice4444FormatsFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 formatA4R4G4B4;
    VkBool32 formatA4B4G4R4;
} VkPhysicalDevice4444FormatsFeaturesEXT32;

typedef struct VkPhysicalDevice8BitStorageFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 storageBuffer8BitAccess;
    VkBool32 uniformAndStorageBuffer8BitAccess;
    VkBool32 storagePushConstant8;
} VkPhysicalDevice8BitStorageFeatures32;
typedef VkPhysicalDevice8BitStorageFeatures32 VkPhysicalDevice8BitStorageFeaturesKHR32;

typedef struct VkPhysicalDeviceASTCDecodeFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 decodeModeSharedExponent;
} VkPhysicalDeviceASTCDecodeFeaturesEXT32;

typedef struct VkPhysicalDeviceAccelerationStructureFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 accelerationStructure;
    VkBool32 accelerationStructureCaptureReplay;
    VkBool32 accelerationStructureIndirectBuild;
    VkBool32 accelerationStructureHostCommands;
    VkBool32 descriptorBindingAccelerationStructureUpdateAfterBind;
} VkPhysicalDeviceAccelerationStructureFeaturesKHR32;

typedef struct VkPhysicalDeviceAccelerationStructurePropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) maxGeometryCount;
    uint64_t DECLSPEC_ALIGN(8) maxInstanceCount;
    uint64_t DECLSPEC_ALIGN(8) maxPrimitiveCount;
    uint32_t maxPerStageDescriptorAccelerationStructures;
    uint32_t maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
    uint32_t maxDescriptorSetAccelerationStructures;
    uint32_t maxDescriptorSetUpdateAfterBindAccelerationStructures;
    uint32_t minAccelerationStructureScratchOffsetAlignment;
} VkPhysicalDeviceAccelerationStructurePropertiesKHR32;

typedef struct VkPhysicalDeviceAddressBindingReportFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 reportAddressBinding;
} VkPhysicalDeviceAddressBindingReportFeaturesEXT32;

typedef struct VkPhysicalDeviceAntiLagFeaturesAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 antiLag;
} VkPhysicalDeviceAntiLagFeaturesAMD32;

typedef struct VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 attachmentFeedbackLoopDynamicState;
} VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32;

typedef struct VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 attachmentFeedbackLoopLayout;
} VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32;

typedef struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 advancedBlendCoherentOperations;
} VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32;

typedef struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t advancedBlendMaxColorAttachments;
    VkBool32 advancedBlendIndependentBlend;
    VkBool32 advancedBlendNonPremultipliedSrcColor;
    VkBool32 advancedBlendNonPremultipliedDstColor;
    VkBool32 advancedBlendCorrelatedOverlap;
    VkBool32 advancedBlendAllOperations;
} VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT32;

typedef struct VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 borderColorSwizzle;
    VkBool32 borderColorSwizzleFromImage;
} VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32;

typedef struct VkPhysicalDeviceBufferDeviceAddressFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 bufferDeviceAddress;
    VkBool32 bufferDeviceAddressCaptureReplay;
    VkBool32 bufferDeviceAddressMultiDevice;
} VkPhysicalDeviceBufferDeviceAddressFeatures32;
typedef VkPhysicalDeviceBufferDeviceAddressFeatures32 VkPhysicalDeviceBufferDeviceAddressFeaturesKHR32;

typedef struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 bufferDeviceAddress;
    VkBool32 bufferDeviceAddressCaptureReplay;
    VkBool32 bufferDeviceAddressMultiDevice;
} VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32;
typedef VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 VkPhysicalDeviceBufferAddressFeaturesEXT32;

typedef struct VkPhysicalDeviceClusterAccelerationStructureFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 clusterAccelerationStructure;
} VkPhysicalDeviceClusterAccelerationStructureFeaturesNV32;

typedef struct VkPhysicalDeviceClusterAccelerationStructurePropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxVerticesPerCluster;
    uint32_t maxTrianglesPerCluster;
    uint32_t clusterScratchByteAlignment;
    uint32_t clusterByteAlignment;
    uint32_t clusterTemplateByteAlignment;
    uint32_t clusterBottomLevelByteAlignment;
    uint32_t clusterTemplateBoundsByteAlignment;
    uint32_t maxClusterGeometryIndex;
} VkPhysicalDeviceClusterAccelerationStructurePropertiesNV32;

typedef struct VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 clustercullingShader;
    VkBool32 multiviewClusterCullingShader;
} VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32;

typedef struct VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxWorkGroupCount[3];
    uint32_t maxWorkGroupSize[3];
    uint32_t maxOutputClusterCount;
    VkDeviceSize DECLSPEC_ALIGN(8) indirectBufferOffsetAlignment;
} VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI32;

typedef struct VkPhysicalDeviceCoherentMemoryFeaturesAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 deviceCoherentMemory;
} VkPhysicalDeviceCoherentMemoryFeaturesAMD32;

typedef struct VkPhysicalDeviceColorWriteEnableFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 colorWriteEnable;
} VkPhysicalDeviceColorWriteEnableFeaturesEXT32;

typedef struct VkPhysicalDeviceCommandBufferInheritanceFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 commandBufferInheritance;
} VkPhysicalDeviceCommandBufferInheritanceFeaturesNV32;

typedef struct VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 computeDerivativeGroupQuads;
    VkBool32 computeDerivativeGroupLinear;
} VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR32;
typedef VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR32 VkPhysicalDeviceComputeShaderDerivativesFeaturesNV32;

typedef struct VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 meshAndTaskShaderDerivatives;
} VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR32;

typedef struct VkPhysicalDeviceConditionalRenderingFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 conditionalRendering;
    VkBool32 inheritedConditionalRendering;
} VkPhysicalDeviceConditionalRenderingFeaturesEXT32;

typedef struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    float primitiveOverestimationSize;
    float maxExtraPrimitiveOverestimationSize;
    float extraPrimitiveOverestimationSizeGranularity;
    VkBool32 primitiveUnderestimation;
    VkBool32 conservativePointAndLineRasterization;
    VkBool32 degenerateTrianglesRasterized;
    VkBool32 degenerateLinesRasterized;
    VkBool32 fullyCoveredFragmentShaderInputVariable;
    VkBool32 conservativeRasterizationPostDepthCoverage;
} VkPhysicalDeviceConservativeRasterizationPropertiesEXT32;

typedef struct VkPhysicalDeviceCooperativeMatrix2FeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 cooperativeMatrixWorkgroupScope;
    VkBool32 cooperativeMatrixFlexibleDimensions;
    VkBool32 cooperativeMatrixReductions;
    VkBool32 cooperativeMatrixConversions;
    VkBool32 cooperativeMatrixPerElementOperations;
    VkBool32 cooperativeMatrixTensorAddressing;
    VkBool32 cooperativeMatrixBlockLoads;
} VkPhysicalDeviceCooperativeMatrix2FeaturesNV32;

typedef struct VkPhysicalDeviceCooperativeMatrix2PropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t cooperativeMatrixWorkgroupScopeMaxWorkgroupSize;
    uint32_t cooperativeMatrixFlexibleDimensionsMaxDimension;
    uint32_t cooperativeMatrixWorkgroupScopeReservedSharedMemory;
} VkPhysicalDeviceCooperativeMatrix2PropertiesNV32;

typedef struct VkPhysicalDeviceCooperativeMatrixFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 cooperativeMatrix;
    VkBool32 cooperativeMatrixRobustBufferAccess;
} VkPhysicalDeviceCooperativeMatrixFeaturesKHR32;

typedef struct VkPhysicalDeviceCooperativeMatrixFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 cooperativeMatrix;
    VkBool32 cooperativeMatrixRobustBufferAccess;
} VkPhysicalDeviceCooperativeMatrixFeaturesNV32;

typedef struct VkPhysicalDeviceCooperativeMatrixPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags cooperativeMatrixSupportedStages;
} VkPhysicalDeviceCooperativeMatrixPropertiesKHR32;

typedef struct VkPhysicalDeviceCooperativeMatrixPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags cooperativeMatrixSupportedStages;
} VkPhysicalDeviceCooperativeMatrixPropertiesNV32;

typedef struct VkPhysicalDeviceCooperativeVectorFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 cooperativeVector;
    VkBool32 cooperativeVectorTraining;
} VkPhysicalDeviceCooperativeVectorFeaturesNV32;

typedef struct VkPhysicalDeviceCooperativeVectorPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags cooperativeVectorSupportedStages;
    VkBool32 cooperativeVectorTrainingFloat16Accumulation;
    VkBool32 cooperativeVectorTrainingFloat32Accumulation;
    uint32_t maxCooperativeVectorComponents;
} VkPhysicalDeviceCooperativeVectorPropertiesNV32;

typedef struct VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 indirectCopy;
} VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32;

typedef struct VkPhysicalDeviceCopyMemoryIndirectPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueueFlags supportedQueues;
} VkPhysicalDeviceCopyMemoryIndirectPropertiesNV32;

typedef struct VkPhysicalDeviceCornerSampledImageFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 cornerSampledImage;
} VkPhysicalDeviceCornerSampledImageFeaturesNV32;

typedef struct VkPhysicalDeviceCoverageReductionModeFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 coverageReductionMode;
} VkPhysicalDeviceCoverageReductionModeFeaturesNV32;

typedef struct VkPhysicalDeviceCubicClampFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 cubicRangeClamp;
} VkPhysicalDeviceCubicClampFeaturesQCOM32;

typedef struct VkPhysicalDeviceCubicWeightsFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 selectableCubicWeights;
} VkPhysicalDeviceCubicWeightsFeaturesQCOM32;

typedef struct VkPhysicalDeviceCustomBorderColorFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 customBorderColors;
    VkBool32 customBorderColorWithoutFormat;
} VkPhysicalDeviceCustomBorderColorFeaturesEXT32;

typedef struct VkPhysicalDeviceCustomBorderColorPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxCustomBorderColorSamplers;
} VkPhysicalDeviceCustomBorderColorPropertiesEXT32;

typedef struct VkPhysicalDeviceDataGraphFeaturesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dataGraph;
    VkBool32 dataGraphUpdateAfterBind;
    VkBool32 dataGraphSpecializationConstants;
    VkBool32 dataGraphDescriptorBuffer;
    VkBool32 dataGraphShaderModule;
} VkPhysicalDeviceDataGraphFeaturesARM32;

typedef struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dedicatedAllocationImageAliasing;
} VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32;

typedef struct VkPhysicalDeviceDepthBiasControlFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 depthBiasControl;
    VkBool32 leastRepresentableValueForceUnormRepresentation;
    VkBool32 floatRepresentation;
    VkBool32 depthBiasExact;
} VkPhysicalDeviceDepthBiasControlFeaturesEXT32;

typedef struct VkPhysicalDeviceDepthClampControlFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 depthClampControl;
} VkPhysicalDeviceDepthClampControlFeaturesEXT32;

typedef struct VkPhysicalDeviceDepthClampZeroOneFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 depthClampZeroOne;
} VkPhysicalDeviceDepthClampZeroOneFeaturesKHR32;
typedef VkPhysicalDeviceDepthClampZeroOneFeaturesKHR32 VkPhysicalDeviceDepthClampZeroOneFeaturesEXT32;

typedef struct VkPhysicalDeviceDepthClipControlFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 depthClipControl;
} VkPhysicalDeviceDepthClipControlFeaturesEXT32;

typedef struct VkPhysicalDeviceDepthClipEnableFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 depthClipEnable;
} VkPhysicalDeviceDepthClipEnableFeaturesEXT32;

typedef struct VkPhysicalDeviceDepthStencilResolveProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkResolveModeFlags supportedDepthResolveModes;
    VkResolveModeFlags supportedStencilResolveModes;
    VkBool32 independentResolveNone;
    VkBool32 independentResolve;
} VkPhysicalDeviceDepthStencilResolveProperties32;
typedef VkPhysicalDeviceDepthStencilResolveProperties32 VkPhysicalDeviceDepthStencilResolvePropertiesKHR32;

typedef struct VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 combinedImageSamplerDensityMapDescriptorSize;
} VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT32;

typedef struct VkPhysicalDeviceDescriptorBufferFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 descriptorBuffer;
    VkBool32 descriptorBufferCaptureReplay;
    VkBool32 descriptorBufferImageLayoutIgnored;
    VkBool32 descriptorBufferPushDescriptors;
} VkPhysicalDeviceDescriptorBufferFeaturesEXT32;

typedef struct VkPhysicalDeviceDescriptorBufferPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 combinedImageSamplerDescriptorSingleArray;
    VkBool32 bufferlessPushDescriptors;
    VkBool32 allowSamplerImageViewPostSubmitCreation;
    VkDeviceSize DECLSPEC_ALIGN(8) descriptorBufferOffsetAlignment;
    uint32_t maxDescriptorBufferBindings;
    uint32_t maxResourceDescriptorBufferBindings;
    uint32_t maxSamplerDescriptorBufferBindings;
    uint32_t maxEmbeddedImmutableSamplerBindings;
    uint32_t maxEmbeddedImmutableSamplers;
    PTR32 bufferCaptureReplayDescriptorDataSize;
    PTR32 imageCaptureReplayDescriptorDataSize;
    PTR32 imageViewCaptureReplayDescriptorDataSize;
    PTR32 samplerCaptureReplayDescriptorDataSize;
    PTR32 accelerationStructureCaptureReplayDescriptorDataSize;
    PTR32 samplerDescriptorSize;
    PTR32 combinedImageSamplerDescriptorSize;
    PTR32 sampledImageDescriptorSize;
    PTR32 storageImageDescriptorSize;
    PTR32 uniformTexelBufferDescriptorSize;
    PTR32 robustUniformTexelBufferDescriptorSize;
    PTR32 storageTexelBufferDescriptorSize;
    PTR32 robustStorageTexelBufferDescriptorSize;
    PTR32 uniformBufferDescriptorSize;
    PTR32 robustUniformBufferDescriptorSize;
    PTR32 storageBufferDescriptorSize;
    PTR32 robustStorageBufferDescriptorSize;
    PTR32 inputAttachmentDescriptorSize;
    PTR32 accelerationStructureDescriptorSize;
    VkDeviceSize DECLSPEC_ALIGN(8) maxSamplerDescriptorBufferRange;
    VkDeviceSize DECLSPEC_ALIGN(8) maxResourceDescriptorBufferRange;
    VkDeviceSize DECLSPEC_ALIGN(8) samplerDescriptorBufferAddressSpaceSize;
    VkDeviceSize DECLSPEC_ALIGN(8) resourceDescriptorBufferAddressSpaceSize;
    VkDeviceSize DECLSPEC_ALIGN(8) descriptorBufferAddressSpaceSize;
} VkPhysicalDeviceDescriptorBufferPropertiesEXT32;

typedef struct VkPhysicalDeviceDescriptorBufferTensorFeaturesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 descriptorBufferTensorDescriptors;
} VkPhysicalDeviceDescriptorBufferTensorFeaturesARM32;

typedef struct VkPhysicalDeviceDescriptorBufferTensorPropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 tensorCaptureReplayDescriptorDataSize;
    PTR32 tensorViewCaptureReplayDescriptorDataSize;
    PTR32 tensorDescriptorSize;
} VkPhysicalDeviceDescriptorBufferTensorPropertiesARM32;

typedef struct VkPhysicalDeviceDescriptorIndexingFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderInputAttachmentArrayDynamicIndexing;
    VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
    VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
    VkBool32 shaderUniformBufferArrayNonUniformIndexing;
    VkBool32 shaderSampledImageArrayNonUniformIndexing;
    VkBool32 shaderStorageBufferArrayNonUniformIndexing;
    VkBool32 shaderStorageImageArrayNonUniformIndexing;
    VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
    VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
    VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
    VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
    VkBool32 descriptorBindingSampledImageUpdateAfterBind;
    VkBool32 descriptorBindingStorageImageUpdateAfterBind;
    VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
    VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
    VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
    VkBool32 descriptorBindingUpdateUnusedWhilePending;
    VkBool32 descriptorBindingPartiallyBound;
    VkBool32 descriptorBindingVariableDescriptorCount;
    VkBool32 runtimeDescriptorArray;
} VkPhysicalDeviceDescriptorIndexingFeatures32;
typedef VkPhysicalDeviceDescriptorIndexingFeatures32 VkPhysicalDeviceDescriptorIndexingFeaturesEXT32;

typedef struct VkPhysicalDeviceDescriptorIndexingProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxUpdateAfterBindDescriptorsInAllPools;
    VkBool32 shaderUniformBufferArrayNonUniformIndexingNative;
    VkBool32 shaderSampledImageArrayNonUniformIndexingNative;
    VkBool32 shaderStorageBufferArrayNonUniformIndexingNative;
    VkBool32 shaderStorageImageArrayNonUniformIndexingNative;
    VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative;
    VkBool32 robustBufferAccessUpdateAfterBind;
    VkBool32 quadDivergentImplicitLod;
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t maxPerStageUpdateAfterBindResources;
    uint32_t maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
} VkPhysicalDeviceDescriptorIndexingProperties32;
typedef VkPhysicalDeviceDescriptorIndexingProperties32 VkPhysicalDeviceDescriptorIndexingPropertiesEXT32;

typedef struct VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 descriptorPoolOverallocation;
} VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32;

typedef struct VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 descriptorSetHostMapping;
} VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32;

typedef struct VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 deviceGeneratedCompute;
    VkBool32 deviceGeneratedComputePipelines;
    VkBool32 deviceGeneratedComputeCaptureReplay;
} VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32;

typedef struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 deviceGeneratedCommands;
    VkBool32 dynamicGeneratedPipelineLayout;
} VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT32;

typedef struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 deviceGeneratedCommands;
} VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32;

typedef struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxIndirectPipelineCount;
    uint32_t maxIndirectShaderObjectCount;
    uint32_t maxIndirectSequenceCount;
    uint32_t maxIndirectCommandsTokenCount;
    uint32_t maxIndirectCommandsTokenOffset;
    uint32_t maxIndirectCommandsIndirectStride;
    VkIndirectCommandsInputModeFlagsEXT supportedIndirectCommandsInputModes;
    VkShaderStageFlags supportedIndirectCommandsShaderStages;
    VkShaderStageFlags supportedIndirectCommandsShaderStagesPipelineBinding;
    VkShaderStageFlags supportedIndirectCommandsShaderStagesShaderBinding;
    VkBool32 deviceGeneratedCommandsTransformFeedback;
    VkBool32 deviceGeneratedCommandsMultiDrawIndirectCount;
} VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT32;

typedef struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxGraphicsShaderGroupCount;
    uint32_t maxIndirectSequenceCount;
    uint32_t maxIndirectCommandsTokenCount;
    uint32_t maxIndirectCommandsStreamCount;
    uint32_t maxIndirectCommandsTokenOffset;
    uint32_t maxIndirectCommandsStreamStride;
    uint32_t minSequencesCountBufferOffsetAlignment;
    uint32_t minSequencesIndexBufferOffsetAlignment;
    uint32_t minIndirectCommandsBufferOffsetAlignment;
} VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV32;

typedef struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 diagnosticsConfig;
} VkPhysicalDeviceDiagnosticsConfigFeaturesNV32;

typedef struct VkPhysicalDeviceDiscardRectanglePropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxDiscardRectangles;
} VkPhysicalDeviceDiscardRectanglePropertiesEXT32;

typedef struct VkPhysicalDeviceDriverProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDriverId driverID;
    char driverName[VK_MAX_DRIVER_NAME_SIZE];
    char driverInfo[VK_MAX_DRIVER_INFO_SIZE];
    VkConformanceVersion conformanceVersion;
} VkPhysicalDeviceDriverProperties32;
typedef VkPhysicalDeviceDriverProperties32 VkPhysicalDeviceDriverPropertiesKHR32;

typedef struct VkPhysicalDeviceDynamicRenderingFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dynamicRendering;
} VkPhysicalDeviceDynamicRenderingFeatures32;
typedef VkPhysicalDeviceDynamicRenderingFeatures32 VkPhysicalDeviceDynamicRenderingFeaturesKHR32;

typedef struct VkPhysicalDeviceDynamicRenderingLocalReadFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dynamicRenderingLocalRead;
} VkPhysicalDeviceDynamicRenderingLocalReadFeatures32;
typedef VkPhysicalDeviceDynamicRenderingLocalReadFeatures32 VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR32;

typedef struct VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dynamicRenderingUnusedAttachments;
} VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32;

typedef struct VkPhysicalDeviceExclusiveScissorFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 exclusiveScissor;
} VkPhysicalDeviceExclusiveScissorFeaturesNV32;

typedef struct VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 extendedDynamicState2;
    VkBool32 extendedDynamicState2LogicOp;
    VkBool32 extendedDynamicState2PatchControlPoints;
} VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32;

typedef struct VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 extendedDynamicState3TessellationDomainOrigin;
    VkBool32 extendedDynamicState3DepthClampEnable;
    VkBool32 extendedDynamicState3PolygonMode;
    VkBool32 extendedDynamicState3RasterizationSamples;
    VkBool32 extendedDynamicState3SampleMask;
    VkBool32 extendedDynamicState3AlphaToCoverageEnable;
    VkBool32 extendedDynamicState3AlphaToOneEnable;
    VkBool32 extendedDynamicState3LogicOpEnable;
    VkBool32 extendedDynamicState3ColorBlendEnable;
    VkBool32 extendedDynamicState3ColorBlendEquation;
    VkBool32 extendedDynamicState3ColorWriteMask;
    VkBool32 extendedDynamicState3RasterizationStream;
    VkBool32 extendedDynamicState3ConservativeRasterizationMode;
    VkBool32 extendedDynamicState3ExtraPrimitiveOverestimationSize;
    VkBool32 extendedDynamicState3DepthClipEnable;
    VkBool32 extendedDynamicState3SampleLocationsEnable;
    VkBool32 extendedDynamicState3ColorBlendAdvanced;
    VkBool32 extendedDynamicState3ProvokingVertexMode;
    VkBool32 extendedDynamicState3LineRasterizationMode;
    VkBool32 extendedDynamicState3LineStippleEnable;
    VkBool32 extendedDynamicState3DepthClipNegativeOneToOne;
    VkBool32 extendedDynamicState3ViewportWScalingEnable;
    VkBool32 extendedDynamicState3ViewportSwizzle;
    VkBool32 extendedDynamicState3CoverageToColorEnable;
    VkBool32 extendedDynamicState3CoverageToColorLocation;
    VkBool32 extendedDynamicState3CoverageModulationMode;
    VkBool32 extendedDynamicState3CoverageModulationTableEnable;
    VkBool32 extendedDynamicState3CoverageModulationTable;
    VkBool32 extendedDynamicState3CoverageReductionMode;
    VkBool32 extendedDynamicState3RepresentativeFragmentTestEnable;
    VkBool32 extendedDynamicState3ShadingRateImageEnable;
} VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32;

typedef struct VkPhysicalDeviceExtendedDynamicState3PropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 dynamicPrimitiveTopologyUnrestricted;
} VkPhysicalDeviceExtendedDynamicState3PropertiesEXT32;

typedef struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 extendedDynamicState;
} VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32;

typedef struct VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 extendedSparseAddressSpace;
} VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32;

typedef struct VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) extendedSparseAddressSpaceSize;
    VkImageUsageFlags extendedSparseImageUsageFlags;
    VkBufferUsageFlags extendedSparseBufferUsageFlags;
} VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV32;

typedef struct VkPhysicalDeviceExternalBufferInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBufferCreateFlags flags;
    VkBufferUsageFlags usage;
    VkExternalMemoryHandleTypeFlagBits handleType;
} VkPhysicalDeviceExternalBufferInfo32;
typedef VkPhysicalDeviceExternalBufferInfo32 VkPhysicalDeviceExternalBufferInfoKHR32;

typedef struct VkPhysicalDeviceExternalFenceInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalFenceHandleTypeFlagBits handleType;
} VkPhysicalDeviceExternalFenceInfo32;
typedef VkPhysicalDeviceExternalFenceInfo32 VkPhysicalDeviceExternalFenceInfoKHR32;

typedef struct VkPhysicalDeviceExternalImageFormatInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalMemoryHandleTypeFlagBits handleType;
} VkPhysicalDeviceExternalImageFormatInfo32;
typedef VkPhysicalDeviceExternalImageFormatInfo32 VkPhysicalDeviceExternalImageFormatInfoKHR32;

typedef struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) minImportedHostPointerAlignment;
} VkPhysicalDeviceExternalMemoryHostPropertiesEXT32;

typedef struct VkPhysicalDeviceExternalSemaphoreInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalSemaphoreHandleTypeFlagBits handleType;
} VkPhysicalDeviceExternalSemaphoreInfo32;
typedef VkPhysicalDeviceExternalSemaphoreInfo32 VkPhysicalDeviceExternalSemaphoreInfoKHR32;

typedef struct VkPhysicalDeviceExternalTensorInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorCreateFlagsARM DECLSPEC_ALIGN(8) flags;
    PTR32 pDescription;
    VkExternalMemoryHandleTypeFlagBits handleType;
} VkPhysicalDeviceExternalTensorInfoARM32;

typedef struct VkPhysicalDeviceFaultFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 deviceFault;
    VkBool32 deviceFaultVendorBinary;
} VkPhysicalDeviceFaultFeaturesEXT32;

typedef struct VkPhysicalDeviceFeatures232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPhysicalDeviceFeatures features;
} VkPhysicalDeviceFeatures232;
typedef VkPhysicalDeviceFeatures232 VkPhysicalDeviceFeatures2KHR32;

typedef struct VkPhysicalDeviceFloatControlsProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderFloatControlsIndependence denormBehaviorIndependence;
    VkShaderFloatControlsIndependence roundingModeIndependence;
    VkBool32 shaderSignedZeroInfNanPreserveFloat16;
    VkBool32 shaderSignedZeroInfNanPreserveFloat32;
    VkBool32 shaderSignedZeroInfNanPreserveFloat64;
    VkBool32 shaderDenormPreserveFloat16;
    VkBool32 shaderDenormPreserveFloat32;
    VkBool32 shaderDenormPreserveFloat64;
    VkBool32 shaderDenormFlushToZeroFloat16;
    VkBool32 shaderDenormFlushToZeroFloat32;
    VkBool32 shaderDenormFlushToZeroFloat64;
    VkBool32 shaderRoundingModeRTEFloat16;
    VkBool32 shaderRoundingModeRTEFloat32;
    VkBool32 shaderRoundingModeRTEFloat64;
    VkBool32 shaderRoundingModeRTZFloat16;
    VkBool32 shaderRoundingModeRTZFloat32;
    VkBool32 shaderRoundingModeRTZFloat64;
} VkPhysicalDeviceFloatControlsProperties32;
typedef VkPhysicalDeviceFloatControlsProperties32 VkPhysicalDeviceFloatControlsPropertiesKHR32;

typedef struct VkPhysicalDeviceFormatPackFeaturesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 formatPack;
} VkPhysicalDeviceFormatPackFeaturesARM32;

typedef struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentDensityMapDeferred;
} VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32;

typedef struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 subsampledLoads;
    VkBool32 subsampledCoarseReconstructionEarlyAccess;
    uint32_t maxSubsampledArrayLayers;
    uint32_t maxDescriptorSetSubsampledSamplers;
} VkPhysicalDeviceFragmentDensityMap2PropertiesEXT32;

typedef struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentDensityMap;
    VkBool32 fragmentDensityMapDynamic;
    VkBool32 fragmentDensityMapNonSubsampledImages;
} VkPhysicalDeviceFragmentDensityMapFeaturesEXT32;

typedef struct VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentDensityMapLayered;
} VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE32;

typedef struct VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxFragmentDensityMapLayers;
} VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE32;

typedef struct VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentDensityMapOffset;
} VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT32;
typedef VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT32 VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM32;

typedef struct VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D fragmentDensityOffsetGranularity;
} VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT32;
typedef VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT32 VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM32;

typedef struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D minFragmentDensityTexelSize;
    VkExtent2D maxFragmentDensityTexelSize;
    VkBool32 fragmentDensityInvocations;
} VkPhysicalDeviceFragmentDensityMapPropertiesEXT32;

typedef struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentShaderBarycentric;
} VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32;
typedef VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV32;

typedef struct VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 triStripVertexOrderIndependentOfProvokingVertex;
} VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR32;

typedef struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentShaderSampleInterlock;
    VkBool32 fragmentShaderPixelInterlock;
    VkBool32 fragmentShaderShadingRateInterlock;
} VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32;

typedef struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 fragmentShadingRateEnums;
    VkBool32 supersampleFragmentShadingRates;
    VkBool32 noInvocationFragmentShadingRates;
} VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32;

typedef struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSampleCountFlagBits maxFragmentShadingRateInvocationCount;
} VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV32;

typedef struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineFragmentShadingRate;
    VkBool32 primitiveFragmentShadingRate;
    VkBool32 attachmentFragmentShadingRate;
} VkPhysicalDeviceFragmentShadingRateFeaturesKHR32;

typedef struct VkPhysicalDeviceFragmentShadingRateKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSampleCountFlags sampleCounts;
    VkExtent2D fragmentSize;
} VkPhysicalDeviceFragmentShadingRateKHR32;

typedef struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D minFragmentShadingRateAttachmentTexelSize;
    VkExtent2D maxFragmentShadingRateAttachmentTexelSize;
    uint32_t maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
    VkBool32 primitiveFragmentShadingRateWithMultipleViewports;
    VkBool32 layeredShadingRateAttachments;
    VkBool32 fragmentShadingRateNonTrivialCombinerOps;
    VkExtent2D maxFragmentSize;
    uint32_t maxFragmentSizeAspectRatio;
    uint32_t maxFragmentShadingRateCoverageSamples;
    VkSampleCountFlagBits maxFragmentShadingRateRasterizationSamples;
    VkBool32 fragmentShadingRateWithShaderDepthStencilWrites;
    VkBool32 fragmentShadingRateWithSampleMask;
    VkBool32 fragmentShadingRateWithShaderSampleMask;
    VkBool32 fragmentShadingRateWithConservativeRasterization;
    VkBool32 fragmentShadingRateWithFragmentShaderInterlock;
    VkBool32 fragmentShadingRateWithCustomSampleLocations;
    VkBool32 fragmentShadingRateStrictMultiplyCombiner;
} VkPhysicalDeviceFragmentShadingRatePropertiesKHR32;

typedef struct VkPhysicalDeviceFrameBoundaryFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 frameBoundary;
} VkPhysicalDeviceFrameBoundaryFeaturesEXT32;

typedef struct VkPhysicalDeviceGlobalPriorityQueryFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 globalPriorityQuery;
} VkPhysicalDeviceGlobalPriorityQueryFeatures32;
typedef VkPhysicalDeviceGlobalPriorityQueryFeatures32 VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR32;
typedef VkPhysicalDeviceGlobalPriorityQueryFeatures32 VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT32;

typedef struct VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 graphicsPipelineLibrary;
} VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32;

typedef struct VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 graphicsPipelineLibraryFastLinking;
    VkBool32 graphicsPipelineLibraryIndependentInterpolationDecoration;
} VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT32;

typedef struct VkPhysicalDeviceGroupProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t physicalDeviceCount;
    PTR32 physicalDevices[VK_MAX_DEVICE_GROUP_SIZE];
    VkBool32 subsetAllocation;
} VkPhysicalDeviceGroupProperties32;
typedef VkPhysicalDeviceGroupProperties32 VkPhysicalDeviceGroupPropertiesKHR32;

typedef struct VkPhysicalDeviceHdrVividFeaturesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 hdrVivid;
} VkPhysicalDeviceHdrVividFeaturesHUAWEI32;

typedef struct VkPhysicalDeviceHostImageCopyFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 hostImageCopy;
} VkPhysicalDeviceHostImageCopyFeatures32;
typedef VkPhysicalDeviceHostImageCopyFeatures32 VkPhysicalDeviceHostImageCopyFeaturesEXT32;

typedef struct VkPhysicalDeviceHostImageCopyProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t copySrcLayoutCount;
    PTR32 pCopySrcLayouts;
    uint32_t copyDstLayoutCount;
    PTR32 pCopyDstLayouts;
    uint8_t optimalTilingLayoutUUID[VK_UUID_SIZE];
    VkBool32 identicalMemoryTypeRequirements;
} VkPhysicalDeviceHostImageCopyProperties32;
typedef VkPhysicalDeviceHostImageCopyProperties32 VkPhysicalDeviceHostImageCopyPropertiesEXT32;

typedef struct VkPhysicalDeviceHostQueryResetFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 hostQueryReset;
} VkPhysicalDeviceHostQueryResetFeatures32;
typedef VkPhysicalDeviceHostQueryResetFeatures32 VkPhysicalDeviceHostQueryResetFeaturesEXT32;

typedef struct VkPhysicalDeviceIDProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint8_t deviceUUID[VK_UUID_SIZE];
    uint8_t driverUUID[VK_UUID_SIZE];
    uint8_t deviceLUID[VK_LUID_SIZE];
    uint32_t deviceNodeMask;
    VkBool32 deviceLUIDValid;
} VkPhysicalDeviceIDProperties32;
typedef VkPhysicalDeviceIDProperties32 VkPhysicalDeviceIDPropertiesKHR32;

typedef struct VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 image2DViewOf3D;
    VkBool32 sampler2DViewOf3D;
} VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32;

typedef struct VkPhysicalDeviceImageAlignmentControlFeaturesMESA32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imageAlignmentControl;
} VkPhysicalDeviceImageAlignmentControlFeaturesMESA32;

typedef struct VkPhysicalDeviceImageAlignmentControlPropertiesMESA32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t supportedImageAlignmentMask;
} VkPhysicalDeviceImageAlignmentControlPropertiesMESA32;

typedef struct VkPhysicalDeviceImageCompressionControlFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imageCompressionControl;
} VkPhysicalDeviceImageCompressionControlFeaturesEXT32;

typedef struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imageCompressionControlSwapchain;
} VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32;

typedef struct VkPhysicalDeviceImageFormatInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat format;
    VkImageType type;
    VkImageTiling tiling;
    VkImageUsageFlags usage;
    VkImageCreateFlags flags;
} VkPhysicalDeviceImageFormatInfo232;
typedef VkPhysicalDeviceImageFormatInfo232 VkPhysicalDeviceImageFormatInfo2KHR32;

typedef struct VkPhysicalDeviceImageProcessing2FeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 textureBlockMatch2;
} VkPhysicalDeviceImageProcessing2FeaturesQCOM32;

typedef struct VkPhysicalDeviceImageProcessing2PropertiesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D maxBlockMatchWindow;
} VkPhysicalDeviceImageProcessing2PropertiesQCOM32;

typedef struct VkPhysicalDeviceImageProcessingFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 textureSampleWeighted;
    VkBool32 textureBoxFilter;
    VkBool32 textureBlockMatch;
} VkPhysicalDeviceImageProcessingFeaturesQCOM32;

typedef struct VkPhysicalDeviceImageProcessingPropertiesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxWeightFilterPhases;
    VkExtent2D maxWeightFilterDimension;
    VkExtent2D maxBlockMatchRegion;
    VkExtent2D maxBoxFilterBlockSize;
} VkPhysicalDeviceImageProcessingPropertiesQCOM32;

typedef struct VkPhysicalDeviceImageRobustnessFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 robustImageAccess;
} VkPhysicalDeviceImageRobustnessFeatures32;
typedef VkPhysicalDeviceImageRobustnessFeatures32 VkPhysicalDeviceImageRobustnessFeaturesEXT32;

typedef struct VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imageSlicedViewOf3D;
} VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32;

typedef struct VkPhysicalDeviceImageViewImageFormatInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageViewType imageViewType;
} VkPhysicalDeviceImageViewImageFormatInfoEXT32;

typedef struct VkPhysicalDeviceImageViewMinLodFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 minLod;
} VkPhysicalDeviceImageViewMinLodFeaturesEXT32;

typedef struct VkPhysicalDeviceImagelessFramebufferFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imagelessFramebuffer;
} VkPhysicalDeviceImagelessFramebufferFeatures32;
typedef VkPhysicalDeviceImagelessFramebufferFeatures32 VkPhysicalDeviceImagelessFramebufferFeaturesKHR32;

typedef struct VkPhysicalDeviceIndexTypeUint8Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 indexTypeUint8;
} VkPhysicalDeviceIndexTypeUint8Features32;
typedef VkPhysicalDeviceIndexTypeUint8Features32 VkPhysicalDeviceIndexTypeUint8FeaturesKHR32;
typedef VkPhysicalDeviceIndexTypeUint8Features32 VkPhysicalDeviceIndexTypeUint8FeaturesEXT32;

typedef struct VkPhysicalDeviceInheritedViewportScissorFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 inheritedViewportScissor2D;
} VkPhysicalDeviceInheritedViewportScissorFeaturesNV32;

typedef struct VkPhysicalDeviceInlineUniformBlockFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 inlineUniformBlock;
    VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind;
} VkPhysicalDeviceInlineUniformBlockFeatures32;
typedef VkPhysicalDeviceInlineUniformBlockFeatures32 VkPhysicalDeviceInlineUniformBlockFeaturesEXT32;

typedef struct VkPhysicalDeviceInlineUniformBlockProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxInlineUniformBlockSize;
    uint32_t maxPerStageDescriptorInlineUniformBlocks;
    uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    uint32_t maxDescriptorSetInlineUniformBlocks;
    uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
} VkPhysicalDeviceInlineUniformBlockProperties32;
typedef VkPhysicalDeviceInlineUniformBlockProperties32 VkPhysicalDeviceInlineUniformBlockPropertiesEXT32;

typedef struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 invocationMask;
} VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32;

typedef struct VkPhysicalDeviceLayeredDriverPropertiesMSFT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkLayeredDriverUnderlyingApiMSFT underlyingAPI;
} VkPhysicalDeviceLayeredDriverPropertiesMSFT32;

typedef struct VkPhysicalDeviceLegacyDitheringFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 legacyDithering;
} VkPhysicalDeviceLegacyDitheringFeaturesEXT32;

typedef struct VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 legacyVertexAttributes;
} VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT32;

typedef struct VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 nativeUnalignedPerformance;
} VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT32;

typedef struct VkPhysicalDeviceLineRasterizationFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rectangularLines;
    VkBool32 bresenhamLines;
    VkBool32 smoothLines;
    VkBool32 stippledRectangularLines;
    VkBool32 stippledBresenhamLines;
    VkBool32 stippledSmoothLines;
} VkPhysicalDeviceLineRasterizationFeatures32;
typedef VkPhysicalDeviceLineRasterizationFeatures32 VkPhysicalDeviceLineRasterizationFeaturesKHR32;
typedef VkPhysicalDeviceLineRasterizationFeatures32 VkPhysicalDeviceLineRasterizationFeaturesEXT32;

typedef struct VkPhysicalDeviceLineRasterizationProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t lineSubPixelPrecisionBits;
} VkPhysicalDeviceLineRasterizationProperties32;
typedef VkPhysicalDeviceLineRasterizationProperties32 VkPhysicalDeviceLineRasterizationPropertiesKHR32;
typedef VkPhysicalDeviceLineRasterizationProperties32 VkPhysicalDeviceLineRasterizationPropertiesEXT32;

typedef struct VkPhysicalDeviceLinearColorAttachmentFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 linearColorAttachment;
} VkPhysicalDeviceLinearColorAttachmentFeaturesNV32;

typedef struct VkPhysicalDeviceMaintenance3Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxPerSetDescriptors;
    VkDeviceSize DECLSPEC_ALIGN(8) maxMemoryAllocationSize;
} VkPhysicalDeviceMaintenance3Properties32;
typedef VkPhysicalDeviceMaintenance3Properties32 VkPhysicalDeviceMaintenance3PropertiesKHR32;

typedef struct VkPhysicalDeviceMaintenance4Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 maintenance4;
} VkPhysicalDeviceMaintenance4Features32;
typedef VkPhysicalDeviceMaintenance4Features32 VkPhysicalDeviceMaintenance4FeaturesKHR32;

typedef struct VkPhysicalDeviceMaintenance4Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) maxBufferSize;
} VkPhysicalDeviceMaintenance4Properties32;
typedef VkPhysicalDeviceMaintenance4Properties32 VkPhysicalDeviceMaintenance4PropertiesKHR32;

typedef struct VkPhysicalDeviceMaintenance5Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 maintenance5;
} VkPhysicalDeviceMaintenance5Features32;
typedef VkPhysicalDeviceMaintenance5Features32 VkPhysicalDeviceMaintenance5FeaturesKHR32;

typedef struct VkPhysicalDeviceMaintenance5Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 earlyFragmentMultisampleCoverageAfterSampleCounting;
    VkBool32 earlyFragmentSampleMaskTestBeforeSampleCounting;
    VkBool32 depthStencilSwizzleOneSupport;
    VkBool32 polygonModePointSize;
    VkBool32 nonStrictSinglePixelWideLinesUseParallelogram;
    VkBool32 nonStrictWideLinesUseParallelogram;
} VkPhysicalDeviceMaintenance5Properties32;
typedef VkPhysicalDeviceMaintenance5Properties32 VkPhysicalDeviceMaintenance5PropertiesKHR32;

typedef struct VkPhysicalDeviceMaintenance6Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 maintenance6;
} VkPhysicalDeviceMaintenance6Features32;
typedef VkPhysicalDeviceMaintenance6Features32 VkPhysicalDeviceMaintenance6FeaturesKHR32;

typedef struct VkPhysicalDeviceMaintenance6Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 blockTexelViewCompatibleMultipleLayers;
    uint32_t maxCombinedImageSamplerDescriptorCount;
    VkBool32 fragmentShadingRateClampCombinerInputs;
} VkPhysicalDeviceMaintenance6Properties32;
typedef VkPhysicalDeviceMaintenance6Properties32 VkPhysicalDeviceMaintenance6PropertiesKHR32;

typedef struct VkPhysicalDeviceMaintenance8FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 maintenance8;
} VkPhysicalDeviceMaintenance8FeaturesKHR32;

typedef struct VkPhysicalDeviceMaintenance9FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 maintenance9;
} VkPhysicalDeviceMaintenance9FeaturesKHR32;

typedef struct VkPhysicalDeviceMaintenance9PropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 image2DViewOf3DSparse;
    VkDefaultVertexAttributeValueKHR defaultVertexAttributeValue;
} VkPhysicalDeviceMaintenance9PropertiesKHR32;

typedef struct VkPhysicalDeviceMemoryBudgetPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) heapBudget[VK_MAX_MEMORY_HEAPS];
    VkDeviceSize DECLSPEC_ALIGN(8) heapUsage[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryBudgetPropertiesEXT32;

typedef struct VkPhysicalDeviceMemoryDecompressionFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 memoryDecompression;
} VkPhysicalDeviceMemoryDecompressionFeaturesNV32;

typedef struct VkPhysicalDeviceMemoryDecompressionPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkMemoryDecompressionMethodFlagsNV DECLSPEC_ALIGN(8) decompressionMethods;
    uint64_t DECLSPEC_ALIGN(8) maxDecompressionIndirectCount;
} VkPhysicalDeviceMemoryDecompressionPropertiesNV32;

typedef struct VkPhysicalDeviceMemoryPriorityFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 memoryPriority;
} VkPhysicalDeviceMemoryPriorityFeaturesEXT32;

typedef struct VkPhysicalDeviceMemoryProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkPhysicalDeviceMemoryProperties32 DECLSPEC_ALIGN(8) memoryProperties;
} VkPhysicalDeviceMemoryProperties232;
typedef VkPhysicalDeviceMemoryProperties232 VkPhysicalDeviceMemoryProperties2KHR32;

typedef struct VkPhysicalDeviceMeshShaderFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 taskShader;
    VkBool32 meshShader;
    VkBool32 multiviewMeshShader;
    VkBool32 primitiveFragmentShadingRateMeshShader;
    VkBool32 meshShaderQueries;
} VkPhysicalDeviceMeshShaderFeaturesEXT32;

typedef struct VkPhysicalDeviceMeshShaderFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 taskShader;
    VkBool32 meshShader;
} VkPhysicalDeviceMeshShaderFeaturesNV32;

typedef struct VkPhysicalDeviceMeshShaderPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxTaskWorkGroupTotalCount;
    uint32_t maxTaskWorkGroupCount[3];
    uint32_t maxTaskWorkGroupInvocations;
    uint32_t maxTaskWorkGroupSize[3];
    uint32_t maxTaskPayloadSize;
    uint32_t maxTaskSharedMemorySize;
    uint32_t maxTaskPayloadAndSharedMemorySize;
    uint32_t maxMeshWorkGroupTotalCount;
    uint32_t maxMeshWorkGroupCount[3];
    uint32_t maxMeshWorkGroupInvocations;
    uint32_t maxMeshWorkGroupSize[3];
    uint32_t maxMeshSharedMemorySize;
    uint32_t maxMeshPayloadAndSharedMemorySize;
    uint32_t maxMeshOutputMemorySize;
    uint32_t maxMeshPayloadAndOutputMemorySize;
    uint32_t maxMeshOutputComponents;
    uint32_t maxMeshOutputVertices;
    uint32_t maxMeshOutputPrimitives;
    uint32_t maxMeshOutputLayers;
    uint32_t maxMeshMultiviewViewCount;
    uint32_t meshOutputPerVertexGranularity;
    uint32_t meshOutputPerPrimitiveGranularity;
    uint32_t maxPreferredTaskWorkGroupInvocations;
    uint32_t maxPreferredMeshWorkGroupInvocations;
    VkBool32 prefersLocalInvocationVertexOutput;
    VkBool32 prefersLocalInvocationPrimitiveOutput;
    VkBool32 prefersCompactVertexOutput;
    VkBool32 prefersCompactPrimitiveOutput;
} VkPhysicalDeviceMeshShaderPropertiesEXT32;

typedef struct VkPhysicalDeviceMeshShaderPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxDrawMeshTasksCount;
    uint32_t maxTaskWorkGroupInvocations;
    uint32_t maxTaskWorkGroupSize[3];
    uint32_t maxTaskTotalMemorySize;
    uint32_t maxTaskOutputCount;
    uint32_t maxMeshWorkGroupInvocations;
    uint32_t maxMeshWorkGroupSize[3];
    uint32_t maxMeshTotalMemorySize;
    uint32_t maxMeshOutputVertices;
    uint32_t maxMeshOutputPrimitives;
    uint32_t maxMeshMultiviewViewCount;
    uint32_t meshOutputPerVertexGranularity;
    uint32_t meshOutputPerPrimitiveGranularity;
} VkPhysicalDeviceMeshShaderPropertiesNV32;

typedef struct VkPhysicalDeviceMultiDrawFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multiDraw;
} VkPhysicalDeviceMultiDrawFeaturesEXT32;

typedef struct VkPhysicalDeviceMultiDrawPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxMultiDrawCount;
} VkPhysicalDeviceMultiDrawPropertiesEXT32;

typedef struct VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multisampledRenderToSingleSampled;
} VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32;

typedef struct VkPhysicalDeviceMultiviewFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multiview;
    VkBool32 multiviewGeometryShader;
    VkBool32 multiviewTessellationShader;
} VkPhysicalDeviceMultiviewFeatures32;
typedef VkPhysicalDeviceMultiviewFeatures32 VkPhysicalDeviceMultiviewFeaturesKHR32;

typedef struct VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multiviewPerViewRenderAreas;
} VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32;

typedef struct VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 multiviewPerViewViewports;
} VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32;

typedef struct VkPhysicalDeviceMultiviewProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxMultiviewViewCount;
    uint32_t maxMultiviewInstanceIndex;
} VkPhysicalDeviceMultiviewProperties32;
typedef VkPhysicalDeviceMultiviewProperties32 VkPhysicalDeviceMultiviewPropertiesKHR32;

typedef struct VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 mutableDescriptorType;
} VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32;
typedef VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE32;

typedef struct VkPhysicalDeviceNestedCommandBufferFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 nestedCommandBuffer;
    VkBool32 nestedCommandBufferRendering;
    VkBool32 nestedCommandBufferSimultaneousUse;
} VkPhysicalDeviceNestedCommandBufferFeaturesEXT32;

typedef struct VkPhysicalDeviceNestedCommandBufferPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxCommandBufferNestingLevel;
} VkPhysicalDeviceNestedCommandBufferPropertiesEXT32;

typedef struct VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 nonSeamlessCubeMap;
} VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32;

typedef struct VkPhysicalDeviceOpacityMicromapFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 micromap;
    VkBool32 micromapCaptureReplay;
    VkBool32 micromapHostCommands;
} VkPhysicalDeviceOpacityMicromapFeaturesEXT32;

typedef struct VkPhysicalDeviceOpacityMicromapPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxOpacity2StateSubdivisionLevel;
    uint32_t maxOpacity4StateSubdivisionLevel;
} VkPhysicalDeviceOpacityMicromapPropertiesEXT32;

typedef struct VkPhysicalDeviceOpticalFlowFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 opticalFlow;
} VkPhysicalDeviceOpticalFlowFeaturesNV32;

typedef struct VkPhysicalDeviceOpticalFlowPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkOpticalFlowGridSizeFlagsNV supportedOutputGridSizes;
    VkOpticalFlowGridSizeFlagsNV supportedHintGridSizes;
    VkBool32 hintSupported;
    VkBool32 costSupported;
    VkBool32 bidirectionalFlowSupported;
    VkBool32 globalFlowSupported;
    uint32_t minWidth;
    uint32_t minHeight;
    uint32_t maxWidth;
    uint32_t maxHeight;
    uint32_t maxNumRegionsOfInterest;
} VkPhysicalDeviceOpticalFlowPropertiesNV32;

typedef struct VkPhysicalDevicePCIBusInfoPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t pciDomain;
    uint32_t pciBus;
    uint32_t pciDevice;
    uint32_t pciFunction;
} VkPhysicalDevicePCIBusInfoPropertiesEXT32;

typedef struct VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pageableDeviceLocalMemory;
} VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32;

typedef struct VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 partitionedAccelerationStructure;
} VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV32;

typedef struct VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxPartitionCount;
} VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV32;

typedef struct VkPhysicalDevicePerStageDescriptorSetFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 perStageDescriptorSet;
    VkBool32 dynamicPipelineLayout;
} VkPhysicalDevicePerStageDescriptorSetFeaturesNV32;

typedef struct VkPhysicalDevicePerformanceQueryFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 performanceCounterQueryPools;
    VkBool32 performanceCounterMultipleQueryPools;
} VkPhysicalDevicePerformanceQueryFeaturesKHR32;

typedef struct VkPhysicalDevicePerformanceQueryPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 allowCommandBufferQueryCopies;
} VkPhysicalDevicePerformanceQueryPropertiesKHR32;

typedef struct VkPhysicalDevicePipelineBinaryFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineBinaries;
} VkPhysicalDevicePipelineBinaryFeaturesKHR32;

typedef struct VkPhysicalDevicePipelineBinaryPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineBinaryInternalCache;
    VkBool32 pipelineBinaryInternalCacheControl;
    VkBool32 pipelineBinaryPrefersInternalCache;
    VkBool32 pipelineBinaryPrecompiledInternalCache;
    VkBool32 pipelineBinaryCompressedData;
} VkPhysicalDevicePipelineBinaryPropertiesKHR32;

typedef struct VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineCacheIncrementalMode;
} VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC32;

typedef struct VkPhysicalDevicePipelineCreationCacheControlFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineCreationCacheControl;
} VkPhysicalDevicePipelineCreationCacheControlFeatures32;
typedef VkPhysicalDevicePipelineCreationCacheControlFeatures32 VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT32;

typedef struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineExecutableInfo;
} VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32;

typedef struct VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineLibraryGroupHandles;
} VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32;

typedef struct VkPhysicalDevicePipelineOpacityMicromapFeaturesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineOpacityMicromap;
} VkPhysicalDevicePipelineOpacityMicromapFeaturesARM32;

typedef struct VkPhysicalDevicePipelinePropertiesFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelinePropertiesIdentifier;
} VkPhysicalDevicePipelinePropertiesFeaturesEXT32;

typedef struct VkPhysicalDevicePipelineProtectedAccessFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineProtectedAccess;
} VkPhysicalDevicePipelineProtectedAccessFeatures32;
typedef VkPhysicalDevicePipelineProtectedAccessFeatures32 VkPhysicalDevicePipelineProtectedAccessFeaturesEXT32;

typedef struct VkPhysicalDevicePipelineRobustnessFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 pipelineRobustness;
} VkPhysicalDevicePipelineRobustnessFeatures32;
typedef VkPhysicalDevicePipelineRobustnessFeatures32 VkPhysicalDevicePipelineRobustnessFeaturesEXT32;

typedef struct VkPhysicalDevicePipelineRobustnessProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRobustnessBufferBehavior defaultRobustnessStorageBuffers;
    VkPipelineRobustnessBufferBehavior defaultRobustnessUniformBuffers;
    VkPipelineRobustnessBufferBehavior defaultRobustnessVertexInputs;
    VkPipelineRobustnessImageBehavior defaultRobustnessImages;
} VkPhysicalDevicePipelineRobustnessProperties32;
typedef VkPhysicalDevicePipelineRobustnessProperties32 VkPhysicalDevicePipelineRobustnessPropertiesEXT32;

typedef struct VkPhysicalDevicePointClippingProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPointClippingBehavior pointClippingBehavior;
} VkPhysicalDevicePointClippingProperties32;
typedef VkPhysicalDevicePointClippingProperties32 VkPhysicalDevicePointClippingPropertiesKHR32;

typedef struct VkPhysicalDevicePresentBarrierFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentBarrier;
} VkPhysicalDevicePresentBarrierFeaturesNV32;

typedef struct VkPhysicalDevicePresentId2FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentId2;
} VkPhysicalDevicePresentId2FeaturesKHR32;

typedef struct VkPhysicalDevicePresentIdFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentId;
} VkPhysicalDevicePresentIdFeaturesKHR32;

typedef struct VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentModeFifoLatestReady;
} VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR32;
typedef VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR32 VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT32;

typedef struct VkPhysicalDevicePresentWait2FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentWait2;
} VkPhysicalDevicePresentWait2FeaturesKHR32;

typedef struct VkPhysicalDevicePresentWaitFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentWait;
} VkPhysicalDevicePresentWaitFeaturesKHR32;

typedef struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 primitiveTopologyListRestart;
    VkBool32 primitiveTopologyPatchListRestart;
} VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32;

typedef struct VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 primitivesGeneratedQuery;
    VkBool32 primitivesGeneratedQueryWithRasterizerDiscard;
    VkBool32 primitivesGeneratedQueryWithNonZeroStreams;
} VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32;

typedef struct VkPhysicalDevicePrivateDataFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 privateData;
} VkPhysicalDevicePrivateDataFeatures32;
typedef VkPhysicalDevicePrivateDataFeatures32 VkPhysicalDevicePrivateDataFeaturesEXT32;

typedef struct VkPhysicalDeviceProtectedMemoryFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 protectedMemory;
} VkPhysicalDeviceProtectedMemoryFeatures32;

typedef struct VkPhysicalDeviceProtectedMemoryProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 protectedNoFault;
} VkPhysicalDeviceProtectedMemoryProperties32;

typedef struct VkPhysicalDeviceProvokingVertexFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 provokingVertexLast;
    VkBool32 transformFeedbackPreservesProvokingVertex;
} VkPhysicalDeviceProvokingVertexFeaturesEXT32;

typedef struct VkPhysicalDeviceProvokingVertexPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 provokingVertexModePerPipeline;
    VkBool32 transformFeedbackPreservesTriangleFanProvokingVertex;
} VkPhysicalDeviceProvokingVertexPropertiesEXT32;

typedef struct VkPhysicalDevicePushDescriptorProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxPushDescriptors;
} VkPhysicalDevicePushDescriptorProperties32;
typedef VkPhysicalDevicePushDescriptorProperties32 VkPhysicalDevicePushDescriptorPropertiesKHR32;

typedef struct VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t queueFamilyIndex;
    VkPhysicalDeviceDataGraphProcessingEngineTypeARM engineType;
} VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM32;

typedef struct VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 formatRgba10x6WithoutYCbCrSampler;
} VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32;

typedef struct VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rasterizationOrderColorAttachmentAccess;
    VkBool32 rasterizationOrderDepthAttachmentAccess;
    VkBool32 rasterizationOrderStencilAttachmentAccess;
} VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32;
typedef VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM32;

typedef struct VkPhysicalDeviceRawAccessChainsFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderRawAccessChains;
} VkPhysicalDeviceRawAccessChainsFeaturesNV32;

typedef struct VkPhysicalDeviceRayQueryFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayQuery;
} VkPhysicalDeviceRayQueryFeaturesKHR32;

typedef struct VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingInvocationReorder;
} VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32;

typedef struct VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRayTracingInvocationReorderModeNV rayTracingInvocationReorderReorderingHint;
} VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV32;

typedef struct VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 spheres;
    VkBool32 linearSweptSpheres;
} VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV32;

typedef struct VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingMaintenance1;
    VkBool32 rayTracingPipelineTraceRaysIndirect2;
} VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32;

typedef struct VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingMotionBlur;
    VkBool32 rayTracingMotionBlurPipelineTraceRaysIndirect;
} VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32;

typedef struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingPipeline;
    VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplay;
    VkBool32 rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
    VkBool32 rayTracingPipelineTraceRaysIndirect;
    VkBool32 rayTraversalPrimitiveCulling;
} VkPhysicalDeviceRayTracingPipelineFeaturesKHR32;

typedef struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderGroupHandleSize;
    uint32_t maxRayRecursionDepth;
    uint32_t maxShaderGroupStride;
    uint32_t shaderGroupBaseAlignment;
    uint32_t shaderGroupHandleCaptureReplaySize;
    uint32_t maxRayDispatchInvocationCount;
    uint32_t shaderGroupHandleAlignment;
    uint32_t maxRayHitAttributeSize;
} VkPhysicalDeviceRayTracingPipelinePropertiesKHR32;

typedef struct VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingPositionFetch;
} VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32;

typedef struct VkPhysicalDeviceRayTracingPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderGroupHandleSize;
    uint32_t maxRecursionDepth;
    uint32_t maxShaderGroupStride;
    uint32_t shaderGroupBaseAlignment;
    uint64_t DECLSPEC_ALIGN(8) maxGeometryCount;
    uint64_t DECLSPEC_ALIGN(8) maxInstanceCount;
    uint64_t DECLSPEC_ALIGN(8) maxTriangleCount;
    uint32_t maxDescriptorSetAccelerationStructures;
} VkPhysicalDeviceRayTracingPropertiesNV32;

typedef struct VkPhysicalDeviceRayTracingValidationFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 rayTracingValidation;
} VkPhysicalDeviceRayTracingValidationFeaturesNV32;

typedef struct VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 relaxedLineRasterization;
} VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG32;

typedef struct VkPhysicalDeviceRenderPassStripedFeaturesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 renderPassStriped;
} VkPhysicalDeviceRenderPassStripedFeaturesARM32;

typedef struct VkPhysicalDeviceRenderPassStripedPropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D renderPassStripeGranularity;
    uint32_t maxRenderPassStripes;
} VkPhysicalDeviceRenderPassStripedPropertiesARM32;

typedef struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 representativeFragmentTest;
} VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32;

typedef struct VkPhysicalDeviceRobustness2FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 robustBufferAccess2;
    VkBool32 robustImageAccess2;
    VkBool32 nullDescriptor;
} VkPhysicalDeviceRobustness2FeaturesKHR32;
typedef VkPhysicalDeviceRobustness2FeaturesKHR32 VkPhysicalDeviceRobustness2FeaturesEXT32;

typedef struct VkPhysicalDeviceRobustness2PropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) robustStorageBufferAccessSizeAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) robustUniformBufferAccessSizeAlignment;
} VkPhysicalDeviceRobustness2PropertiesKHR32;
typedef VkPhysicalDeviceRobustness2PropertiesKHR32 VkPhysicalDeviceRobustness2PropertiesEXT32;

typedef struct VkPhysicalDeviceSampleLocationsPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSampleCountFlags sampleLocationSampleCounts;
    VkExtent2D maxSampleLocationGridSize;
    float sampleLocationCoordinateRange[2];
    uint32_t sampleLocationSubPixelBits;
    VkBool32 variableSampleLocations;
} VkPhysicalDeviceSampleLocationsPropertiesEXT32;

typedef struct VkPhysicalDeviceSamplerFilterMinmaxProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 filterMinmaxSingleComponentFormats;
    VkBool32 filterMinmaxImageComponentMapping;
} VkPhysicalDeviceSamplerFilterMinmaxProperties32;
typedef VkPhysicalDeviceSamplerFilterMinmaxProperties32 VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT32;

typedef struct VkPhysicalDeviceSamplerYcbcrConversionFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 samplerYcbcrConversion;
} VkPhysicalDeviceSamplerYcbcrConversionFeatures32;
typedef VkPhysicalDeviceSamplerYcbcrConversionFeatures32 VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR32;

typedef struct VkPhysicalDeviceScalarBlockLayoutFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 scalarBlockLayout;
} VkPhysicalDeviceScalarBlockLayoutFeatures32;
typedef VkPhysicalDeviceScalarBlockLayoutFeatures32 VkPhysicalDeviceScalarBlockLayoutFeaturesEXT32;

typedef struct VkPhysicalDeviceSchedulingControlsFeaturesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 schedulingControls;
} VkPhysicalDeviceSchedulingControlsFeaturesARM32;

typedef struct VkPhysicalDeviceSchedulingControlsPropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPhysicalDeviceSchedulingControlsFlagsARM DECLSPEC_ALIGN(8) schedulingControlsFlags;
} VkPhysicalDeviceSchedulingControlsPropertiesARM32;

typedef struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 separateDepthStencilLayouts;
} VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32;
typedef VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderFloat16VectorAtomics;
} VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV32;

typedef struct VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderBufferFloat16Atomics;
    VkBool32 shaderBufferFloat16AtomicAdd;
    VkBool32 shaderBufferFloat16AtomicMinMax;
    VkBool32 shaderBufferFloat32AtomicMinMax;
    VkBool32 shaderBufferFloat64AtomicMinMax;
    VkBool32 shaderSharedFloat16Atomics;
    VkBool32 shaderSharedFloat16AtomicAdd;
    VkBool32 shaderSharedFloat16AtomicMinMax;
    VkBool32 shaderSharedFloat32AtomicMinMax;
    VkBool32 shaderSharedFloat64AtomicMinMax;
    VkBool32 shaderImageFloat32AtomicMinMax;
    VkBool32 sparseImageFloat32AtomicMinMax;
} VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32;

typedef struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderBufferFloat32Atomics;
    VkBool32 shaderBufferFloat32AtomicAdd;
    VkBool32 shaderBufferFloat64Atomics;
    VkBool32 shaderBufferFloat64AtomicAdd;
    VkBool32 shaderSharedFloat32Atomics;
    VkBool32 shaderSharedFloat32AtomicAdd;
    VkBool32 shaderSharedFloat64Atomics;
    VkBool32 shaderSharedFloat64AtomicAdd;
    VkBool32 shaderImageFloat32Atomics;
    VkBool32 shaderImageFloat32AtomicAdd;
    VkBool32 sparseImageFloat32Atomics;
    VkBool32 sparseImageFloat32AtomicAdd;
} VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderAtomicInt64Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderBufferInt64Atomics;
    VkBool32 shaderSharedInt64Atomics;
} VkPhysicalDeviceShaderAtomicInt64Features32;
typedef VkPhysicalDeviceShaderAtomicInt64Features32 VkPhysicalDeviceShaderAtomicInt64FeaturesKHR32;

typedef struct VkPhysicalDeviceShaderBfloat16FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderBFloat16Type;
    VkBool32 shaderBFloat16DotProduct;
    VkBool32 shaderBFloat16CooperativeMatrix;
} VkPhysicalDeviceShaderBfloat16FeaturesKHR32;

typedef struct VkPhysicalDeviceShaderClockFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderSubgroupClock;
    VkBool32 shaderDeviceClock;
} VkPhysicalDeviceShaderClockFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderCoreBuiltins;
} VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32;

typedef struct VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) shaderCoreMask;
    uint32_t shaderCoreCount;
    uint32_t shaderWarpsPerCore;
} VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM32;

typedef struct VkPhysicalDeviceShaderCoreProperties2AMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderCorePropertiesFlagsAMD shaderCoreFeatures;
    uint32_t activeComputeUnitCount;
} VkPhysicalDeviceShaderCoreProperties2AMD32;

typedef struct VkPhysicalDeviceShaderCorePropertiesAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderEngineCount;
    uint32_t shaderArraysPerEngineCount;
    uint32_t computeUnitsPerShaderArray;
    uint32_t simdPerComputeUnit;
    uint32_t wavefrontsPerSimd;
    uint32_t wavefrontSize;
    uint32_t sgprsPerSimd;
    uint32_t minSgprAllocation;
    uint32_t maxSgprAllocation;
    uint32_t sgprAllocationGranularity;
    uint32_t vgprsPerSimd;
    uint32_t minVgprAllocation;
    uint32_t maxVgprAllocation;
    uint32_t vgprAllocationGranularity;
} VkPhysicalDeviceShaderCorePropertiesAMD32;

typedef struct VkPhysicalDeviceShaderCorePropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t pixelRate;
    uint32_t texelRate;
    uint32_t fmaRate;
} VkPhysicalDeviceShaderCorePropertiesARM32;

typedef struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderDemoteToHelperInvocation;
} VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32;
typedef VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderDrawParametersFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderDrawParameters;
} VkPhysicalDeviceShaderDrawParametersFeatures32;
typedef VkPhysicalDeviceShaderDrawParametersFeatures32 VkPhysicalDeviceShaderDrawParameterFeatures32;

typedef struct VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderEarlyAndLateFragmentTests;
} VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32;

typedef struct VkPhysicalDeviceShaderExpectAssumeFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderExpectAssume;
} VkPhysicalDeviceShaderExpectAssumeFeatures32;
typedef VkPhysicalDeviceShaderExpectAssumeFeatures32 VkPhysicalDeviceShaderExpectAssumeFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderFloat16Int8Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderFloat16;
    VkBool32 shaderInt8;
} VkPhysicalDeviceShaderFloat16Int8Features32;
typedef VkPhysicalDeviceShaderFloat16Int8Features32 VkPhysicalDeviceShaderFloat16Int8FeaturesKHR32;
typedef VkPhysicalDeviceShaderFloat16Int8Features32 VkPhysicalDeviceFloat16Int8FeaturesKHR32;

typedef struct VkPhysicalDeviceShaderFloat8FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderFloat8;
    VkBool32 shaderFloat8CooperativeMatrix;
} VkPhysicalDeviceShaderFloat8FeaturesEXT32;

typedef struct VkPhysicalDeviceShaderFloatControls2Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderFloatControls2;
} VkPhysicalDeviceShaderFloatControls2Features32;
typedef VkPhysicalDeviceShaderFloatControls2Features32 VkPhysicalDeviceShaderFloatControls2FeaturesKHR32;

typedef struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderImageInt64Atomics;
    VkBool32 sparseImageInt64Atomics;
} VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32;

typedef struct VkPhysicalDeviceShaderImageFootprintFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 imageFootprint;
} VkPhysicalDeviceShaderImageFootprintFeaturesNV32;

typedef struct VkPhysicalDeviceShaderIntegerDotProductFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderIntegerDotProduct;
} VkPhysicalDeviceShaderIntegerDotProductFeatures32;
typedef VkPhysicalDeviceShaderIntegerDotProductFeatures32 VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderIntegerDotProductProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 integerDotProduct8BitUnsignedAccelerated;
    VkBool32 integerDotProduct8BitSignedAccelerated;
    VkBool32 integerDotProduct8BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated;
    VkBool32 integerDotProduct4x8BitPackedSignedAccelerated;
    VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated;
    VkBool32 integerDotProduct16BitUnsignedAccelerated;
    VkBool32 integerDotProduct16BitSignedAccelerated;
    VkBool32 integerDotProduct16BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct32BitUnsignedAccelerated;
    VkBool32 integerDotProduct32BitSignedAccelerated;
    VkBool32 integerDotProduct32BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct64BitUnsignedAccelerated;
    VkBool32 integerDotProduct64BitSignedAccelerated;
    VkBool32 integerDotProduct64BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
} VkPhysicalDeviceShaderIntegerDotProductProperties32;
typedef VkPhysicalDeviceShaderIntegerDotProductProperties32 VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR32;

typedef struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderIntegerFunctions2;
} VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32;

typedef struct VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderMaximalReconvergence;
} VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderModuleIdentifier;
} VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint8_t shaderModuleIdentifierAlgorithmUUID[VK_UUID_SIZE];
} VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT32;

typedef struct VkPhysicalDeviceShaderObjectFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderObject;
} VkPhysicalDeviceShaderObjectFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderObjectPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint8_t shaderBinaryUUID[VK_UUID_SIZE];
    uint32_t shaderBinaryVersion;
} VkPhysicalDeviceShaderObjectPropertiesEXT32;

typedef struct VkPhysicalDeviceShaderQuadControlFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderQuadControl;
} VkPhysicalDeviceShaderQuadControlFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderRelaxedExtendedInstruction;
} VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderReplicatedComposites;
} VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderSMBuiltins;
} VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32;

typedef struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t shaderSMCount;
    uint32_t shaderWarpsPerSM;
} VkPhysicalDeviceShaderSMBuiltinsPropertiesNV32;

typedef struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderSubgroupExtendedTypes;
} VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32;
typedef VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderSubgroupRotateFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderSubgroupRotate;
    VkBool32 shaderSubgroupRotateClustered;
} VkPhysicalDeviceShaderSubgroupRotateFeatures32;
typedef VkPhysicalDeviceShaderSubgroupRotateFeatures32 VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderSubgroupUniformControlFlow;
} VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderTerminateInvocationFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderTerminateInvocation;
} VkPhysicalDeviceShaderTerminateInvocationFeatures32;
typedef VkPhysicalDeviceShaderTerminateInvocationFeatures32 VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR32;

typedef struct VkPhysicalDeviceShaderTileImageFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderTileImageColorReadAccess;
    VkBool32 shaderTileImageDepthReadAccess;
    VkBool32 shaderTileImageStencilReadAccess;
} VkPhysicalDeviceShaderTileImageFeaturesEXT32;

typedef struct VkPhysicalDeviceShaderTileImagePropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderTileImageCoherentReadAccelerated;
    VkBool32 shaderTileImageReadSampleFromPixelRateInvocation;
    VkBool32 shaderTileImageReadFromHelperInvocation;
} VkPhysicalDeviceShaderTileImagePropertiesEXT32;

typedef struct VkPhysicalDeviceShaderUntypedPointersFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderUntypedPointers;
} VkPhysicalDeviceShaderUntypedPointersFeaturesKHR32;

typedef struct VkPhysicalDeviceShadingRateImageFeaturesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shadingRateImage;
    VkBool32 shadingRateCoarseSampleOrder;
} VkPhysicalDeviceShadingRateImageFeaturesNV32;

typedef struct VkPhysicalDeviceShadingRateImagePropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D shadingRateTexelSize;
    uint32_t shadingRatePaletteSize;
    uint32_t shadingRateMaxCoarseSamples;
} VkPhysicalDeviceShadingRateImagePropertiesNV32;

typedef struct VkPhysicalDeviceSparseImageFormatInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat format;
    VkImageType type;
    VkSampleCountFlagBits samples;
    VkImageUsageFlags usage;
    VkImageTiling tiling;
} VkPhysicalDeviceSparseImageFormatInfo232;
typedef VkPhysicalDeviceSparseImageFormatInfo232 VkPhysicalDeviceSparseImageFormatInfo2KHR32;

typedef struct VkPhysicalDeviceSubgroupProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t subgroupSize;
    VkShaderStageFlags supportedStages;
    VkSubgroupFeatureFlags supportedOperations;
    VkBool32 quadOperationsInAllStages;
} VkPhysicalDeviceSubgroupProperties32;

typedef struct VkPhysicalDeviceSubgroupSizeControlFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 subgroupSizeControl;
    VkBool32 computeFullSubgroups;
} VkPhysicalDeviceSubgroupSizeControlFeatures32;
typedef VkPhysicalDeviceSubgroupSizeControlFeatures32 VkPhysicalDeviceSubgroupSizeControlFeaturesEXT32;

typedef struct VkPhysicalDeviceSubgroupSizeControlProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t minSubgroupSize;
    uint32_t maxSubgroupSize;
    uint32_t maxComputeWorkgroupSubgroups;
    VkShaderStageFlags requiredSubgroupSizeStages;
} VkPhysicalDeviceSubgroupSizeControlProperties32;
typedef VkPhysicalDeviceSubgroupSizeControlProperties32 VkPhysicalDeviceSubgroupSizeControlPropertiesEXT32;

typedef struct VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 subpassMergeFeedback;
} VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32;

typedef struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 subpassShading;
} VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32;

typedef struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxSubpassShadingWorkgroupSizeAspectRatio;
} VkPhysicalDeviceSubpassShadingPropertiesHUAWEI32;

typedef struct VkPhysicalDeviceSurfaceInfo2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
} VkPhysicalDeviceSurfaceInfo2KHR32;

typedef struct VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 swapchainMaintenance1;
} VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR32;
typedef VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR32 VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT32;

typedef struct VkPhysicalDeviceSynchronization2Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 synchronization2;
} VkPhysicalDeviceSynchronization2Features32;
typedef VkPhysicalDeviceSynchronization2Features32 VkPhysicalDeviceSynchronization2FeaturesKHR32;

typedef struct VkPhysicalDeviceTensorFeaturesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 tensorNonPacked;
    VkBool32 shaderTensorAccess;
    VkBool32 shaderStorageTensorArrayDynamicIndexing;
    VkBool32 shaderStorageTensorArrayNonUniformIndexing;
    VkBool32 descriptorBindingStorageTensorUpdateAfterBind;
    VkBool32 tensors;
} VkPhysicalDeviceTensorFeaturesARM32;

typedef struct VkPhysicalDeviceTensorPropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxTensorDimensionCount;
    uint64_t DECLSPEC_ALIGN(8) maxTensorElements;
    uint64_t DECLSPEC_ALIGN(8) maxPerDimensionTensorElements;
    int64_t maxTensorStride;
    uint64_t DECLSPEC_ALIGN(8) maxTensorSize;
    uint32_t maxTensorShaderAccessArrayLength;
    uint32_t maxTensorShaderAccessSize;
    uint32_t maxDescriptorSetStorageTensors;
    uint32_t maxPerStageDescriptorSetStorageTensors;
    uint32_t maxDescriptorSetUpdateAfterBindStorageTensors;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageTensors;
    VkBool32 shaderStorageTensorArrayNonUniformIndexingNative;
    VkShaderStageFlags shaderTensorSupportedStages;
} VkPhysicalDeviceTensorPropertiesARM32;

typedef struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 texelBufferAlignment;
} VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32;

typedef struct VkPhysicalDeviceTexelBufferAlignmentProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) storageTexelBufferOffsetAlignmentBytes;
    VkBool32 storageTexelBufferOffsetSingleTexelAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) uniformTexelBufferOffsetAlignmentBytes;
    VkBool32 uniformTexelBufferOffsetSingleTexelAlignment;
} VkPhysicalDeviceTexelBufferAlignmentProperties32;
typedef VkPhysicalDeviceTexelBufferAlignmentProperties32 VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT32;

typedef struct VkPhysicalDeviceTextureCompressionASTCHDRFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 textureCompressionASTC_HDR;
} VkPhysicalDeviceTextureCompressionASTCHDRFeatures32;
typedef VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT32;

typedef struct VkPhysicalDeviceTileMemoryHeapFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 tileMemoryHeap;
} VkPhysicalDeviceTileMemoryHeapFeaturesQCOM32;

typedef struct VkPhysicalDeviceTileMemoryHeapPropertiesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 queueSubmitBoundary;
    VkBool32 tileBufferTransfers;
} VkPhysicalDeviceTileMemoryHeapPropertiesQCOM32;

typedef struct VkPhysicalDeviceTilePropertiesFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 tileProperties;
} VkPhysicalDeviceTilePropertiesFeaturesQCOM32;

typedef struct VkPhysicalDeviceTileShadingFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 tileShading;
    VkBool32 tileShadingFragmentStage;
    VkBool32 tileShadingColorAttachments;
    VkBool32 tileShadingDepthAttachments;
    VkBool32 tileShadingStencilAttachments;
    VkBool32 tileShadingInputAttachments;
    VkBool32 tileShadingSampledAttachments;
    VkBool32 tileShadingPerTileDraw;
    VkBool32 tileShadingPerTileDispatch;
    VkBool32 tileShadingDispatchTile;
    VkBool32 tileShadingApron;
    VkBool32 tileShadingAnisotropicApron;
    VkBool32 tileShadingAtomicOps;
    VkBool32 tileShadingImageProcessing;
} VkPhysicalDeviceTileShadingFeaturesQCOM32;

typedef struct VkPhysicalDeviceTileShadingPropertiesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxApronSize;
    VkBool32 preferNonCoherent;
    VkExtent2D tileGranularity;
    VkExtent2D maxTileShadingRate;
} VkPhysicalDeviceTileShadingPropertiesQCOM32;

typedef struct VkPhysicalDeviceTimelineSemaphoreFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 timelineSemaphore;
} VkPhysicalDeviceTimelineSemaphoreFeatures32;
typedef VkPhysicalDeviceTimelineSemaphoreFeatures32 VkPhysicalDeviceTimelineSemaphoreFeaturesKHR32;

typedef struct VkPhysicalDeviceTimelineSemaphoreProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) maxTimelineSemaphoreValueDifference;
} VkPhysicalDeviceTimelineSemaphoreProperties32;
typedef VkPhysicalDeviceTimelineSemaphoreProperties32 VkPhysicalDeviceTimelineSemaphorePropertiesKHR32;

typedef struct VkPhysicalDeviceToolProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    char name[VK_MAX_EXTENSION_NAME_SIZE];
    char version[VK_MAX_EXTENSION_NAME_SIZE];
    VkToolPurposeFlags purposes;
    char description[VK_MAX_DESCRIPTION_SIZE];
    char layer[VK_MAX_EXTENSION_NAME_SIZE];
} VkPhysicalDeviceToolProperties32;
typedef VkPhysicalDeviceToolProperties32 VkPhysicalDeviceToolPropertiesEXT32;

typedef struct VkPhysicalDeviceTransformFeedbackFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 transformFeedback;
    VkBool32 geometryStreams;
} VkPhysicalDeviceTransformFeedbackFeaturesEXT32;

typedef struct VkPhysicalDeviceTransformFeedbackPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxTransformFeedbackStreams;
    uint32_t maxTransformFeedbackBuffers;
    VkDeviceSize DECLSPEC_ALIGN(8) maxTransformFeedbackBufferSize;
    uint32_t maxTransformFeedbackStreamDataSize;
    uint32_t maxTransformFeedbackBufferDataSize;
    uint32_t maxTransformFeedbackBufferDataStride;
    VkBool32 transformFeedbackQueries;
    VkBool32 transformFeedbackStreamsLinesTriangles;
    VkBool32 transformFeedbackRasterizationStreamSelect;
    VkBool32 transformFeedbackDraw;
} VkPhysicalDeviceTransformFeedbackPropertiesEXT32;

typedef struct VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 unifiedImageLayouts;
    VkBool32 unifiedImageLayoutsVideo;
} VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR32;

typedef struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 uniformBufferStandardLayout;
} VkPhysicalDeviceUniformBufferStandardLayoutFeatures32;
typedef VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR32;

typedef struct VkPhysicalDeviceVariablePointersFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 variablePointersStorageBuffer;
    VkBool32 variablePointers;
} VkPhysicalDeviceVariablePointersFeatures32;
typedef VkPhysicalDeviceVariablePointersFeatures32 VkPhysicalDeviceVariablePointersFeaturesKHR32;
typedef VkPhysicalDeviceVariablePointersFeatures32 VkPhysicalDeviceVariablePointerFeaturesKHR32;
typedef VkPhysicalDeviceVariablePointersFeatures32 VkPhysicalDeviceVariablePointerFeatures32;

typedef struct VkPhysicalDeviceVertexAttributeDivisorFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 vertexAttributeInstanceRateDivisor;
    VkBool32 vertexAttributeInstanceRateZeroDivisor;
} VkPhysicalDeviceVertexAttributeDivisorFeatures32;
typedef VkPhysicalDeviceVertexAttributeDivisorFeatures32 VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR32;
typedef VkPhysicalDeviceVertexAttributeDivisorFeatures32 VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT32;

typedef struct VkPhysicalDeviceVertexAttributeDivisorProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxVertexAttribDivisor;
    VkBool32 supportsNonZeroFirstInstance;
} VkPhysicalDeviceVertexAttributeDivisorProperties32;
typedef VkPhysicalDeviceVertexAttributeDivisorProperties32 VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR32;

typedef struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxVertexAttribDivisor;
} VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT32;

typedef struct VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 vertexAttributeRobustness;
} VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT32;

typedef struct VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 vertexInputDynamicState;
} VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32;

typedef struct VkPhysicalDeviceVideoDecodeVP9FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 videoDecodeVP9;
} VkPhysicalDeviceVideoDecodeVP9FeaturesKHR32;

typedef struct VkPhysicalDeviceVideoEncodeAV1FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 videoEncodeAV1;
} VkPhysicalDeviceVideoEncodeAV1FeaturesKHR32;

typedef struct VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 videoEncodeIntraRefresh;
} VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR32;

typedef struct VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pVideoProfile;
    uint32_t qualityLevel;
} VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR32;

typedef struct VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 videoEncodeQuantizationMap;
} VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR32;

typedef struct VkPhysicalDeviceVideoFormatInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageUsageFlags imageUsage;
} VkPhysicalDeviceVideoFormatInfoKHR32;

typedef struct VkPhysicalDeviceVideoMaintenance1FeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 videoMaintenance1;
} VkPhysicalDeviceVideoMaintenance1FeaturesKHR32;

typedef struct VkPhysicalDeviceVulkan11Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 storageBuffer16BitAccess;
    VkBool32 uniformAndStorageBuffer16BitAccess;
    VkBool32 storagePushConstant16;
    VkBool32 storageInputOutput16;
    VkBool32 multiview;
    VkBool32 multiviewGeometryShader;
    VkBool32 multiviewTessellationShader;
    VkBool32 variablePointersStorageBuffer;
    VkBool32 variablePointers;
    VkBool32 protectedMemory;
    VkBool32 samplerYcbcrConversion;
    VkBool32 shaderDrawParameters;
} VkPhysicalDeviceVulkan11Features32;

typedef struct VkPhysicalDeviceVulkan11Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint8_t deviceUUID[VK_UUID_SIZE];
    uint8_t driverUUID[VK_UUID_SIZE];
    uint8_t deviceLUID[VK_LUID_SIZE];
    uint32_t deviceNodeMask;
    VkBool32 deviceLUIDValid;
    uint32_t subgroupSize;
    VkShaderStageFlags subgroupSupportedStages;
    VkSubgroupFeatureFlags subgroupSupportedOperations;
    VkBool32 subgroupQuadOperationsInAllStages;
    VkPointClippingBehavior pointClippingBehavior;
    uint32_t maxMultiviewViewCount;
    uint32_t maxMultiviewInstanceIndex;
    VkBool32 protectedNoFault;
    uint32_t maxPerSetDescriptors;
    VkDeviceSize DECLSPEC_ALIGN(8) maxMemoryAllocationSize;
} VkPhysicalDeviceVulkan11Properties32;

typedef struct VkPhysicalDeviceVulkan12Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 samplerMirrorClampToEdge;
    VkBool32 drawIndirectCount;
    VkBool32 storageBuffer8BitAccess;
    VkBool32 uniformAndStorageBuffer8BitAccess;
    VkBool32 storagePushConstant8;
    VkBool32 shaderBufferInt64Atomics;
    VkBool32 shaderSharedInt64Atomics;
    VkBool32 shaderFloat16;
    VkBool32 shaderInt8;
    VkBool32 descriptorIndexing;
    VkBool32 shaderInputAttachmentArrayDynamicIndexing;
    VkBool32 shaderUniformTexelBufferArrayDynamicIndexing;
    VkBool32 shaderStorageTexelBufferArrayDynamicIndexing;
    VkBool32 shaderUniformBufferArrayNonUniformIndexing;
    VkBool32 shaderSampledImageArrayNonUniformIndexing;
    VkBool32 shaderStorageBufferArrayNonUniformIndexing;
    VkBool32 shaderStorageImageArrayNonUniformIndexing;
    VkBool32 shaderInputAttachmentArrayNonUniformIndexing;
    VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing;
    VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing;
    VkBool32 descriptorBindingUniformBufferUpdateAfterBind;
    VkBool32 descriptorBindingSampledImageUpdateAfterBind;
    VkBool32 descriptorBindingStorageImageUpdateAfterBind;
    VkBool32 descriptorBindingStorageBufferUpdateAfterBind;
    VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
    VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
    VkBool32 descriptorBindingUpdateUnusedWhilePending;
    VkBool32 descriptorBindingPartiallyBound;
    VkBool32 descriptorBindingVariableDescriptorCount;
    VkBool32 runtimeDescriptorArray;
    VkBool32 samplerFilterMinmax;
    VkBool32 scalarBlockLayout;
    VkBool32 imagelessFramebuffer;
    VkBool32 uniformBufferStandardLayout;
    VkBool32 shaderSubgroupExtendedTypes;
    VkBool32 separateDepthStencilLayouts;
    VkBool32 hostQueryReset;
    VkBool32 timelineSemaphore;
    VkBool32 bufferDeviceAddress;
    VkBool32 bufferDeviceAddressCaptureReplay;
    VkBool32 bufferDeviceAddressMultiDevice;
    VkBool32 vulkanMemoryModel;
    VkBool32 vulkanMemoryModelDeviceScope;
    VkBool32 vulkanMemoryModelAvailabilityVisibilityChains;
    VkBool32 shaderOutputViewportIndex;
    VkBool32 shaderOutputLayer;
    VkBool32 subgroupBroadcastDynamicId;
} VkPhysicalDeviceVulkan12Features32;

typedef struct VkPhysicalDeviceVulkan12Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDriverId driverID;
    char driverName[VK_MAX_DRIVER_NAME_SIZE];
    char driverInfo[VK_MAX_DRIVER_INFO_SIZE];
    VkConformanceVersion conformanceVersion;
    VkShaderFloatControlsIndependence denormBehaviorIndependence;
    VkShaderFloatControlsIndependence roundingModeIndependence;
    VkBool32 shaderSignedZeroInfNanPreserveFloat16;
    VkBool32 shaderSignedZeroInfNanPreserveFloat32;
    VkBool32 shaderSignedZeroInfNanPreserveFloat64;
    VkBool32 shaderDenormPreserveFloat16;
    VkBool32 shaderDenormPreserveFloat32;
    VkBool32 shaderDenormPreserveFloat64;
    VkBool32 shaderDenormFlushToZeroFloat16;
    VkBool32 shaderDenormFlushToZeroFloat32;
    VkBool32 shaderDenormFlushToZeroFloat64;
    VkBool32 shaderRoundingModeRTEFloat16;
    VkBool32 shaderRoundingModeRTEFloat32;
    VkBool32 shaderRoundingModeRTEFloat64;
    VkBool32 shaderRoundingModeRTZFloat16;
    VkBool32 shaderRoundingModeRTZFloat32;
    VkBool32 shaderRoundingModeRTZFloat64;
    uint32_t maxUpdateAfterBindDescriptorsInAllPools;
    VkBool32 shaderUniformBufferArrayNonUniformIndexingNative;
    VkBool32 shaderSampledImageArrayNonUniformIndexingNative;
    VkBool32 shaderStorageBufferArrayNonUniformIndexingNative;
    VkBool32 shaderStorageImageArrayNonUniformIndexingNative;
    VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative;
    VkBool32 robustBufferAccessUpdateAfterBind;
    VkBool32 quadDivergentImplicitLod;
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t maxPerStageUpdateAfterBindResources;
    uint32_t maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
    VkResolveModeFlags supportedDepthResolveModes;
    VkResolveModeFlags supportedStencilResolveModes;
    VkBool32 independentResolveNone;
    VkBool32 independentResolve;
    VkBool32 filterMinmaxSingleComponentFormats;
    VkBool32 filterMinmaxImageComponentMapping;
    uint64_t DECLSPEC_ALIGN(8) maxTimelineSemaphoreValueDifference;
    VkSampleCountFlags framebufferIntegerColorSampleCounts;
} VkPhysicalDeviceVulkan12Properties32;

typedef struct VkPhysicalDeviceVulkan13Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 robustImageAccess;
    VkBool32 inlineUniformBlock;
    VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind;
    VkBool32 pipelineCreationCacheControl;
    VkBool32 privateData;
    VkBool32 shaderDemoteToHelperInvocation;
    VkBool32 shaderTerminateInvocation;
    VkBool32 subgroupSizeControl;
    VkBool32 computeFullSubgroups;
    VkBool32 synchronization2;
    VkBool32 textureCompressionASTC_HDR;
    VkBool32 shaderZeroInitializeWorkgroupMemory;
    VkBool32 dynamicRendering;
    VkBool32 shaderIntegerDotProduct;
    VkBool32 maintenance4;
} VkPhysicalDeviceVulkan13Features32;

typedef struct VkPhysicalDeviceVulkan13Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t minSubgroupSize;
    uint32_t maxSubgroupSize;
    uint32_t maxComputeWorkgroupSubgroups;
    VkShaderStageFlags requiredSubgroupSizeStages;
    uint32_t maxInlineUniformBlockSize;
    uint32_t maxPerStageDescriptorInlineUniformBlocks;
    uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    uint32_t maxDescriptorSetInlineUniformBlocks;
    uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
    uint32_t maxInlineUniformTotalSize;
    VkBool32 integerDotProduct8BitUnsignedAccelerated;
    VkBool32 integerDotProduct8BitSignedAccelerated;
    VkBool32 integerDotProduct8BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated;
    VkBool32 integerDotProduct4x8BitPackedSignedAccelerated;
    VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated;
    VkBool32 integerDotProduct16BitUnsignedAccelerated;
    VkBool32 integerDotProduct16BitSignedAccelerated;
    VkBool32 integerDotProduct16BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct32BitUnsignedAccelerated;
    VkBool32 integerDotProduct32BitSignedAccelerated;
    VkBool32 integerDotProduct32BitMixedSignednessAccelerated;
    VkBool32 integerDotProduct64BitUnsignedAccelerated;
    VkBool32 integerDotProduct64BitSignedAccelerated;
    VkBool32 integerDotProduct64BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated;
    VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
    VkDeviceSize DECLSPEC_ALIGN(8) storageTexelBufferOffsetAlignmentBytes;
    VkBool32 storageTexelBufferOffsetSingleTexelAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) uniformTexelBufferOffsetAlignmentBytes;
    VkBool32 uniformTexelBufferOffsetSingleTexelAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) maxBufferSize;
} VkPhysicalDeviceVulkan13Properties32;

typedef struct VkPhysicalDeviceVulkan14Features32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 globalPriorityQuery;
    VkBool32 shaderSubgroupRotate;
    VkBool32 shaderSubgroupRotateClustered;
    VkBool32 shaderFloatControls2;
    VkBool32 shaderExpectAssume;
    VkBool32 rectangularLines;
    VkBool32 bresenhamLines;
    VkBool32 smoothLines;
    VkBool32 stippledRectangularLines;
    VkBool32 stippledBresenhamLines;
    VkBool32 stippledSmoothLines;
    VkBool32 vertexAttributeInstanceRateDivisor;
    VkBool32 vertexAttributeInstanceRateZeroDivisor;
    VkBool32 indexTypeUint8;
    VkBool32 dynamicRenderingLocalRead;
    VkBool32 maintenance5;
    VkBool32 maintenance6;
    VkBool32 pipelineProtectedAccess;
    VkBool32 pipelineRobustness;
    VkBool32 hostImageCopy;
    VkBool32 pushDescriptor;
} VkPhysicalDeviceVulkan14Features32;

typedef struct VkPhysicalDeviceVulkan14Properties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t lineSubPixelPrecisionBits;
    uint32_t maxVertexAttribDivisor;
    VkBool32 supportsNonZeroFirstInstance;
    uint32_t maxPushDescriptors;
    VkBool32 dynamicRenderingLocalReadDepthStencilAttachments;
    VkBool32 dynamicRenderingLocalReadMultisampledAttachments;
    VkBool32 earlyFragmentMultisampleCoverageAfterSampleCounting;
    VkBool32 earlyFragmentSampleMaskTestBeforeSampleCounting;
    VkBool32 depthStencilSwizzleOneSupport;
    VkBool32 polygonModePointSize;
    VkBool32 nonStrictSinglePixelWideLinesUseParallelogram;
    VkBool32 nonStrictWideLinesUseParallelogram;
    VkBool32 blockTexelViewCompatibleMultipleLayers;
    uint32_t maxCombinedImageSamplerDescriptorCount;
    VkBool32 fragmentShadingRateClampCombinerInputs;
    VkPipelineRobustnessBufferBehavior defaultRobustnessStorageBuffers;
    VkPipelineRobustnessBufferBehavior defaultRobustnessUniformBuffers;
    VkPipelineRobustnessBufferBehavior defaultRobustnessVertexInputs;
    VkPipelineRobustnessImageBehavior defaultRobustnessImages;
    uint32_t copySrcLayoutCount;
    PTR32 pCopySrcLayouts;
    uint32_t copyDstLayoutCount;
    PTR32 pCopyDstLayouts;
    uint8_t optimalTilingLayoutUUID[VK_UUID_SIZE];
    VkBool32 identicalMemoryTypeRequirements;
} VkPhysicalDeviceVulkan14Properties32;

typedef struct VkPhysicalDeviceVulkanMemoryModelFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 vulkanMemoryModel;
    VkBool32 vulkanMemoryModelDeviceScope;
    VkBool32 vulkanMemoryModelAvailabilityVisibilityChains;
} VkPhysicalDeviceVulkanMemoryModelFeatures32;
typedef VkPhysicalDeviceVulkanMemoryModelFeatures32 VkPhysicalDeviceVulkanMemoryModelFeaturesKHR32;

typedef struct VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 workgroupMemoryExplicitLayout;
    VkBool32 workgroupMemoryExplicitLayoutScalarBlockLayout;
    VkBool32 workgroupMemoryExplicitLayout8BitAccess;
    VkBool32 workgroupMemoryExplicitLayout16BitAccess;
} VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32;

typedef struct VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 ycbcr2plane444Formats;
} VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32;

typedef struct VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 ycbcrDegamma;
} VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32;

typedef struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 ycbcrImageArrays;
} VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32;

typedef struct VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 zeroInitializeDeviceMemory;
} VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT32;

typedef struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shaderZeroInitializeWorkgroupMemory;
} VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32;
typedef VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR32;

typedef struct VkPipelineBinaryCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pKeysAndDataInfo;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
    PTR32 pPipelineCreateInfo;
} VkPipelineBinaryCreateInfoKHR32;

typedef struct VkPipelineBinaryDataInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineBinaryKHR DECLSPEC_ALIGN(8) pipelineBinary;
} VkPipelineBinaryDataInfoKHR32;

typedef struct VkPipelineBinaryHandlesInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t pipelineBinaryCount;
    PTR32 pPipelineBinaries;
} VkPipelineBinaryHandlesInfoKHR32;

typedef struct VkPipelineBinaryInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t binaryCount;
    PTR32 pPipelineBinaries;
} VkPipelineBinaryInfoKHR32;

typedef struct VkPipelineColorBlendAdvancedStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 srcPremultiplied;
    VkBool32 dstPremultiplied;
    VkBlendOverlapEXT blendOverlap;
} VkPipelineColorBlendAdvancedStateCreateInfoEXT32;

typedef struct VkPipelineColorWriteCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t attachmentCount;
    PTR32 pColorWriteEnables;
} VkPipelineColorWriteCreateInfoEXT32;

typedef struct VkPipelineCompilerControlCreateInfoAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCompilerControlFlagsAMD compilerControlFlags;
} VkPipelineCompilerControlCreateInfoAMD32;

typedef struct VkPipelineCoverageModulationStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCoverageModulationStateCreateFlagsNV flags;
    VkCoverageModulationModeNV coverageModulationMode;
    VkBool32 coverageModulationTableEnable;
    uint32_t coverageModulationTableCount;
    PTR32 pCoverageModulationTable;
} VkPipelineCoverageModulationStateCreateInfoNV32;

typedef struct VkPipelineCoverageReductionStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCoverageReductionStateCreateFlagsNV flags;
    VkCoverageReductionModeNV coverageReductionMode;
} VkPipelineCoverageReductionStateCreateInfoNV32;

typedef struct VkPipelineCoverageToColorStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCoverageToColorStateCreateFlagsNV flags;
    VkBool32 coverageToColorEnable;
    uint32_t coverageToColorLocation;
} VkPipelineCoverageToColorStateCreateInfoNV32;

typedef struct VkPipelineCreateFlags2CreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags2 DECLSPEC_ALIGN(8) flags;
} VkPipelineCreateFlags2CreateInfo32;
typedef VkPipelineCreateFlags2CreateInfo32 VkPipelineCreateFlags2CreateInfoKHR32;

typedef struct VkPipelineCreationFeedbackCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pPipelineCreationFeedback;
    uint32_t pipelineStageCreationFeedbackCount;
    PTR32 pPipelineStageCreationFeedbacks;
} VkPipelineCreationFeedbackCreateInfo32;
typedef VkPipelineCreationFeedbackCreateInfo32 VkPipelineCreationFeedbackCreateInfoEXT32;

typedef struct VkPipelineDiscardRectangleStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineDiscardRectangleStateCreateFlagsEXT flags;
    VkDiscardRectangleModeEXT discardRectangleMode;
    uint32_t discardRectangleCount;
    PTR32 pDiscardRectangles;
} VkPipelineDiscardRectangleStateCreateInfoEXT32;

typedef struct VkPipelineExecutableInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
    uint32_t executableIndex;
} VkPipelineExecutableInfoKHR32;

typedef struct VkPipelineExecutableInternalRepresentationKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    char name[VK_MAX_DESCRIPTION_SIZE];
    char description[VK_MAX_DESCRIPTION_SIZE];
    VkBool32 isText;
    PTR32 dataSize;
    PTR32 pData;
} VkPipelineExecutableInternalRepresentationKHR32;

typedef struct VkPipelineExecutablePropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags stages;
    char name[VK_MAX_DESCRIPTION_SIZE];
    char description[VK_MAX_DESCRIPTION_SIZE];
    uint32_t subgroupSize;
} VkPipelineExecutablePropertiesKHR32;

typedef struct VkPipelineExecutableStatisticKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    char name[VK_MAX_DESCRIPTION_SIZE];
    char description[VK_MAX_DESCRIPTION_SIZE];
    VkPipelineExecutableStatisticFormatKHR format;
    VkPipelineExecutableStatisticValueKHR32 DECLSPEC_ALIGN(8) value;
} VkPipelineExecutableStatisticKHR32;

typedef struct VkPipelineFragmentDensityMapLayeredCreateInfoVALVE32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxFragmentDensityMapLayers;
} VkPipelineFragmentDensityMapLayeredCreateInfoVALVE32;

typedef struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFragmentShadingRateTypeNV shadingRateType;
    VkFragmentShadingRateNV shadingRate;
    VkFragmentShadingRateCombinerOpKHR combinerOps[2];
} VkPipelineFragmentShadingRateEnumStateCreateInfoNV32;

typedef struct VkPipelineFragmentShadingRateStateCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D fragmentSize;
    VkFragmentShadingRateCombinerOpKHR combinerOps[2];
} VkPipelineFragmentShadingRateStateCreateInfoKHR32;

typedef struct VkPipelineIndirectDeviceAddressInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineBindPoint pipelineBindPoint;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
} VkPipelineIndirectDeviceAddressInfoNV32;


typedef struct VkPipelineInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
} VkPipelineInfoKHR32;
typedef VkPipelineInfoKHR32 VkPipelineInfoEXT32;

typedef struct VkPipelineLayoutCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineLayoutCreateFlags flags;
    uint32_t setLayoutCount;
    PTR32 pSetLayouts;
    uint32_t pushConstantRangeCount;
    PTR32 pPushConstantRanges;
} VkPipelineLayoutCreateInfo32;

typedef struct VkPipelineRasterizationConservativeStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRasterizationConservativeStateCreateFlagsEXT flags;
    VkConservativeRasterizationModeEXT conservativeRasterizationMode;
    float extraPrimitiveOverestimationSize;
} VkPipelineRasterizationConservativeStateCreateInfoEXT32;

typedef struct VkPipelineRasterizationDepthClipStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags;
    VkBool32 depthClipEnable;
} VkPipelineRasterizationDepthClipStateCreateInfoEXT32;

typedef struct VkPipelineRasterizationLineStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkLineRasterizationMode lineRasterizationMode;
    VkBool32 stippledLineEnable;
    uint32_t lineStippleFactor;
    uint16_t lineStipplePattern;
} VkPipelineRasterizationLineStateCreateInfo32;
typedef VkPipelineRasterizationLineStateCreateInfo32 VkPipelineRasterizationLineStateCreateInfoKHR32;
typedef VkPipelineRasterizationLineStateCreateInfo32 VkPipelineRasterizationLineStateCreateInfoEXT32;

typedef struct VkPipelineRasterizationProvokingVertexStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkProvokingVertexModeEXT provokingVertexMode;
} VkPipelineRasterizationProvokingVertexStateCreateInfoEXT32;

typedef struct VkPipelineRasterizationStateRasterizationOrderAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRasterizationOrderAMD rasterizationOrder;
} VkPipelineRasterizationStateRasterizationOrderAMD32;

typedef struct VkPipelineRasterizationStateStreamCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRasterizationStateStreamCreateFlagsEXT flags;
    uint32_t rasterizationStream;
} VkPipelineRasterizationStateStreamCreateInfoEXT32;

typedef struct VkPipelineRenderingCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachmentFormats;
    VkFormat depthAttachmentFormat;
    VkFormat stencilAttachmentFormat;
} VkPipelineRenderingCreateInfo32;
typedef VkPipelineRenderingCreateInfo32 VkPipelineRenderingCreateInfoKHR32;

typedef struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 representativeFragmentTestEnable;
} VkPipelineRepresentativeFragmentTestStateCreateInfoNV32;

typedef struct VkPipelineRobustnessCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineRobustnessBufferBehavior storageBuffers;
    VkPipelineRobustnessBufferBehavior uniformBuffers;
    VkPipelineRobustnessBufferBehavior vertexInputs;
    VkPipelineRobustnessImageBehavior images;
} VkPipelineRobustnessCreateInfo32;
typedef VkPipelineRobustnessCreateInfo32 VkPipelineRobustnessCreateInfoEXT32;

typedef struct VkPipelineSampleLocationsStateCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 sampleLocationsEnable;
    VkSampleLocationsInfoEXT32 sampleLocationsInfo;
} VkPipelineSampleLocationsStateCreateInfoEXT32;

typedef struct VkPipelineShaderStageModuleIdentifierCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t identifierSize;
    PTR32 pIdentifier;
} VkPipelineShaderStageModuleIdentifierCreateInfoEXT32;

typedef struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t requiredSubgroupSize;
} VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32;
typedef VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT32;
typedef VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 VkShaderRequiredSubgroupSizeCreateInfoEXT32;

typedef struct VkPipelineTessellationDomainOriginStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTessellationDomainOrigin domainOrigin;
} VkPipelineTessellationDomainOriginStateCreateInfo32;
typedef VkPipelineTessellationDomainOriginStateCreateInfo32 VkPipelineTessellationDomainOriginStateCreateInfoKHR32;

typedef struct VkPipelineVertexInputDivisorStateCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t vertexBindingDivisorCount;
    PTR32 pVertexBindingDivisors;
} VkPipelineVertexInputDivisorStateCreateInfo32;
typedef VkPipelineVertexInputDivisorStateCreateInfo32 VkPipelineVertexInputDivisorStateCreateInfoKHR32;
typedef VkPipelineVertexInputDivisorStateCreateInfo32 VkPipelineVertexInputDivisorStateCreateInfoEXT32;

typedef struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCoarseSampleOrderTypeNV sampleOrderType;
    uint32_t customSampleOrderCount;
    PTR32 pCustomSampleOrders;
} VkPipelineViewportCoarseSampleOrderStateCreateInfoNV32;

typedef struct VkPipelineViewportDepthClampControlCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDepthClampModeEXT depthClampMode;
    PTR32 pDepthClampRange;
} VkPipelineViewportDepthClampControlCreateInfoEXT32;

typedef struct VkPipelineViewportDepthClipControlCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 negativeOneToOne;
} VkPipelineViewportDepthClipControlCreateInfoEXT32;

typedef struct VkPipelineViewportExclusiveScissorStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t exclusiveScissorCount;
    PTR32 pExclusiveScissors;
} VkPipelineViewportExclusiveScissorStateCreateInfoNV32;

typedef struct VkPipelineViewportShadingRateImageStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 shadingRateImageEnable;
    uint32_t viewportCount;
    PTR32 pShadingRatePalettes;
} VkPipelineViewportShadingRateImageStateCreateInfoNV32;

typedef struct VkPipelineViewportSwizzleStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineViewportSwizzleStateCreateFlagsNV flags;
    uint32_t viewportCount;
    PTR32 pViewportSwizzles;
} VkPipelineViewportSwizzleStateCreateInfoNV32;

typedef struct VkPipelineViewportWScalingStateCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 viewportWScalingEnable;
    uint32_t viewportCount;
    PTR32 pViewportWScalings;
} VkPipelineViewportWScalingStateCreateInfoNV32;

typedef struct VkPresentId2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pPresentIds;
} VkPresentId2KHR32;

typedef struct VkPresentIdKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pPresentIds;
} VkPresentIdKHR32;

typedef struct VkPresentInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreCount;
    PTR32 pWaitSemaphores;
    uint32_t swapchainCount;
    PTR32 pSwapchains;
    PTR32 pImageIndices;
    PTR32 pResults;
} VkPresentInfoKHR32;

typedef struct VkPresentRegionsKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pRegions;
} VkPresentRegionsKHR32;

typedef struct VkPresentWait2InfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) presentId;
    uint64_t DECLSPEC_ALIGN(8) timeout;
} VkPresentWait2InfoKHR32;

typedef struct VkPrivateDataSlotCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPrivateDataSlotCreateFlags flags;
} VkPrivateDataSlotCreateInfo32;
typedef VkPrivateDataSlotCreateInfo32 VkPrivateDataSlotCreateInfoEXT32;

typedef struct VkProtectedSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 protectedSubmit;
} VkProtectedSubmitInfo32;

typedef struct VkPushConstantsInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    VkShaderStageFlags stageFlags;
    uint32_t offset;
    uint32_t size;
    PTR32 pValues;
} VkPushConstantsInfo32;
typedef VkPushConstantsInfo32 VkPushConstantsInfoKHR32;

typedef struct VkPushDescriptorSetInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags stageFlags;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    uint32_t set;
    uint32_t descriptorWriteCount;
    PTR32 pDescriptorWrites;
} VkPushDescriptorSetInfo32;
typedef VkPushDescriptorSetInfo32 VkPushDescriptorSetInfoKHR32;

typedef struct VkPushDescriptorSetWithTemplateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    uint32_t set;
    PTR32 pData;
} VkPushDescriptorSetWithTemplateInfo32;
typedef VkPushDescriptorSetWithTemplateInfo32 VkPushDescriptorSetWithTemplateInfoKHR32;

typedef struct VkQueryLowLatencySupportNV32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pQueriedLowLatencyData;
} VkQueryLowLatencySupportNV32;

typedef struct VkQueryPoolCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueryPoolCreateFlags flags;
    VkQueryType queryType;
    uint32_t queryCount;
    VkQueryPipelineStatisticFlags pipelineStatistics;
} VkQueryPoolCreateInfo32;

typedef struct VkQueryPoolPerformanceCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t queueFamilyIndex;
    uint32_t counterIndexCount;
    PTR32 pCounterIndices;
} VkQueryPoolPerformanceCreateInfoKHR32;

typedef struct VkQueryPoolPerformanceQueryCreateInfoINTEL32
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueryPoolSamplingModeINTEL performanceCountersSampling;
} VkQueryPoolPerformanceQueryCreateInfoINTEL32;
typedef VkQueryPoolPerformanceQueryCreateInfoINTEL32 VkQueryPoolCreateInfoINTEL32;

typedef struct VkQueryPoolVideoEncodeFeedbackCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeFeedbackFlagsKHR encodeFeedbackFlags;
} VkQueryPoolVideoEncodeFeedbackCreateInfoKHR32;

typedef struct VkQueueFamilyCheckpointProperties2NV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags2 DECLSPEC_ALIGN(8) checkpointExecutionStageMask;
} VkQueueFamilyCheckpointProperties2NV32;

typedef struct VkQueueFamilyCheckpointPropertiesNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineStageFlags checkpointExecutionStageMask;
} VkQueueFamilyCheckpointPropertiesNV32;

typedef struct VkQueueFamilyDataGraphProcessingEnginePropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExternalSemaphoreHandleTypeFlags foreignSemaphoreHandleTypes;
    VkExternalMemoryHandleTypeFlags foreignMemoryHandleTypes;
} VkQueueFamilyDataGraphProcessingEnginePropertiesARM32;

typedef struct VkQueueFamilyDataGraphPropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPhysicalDeviceDataGraphProcessingEngineARM engine;
    VkPhysicalDeviceDataGraphOperationSupportARM operation;
} VkQueueFamilyDataGraphPropertiesARM32;

typedef struct VkQueueFamilyGlobalPriorityProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t priorityCount;
    VkQueueGlobalPriority priorities[VK_MAX_GLOBAL_PRIORITY_SIZE];
} VkQueueFamilyGlobalPriorityProperties32;
typedef VkQueueFamilyGlobalPriorityProperties32 VkQueueFamilyGlobalPriorityPropertiesKHR32;
typedef VkQueueFamilyGlobalPriorityProperties32 VkQueueFamilyGlobalPriorityPropertiesEXT32;

typedef struct VkQueueFamilyOwnershipTransferPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t optimalImageTransferToQueueFamilies;
} VkQueueFamilyOwnershipTransferPropertiesKHR32;

typedef struct VkQueueFamilyProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueueFamilyProperties queueFamilyProperties;
} VkQueueFamilyProperties232;
typedef VkQueueFamilyProperties232 VkQueueFamilyProperties2KHR32;

typedef struct VkQueueFamilyQueryResultStatusPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 queryResultStatusSupport;
} VkQueueFamilyQueryResultStatusPropertiesKHR32;

typedef struct VkQueueFamilyVideoPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoCodecOperationFlagsKHR videoCodecOperations;
} VkQueueFamilyVideoPropertiesKHR32;

typedef struct VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 allowClusterAccelerationStructure;
} VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV32;

typedef struct VkRayTracingPipelineCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags flags;
    uint32_t stageCount;
    PTR32 pStages;
    uint32_t groupCount;
    PTR32 pGroups;
    uint32_t maxPipelineRayRecursionDepth;
    PTR32 pLibraryInfo;
    PTR32 pLibraryInterface;
    PTR32 pDynamicState;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    VkPipeline DECLSPEC_ALIGN(8) basePipelineHandle;
    int32_t basePipelineIndex;
} VkRayTracingPipelineCreateInfoKHR32;

typedef struct VkRayTracingPipelineCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipelineCreateFlags flags;
    uint32_t stageCount;
    PTR32 pStages;
    uint32_t groupCount;
    PTR32 pGroups;
    uint32_t maxRecursionDepth;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    VkPipeline DECLSPEC_ALIGN(8) basePipelineHandle;
    int32_t basePipelineIndex;
} VkRayTracingPipelineCreateInfoNV32;

typedef struct VkReleaseCapturedPipelineDataInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
} VkReleaseCapturedPipelineDataInfoKHR32;

typedef struct VkReleaseSwapchainImagesInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
    uint32_t imageIndexCount;
    PTR32 pImageIndices;
} VkReleaseSwapchainImagesInfoKHR32;
typedef VkReleaseSwapchainImagesInfoKHR32 VkReleaseSwapchainImagesInfoEXT32;

typedef struct VkRenderPassAttachmentBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t attachmentCount;
    PTR32 pAttachments;
} VkRenderPassAttachmentBeginInfo32;
typedef VkRenderPassAttachmentBeginInfo32 VkRenderPassAttachmentBeginInfoKHR32;

typedef struct VkRenderPassBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderPass DECLSPEC_ALIGN(8) renderPass;
    VkFramebuffer DECLSPEC_ALIGN(8) framebuffer;
    VkRect2D renderArea;
    uint32_t clearValueCount;
    PTR32 pClearValues;
} VkRenderPassBeginInfo32;

typedef struct VkRenderPassCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderPassCreateFlags flags;
    uint32_t attachmentCount;
    PTR32 pAttachments;
    uint32_t subpassCount;
    PTR32 pSubpasses;
    uint32_t dependencyCount;
    PTR32 pDependencies;
} VkRenderPassCreateInfo32;

typedef struct VkRenderPassCreateInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderPassCreateFlags flags;
    uint32_t attachmentCount;
    PTR32 pAttachments;
    uint32_t subpassCount;
    PTR32 pSubpasses;
    uint32_t dependencyCount;
    PTR32 pDependencies;
    uint32_t correlatedViewMaskCount;
    PTR32 pCorrelatedViewMasks;
} VkRenderPassCreateInfo232;
typedef VkRenderPassCreateInfo232 VkRenderPassCreateInfo2KHR32;

typedef struct VkRenderPassCreationControlEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 disallowMerging;
} VkRenderPassCreationControlEXT32;

typedef struct VkRenderPassCreationFeedbackCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pRenderPassFeedback;
} VkRenderPassCreationFeedbackCreateInfoEXT32;

typedef struct VkRenderPassFragmentDensityMapCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkAttachmentReference fragmentDensityMapAttachment;
} VkRenderPassFragmentDensityMapCreateInfoEXT32;

typedef struct VkRenderPassFragmentDensityMapOffsetEndInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t fragmentDensityOffsetCount;
    PTR32 pFragmentDensityOffsets;
} VkRenderPassFragmentDensityMapOffsetEndInfoEXT32;
typedef VkRenderPassFragmentDensityMapOffsetEndInfoEXT32 VkSubpassFragmentDensityMapOffsetEndInfoQCOM32;

typedef struct VkRenderPassInputAttachmentAspectCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t aspectReferenceCount;
    PTR32 pAspectReferences;
} VkRenderPassInputAttachmentAspectCreateInfo32;
typedef VkRenderPassInputAttachmentAspectCreateInfo32 VkRenderPassInputAttachmentAspectCreateInfoKHR32;

typedef struct VkRenderPassMultiviewCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t subpassCount;
    PTR32 pViewMasks;
    uint32_t dependencyCount;
    PTR32 pViewOffsets;
    uint32_t correlationMaskCount;
    PTR32 pCorrelationMasks;
} VkRenderPassMultiviewCreateInfo32;
typedef VkRenderPassMultiviewCreateInfo32 VkRenderPassMultiviewCreateInfoKHR32;

typedef struct VkRenderPassSampleLocationsBeginInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t attachmentInitialSampleLocationsCount;
    PTR32 pAttachmentInitialSampleLocations;
    uint32_t postSubpassSampleLocationsCount;
    PTR32 pPostSubpassSampleLocations;
} VkRenderPassSampleLocationsBeginInfoEXT32;

typedef struct VkRenderPassStripeBeginInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t stripeInfoCount;
    PTR32 pStripeInfos;
} VkRenderPassStripeBeginInfoARM32;

typedef struct VkRenderPassStripeSubmitInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t stripeSemaphoreInfoCount;
    PTR32 pStripeSemaphoreInfos;
} VkRenderPassStripeSubmitInfoARM32;

typedef struct VkRenderPassSubpassFeedbackCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pSubpassFeedback;
} VkRenderPassSubpassFeedbackCreateInfoEXT32;

typedef struct VkRenderPassTileShadingCreateInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTileShadingRenderPassFlagsQCOM flags;
    VkExtent2D tileApronSize;
} VkRenderPassTileShadingCreateInfoQCOM32;

typedef struct VkRenderPassTransformBeginInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceTransformFlagBitsKHR transform;
} VkRenderPassTransformBeginInfoQCOM32;

typedef struct VkRenderingAreaInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachmentFormats;
    VkFormat depthAttachmentFormat;
    VkFormat stencilAttachmentFormat;
} VkRenderingAreaInfo32;
typedef VkRenderingAreaInfo32 VkRenderingAreaInfoKHR32;

typedef struct VkRenderingAttachmentLocationInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachmentLocations;
} VkRenderingAttachmentLocationInfo32;
typedef VkRenderingAttachmentLocationInfo32 VkRenderingAttachmentLocationInfoKHR32;

typedef struct VkRenderingEndInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
} VkRenderingEndInfoEXT32;

typedef struct VkRenderingFragmentDensityMapAttachmentInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) imageView;
    VkImageLayout imageLayout;
} VkRenderingFragmentDensityMapAttachmentInfoEXT32;

typedef struct VkRenderingFragmentShadingRateAttachmentInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) imageView;
    VkImageLayout imageLayout;
    VkExtent2D shadingRateAttachmentTexelSize;
} VkRenderingFragmentShadingRateAttachmentInfoKHR32;

typedef struct VkRenderingInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderingFlags flags;
    VkRect2D renderArea;
    uint32_t layerCount;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachments;
    PTR32 pDepthAttachment;
    PTR32 pStencilAttachment;
} VkRenderingInfo32;
typedef VkRenderingInfo32 VkRenderingInfoKHR32;

typedef struct VkRenderingInputAttachmentIndexInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t colorAttachmentCount;
    PTR32 pColorAttachmentInputIndices;
    PTR32 pDepthInputAttachmentIndex;
    PTR32 pStencilInputAttachmentIndex;
} VkRenderingInputAttachmentIndexInfo32;
typedef VkRenderingInputAttachmentIndexInfo32 VkRenderingInputAttachmentIndexInfoKHR32;

typedef struct VkResolveImageInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkImage DECLSPEC_ALIGN(8) srcImage;
    VkImageLayout srcImageLayout;
    VkImage DECLSPEC_ALIGN(8) dstImage;
    VkImageLayout dstImageLayout;
    uint32_t regionCount;
    PTR32 pRegions;
} VkResolveImageInfo232;
typedef VkResolveImageInfo232 VkResolveImageInfo2KHR32;

typedef struct VkSamplerBlockMatchWindowCreateInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D windowExtent;
    VkBlockMatchWindowCompareModeQCOM windowCompareMode;
} VkSamplerBlockMatchWindowCreateInfoQCOM32;

typedef struct VkSamplerBorderColorComponentMappingCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkComponentMapping components;
    VkBool32 srgb;
} VkSamplerBorderColorComponentMappingCreateInfoEXT32;

typedef struct VkSamplerCaptureDescriptorDataInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSampler DECLSPEC_ALIGN(8) sampler;
} VkSamplerCaptureDescriptorDataInfoEXT32;

typedef struct VkSamplerCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSamplerCreateFlags flags;
    VkFilter magFilter;
    VkFilter minFilter;
    VkSamplerMipmapMode mipmapMode;
    VkSamplerAddressMode addressModeU;
    VkSamplerAddressMode addressModeV;
    VkSamplerAddressMode addressModeW;
    float mipLodBias;
    VkBool32 anisotropyEnable;
    float maxAnisotropy;
    VkBool32 compareEnable;
    VkCompareOp compareOp;
    float minLod;
    float maxLod;
    VkBorderColor borderColor;
    VkBool32 unnormalizedCoordinates;
} VkSamplerCreateInfo32;

typedef struct VkSamplerCubicWeightsCreateInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkCubicFilterWeightsQCOM cubicWeights;
} VkSamplerCubicWeightsCreateInfoQCOM32;

typedef struct VkSamplerCustomBorderColorCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkClearColorValue customBorderColor;
    VkFormat format;
} VkSamplerCustomBorderColorCreateInfoEXT32;

typedef struct VkSamplerReductionModeCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSamplerReductionMode reductionMode;
} VkSamplerReductionModeCreateInfo32;
typedef VkSamplerReductionModeCreateInfo32 VkSamplerReductionModeCreateInfoEXT32;

typedef struct VkSamplerYcbcrConversionCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat format;
    VkSamplerYcbcrModelConversion ycbcrModel;
    VkSamplerYcbcrRange ycbcrRange;
    VkComponentMapping components;
    VkChromaLocation xChromaOffset;
    VkChromaLocation yChromaOffset;
    VkFilter chromaFilter;
    VkBool32 forceExplicitReconstruction;
} VkSamplerYcbcrConversionCreateInfo32;
typedef VkSamplerYcbcrConversionCreateInfo32 VkSamplerYcbcrConversionCreateInfoKHR32;

typedef struct VkSamplerYcbcrConversionImageFormatProperties32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t combinedImageSamplerDescriptorCount;
} VkSamplerYcbcrConversionImageFormatProperties32;
typedef VkSamplerYcbcrConversionImageFormatProperties32 VkSamplerYcbcrConversionImageFormatPropertiesKHR32;

typedef struct VkSamplerYcbcrConversionInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSamplerYcbcrConversion DECLSPEC_ALIGN(8) conversion;
} VkSamplerYcbcrConversionInfo32;
typedef VkSamplerYcbcrConversionInfo32 VkSamplerYcbcrConversionInfoKHR32;

typedef struct VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 enableYDegamma;
    VkBool32 enableCbCrDegamma;
} VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM32;

typedef struct VkSemaphoreCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphoreCreateFlags flags;
} VkSemaphoreCreateInfo32;

typedef struct VkSemaphoreGetWin32HandleInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    VkExternalSemaphoreHandleTypeFlagBits handleType;
} VkSemaphoreGetWin32HandleInfoKHR32;

typedef struct VkSemaphoreSignalInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
    uint64_t DECLSPEC_ALIGN(8) value;
} VkSemaphoreSignalInfo32;
typedef VkSemaphoreSignalInfo32 VkSemaphoreSignalInfoKHR32;

typedef struct VkSemaphoreTypeCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphoreType semaphoreType;
    uint64_t DECLSPEC_ALIGN(8) initialValue;
} VkSemaphoreTypeCreateInfo32;
typedef VkSemaphoreTypeCreateInfo32 VkSemaphoreTypeCreateInfoKHR32;

typedef struct VkSemaphoreWaitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSemaphoreWaitFlags flags;
    uint32_t semaphoreCount;
    PTR32 pSemaphores;
    PTR32 pValues;
} VkSemaphoreWaitInfo32;
typedef VkSemaphoreWaitInfo32 VkSemaphoreWaitInfoKHR32;

typedef struct VkSetDescriptorBufferOffsetsInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderStageFlags stageFlags;
    VkPipelineLayout DECLSPEC_ALIGN(8) layout;
    uint32_t firstSet;
    uint32_t setCount;
    PTR32 pBufferIndices;
    PTR32 pOffsets;
} VkSetDescriptorBufferOffsetsInfoEXT32;

typedef struct VkSetLatencyMarkerInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint64_t DECLSPEC_ALIGN(8) presentID;
    VkLatencyMarkerNV marker;
} VkSetLatencyMarkerInfoNV32;

typedef struct VkShaderCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderCreateFlagsEXT flags;
    VkShaderStageFlagBits stage;
    VkShaderStageFlags nextStage;
    VkShaderCodeTypeEXT codeType;
    PTR32 codeSize;
    PTR32 pCode;
    PTR32 pName;
    uint32_t setLayoutCount;
    PTR32 pSetLayouts;
    uint32_t pushConstantRangeCount;
    PTR32 pPushConstantRanges;
    PTR32 pSpecializationInfo;
} VkShaderCreateInfoEXT32;

typedef struct VkShaderModuleCreateInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkShaderModuleCreateFlags flags;
    PTR32 codeSize;
    PTR32 pCode;
} VkShaderModuleCreateInfo32;

typedef struct VkShaderModuleIdentifierEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t identifierSize;
    uint8_t identifier[VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT];
} VkShaderModuleIdentifierEXT32;

typedef struct VkShaderModuleValidationCacheCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkValidationCacheEXT DECLSPEC_ALIGN(8) validationCache;
} VkShaderModuleValidationCacheCreateInfoEXT32;

typedef struct VkSparseImageFormatProperties232
{
    VkStructureType sType;
    PTR32 pNext;
    VkSparseImageFormatProperties properties;
} VkSparseImageFormatProperties232;
typedef VkSparseImageFormatProperties232 VkSparseImageFormatProperties2KHR32;

typedef struct VkSparseImageMemoryRequirements232
{
    VkStructureType sType;
    PTR32 pNext;
    VkSparseImageMemoryRequirements32 DECLSPEC_ALIGN(8) memoryRequirements;
} VkSparseImageMemoryRequirements232;
typedef VkSparseImageMemoryRequirements232 VkSparseImageMemoryRequirements2KHR32;

typedef struct VkSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreCount;
    PTR32 pWaitSemaphores;
    PTR32 pWaitDstStageMask;
    uint32_t commandBufferCount;
    PTR32 pCommandBuffers;
    uint32_t signalSemaphoreCount;
    PTR32 pSignalSemaphores;
} VkSubmitInfo32;

typedef struct VkSubmitInfo232
{
    VkStructureType sType;
    PTR32 pNext;
    VkSubmitFlags flags;
    uint32_t waitSemaphoreInfoCount;
    PTR32 pWaitSemaphoreInfos;
    uint32_t commandBufferInfoCount;
    PTR32 pCommandBufferInfos;
    uint32_t signalSemaphoreInfoCount;
    PTR32 pSignalSemaphoreInfos;
} VkSubmitInfo232;
typedef VkSubmitInfo232 VkSubmitInfo2KHR32;

typedef struct VkSubpassBeginInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSubpassContents contents;
} VkSubpassBeginInfo32;
typedef VkSubpassBeginInfo32 VkSubpassBeginInfoKHR32;

typedef struct VkSubpassDescriptionDepthStencilResolve32
{
    VkStructureType sType;
    PTR32 pNext;
    VkResolveModeFlagBits depthResolveMode;
    VkResolveModeFlagBits stencilResolveMode;
    PTR32 pDepthStencilResolveAttachment;
} VkSubpassDescriptionDepthStencilResolve32;
typedef VkSubpassDescriptionDepthStencilResolve32 VkSubpassDescriptionDepthStencilResolveKHR32;

typedef struct VkSubpassEndInfo32
{
    VkStructureType sType;
    PTR32 pNext;
} VkSubpassEndInfo32;
typedef VkSubpassEndInfo32 VkSubpassEndInfoKHR32;

typedef struct VkSubpassResolvePerformanceQueryEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 optimal;
} VkSubpassResolvePerformanceQueryEXT32;

typedef struct VkSubpassShadingPipelineCreateInfoHUAWEI32
{
    VkStructureType sType;
    PTR32 pNext;
    VkRenderPass DECLSPEC_ALIGN(8) renderPass;
    uint32_t subpass;
} VkSubpassShadingPipelineCreateInfoHUAWEI32;

typedef struct VkSubresourceHostMemcpySize32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkSubresourceHostMemcpySize32;
typedef VkSubresourceHostMemcpySize32 VkSubresourceHostMemcpySizeEXT32;

typedef struct VkSubresourceLayout232
{
    VkStructureType sType;
    PTR32 pNext;
    VkSubresourceLayout32 DECLSPEC_ALIGN(8) subresourceLayout;
} VkSubresourceLayout232;
typedef VkSubresourceLayout232 VkSubresourceLayout2KHR32;
typedef VkSubresourceLayout232 VkSubresourceLayout2EXT32;

typedef struct VkSurfaceCapabilities2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceCapabilitiesKHR surfaceCapabilities;
} VkSurfaceCapabilities2KHR32;

typedef struct VkSurfaceCapabilitiesPresentBarrierNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentBarrierSupported;
} VkSurfaceCapabilitiesPresentBarrierNV32;

typedef struct VkSurfaceCapabilitiesPresentId2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentId2Supported;
} VkSurfaceCapabilitiesPresentId2KHR32;

typedef struct VkSurfaceCapabilitiesPresentWait2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentWait2Supported;
} VkSurfaceCapabilitiesPresentWait2KHR32;

typedef struct VkSurfaceFormat2KHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSurfaceFormatKHR surfaceFormat;
} VkSurfaceFormat2KHR32;

typedef struct VkSurfacePresentModeCompatibilityKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t presentModeCount;
    PTR32 pPresentModes;
} VkSurfacePresentModeCompatibilityKHR32;
typedef VkSurfacePresentModeCompatibilityKHR32 VkSurfacePresentModeCompatibilityEXT32;

typedef struct VkSurfacePresentModeKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPresentModeKHR presentMode;
} VkSurfacePresentModeKHR32;
typedef VkSurfacePresentModeKHR32 VkSurfacePresentModeEXT32;

typedef struct VkSurfacePresentScalingCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPresentScalingFlagsKHR supportedPresentScaling;
    VkPresentGravityFlagsKHR supportedPresentGravityX;
    VkPresentGravityFlagsKHR supportedPresentGravityY;
    VkExtent2D minScaledImageExtent;
    VkExtent2D maxScaledImageExtent;
} VkSurfacePresentScalingCapabilitiesKHR32;
typedef VkSurfacePresentScalingCapabilitiesKHR32 VkSurfacePresentScalingCapabilitiesEXT32;

typedef struct VkSwapchainCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkSwapchainCreateFlagsKHR flags;
    VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
    uint32_t minImageCount;
    VkFormat imageFormat;
    VkColorSpaceKHR imageColorSpace;
    VkExtent2D imageExtent;
    uint32_t imageArrayLayers;
    VkImageUsageFlags imageUsage;
    VkSharingMode imageSharingMode;
    uint32_t queueFamilyIndexCount;
    PTR32 pQueueFamilyIndices;
    VkSurfaceTransformFlagBitsKHR preTransform;
    VkCompositeAlphaFlagBitsKHR compositeAlpha;
    VkPresentModeKHR presentMode;
    VkBool32 clipped;
    VkSwapchainKHR DECLSPEC_ALIGN(8) oldSwapchain;
} VkSwapchainCreateInfoKHR32;

typedef struct VkSwapchainLatencyCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 latencyModeEnable;
} VkSwapchainLatencyCreateInfoNV32;

typedef struct VkSwapchainPresentBarrierCreateInfoNV32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 presentBarrierEnable;
} VkSwapchainPresentBarrierCreateInfoNV32;

typedef struct VkSwapchainPresentFenceInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pFences;
} VkSwapchainPresentFenceInfoKHR32;
typedef VkSwapchainPresentFenceInfoKHR32 VkSwapchainPresentFenceInfoEXT32;

typedef struct VkSwapchainPresentModeInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t swapchainCount;
    PTR32 pPresentModes;
} VkSwapchainPresentModeInfoKHR32;
typedef VkSwapchainPresentModeInfoKHR32 VkSwapchainPresentModeInfoEXT32;

typedef struct VkSwapchainPresentModesCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t presentModeCount;
    PTR32 pPresentModes;
} VkSwapchainPresentModesCreateInfoKHR32;
typedef VkSwapchainPresentModesCreateInfoKHR32 VkSwapchainPresentModesCreateInfoEXT32;

typedef struct VkSwapchainPresentScalingCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkPresentScalingFlagsKHR scalingBehavior;
    VkPresentGravityFlagsKHR presentGravityX;
    VkPresentGravityFlagsKHR presentGravityY;
} VkSwapchainPresentScalingCreateInfoKHR32;
typedef VkSwapchainPresentScalingCreateInfoKHR32 VkSwapchainPresentScalingCreateInfoEXT32;

typedef struct VkTensorCaptureDescriptorDataInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorARM DECLSPEC_ALIGN(8) tensor;
} VkTensorCaptureDescriptorDataInfoARM32;

typedef struct VkTensorDependencyInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t tensorMemoryBarrierCount;
    PTR32 pTensorMemoryBarriers;
} VkTensorDependencyInfoARM32;

typedef struct VkTensorFormatPropertiesARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormatFeatureFlags2 DECLSPEC_ALIGN(8) optimalTilingTensorFeatures;
    VkFormatFeatureFlags2 DECLSPEC_ALIGN(8) linearTilingTensorFeatures;
} VkTensorFormatPropertiesARM32;

typedef struct VkTensorMemoryRequirementsInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorARM DECLSPEC_ALIGN(8) tensor;
} VkTensorMemoryRequirementsInfoARM32;

typedef struct VkTensorViewCaptureDescriptorDataInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorViewARM DECLSPEC_ALIGN(8) tensorView;
} VkTensorViewCaptureDescriptorDataInfoARM32;

typedef struct VkTensorViewCreateInfoARM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkTensorViewCreateFlagsARM DECLSPEC_ALIGN(8) flags;
    VkTensorARM DECLSPEC_ALIGN(8) tensor;
    VkFormat format;
} VkTensorViewCreateInfoARM32;

typedef struct VkTextureLODGatherFormatPropertiesAMD32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 supportsTextureGatherLODBiasAMD;
} VkTextureLODGatherFormatPropertiesAMD32;

typedef struct VkTileMemoryBindInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
} VkTileMemoryBindInfoQCOM32;

typedef struct VkTileMemoryRequirementsQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
    VkDeviceSize DECLSPEC_ALIGN(8) alignment;
} VkTileMemoryRequirementsQCOM32;

typedef struct VkTileMemorySizeInfoQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkDeviceSize DECLSPEC_ALIGN(8) size;
} VkTileMemorySizeInfoQCOM32;

typedef struct VkTilePropertiesQCOM32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent3D tileSize;
    VkExtent2D apronSize;
    VkOffset2D origin;
} VkTilePropertiesQCOM32;

typedef struct VkTimelineSemaphoreSubmitInfo32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t waitSemaphoreValueCount;
    PTR32 pWaitSemaphoreValues;
    uint32_t signalSemaphoreValueCount;
    PTR32 pSignalSemaphoreValues;
} VkTimelineSemaphoreSubmitInfo32;
typedef VkTimelineSemaphoreSubmitInfo32 VkTimelineSemaphoreSubmitInfoKHR32;

typedef struct VkValidationCacheCreateInfoEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    VkValidationCacheCreateFlagsEXT flags;
    PTR32 initialDataSize;
    PTR32 pInitialData;
} VkValidationCacheCreateInfoEXT32;

typedef struct VkValidationFeaturesEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t enabledValidationFeatureCount;
    PTR32 pEnabledValidationFeatures;
    uint32_t disabledValidationFeatureCount;
    PTR32 pDisabledValidationFeatures;
} VkValidationFeaturesEXT32;

typedef struct VkValidationFlagsEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t disabledValidationCheckCount;
    PTR32 pDisabledValidationChecks;
} VkValidationFlagsEXT32;

typedef struct VkVertexInputAttributeDescription2EXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t location;
    uint32_t binding;
    VkFormat format;
    uint32_t offset;
} VkVertexInputAttributeDescription2EXT32;

typedef struct VkVertexInputBindingDescription2EXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t binding;
    uint32_t stride;
    VkVertexInputRate inputRate;
    uint32_t divisor;
} VkVertexInputBindingDescription2EXT32;

typedef struct VkVideoBeginCodingInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoBeginCodingFlagsKHR flags;
    VkVideoSessionKHR DECLSPEC_ALIGN(8) videoSession;
    VkVideoSessionParametersKHR DECLSPEC_ALIGN(8) videoSessionParameters;
    uint32_t referenceSlotCount;
    PTR32 pReferenceSlots;
} VkVideoBeginCodingInfoKHR32;

typedef struct VkVideoCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoCapabilityFlagsKHR flags;
    VkDeviceSize DECLSPEC_ALIGN(8) minBitstreamBufferOffsetAlignment;
    VkDeviceSize DECLSPEC_ALIGN(8) minBitstreamBufferSizeAlignment;
    VkExtent2D pictureAccessGranularity;
    VkExtent2D minCodedExtent;
    VkExtent2D maxCodedExtent;
    uint32_t maxDpbSlots;
    uint32_t maxActiveReferencePictures;
    VkExtensionProperties stdHeaderVersion;
} VkVideoCapabilitiesKHR32;

typedef struct VkVideoCodingControlInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoCodingControlFlagsKHR flags;
} VkVideoCodingControlInfoKHR32;

typedef struct VkVideoDecodeAV1CapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    StdVideoAV1Level maxLevel;
} VkVideoDecodeAV1CapabilitiesKHR32;

typedef struct VkVideoDecodeAV1DpbSlotInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pStdReferenceInfo;
} VkVideoDecodeAV1DpbSlotInfoKHR32;

typedef struct VkVideoDecodeAV1PictureInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pStdPictureInfo;
    int32_t referenceNameSlotIndices[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR];
    uint32_t frameHeaderOffset;
    uint32_t tileCount;
    PTR32 pTileOffsets;
    PTR32 pTileSizes;
} VkVideoDecodeAV1PictureInfoKHR32;

typedef struct VkVideoDecodeAV1ProfileInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    StdVideoAV1Profile stdProfile;
    VkBool32 filmGrainSupport;
} VkVideoDecodeAV1ProfileInfoKHR32;

typedef struct VkVideoDecodeAV1SessionParametersCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pStdSequenceHeader;
} VkVideoDecodeAV1SessionParametersCreateInfoKHR32;

typedef struct VkVideoDecodeCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoDecodeCapabilityFlagsKHR flags;
} VkVideoDecodeCapabilitiesKHR32;

typedef struct VkVideoDecodeH264CapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    StdVideoH264LevelIdc maxLevelIdc;
    VkOffset2D fieldOffsetGranularity;
} VkVideoDecodeH264CapabilitiesKHR32;

typedef struct VkVideoDecodeH264DpbSlotInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pStdReferenceInfo;
} VkVideoDecodeH264DpbSlotInfoKHR32;

typedef struct VkVideoDecodeH264PictureInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pStdPictureInfo;
    uint32_t sliceCount;
    PTR32 pSliceOffsets;
} VkVideoDecodeH264PictureInfoKHR32;

typedef struct VkVideoDecodeH264ProfileInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    StdVideoH264ProfileIdc stdProfileIdc;
    VkVideoDecodeH264PictureLayoutFlagBitsKHR pictureLayout;
} VkVideoDecodeH264ProfileInfoKHR32;

typedef struct VkVideoDecodeH264SessionParametersCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxStdSPSCount;
    uint32_t maxStdPPSCount;
    PTR32 pParametersAddInfo;
} VkVideoDecodeH264SessionParametersCreateInfoKHR32;

typedef struct VkVideoDecodeInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoDecodeFlagsKHR flags;
    VkBuffer DECLSPEC_ALIGN(8) srcBuffer;
    VkDeviceSize DECLSPEC_ALIGN(8) srcBufferOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) srcBufferRange;
    VkVideoPictureResourceInfoKHR32 DECLSPEC_ALIGN(8) dstPictureResource;
    PTR32 pSetupReferenceSlot;
    uint32_t referenceSlotCount;
    PTR32 pReferenceSlots;
} VkVideoDecodeInfoKHR32;

typedef struct VkVideoDecodeUsageInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoDecodeUsageFlagsKHR videoUsageHints;
} VkVideoDecodeUsageInfoKHR32;

typedef struct VkVideoDecodeVP9CapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    StdVideoVP9Level maxLevel;
} VkVideoDecodeVP9CapabilitiesKHR32;

typedef struct VkVideoDecodeVP9PictureInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pStdPictureInfo;
    int32_t referenceNameSlotIndices[VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR];
    uint32_t uncompressedHeaderOffset;
    uint32_t compressedHeaderOffset;
    uint32_t tilesOffset;
} VkVideoDecodeVP9PictureInfoKHR32;

typedef struct VkVideoDecodeVP9ProfileInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    StdVideoVP9Profile stdProfile;
} VkVideoDecodeVP9ProfileInfoKHR32;

typedef struct VkVideoEncodeAV1CapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeAV1CapabilityFlagsKHR flags;
    StdVideoAV1Level maxLevel;
    VkExtent2D codedPictureAlignment;
    VkExtent2D maxTiles;
    VkExtent2D minTileSize;
    VkExtent2D maxTileSize;
    VkVideoEncodeAV1SuperblockSizeFlagsKHR superblockSizes;
    uint32_t maxSingleReferenceCount;
    uint32_t singleReferenceNameMask;
    uint32_t maxUnidirectionalCompoundReferenceCount;
    uint32_t maxUnidirectionalCompoundGroup1ReferenceCount;
    uint32_t unidirectionalCompoundReferenceNameMask;
    uint32_t maxBidirectionalCompoundReferenceCount;
    uint32_t maxBidirectionalCompoundGroup1ReferenceCount;
    uint32_t maxBidirectionalCompoundGroup2ReferenceCount;
    uint32_t bidirectionalCompoundReferenceNameMask;
    uint32_t maxTemporalLayerCount;
    uint32_t maxSpatialLayerCount;
    uint32_t maxOperatingPoints;
    uint32_t minQIndex;
    uint32_t maxQIndex;
    VkBool32 prefersGopRemainingFrames;
    VkBool32 requiresGopRemainingFrames;
    VkVideoEncodeAV1StdFlagsKHR stdSyntaxFlags;
} VkVideoEncodeAV1CapabilitiesKHR32;

typedef struct VkVideoEncodeAV1DpbSlotInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pStdReferenceInfo;
} VkVideoEncodeAV1DpbSlotInfoKHR32;

typedef struct VkVideoEncodeAV1GopRemainingFrameInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 useGopRemainingFrames;
    uint32_t gopRemainingIntra;
    uint32_t gopRemainingPredictive;
    uint32_t gopRemainingBipredictive;
} VkVideoEncodeAV1GopRemainingFrameInfoKHR32;

typedef struct VkVideoEncodeAV1PictureInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeAV1PredictionModeKHR predictionMode;
    VkVideoEncodeAV1RateControlGroupKHR rateControlGroup;
    uint32_t constantQIndex;
    PTR32 pStdPictureInfo;
    int32_t referenceNameSlotIndices[VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR];
    VkBool32 primaryReferenceCdfOnly;
    VkBool32 generateObuExtensionHeader;
} VkVideoEncodeAV1PictureInfoKHR32;

typedef struct VkVideoEncodeAV1ProfileInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    StdVideoAV1Profile stdProfile;
} VkVideoEncodeAV1ProfileInfoKHR32;

typedef struct VkVideoEncodeAV1QualityLevelPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeAV1RateControlFlagsKHR preferredRateControlFlags;
    uint32_t preferredGopFrameCount;
    uint32_t preferredKeyFramePeriod;
    uint32_t preferredConsecutiveBipredictiveFrameCount;
    uint32_t preferredTemporalLayerCount;
    VkVideoEncodeAV1QIndexKHR preferredConstantQIndex;
    uint32_t preferredMaxSingleReferenceCount;
    uint32_t preferredSingleReferenceNameMask;
    uint32_t preferredMaxUnidirectionalCompoundReferenceCount;
    uint32_t preferredMaxUnidirectionalCompoundGroup1ReferenceCount;
    uint32_t preferredUnidirectionalCompoundReferenceNameMask;
    uint32_t preferredMaxBidirectionalCompoundReferenceCount;
    uint32_t preferredMaxBidirectionalCompoundGroup1ReferenceCount;
    uint32_t preferredMaxBidirectionalCompoundGroup2ReferenceCount;
    uint32_t preferredBidirectionalCompoundReferenceNameMask;
} VkVideoEncodeAV1QualityLevelPropertiesKHR32;

typedef struct VkVideoEncodeAV1QuantizationMapCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    int32_t minQIndexDelta;
    int32_t maxQIndexDelta;
} VkVideoEncodeAV1QuantizationMapCapabilitiesKHR32;

typedef struct VkVideoEncodeAV1RateControlInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeAV1RateControlFlagsKHR flags;
    uint32_t gopFrameCount;
    uint32_t keyFramePeriod;
    uint32_t consecutiveBipredictiveFrameCount;
    uint32_t temporalLayerCount;
} VkVideoEncodeAV1RateControlInfoKHR32;

typedef struct VkVideoEncodeAV1RateControlLayerInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 useMinQIndex;
    VkVideoEncodeAV1QIndexKHR minQIndex;
    VkBool32 useMaxQIndex;
    VkVideoEncodeAV1QIndexKHR maxQIndex;
    VkBool32 useMaxFrameSize;
    VkVideoEncodeAV1FrameSizeKHR maxFrameSize;
} VkVideoEncodeAV1RateControlLayerInfoKHR32;

typedef struct VkVideoEncodeAV1SessionCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 useMaxLevel;
    StdVideoAV1Level maxLevel;
} VkVideoEncodeAV1SessionCreateInfoKHR32;

typedef struct VkVideoEncodeAV1SessionParametersCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pStdSequenceHeader;
    PTR32 pStdDecoderModelInfo;
    uint32_t stdOperatingPointCount;
    PTR32 pStdOperatingPoints;
} VkVideoEncodeAV1SessionParametersCreateInfoKHR32;

typedef struct VkVideoEncodeCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeCapabilityFlagsKHR flags;
    VkVideoEncodeRateControlModeFlagsKHR rateControlModes;
    uint32_t maxRateControlLayers;
    uint64_t DECLSPEC_ALIGN(8) maxBitrate;
    uint32_t maxQualityLevels;
    VkExtent2D encodeInputPictureGranularity;
    VkVideoEncodeFeedbackFlagsKHR supportedEncodeFeedbackFlags;
} VkVideoEncodeCapabilitiesKHR32;

typedef struct VkVideoEncodeH264CapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeH264CapabilityFlagsKHR flags;
    StdVideoH264LevelIdc maxLevelIdc;
    uint32_t maxSliceCount;
    uint32_t maxPPictureL0ReferenceCount;
    uint32_t maxBPictureL0ReferenceCount;
    uint32_t maxL1ReferenceCount;
    uint32_t maxTemporalLayerCount;
    VkBool32 expectDyadicTemporalLayerPattern;
    int32_t minQp;
    int32_t maxQp;
    VkBool32 prefersGopRemainingFrames;
    VkBool32 requiresGopRemainingFrames;
    VkVideoEncodeH264StdFlagsKHR stdSyntaxFlags;
} VkVideoEncodeH264CapabilitiesKHR32;

typedef struct VkVideoEncodeH264DpbSlotInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    PTR32 pStdReferenceInfo;
} VkVideoEncodeH264DpbSlotInfoKHR32;

typedef struct VkVideoEncodeH264GopRemainingFrameInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 useGopRemainingFrames;
    uint32_t gopRemainingI;
    uint32_t gopRemainingP;
    uint32_t gopRemainingB;
} VkVideoEncodeH264GopRemainingFrameInfoKHR32;

typedef struct VkVideoEncodeH264PictureInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t naluSliceEntryCount;
    PTR32 pNaluSliceEntries;
    PTR32 pStdPictureInfo;
    VkBool32 generatePrefixNalu;
} VkVideoEncodeH264PictureInfoKHR32;

typedef struct VkVideoEncodeH264ProfileInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    StdVideoH264ProfileIdc stdProfileIdc;
} VkVideoEncodeH264ProfileInfoKHR32;

typedef struct VkVideoEncodeH264QualityLevelPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeH264RateControlFlagsKHR preferredRateControlFlags;
    uint32_t preferredGopFrameCount;
    uint32_t preferredIdrPeriod;
    uint32_t preferredConsecutiveBFrameCount;
    uint32_t preferredTemporalLayerCount;
    VkVideoEncodeH264QpKHR preferredConstantQp;
    uint32_t preferredMaxL0ReferenceCount;
    uint32_t preferredMaxL1ReferenceCount;
    VkBool32 preferredStdEntropyCodingModeFlag;
} VkVideoEncodeH264QualityLevelPropertiesKHR32;

typedef struct VkVideoEncodeH264QuantizationMapCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    int32_t minQpDelta;
    int32_t maxQpDelta;
} VkVideoEncodeH264QuantizationMapCapabilitiesKHR32;

typedef struct VkVideoEncodeH264RateControlInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeH264RateControlFlagsKHR flags;
    uint32_t gopFrameCount;
    uint32_t idrPeriod;
    uint32_t consecutiveBFrameCount;
    uint32_t temporalLayerCount;
} VkVideoEncodeH264RateControlInfoKHR32;

typedef struct VkVideoEncodeH264RateControlLayerInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 useMinQp;
    VkVideoEncodeH264QpKHR minQp;
    VkBool32 useMaxQp;
    VkVideoEncodeH264QpKHR maxQp;
    VkBool32 useMaxFrameSize;
    VkVideoEncodeH264FrameSizeKHR maxFrameSize;
} VkVideoEncodeH264RateControlLayerInfoKHR32;

typedef struct VkVideoEncodeH264SessionCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 useMaxLevelIdc;
    StdVideoH264LevelIdc maxLevelIdc;
} VkVideoEncodeH264SessionCreateInfoKHR32;

typedef struct VkVideoEncodeH264SessionParametersCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t maxStdSPSCount;
    uint32_t maxStdPPSCount;
    PTR32 pParametersAddInfo;
} VkVideoEncodeH264SessionParametersCreateInfoKHR32;

typedef struct VkVideoEncodeH264SessionParametersFeedbackInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 hasStdSPSOverrides;
    VkBool32 hasStdPPSOverrides;
} VkVideoEncodeH264SessionParametersFeedbackInfoKHR32;

typedef struct VkVideoEncodeH264SessionParametersGetInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 writeStdSPS;
    VkBool32 writeStdPPS;
    uint32_t stdSPSId;
    uint32_t stdPPSId;
} VkVideoEncodeH264SessionParametersGetInfoKHR32;

typedef struct VkVideoEncodeH265QuantizationMapCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    int32_t minQpDelta;
    int32_t maxQpDelta;
} VkVideoEncodeH265QuantizationMapCapabilitiesKHR32;

typedef struct VkVideoEncodeInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeFlagsKHR flags;
    VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
    VkDeviceSize DECLSPEC_ALIGN(8) dstBufferOffset;
    VkDeviceSize DECLSPEC_ALIGN(8) dstBufferRange;
    VkVideoPictureResourceInfoKHR32 DECLSPEC_ALIGN(8) srcPictureResource;
    PTR32 pSetupReferenceSlot;
    uint32_t referenceSlotCount;
    PTR32 pReferenceSlots;
    uint32_t precedingExternallyEncodedBytes;
} VkVideoEncodeInfoKHR32;

typedef struct VkVideoEncodeIntraRefreshCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeIntraRefreshModeFlagsKHR intraRefreshModes;
    uint32_t maxIntraRefreshCycleDuration;
    uint32_t maxIntraRefreshActiveReferencePictures;
    VkBool32 partitionIndependentIntraRefreshRegions;
    VkBool32 nonRectangularIntraRefreshRegions;
} VkVideoEncodeIntraRefreshCapabilitiesKHR32;

typedef struct VkVideoEncodeIntraRefreshInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t intraRefreshCycleDuration;
    uint32_t intraRefreshIndex;
} VkVideoEncodeIntraRefreshInfoKHR32;

typedef struct VkVideoEncodeQualityLevelInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t qualityLevel;
} VkVideoEncodeQualityLevelInfoKHR32;

typedef struct VkVideoEncodeQualityLevelPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeRateControlModeFlagBitsKHR preferredRateControlMode;
    uint32_t preferredRateControlLayerCount;
} VkVideoEncodeQualityLevelPropertiesKHR32;

typedef struct VkVideoEncodeQuantizationMapCapabilitiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D maxQuantizationMapExtent;
} VkVideoEncodeQuantizationMapCapabilitiesKHR32;

typedef struct VkVideoEncodeQuantizationMapInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkImageView DECLSPEC_ALIGN(8) quantizationMap;
    VkExtent2D quantizationMapExtent;
} VkVideoEncodeQuantizationMapInfoKHR32;

typedef struct VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D quantizationMapTexelSize;
} VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR32;

typedef struct VkVideoEncodeRateControlInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeRateControlFlagsKHR flags;
    VkVideoEncodeRateControlModeFlagBitsKHR rateControlMode;
    uint32_t layerCount;
    PTR32 pLayers;
    uint32_t virtualBufferSizeInMs;
    uint32_t initialVirtualBufferSizeInMs;
} VkVideoEncodeRateControlInfoKHR32;

typedef struct VkVideoEncodeSessionIntraRefreshCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeIntraRefreshModeFlagBitsKHR intraRefreshMode;
} VkVideoEncodeSessionIntraRefreshCreateInfoKHR32;

typedef struct VkVideoEncodeSessionParametersFeedbackInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkBool32 hasOverrides;
} VkVideoEncodeSessionParametersFeedbackInfoKHR32;

typedef struct VkVideoEncodeSessionParametersGetInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoSessionParametersKHR DECLSPEC_ALIGN(8) videoSessionParameters;
} VkVideoEncodeSessionParametersGetInfoKHR32;

typedef struct VkVideoEncodeUsageInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeUsageFlagsKHR videoUsageHints;
    VkVideoEncodeContentFlagsKHR videoContentHints;
    VkVideoEncodeTuningModeKHR tuningMode;
} VkVideoEncodeUsageInfoKHR32;

typedef struct VkVideoEndCodingInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEndCodingFlagsKHR flags;
} VkVideoEndCodingInfoKHR32;

typedef struct VkVideoFormatAV1QuantizationMapPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeAV1SuperblockSizeFlagsKHR compatibleSuperblockSizes;
} VkVideoFormatAV1QuantizationMapPropertiesKHR32;

typedef struct VkVideoFormatH265QuantizationMapPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoEncodeH265CtbSizeFlagsKHR compatibleCtbSizes;
} VkVideoFormatH265QuantizationMapPropertiesKHR32;

typedef struct VkVideoFormatPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkFormat format;
    VkComponentMapping componentMapping;
    VkImageCreateFlags imageCreateFlags;
    VkImageType imageType;
    VkImageTiling imageTiling;
    VkImageUsageFlags imageUsageFlags;
} VkVideoFormatPropertiesKHR32;

typedef struct VkVideoFormatQuantizationMapPropertiesKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkExtent2D quantizationMapTexelSize;
} VkVideoFormatQuantizationMapPropertiesKHR32;

typedef struct VkVideoInlineQueryInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkQueryPool DECLSPEC_ALIGN(8) queryPool;
    uint32_t firstQuery;
    uint32_t queryCount;
} VkVideoInlineQueryInfoKHR32;

typedef struct VkVideoProfileListInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t profileCount;
    PTR32 pProfiles;
} VkVideoProfileListInfoKHR32;

typedef struct VkVideoReferenceIntraRefreshInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t dirtyIntraRefreshRegions;
} VkVideoReferenceIntraRefreshInfoKHR32;

typedef struct VkVideoSessionCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t queueFamilyIndex;
    VkVideoSessionCreateFlagsKHR flags;
    PTR32 pVideoProfile;
    VkFormat pictureFormat;
    VkExtent2D maxCodedExtent;
    VkFormat referencePictureFormat;
    uint32_t maxDpbSlots;
    uint32_t maxActiveReferencePictures;
    PTR32 pStdHeaderVersion;
} VkVideoSessionCreateInfoKHR32;

typedef struct VkVideoSessionMemoryRequirementsKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t memoryBindIndex;
    VkMemoryRequirements32 DECLSPEC_ALIGN(8) memoryRequirements;
} VkVideoSessionMemoryRequirementsKHR32;

typedef struct VkVideoSessionParametersCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkVideoSessionParametersCreateFlagsKHR flags;
    VkVideoSessionParametersKHR DECLSPEC_ALIGN(8) videoSessionParametersTemplate;
    VkVideoSessionKHR DECLSPEC_ALIGN(8) videoSession;
} VkVideoSessionParametersCreateInfoKHR32;

typedef struct VkVideoSessionParametersUpdateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t updateSequenceCount;
} VkVideoSessionParametersUpdateInfoKHR32;

typedef struct VkWin32KeyedMutexAcquireReleaseInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t acquireCount;
    PTR32 pAcquireSyncs;
    PTR32 pAcquireKeys;
    PTR32 pAcquireTimeouts;
    uint32_t releaseCount;
    PTR32 pReleaseSyncs;
    PTR32 pReleaseKeys;
} VkWin32KeyedMutexAcquireReleaseInfoKHR32;

typedef struct VkWin32SurfaceCreateInfoKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    VkWin32SurfaceCreateFlagsKHR flags;
    PTR32 hinstance;
    PTR32 hwnd;
} VkWin32SurfaceCreateInfoKHR32;

typedef struct VkWriteDescriptorSetAccelerationStructureKHR32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t accelerationStructureCount;
    PTR32 pAccelerationStructures;
} VkWriteDescriptorSetAccelerationStructureKHR32;

typedef struct VkWriteDescriptorSetAccelerationStructureNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t accelerationStructureCount;
    PTR32 pAccelerationStructures;
} VkWriteDescriptorSetAccelerationStructureNV32;

typedef struct VkWriteDescriptorSetInlineUniformBlock32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t dataSize;
    PTR32 pData;
} VkWriteDescriptorSetInlineUniformBlock32;
typedef VkWriteDescriptorSetInlineUniformBlock32 VkWriteDescriptorSetInlineUniformBlockEXT32;

typedef struct VkWriteDescriptorSetPartitionedAccelerationStructureNV32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t accelerationStructureCount;
    PTR32 pAccelerationStructures;
} VkWriteDescriptorSetPartitionedAccelerationStructureNV32;

typedef struct VkWriteDescriptorSetTensorARM32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t tensorViewCount;
    PTR32 pTensorViews;
} VkWriteDescriptorSetTensorARM32;

typedef struct VkWriteIndirectExecutionSetPipelineEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t index;
    VkPipeline DECLSPEC_ALIGN(8) pipeline;
} VkWriteIndirectExecutionSetPipelineEXT32;

typedef struct VkWriteIndirectExecutionSetShaderEXT32
{
    VkStructureType sType;
    PTR32 pNext;
    uint32_t index;
    VkShaderEXT DECLSPEC_ALIGN(8) shader;
} VkWriteIndirectExecutionSetShaderEXT32;

static uint64_t wine_vk_unwrap_handle(uint32_t type, uint64_t handle)
{
    switch(type)
    {
    case VK_OBJECT_TYPE_COMMAND_BUFFER:
        return (uint64_t) (uintptr_t) vulkan_command_buffer_from_handle(((VkCommandBuffer) (uintptr_t) handle))->host.command_buffer;
    case VK_OBJECT_TYPE_COMMAND_POOL:
        return (uint64_t) wine_cmd_pool_from_handle(handle)->host.command_pool;
    case VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT:
        return (uint64_t) wine_debug_report_callback_from_handle(handle)->host.debug_callback;
    case VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT:
        return (uint64_t) wine_debug_utils_messenger_from_handle(handle)->host.debug_messenger;
    case VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR:
        return (uint64_t) wine_deferred_operation_from_handle(handle)->host.deferred_operation;
    case VK_OBJECT_TYPE_DEVICE:
        return (uint64_t) (uintptr_t) vulkan_device_from_handle(((VkDevice) (uintptr_t) handle))->host.device;
    case VK_OBJECT_TYPE_DEVICE_MEMORY:
        return (uint64_t) vulkan_device_memory_from_handle(handle)->host.device_memory;
    case VK_OBJECT_TYPE_FENCE:
        return (uint64_t) vulkan_fence_from_handle(handle)->host.fence;
    case VK_OBJECT_TYPE_INSTANCE:
        return (uint64_t) (uintptr_t) vulkan_instance_from_handle(((VkInstance) (uintptr_t) handle))->host.instance;
    case VK_OBJECT_TYPE_PHYSICAL_DEVICE:
        return (uint64_t) (uintptr_t) vulkan_physical_device_from_handle(((VkPhysicalDevice) (uintptr_t) handle))->host.physical_device;
    case VK_OBJECT_TYPE_QUEUE:
        return (uint64_t) (uintptr_t) vulkan_queue_from_handle(((VkQueue) (uintptr_t) handle))->host.queue;
    case VK_OBJECT_TYPE_SEMAPHORE:
        return (uint64_t) vulkan_semaphore_from_handle(handle)->host.semaphore;
    case VK_OBJECT_TYPE_SURFACE_KHR:
        return (uint64_t) vulkan_surface_from_handle(handle)->host.surface;
    case VK_OBJECT_TYPE_SWAPCHAIN_KHR:
        return (uint64_t) vulkan_swapchain_from_handle(handle)->host.swapchain;
    default:
       return handle;
    }
}

static void convert_VkAcquireNextImageInfoKHR_win32_to_unwrapped_host(const VkAcquireNextImageInfoKHR32 *in, VkAcquireNextImageInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->swapchain = in->swapchain;
    out->timeout = in->timeout;
    out->semaphore = in->semaphore;
    out->fence = in->fence;
    out->deviceMask = in->deviceMask;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPerformanceConfigurationAcquireInfoINTEL_win32_to_host(const VkPerformanceConfigurationAcquireInfoINTEL32 *in, VkPerformanceConfigurationAcquireInfoINTEL *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkAcquireProfilingLockInfoKHR_win32_to_host(const VkAcquireProfilingLockInfoKHR32 *in, VkAcquireProfilingLockInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->timeout = in->timeout;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCommandBufferAllocateInfo_win32_to_unwrapped_host(const VkCommandBufferAllocateInfo32 *in, VkCommandBufferAllocateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->commandPool = in->commandPool;
    out->level = in->level;
    out->commandBufferCount = in->commandBufferCount;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkCommandBuffer *convert_VkCommandBuffer_array_win32_to_unwrapped_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkCommandBuffer *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = UlongToPtr(in[i]);
    }

    return out;
}

static void convert_VkDescriptorSetAllocateInfo_win32_to_host(struct conversion_context *ctx, const VkDescriptorSetAllocateInfo32 *in, VkDescriptorSetAllocateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->descriptorPool = in->descriptorPool;
    out->descriptorSetCount = in->descriptorSetCount;
    out->pSetLayouts = UlongToPtr(in->pSetLayouts);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {
            VkDescriptorSetVariableDescriptorCountAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDescriptorSetVariableDescriptorCountAllocateInfo32 *in_ext = (const VkDescriptorSetVariableDescriptorCountAllocateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->descriptorSetCount = in_ext->descriptorSetCount;
            out_ext->pDescriptorCounts = UlongToPtr(in_ext->pDescriptorCounts);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

#ifdef _WIN64
static void convert_VkMemoryAllocateInfo_win64_to_host(struct conversion_context *ctx, const VkMemoryAllocateInfo *in, VkMemoryAllocateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->allocationSize = in->allocationSize;
    out->memoryTypeIndex = in->memoryTypeIndex;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            VkDedicatedAllocationMemoryAllocateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationMemoryAllocateInfoNV *in_ext = (const VkDedicatedAllocationMemoryAllocateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->image = in_ext->image;
            out_ext->buffer = in_ext->buffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            VkExportMemoryAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportMemoryAllocateInfo *in_ext = (const VkExportMemoryAllocateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            VkExportMemoryWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportMemoryWin32HandleInfoKHR *in_ext = (const VkExportMemoryWin32HandleInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pAttributes = in_ext->pAttributes;
            out_ext->dwAccess = in_ext->dwAccess;
            out_ext->name = in_ext->name;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            VkImportMemoryHostPointerInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImportMemoryHostPointerInfoEXT *in_ext = (const VkImportMemoryHostPointerInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_ext->pHostPointer = in_ext->pHostPointer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            VkImportMemoryWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImportMemoryWin32HandleInfoKHR *in_ext = (const VkImportMemoryWin32HandleInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_ext->handle = in_ext->handle;
            out_ext->name = in_ext->name;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            VkMemoryAllocateFlagsInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryAllocateFlagsInfo *in_ext = (const VkMemoryAllocateFlagsInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->deviceMask = in_ext->deviceMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            VkMemoryDedicatedAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryDedicatedAllocateInfo *in_ext = (const VkMemoryDedicatedAllocateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->image = in_ext->image;
            out_ext->buffer = in_ext->buffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM:
        {
            VkMemoryDedicatedAllocateInfoTensorARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryDedicatedAllocateInfoTensorARM *in_ext = (const VkMemoryDedicatedAllocateInfoTensorARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM;
            out_ext->pNext = NULL;
            out_ext->tensor = in_ext->tensor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            VkMemoryOpaqueCaptureAddressAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryOpaqueCaptureAddressAllocateInfo *in_ext = (const VkMemoryOpaqueCaptureAddressAllocateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureAddress = in_ext->opaqueCaptureAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            VkMemoryPriorityAllocateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryPriorityAllocateInfoEXT *in_ext = (const VkMemoryPriorityAllocateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->priority = in_ext->priority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

static void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_context *ctx, const VkMemoryAllocateInfo32 *in, VkMemoryAllocateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->allocationSize = in->allocationSize;
    out->memoryTypeIndex = in->memoryTypeIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {
            VkDedicatedAllocationMemoryAllocateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationMemoryAllocateInfoNV32 *in_ext = (const VkDedicatedAllocationMemoryAllocateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->image = in_ext->image;
            out_ext->buffer = in_ext->buffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {
            VkExportMemoryAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportMemoryAllocateInfo32 *in_ext = (const VkExportMemoryAllocateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            VkExportMemoryWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportMemoryWin32HandleInfoKHR32 *in_ext = (const VkExportMemoryWin32HandleInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
            out_ext->dwAccess = in_ext->dwAccess;
            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {
            VkImportMemoryHostPointerInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImportMemoryHostPointerInfoEXT32 *in_ext = (const VkImportMemoryHostPointerInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_ext->pHostPointer = UlongToPtr(in_ext->pHostPointer);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {
            VkImportMemoryWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImportMemoryWin32HandleInfoKHR32 *in_ext = (const VkImportMemoryWin32HandleInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_ext->handle = (HANDLE)UlongToPtr(in_ext->handle);
            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {
            VkMemoryAllocateFlagsInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryAllocateFlagsInfo32 *in_ext = (const VkMemoryAllocateFlagsInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->deviceMask = in_ext->deviceMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {
            VkMemoryDedicatedAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryDedicatedAllocateInfo32 *in_ext = (const VkMemoryDedicatedAllocateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->image = in_ext->image;
            out_ext->buffer = in_ext->buffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM:
        {
            VkMemoryDedicatedAllocateInfoTensorARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryDedicatedAllocateInfoTensorARM32 *in_ext = (const VkMemoryDedicatedAllocateInfoTensorARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM;
            out_ext->pNext = NULL;
            out_ext->tensor = in_ext->tensor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {
            VkMemoryOpaqueCaptureAddressAllocateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryOpaqueCaptureAddressAllocateInfo32 *in_ext = (const VkMemoryOpaqueCaptureAddressAllocateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureAddress = in_ext->opaqueCaptureAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {
            VkMemoryPriorityAllocateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryPriorityAllocateInfoEXT32 *in_ext = (const VkMemoryPriorityAllocateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->priority = in_ext->priority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkAntiLagPresentationInfoAMD_win32_to_host(const VkAntiLagPresentationInfoAMD32 *in, VkAntiLagPresentationInfoAMD *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->stage = in->stage;
    out->frameIndex = in->frameIndex;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkAntiLagPresentationInfoAMD *convert_VkAntiLagPresentationInfoAMD_array_win32_to_host(struct conversion_context *ctx, const VkAntiLagPresentationInfoAMD32 *in, uint32_t count)
{
    VkAntiLagPresentationInfoAMD *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAntiLagPresentationInfoAMD_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkAntiLagDataAMD_win32_to_host(struct conversion_context *ctx, const VkAntiLagDataAMD32 *in, VkAntiLagDataAMD *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->mode = in->mode;
    out->maxFPS = in->maxFPS;
    out->pPresentationInfo = convert_VkAntiLagPresentationInfoAMD_array_win32_to_host(ctx, (const VkAntiLagPresentationInfoAMD32 *)UlongToPtr(in->pPresentationInfo), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkCommandBufferInheritanceInfo_win64_to_host(struct conversion_context *ctx, const VkCommandBufferInheritanceInfo *in, VkCommandBufferInheritanceInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->renderPass = in->renderPass;
    out->subpass = in->subpass;
    out->framebuffer = in->framebuffer;
    out->occlusionQueryEnable = in->occlusionQueryEnable;
    out->queryFlags = in->queryFlags;
    out->pipelineStatistics = in->pipelineStatistics;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
            VkAttachmentSampleCountInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentSampleCountInfoAMD *in_ext = (const VkAttachmentSampleCountInfoAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentSamples = in_ext->pColorAttachmentSamples;
            out_ext->depthStencilAttachmentSamples = in_ext->depthStencilAttachmentSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            VkCommandBufferInheritanceConditionalRenderingInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceConditionalRenderingInfoEXT *in_ext = (const VkCommandBufferInheritanceConditionalRenderingInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->conditionalRenderingEnable = in_ext->conditionalRenderingEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
            VkCommandBufferInheritanceRenderPassTransformInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceRenderPassTransformInfoQCOM *in_ext = (const VkCommandBufferInheritanceRenderPassTransformInfoQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->transform = in_ext->transform;
            out_ext->renderArea = in_ext->renderArea;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
        {
            VkCommandBufferInheritanceRenderingInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceRenderingInfo *in_ext = (const VkCommandBufferInheritanceRenderingInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->viewMask = in_ext->viewMask;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentFormats = in_ext->pColorAttachmentFormats;
            out_ext->depthAttachmentFormat = in_ext->depthAttachmentFormat;
            out_ext->stencilAttachmentFormat = in_ext->stencilAttachmentFormat;
            out_ext->rasterizationSamples = in_ext->rasterizationSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
        {
            VkCommandBufferInheritanceViewportScissorInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceViewportScissorInfoNV *in_ext = (const VkCommandBufferInheritanceViewportScissorInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->viewportScissor2D = in_ext->viewportScissor2D;
            out_ext->viewportDepthCount = in_ext->viewportDepthCount;
            out_ext->pViewportDepths = in_ext->pViewportDepths;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM:
        {
            VkRenderPassTileShadingCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassTileShadingCreateInfoQCOM *in_ext = (const VkRenderPassTileShadingCreateInfoQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->tileApronSize = in_ext->tileApronSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO:
        {
            VkRenderingAttachmentLocationInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingAttachmentLocationInfo *in_ext = (const VkRenderingAttachmentLocationInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentLocations = in_ext->pColorAttachmentLocations;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO:
        {
            VkRenderingInputAttachmentIndexInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingInputAttachmentIndexInfo *in_ext = (const VkRenderingInputAttachmentIndexInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentInputIndices = in_ext->pColorAttachmentInputIndices;
            out_ext->pDepthInputAttachmentIndex = in_ext->pDepthInputAttachmentIndex;
            out_ext->pStencilInputAttachmentIndex = in_ext->pStencilInputAttachmentIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM:
        {
            VkTileMemoryBindInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTileMemoryBindInfoQCOM *in_ext = (const VkTileMemoryBindInfoQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->memory = vulkan_device_memory_from_handle(in_ext->memory)->host.device_memory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkCommandBufferInheritanceInfo *convert_VkCommandBufferInheritanceInfo_array_win64_to_host(struct conversion_context *ctx, const VkCommandBufferInheritanceInfo *in, uint32_t count)
{
    VkCommandBufferInheritanceInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCommandBufferInheritanceInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkCommandBufferBeginInfo_win64_to_host(struct conversion_context *ctx, const VkCommandBufferBeginInfo *in, VkCommandBufferBeginInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    out->pInheritanceInfo = convert_VkCommandBufferInheritanceInfo_array_win64_to_host(ctx, in->pInheritanceInfo, 1);
}
#endif /* _WIN64 */

static void convert_VkCommandBufferInheritanceInfo_win32_to_host(struct conversion_context *ctx, const VkCommandBufferInheritanceInfo32 *in, VkCommandBufferInheritanceInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->renderPass = in->renderPass;
    out->subpass = in->subpass;
    out->framebuffer = in->framebuffer;
    out->occlusionQueryEnable = in->occlusionQueryEnable;
    out->queryFlags = in->queryFlags;
    out->pipelineStatistics = in->pipelineStatistics;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
            VkAttachmentSampleCountInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentSampleCountInfoAMD32 *in_ext = (const VkAttachmentSampleCountInfoAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentSamples = UlongToPtr(in_ext->pColorAttachmentSamples);
            out_ext->depthStencilAttachmentSamples = in_ext->depthStencilAttachmentSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {
            VkCommandBufferInheritanceConditionalRenderingInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceConditionalRenderingInfoEXT32 *in_ext = (const VkCommandBufferInheritanceConditionalRenderingInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->conditionalRenderingEnable = in_ext->conditionalRenderingEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {
            VkCommandBufferInheritanceRenderPassTransformInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceRenderPassTransformInfoQCOM32 *in_ext = (const VkCommandBufferInheritanceRenderPassTransformInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->transform = in_ext->transform;
            out_ext->renderArea = in_ext->renderArea;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
        {
            VkCommandBufferInheritanceRenderingInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceRenderingInfo32 *in_ext = (const VkCommandBufferInheritanceRenderingInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->viewMask = in_ext->viewMask;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentFormats = UlongToPtr(in_ext->pColorAttachmentFormats);
            out_ext->depthAttachmentFormat = in_ext->depthAttachmentFormat;
            out_ext->stencilAttachmentFormat = in_ext->stencilAttachmentFormat;
            out_ext->rasterizationSamples = in_ext->rasterizationSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
        {
            VkCommandBufferInheritanceViewportScissorInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCommandBufferInheritanceViewportScissorInfoNV32 *in_ext = (const VkCommandBufferInheritanceViewportScissorInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->viewportScissor2D = in_ext->viewportScissor2D;
            out_ext->viewportDepthCount = in_ext->viewportDepthCount;
            out_ext->pViewportDepths = UlongToPtr(in_ext->pViewportDepths);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM:
        {
            VkRenderPassTileShadingCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassTileShadingCreateInfoQCOM32 *in_ext = (const VkRenderPassTileShadingCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->tileApronSize = in_ext->tileApronSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO:
        {
            VkRenderingAttachmentLocationInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingAttachmentLocationInfo32 *in_ext = (const VkRenderingAttachmentLocationInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentLocations = UlongToPtr(in_ext->pColorAttachmentLocations);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO:
        {
            VkRenderingInputAttachmentIndexInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingInputAttachmentIndexInfo32 *in_ext = (const VkRenderingInputAttachmentIndexInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentInputIndices = UlongToPtr(in_ext->pColorAttachmentInputIndices);
            out_ext->pDepthInputAttachmentIndex = UlongToPtr(in_ext->pDepthInputAttachmentIndex);
            out_ext->pStencilInputAttachmentIndex = UlongToPtr(in_ext->pStencilInputAttachmentIndex);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM:
        {
            VkTileMemoryBindInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTileMemoryBindInfoQCOM32 *in_ext = (const VkTileMemoryBindInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->memory = vulkan_device_memory_from_handle(in_ext->memory)->host.device_memory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkCommandBufferInheritanceInfo *convert_VkCommandBufferInheritanceInfo_array_win32_to_host(struct conversion_context *ctx, const VkCommandBufferInheritanceInfo32 *in, uint32_t count)
{
    VkCommandBufferInheritanceInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCommandBufferInheritanceInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkCommandBufferBeginInfo_win32_to_host(struct conversion_context *ctx, const VkCommandBufferBeginInfo32 *in, VkCommandBufferBeginInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pInheritanceInfo = convert_VkCommandBufferInheritanceInfo_array_win32_to_host(ctx, (const VkCommandBufferInheritanceInfo32 *)UlongToPtr(in->pInheritanceInfo), 1);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {
            VkDeviceGroupCommandBufferBeginInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupCommandBufferBeginInfo32 *in_ext = (const VkDeviceGroupCommandBufferBeginInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceMask = in_ext->deviceMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

#ifdef _WIN64
static void convert_VkBindAccelerationStructureMemoryInfoNV_win64_to_host(const VkBindAccelerationStructureMemoryInfoNV *in, VkBindAccelerationStructureMemoryInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->accelerationStructure = in->accelerationStructure;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;
    out->deviceIndexCount = in->deviceIndexCount;
    out->pDeviceIndices = in->pDeviceIndices;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkBindAccelerationStructureMemoryInfoNV *convert_VkBindAccelerationStructureMemoryInfoNV_array_win64_to_host(struct conversion_context *ctx, const VkBindAccelerationStructureMemoryInfoNV *in, uint32_t count)
{
    VkBindAccelerationStructureMemoryInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindAccelerationStructureMemoryInfoNV_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkBindAccelerationStructureMemoryInfoNV_win32_to_host(const VkBindAccelerationStructureMemoryInfoNV32 *in, VkBindAccelerationStructureMemoryInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->accelerationStructure = in->accelerationStructure;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;
    out->deviceIndexCount = in->deviceIndexCount;
    out->pDeviceIndices = UlongToPtr(in->pDeviceIndices);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkBindAccelerationStructureMemoryInfoNV *convert_VkBindAccelerationStructureMemoryInfoNV_array_win32_to_host(struct conversion_context *ctx, const VkBindAccelerationStructureMemoryInfoNV32 *in, uint32_t count)
{
    VkBindAccelerationStructureMemoryInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindAccelerationStructureMemoryInfoNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static void convert_VkBindBufferMemoryInfo_win64_to_host(const VkBindBufferMemoryInfo *in, VkBindBufferMemoryInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->buffer = in->buffer;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkBindBufferMemoryInfo *convert_VkBindBufferMemoryInfo_array_win64_to_host(struct conversion_context *ctx, const VkBindBufferMemoryInfo *in, uint32_t count)
{
    VkBindBufferMemoryInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindBufferMemoryInfo_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkBindBufferMemoryInfo_win32_to_host(struct conversion_context *ctx, const VkBindBufferMemoryInfo32 *in, VkBindBufferMemoryInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->buffer = in->buffer;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {
            VkBindBufferMemoryDeviceGroupInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindBufferMemoryDeviceGroupInfo32 *in_ext = (const VkBindBufferMemoryDeviceGroupInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceIndexCount = in_ext->deviceIndexCount;
            out_ext->pDeviceIndices = UlongToPtr(in_ext->pDeviceIndices);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS:
        {
            VkBindMemoryStatus *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindMemoryStatus32 *in_ext = (const VkBindMemoryStatus32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS;
            out_ext->pNext = NULL;
            out_ext->pResult = UlongToPtr(in_ext->pResult);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkBindBufferMemoryInfo *convert_VkBindBufferMemoryInfo_array_win32_to_host(struct conversion_context *ctx, const VkBindBufferMemoryInfo32 *in, uint32_t count)
{
    VkBindBufferMemoryInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindBufferMemoryInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static void convert_VkBindDataGraphPipelineSessionMemoryInfoARM_win64_to_host(const VkBindDataGraphPipelineSessionMemoryInfoARM *in, VkBindDataGraphPipelineSessionMemoryInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->session = in->session;
    out->bindPoint = in->bindPoint;
    out->objectIndex = in->objectIndex;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkBindDataGraphPipelineSessionMemoryInfoARM *convert_VkBindDataGraphPipelineSessionMemoryInfoARM_array_win64_to_host(struct conversion_context *ctx, const VkBindDataGraphPipelineSessionMemoryInfoARM *in, uint32_t count)
{
    VkBindDataGraphPipelineSessionMemoryInfoARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindDataGraphPipelineSessionMemoryInfoARM_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkBindDataGraphPipelineSessionMemoryInfoARM_win32_to_host(const VkBindDataGraphPipelineSessionMemoryInfoARM32 *in, VkBindDataGraphPipelineSessionMemoryInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->session = in->session;
    out->bindPoint = in->bindPoint;
    out->objectIndex = in->objectIndex;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkBindDataGraphPipelineSessionMemoryInfoARM *convert_VkBindDataGraphPipelineSessionMemoryInfoARM_array_win32_to_host(struct conversion_context *ctx, const VkBindDataGraphPipelineSessionMemoryInfoARM32 *in, uint32_t count)
{
    VkBindDataGraphPipelineSessionMemoryInfoARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindDataGraphPipelineSessionMemoryInfoARM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static void convert_VkBindImageMemoryInfo_win64_to_host(struct conversion_context *ctx, const VkBindImageMemoryInfo *in, VkBindImageMemoryInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            VkBindImageMemoryDeviceGroupInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImageMemoryDeviceGroupInfo *in_ext = (const VkBindImageMemoryDeviceGroupInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceIndexCount = in_ext->deviceIndexCount;
            out_ext->pDeviceIndices = in_ext->pDeviceIndices;
            out_ext->splitInstanceBindRegionCount = in_ext->splitInstanceBindRegionCount;
            out_ext->pSplitInstanceBindRegions = in_ext->pSplitInstanceBindRegions;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            VkBindImageMemorySwapchainInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImageMemorySwapchainInfoKHR *in_ext = (const VkBindImageMemorySwapchainInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchain = vulkan_swapchain_from_handle(in_ext->swapchain)->host.swapchain;
            out_ext->imageIndex = in_ext->imageIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            VkBindImagePlaneMemoryInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImagePlaneMemoryInfo *in_ext = (const VkBindImagePlaneMemoryInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
            out_ext->pNext = NULL;
            out_ext->planeAspect = in_ext->planeAspect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS:
        {
            VkBindMemoryStatus *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindMemoryStatus *in_ext = (const VkBindMemoryStatus *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS;
            out_ext->pNext = NULL;
            out_ext->pResult = in_ext->pResult;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkBindImageMemoryInfo *convert_VkBindImageMemoryInfo_array_win64_to_host(struct conversion_context *ctx, const VkBindImageMemoryInfo *in, uint32_t count)
{
    VkBindImageMemoryInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindImageMemoryInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkBindImageMemoryInfo_win32_to_host(struct conversion_context *ctx, const VkBindImageMemoryInfo32 *in, VkBindImageMemoryInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {
            VkBindImageMemoryDeviceGroupInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImageMemoryDeviceGroupInfo32 *in_ext = (const VkBindImageMemoryDeviceGroupInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceIndexCount = in_ext->deviceIndexCount;
            out_ext->pDeviceIndices = UlongToPtr(in_ext->pDeviceIndices);
            out_ext->splitInstanceBindRegionCount = in_ext->splitInstanceBindRegionCount;
            out_ext->pSplitInstanceBindRegions = UlongToPtr(in_ext->pSplitInstanceBindRegions);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {
            VkBindImageMemorySwapchainInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImageMemorySwapchainInfoKHR32 *in_ext = (const VkBindImageMemorySwapchainInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchain = vulkan_swapchain_from_handle(in_ext->swapchain)->host.swapchain;
            out_ext->imageIndex = in_ext->imageIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {
            VkBindImagePlaneMemoryInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindImagePlaneMemoryInfo32 *in_ext = (const VkBindImagePlaneMemoryInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
            out_ext->pNext = NULL;
            out_ext->planeAspect = in_ext->planeAspect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS:
        {
            VkBindMemoryStatus *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBindMemoryStatus32 *in_ext = (const VkBindMemoryStatus32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS;
            out_ext->pNext = NULL;
            out_ext->pResult = UlongToPtr(in_ext->pResult);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkBindImageMemoryInfo *convert_VkBindImageMemoryInfo_array_win32_to_host(struct conversion_context *ctx, const VkBindImageMemoryInfo32 *in, uint32_t count)
{
    VkBindImageMemoryInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindImageMemoryInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static void convert_VkBindTensorMemoryInfoARM_win64_to_host(const VkBindTensorMemoryInfoARM *in, VkBindTensorMemoryInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->tensor = in->tensor;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkBindTensorMemoryInfoARM *convert_VkBindTensorMemoryInfoARM_array_win64_to_host(struct conversion_context *ctx, const VkBindTensorMemoryInfoARM *in, uint32_t count)
{
    VkBindTensorMemoryInfoARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindTensorMemoryInfoARM_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkBindTensorMemoryInfoARM_win32_to_host(const VkBindTensorMemoryInfoARM32 *in, VkBindTensorMemoryInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->tensor = in->tensor;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkBindTensorMemoryInfoARM *convert_VkBindTensorMemoryInfoARM_array_win32_to_host(struct conversion_context *ctx, const VkBindTensorMemoryInfoARM32 *in, uint32_t count)
{
    VkBindTensorMemoryInfoARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindTensorMemoryInfoARM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static void convert_VkBindVideoSessionMemoryInfoKHR_win64_to_host(const VkBindVideoSessionMemoryInfoKHR *in, VkBindVideoSessionMemoryInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->memoryBindIndex = in->memoryBindIndex;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;
    out->memorySize = in->memorySize;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkBindVideoSessionMemoryInfoKHR *convert_VkBindVideoSessionMemoryInfoKHR_array_win64_to_host(struct conversion_context *ctx, const VkBindVideoSessionMemoryInfoKHR *in, uint32_t count)
{
    VkBindVideoSessionMemoryInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindVideoSessionMemoryInfoKHR_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkBindVideoSessionMemoryInfoKHR_win32_to_host(const VkBindVideoSessionMemoryInfoKHR32 *in, VkBindVideoSessionMemoryInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->memoryBindIndex = in->memoryBindIndex;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->memoryOffset = in->memoryOffset;
    out->memorySize = in->memorySize;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkBindVideoSessionMemoryInfoKHR *convert_VkBindVideoSessionMemoryInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkBindVideoSessionMemoryInfoKHR32 *in, uint32_t count)
{
    VkBindVideoSessionMemoryInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindVideoSessionMemoryInfoKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static const VkMicromapUsageEXT * const*convert_VkMicromapUsageEXT_pointer_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkMicromapUsageEXT **out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = UlongToPtr(in[i]);
    }

    return (void *)out;
}

static void convert_VkAccelerationStructureGeometryTrianglesDataKHR_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureGeometryTrianglesDataKHR32 *in, VkAccelerationStructureGeometryTrianglesDataKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->vertexFormat = in->vertexFormat;
    out->vertexData = in->vertexData;
    out->vertexStride = in->vertexStride;
    out->maxVertex = in->maxVertex;
    out->indexType = in->indexType;
    out->indexData = in->indexData;
    out->transformData = in->transformData;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
        {
            VkAccelerationStructureGeometryMotionTrianglesDataNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAccelerationStructureGeometryMotionTrianglesDataNV32 *in_ext = (const VkAccelerationStructureGeometryMotionTrianglesDataNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV;
            out_ext->pNext = NULL;
            out_ext->vertexData = in_ext->vertexData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT:
        {
            VkAccelerationStructureTrianglesOpacityMicromapEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAccelerationStructureTrianglesOpacityMicromapEXT32 *in_ext = (const VkAccelerationStructureTrianglesOpacityMicromapEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT;
            out_ext->pNext = NULL;
            out_ext->indexType = in_ext->indexType;
            out_ext->indexBuffer = in_ext->indexBuffer;
            out_ext->indexStride = in_ext->indexStride;
            out_ext->baseTriangle = in_ext->baseTriangle;
            out_ext->usageCountsCount = in_ext->usageCountsCount;
            out_ext->pUsageCounts = UlongToPtr(in_ext->pUsageCounts);
            out_ext->ppUsageCounts = convert_VkMicromapUsageEXT_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in_ext->ppUsageCounts), in_ext->usageCountsCount);
            out_ext->micromap = in_ext->micromap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkAccelerationStructureGeometryAabbsDataKHR_win32_to_host(const VkAccelerationStructureGeometryAabbsDataKHR32 *in, VkAccelerationStructureGeometryAabbsDataKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->data = in->data;
    out->stride = in->stride;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkAccelerationStructureGeometryInstancesDataKHR_win32_to_host(const VkAccelerationStructureGeometryInstancesDataKHR32 *in, VkAccelerationStructureGeometryInstancesDataKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->arrayOfPointers = in->arrayOfPointers;
    out->data = in->data;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkAccelerationStructureGeometryDataKHR_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureGeometryDataKHR32 *in, VkAccelerationStructureGeometryDataKHR *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_GEOMETRY_TYPE_TRIANGLES_KHR)
        convert_VkAccelerationStructureGeometryTrianglesDataKHR_win32_to_host(ctx, &in->triangles, &out->triangles);
    if (selector == VK_GEOMETRY_TYPE_AABBS_KHR)
        convert_VkAccelerationStructureGeometryAabbsDataKHR_win32_to_host(&in->aabbs, &out->aabbs);
    if (selector == VK_GEOMETRY_TYPE_INSTANCES_KHR)
        convert_VkAccelerationStructureGeometryInstancesDataKHR_win32_to_host(&in->instances, &out->instances);
}

static void convert_VkAccelerationStructureGeometryKHR_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureGeometryKHR32 *in, VkAccelerationStructureGeometryKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->geometryType = in->geometryType;
    convert_VkAccelerationStructureGeometryDataKHR_win32_to_host(ctx, &in->geometry, &out->geometry, in->geometryType);
    out->flags = in->flags;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV:
        {
            VkAccelerationStructureGeometryLinearSweptSpheresDataNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAccelerationStructureGeometryLinearSweptSpheresDataNV32 *in_ext = (const VkAccelerationStructureGeometryLinearSweptSpheresDataNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV;
            out_ext->pNext = NULL;
            out_ext->vertexFormat = in_ext->vertexFormat;
            out_ext->vertexData = in_ext->vertexData;
            out_ext->vertexStride = in_ext->vertexStride;
            out_ext->radiusFormat = in_ext->radiusFormat;
            out_ext->radiusData = in_ext->radiusData;
            out_ext->radiusStride = in_ext->radiusStride;
            out_ext->indexType = in_ext->indexType;
            out_ext->indexData = in_ext->indexData;
            out_ext->indexStride = in_ext->indexStride;
            out_ext->indexingMode = in_ext->indexingMode;
            out_ext->endCapsMode = in_ext->endCapsMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV:
        {
            VkAccelerationStructureGeometrySpheresDataNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAccelerationStructureGeometrySpheresDataNV32 *in_ext = (const VkAccelerationStructureGeometrySpheresDataNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV;
            out_ext->pNext = NULL;
            out_ext->vertexFormat = in_ext->vertexFormat;
            out_ext->vertexData = in_ext->vertexData;
            out_ext->vertexStride = in_ext->vertexStride;
            out_ext->radiusFormat = in_ext->radiusFormat;
            out_ext->radiusData = in_ext->radiusData;
            out_ext->radiusStride = in_ext->radiusStride;
            out_ext->indexType = in_ext->indexType;
            out_ext->indexData = in_ext->indexData;
            out_ext->indexStride = in_ext->indexStride;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkAccelerationStructureGeometryKHR *convert_VkAccelerationStructureGeometryKHR_array_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureGeometryKHR32 *in, uint32_t count)
{
    VkAccelerationStructureGeometryKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAccelerationStructureGeometryKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static const VkAccelerationStructureGeometryKHR * const*convert_VkAccelerationStructureGeometryKHR_pointer_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkAccelerationStructureGeometryKHR **out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        if (in[i])
        {
            out[i] = conversion_context_alloc(ctx, sizeof(*out[i]));
            convert_VkAccelerationStructureGeometryKHR_win32_to_host(ctx, (VkAccelerationStructureGeometryKHR32 *)UlongToPtr(in[i]), out[i]);
        }
        else
            out[i] = NULL;
    }

    return (void *)out;
}

static void convert_VkAccelerationStructureBuildGeometryInfoKHR_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureBuildGeometryInfoKHR32 *in, VkAccelerationStructureBuildGeometryInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->flags = in->flags;
    out->mode = in->mode;
    out->srcAccelerationStructure = in->srcAccelerationStructure;
    out->dstAccelerationStructure = in->dstAccelerationStructure;
    out->geometryCount = in->geometryCount;
    out->pGeometries = convert_VkAccelerationStructureGeometryKHR_array_win32_to_host(ctx, (const VkAccelerationStructureGeometryKHR32 *)UlongToPtr(in->pGeometries), in->geometryCount);
    out->ppGeometries = convert_VkAccelerationStructureGeometryKHR_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppGeometries), in->geometryCount);
    out->scratchData = in->scratchData;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkAccelerationStructureBuildGeometryInfoKHR *convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureBuildGeometryInfoKHR32 *in, uint32_t count)
{
    VkAccelerationStructureBuildGeometryInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAccelerationStructureBuildGeometryInfoKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static const VkAccelerationStructureBuildRangeInfoKHR * const*convert_VkAccelerationStructureBuildRangeInfoKHR_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkAccelerationStructureBuildRangeInfoKHR **out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = UlongToPtr(in[i]);
    }

    return (void *)out;
}

static void convert_VkMicromapBuildInfoEXT_win32_to_host(struct conversion_context *ctx, const VkMicromapBuildInfoEXT32 *in, VkMicromapBuildInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->flags = in->flags;
    out->mode = in->mode;
    out->dstMicromap = in->dstMicromap;
    out->usageCountsCount = in->usageCountsCount;
    out->pUsageCounts = UlongToPtr(in->pUsageCounts);
    out->ppUsageCounts = convert_VkMicromapUsageEXT_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppUsageCounts), in->usageCountsCount);
    out->data = in->data;
    out->scratchData = in->scratchData;
    out->triangleArray = in->triangleArray;
    out->triangleArrayStride = in->triangleArrayStride;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkMicromapBuildInfoEXT *convert_VkMicromapBuildInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkMicromapBuildInfoEXT32 *in, uint32_t count)
{
    VkMicromapBuildInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMicromapBuildInfoEXT_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkConditionalRenderingBeginInfoEXT_win32_to_host(const VkConditionalRenderingBeginInfoEXT32 *in, VkConditionalRenderingBeginInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->buffer = in->buffer;
    out->offset = in->offset;
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDebugUtilsLabelEXT_win32_to_host(const VkDebugUtilsLabelEXT32 *in, VkDebugUtilsLabelEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pLabelName = UlongToPtr(in->pLabelName);
    memcpy(out->color, in->color, 4 * sizeof(float));
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPerTileBeginInfoQCOM_win32_to_host(const VkPerTileBeginInfoQCOM32 *in, VkPerTileBeginInfoQCOM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkSampleLocationsInfoEXT_win32_to_host(const VkSampleLocationsInfoEXT32 *in, VkSampleLocationsInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->sampleLocationsPerPixel = in->sampleLocationsPerPixel;
    out->sampleLocationGridSize = in->sampleLocationGridSize;
    out->sampleLocationsCount = in->sampleLocationsCount;
    out->pSampleLocations = UlongToPtr(in->pSampleLocations);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkAttachmentSampleLocationsEXT_win32_to_host(const VkAttachmentSampleLocationsEXT32 *in, VkAttachmentSampleLocationsEXT *out)
{
    if (!in) return;

    out->attachmentIndex = in->attachmentIndex;
    convert_VkSampleLocationsInfoEXT_win32_to_host(&in->sampleLocationsInfo, &out->sampleLocationsInfo);
}

static const VkAttachmentSampleLocationsEXT *convert_VkAttachmentSampleLocationsEXT_array_win32_to_host(struct conversion_context *ctx, const VkAttachmentSampleLocationsEXT32 *in, uint32_t count)
{
    VkAttachmentSampleLocationsEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAttachmentSampleLocationsEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkSubpassSampleLocationsEXT_win32_to_host(const VkSubpassSampleLocationsEXT32 *in, VkSubpassSampleLocationsEXT *out)
{
    if (!in) return;

    out->subpassIndex = in->subpassIndex;
    convert_VkSampleLocationsInfoEXT_win32_to_host(&in->sampleLocationsInfo, &out->sampleLocationsInfo);
}

static const VkSubpassSampleLocationsEXT *convert_VkSubpassSampleLocationsEXT_array_win32_to_host(struct conversion_context *ctx, const VkSubpassSampleLocationsEXT32 *in, uint32_t count)
{
    VkSubpassSampleLocationsEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubpassSampleLocationsEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkRenderPassStripeInfoARM_win32_to_host(const VkRenderPassStripeInfoARM32 *in, VkRenderPassStripeInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->stripeArea = in->stripeArea;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkRenderPassStripeInfoARM *convert_VkRenderPassStripeInfoARM_array_win32_to_host(struct conversion_context *ctx, const VkRenderPassStripeInfoARM32 *in, uint32_t count)
{
    VkRenderPassStripeInfoARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRenderPassStripeInfoARM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkRenderPassBeginInfo_win32_to_host(struct conversion_context *ctx, const VkRenderPassBeginInfo32 *in, VkRenderPassBeginInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->renderPass = in->renderPass;
    out->framebuffer = in->framebuffer;
    out->renderArea = in->renderArea;
    out->clearValueCount = in->clearValueCount;
    out->pClearValues = UlongToPtr(in->pClearValues);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            VkDeviceGroupRenderPassBeginInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupRenderPassBeginInfo32 *in_ext = (const VkDeviceGroupRenderPassBeginInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceMask = in_ext->deviceMask;
            out_ext->deviceRenderAreaCount = in_ext->deviceRenderAreaCount;
            out_ext->pDeviceRenderAreas = UlongToPtr(in_ext->pDeviceRenderAreas);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
        {
            VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32 *in_ext = (const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->perViewRenderAreaCount = in_ext->perViewRenderAreaCount;
            out_ext->pPerViewRenderAreas = UlongToPtr(in_ext->pPerViewRenderAreas);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {
            VkRenderPassAttachmentBeginInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassAttachmentBeginInfo32 *in_ext = (const VkRenderPassAttachmentBeginInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO;
            out_ext->pNext = NULL;
            out_ext->attachmentCount = in_ext->attachmentCount;
            out_ext->pAttachments = UlongToPtr(in_ext->pAttachments);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {
            VkRenderPassSampleLocationsBeginInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassSampleLocationsBeginInfoEXT32 *in_ext = (const VkRenderPassSampleLocationsBeginInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentInitialSampleLocationsCount = in_ext->attachmentInitialSampleLocationsCount;
            out_ext->pAttachmentInitialSampleLocations = convert_VkAttachmentSampleLocationsEXT_array_win32_to_host(ctx, (const VkAttachmentSampleLocationsEXT32 *)UlongToPtr(in_ext->pAttachmentInitialSampleLocations), in_ext->attachmentInitialSampleLocationsCount);
            out_ext->postSubpassSampleLocationsCount = in_ext->postSubpassSampleLocationsCount;
            out_ext->pPostSubpassSampleLocations = convert_VkSubpassSampleLocationsEXT_array_win32_to_host(ctx, (const VkSubpassSampleLocationsEXT32 *)UlongToPtr(in_ext->pPostSubpassSampleLocations), in_ext->postSubpassSampleLocationsCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM:
        {
            VkRenderPassStripeBeginInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassStripeBeginInfoARM32 *in_ext = (const VkRenderPassStripeBeginInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->stripeInfoCount = in_ext->stripeInfoCount;
            out_ext->pStripeInfos = convert_VkRenderPassStripeInfoARM_array_win32_to_host(ctx, (const VkRenderPassStripeInfoARM32 *)UlongToPtr(in_ext->pStripeInfos), in_ext->stripeInfoCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {
            VkRenderPassTransformBeginInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassTransformBeginInfoQCOM32 *in_ext = (const VkRenderPassTransformBeginInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->transform = in_ext->transform;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkSubpassBeginInfo_win32_to_host(const VkSubpassBeginInfo32 *in, VkSubpassBeginInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->contents = in->contents;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkRenderingAttachmentInfo_win32_to_host(struct conversion_context *ctx, const VkRenderingAttachmentInfo32 *in, VkRenderingAttachmentInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->imageView = in->imageView;
    out->imageLayout = in->imageLayout;
    out->resolveMode = in->resolveMode;
    out->resolveImageView = in->resolveImageView;
    out->resolveImageLayout = in->resolveImageLayout;
    out->loadOp = in->loadOp;
    out->storeOp = in->storeOp;
    out->clearValue = in->clearValue;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT:
        {
            VkAttachmentFeedbackLoopInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentFeedbackLoopInfoEXT32 *in_ext = (const VkAttachmentFeedbackLoopInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->feedbackLoopEnable = in_ext->feedbackLoopEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkRenderingAttachmentInfo *convert_VkRenderingAttachmentInfo_array_win32_to_host(struct conversion_context *ctx, const VkRenderingAttachmentInfo32 *in, uint32_t count)
{
    VkRenderingAttachmentInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRenderingAttachmentInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkRenderingInfo_win32_to_host(struct conversion_context *ctx, const VkRenderingInfo32 *in, VkRenderingInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->renderArea = in->renderArea;
    out->layerCount = in->layerCount;
    out->viewMask = in->viewMask;
    out->colorAttachmentCount = in->colorAttachmentCount;
    out->pColorAttachments = convert_VkRenderingAttachmentInfo_array_win32_to_host(ctx, (const VkRenderingAttachmentInfo32 *)UlongToPtr(in->pColorAttachments), in->colorAttachmentCount);
    out->pDepthAttachment = convert_VkRenderingAttachmentInfo_array_win32_to_host(ctx, (const VkRenderingAttachmentInfo32 *)UlongToPtr(in->pDepthAttachment), 1);
    out->pStencilAttachment = convert_VkRenderingAttachmentInfo_array_win32_to_host(ctx, (const VkRenderingAttachmentInfo32 *)UlongToPtr(in->pStencilAttachment), 1);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {
            VkDeviceGroupRenderPassBeginInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupRenderPassBeginInfo32 *in_ext = (const VkDeviceGroupRenderPassBeginInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
            out_ext->pNext = NULL;
            out_ext->deviceMask = in_ext->deviceMask;
            out_ext->deviceRenderAreaCount = in_ext->deviceRenderAreaCount;
            out_ext->pDeviceRenderAreas = UlongToPtr(in_ext->pDeviceRenderAreas);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
        {
            VkMultisampledRenderToSingleSampledInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultisampledRenderToSingleSampledInfoEXT32 *in_ext = (const VkMultisampledRenderToSingleSampledInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->multisampledRenderToSingleSampledEnable = in_ext->multisampledRenderToSingleSampledEnable;
            out_ext->rasterizationSamples = in_ext->rasterizationSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
        {
            VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32 *in_ext = (const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->perViewRenderAreaCount = in_ext->perViewRenderAreaCount;
            out_ext->pPerViewRenderAreas = UlongToPtr(in_ext->pPerViewRenderAreas);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM:
        {
            VkRenderPassStripeBeginInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassStripeBeginInfoARM32 *in_ext = (const VkRenderPassStripeBeginInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->stripeInfoCount = in_ext->stripeInfoCount;
            out_ext->pStripeInfos = convert_VkRenderPassStripeInfoARM_array_win32_to_host(ctx, (const VkRenderPassStripeInfoARM32 *)UlongToPtr(in_ext->pStripeInfos), in_ext->stripeInfoCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM:
        {
            VkRenderPassTileShadingCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassTileShadingCreateInfoQCOM32 *in_ext = (const VkRenderPassTileShadingCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->tileApronSize = in_ext->tileApronSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
        {
            VkRenderingFragmentDensityMapAttachmentInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingFragmentDensityMapAttachmentInfoEXT32 *in_ext = (const VkRenderingFragmentDensityMapAttachmentInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->imageView = in_ext->imageView;
            out_ext->imageLayout = in_ext->imageLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            VkRenderingFragmentShadingRateAttachmentInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingFragmentShadingRateAttachmentInfoKHR32 *in_ext = (const VkRenderingFragmentShadingRateAttachmentInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->imageView = in_ext->imageView;
            out_ext->imageLayout = in_ext->imageLayout;
            out_ext->shadingRateAttachmentTexelSize = in_ext->shadingRateAttachmentTexelSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM:
        {
            VkTileMemorySizeInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTileMemorySizeInfoQCOM32 *in_ext = (const VkTileMemorySizeInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->size = in_ext->size;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkVideoPictureResourceInfoKHR_win32_to_host(const VkVideoPictureResourceInfoKHR32 *in, VkVideoPictureResourceInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->codedOffset = in->codedOffset;
    out->codedExtent = in->codedExtent;
    out->baseArrayLayer = in->baseArrayLayer;
    out->imageViewBinding = in->imageViewBinding;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkVideoPictureResourceInfoKHR *convert_VkVideoPictureResourceInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkVideoPictureResourceInfoKHR32 *in, uint32_t count)
{
    VkVideoPictureResourceInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVideoPictureResourceInfoKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_StdVideoEncodeAV1ReferenceInfo_win32_to_host(const StdVideoEncodeAV1ReferenceInfo32 *in, StdVideoEncodeAV1ReferenceInfo *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->RefFrameId = in->RefFrameId;
    out->frame_type = in->frame_type;
    out->OrderHint = in->OrderHint;
    memcpy(out->reserved1, in->reserved1, 3 * sizeof(uint8_t));
    out->pExtensionHeader = UlongToPtr(in->pExtensionHeader);
}

static const StdVideoEncodeAV1ReferenceInfo *convert_StdVideoEncodeAV1ReferenceInfo_array_win32_to_host(struct conversion_context *ctx, const StdVideoEncodeAV1ReferenceInfo32 *in, uint32_t count)
{
    StdVideoEncodeAV1ReferenceInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoEncodeAV1ReferenceInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoReferenceSlotInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoReferenceSlotInfoKHR32 *in, VkVideoReferenceSlotInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->slotIndex = in->slotIndex;
    out->pPictureResource = convert_VkVideoPictureResourceInfoKHR_array_win32_to_host(ctx, (const VkVideoPictureResourceInfoKHR32 *)UlongToPtr(in->pPictureResource), 1);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR:
        {
            VkVideoDecodeAV1DpbSlotInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeAV1DpbSlotInfoKHR32 *in_ext = (const VkVideoDecodeAV1DpbSlotInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pStdReferenceInfo = UlongToPtr(in_ext->pStdReferenceInfo);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR:
        {
            VkVideoDecodeH264DpbSlotInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeH264DpbSlotInfoKHR32 *in_ext = (const VkVideoDecodeH264DpbSlotInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pStdReferenceInfo = UlongToPtr(in_ext->pStdReferenceInfo);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR:
        {
            VkVideoEncodeAV1DpbSlotInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeAV1DpbSlotInfoKHR32 *in_ext = (const VkVideoEncodeAV1DpbSlotInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pStdReferenceInfo = convert_StdVideoEncodeAV1ReferenceInfo_array_win32_to_host(ctx, (const StdVideoEncodeAV1ReferenceInfo32 *)UlongToPtr(in_ext->pStdReferenceInfo), 1);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR:
        {
            VkVideoEncodeH264DpbSlotInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264DpbSlotInfoKHR32 *in_ext = (const VkVideoEncodeH264DpbSlotInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pStdReferenceInfo = UlongToPtr(in_ext->pStdReferenceInfo);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR:
        {
            VkVideoReferenceIntraRefreshInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoReferenceIntraRefreshInfoKHR32 *in_ext = (const VkVideoReferenceIntraRefreshInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->dirtyIntraRefreshRegions = in_ext->dirtyIntraRefreshRegions;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkVideoReferenceSlotInfoKHR *convert_VkVideoReferenceSlotInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkVideoReferenceSlotInfoKHR32 *in, uint32_t count)
{
    VkVideoReferenceSlotInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVideoReferenceSlotInfoKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoEncodeRateControlLayerInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoEncodeRateControlLayerInfoKHR32 *in, VkVideoEncodeRateControlLayerInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->averageBitrate = in->averageBitrate;
    out->maxBitrate = in->maxBitrate;
    out->frameRateNumerator = in->frameRateNumerator;
    out->frameRateDenominator = in->frameRateDenominator;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR:
        {
            VkVideoEncodeAV1RateControlLayerInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeAV1RateControlLayerInfoKHR32 *in_ext = (const VkVideoEncodeAV1RateControlLayerInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->useMinQIndex = in_ext->useMinQIndex;
            out_ext->minQIndex = in_ext->minQIndex;
            out_ext->useMaxQIndex = in_ext->useMaxQIndex;
            out_ext->maxQIndex = in_ext->maxQIndex;
            out_ext->useMaxFrameSize = in_ext->useMaxFrameSize;
            out_ext->maxFrameSize = in_ext->maxFrameSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR:
        {
            VkVideoEncodeH264RateControlLayerInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264RateControlLayerInfoKHR32 *in_ext = (const VkVideoEncodeH264RateControlLayerInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->useMinQp = in_ext->useMinQp;
            out_ext->minQp = in_ext->minQp;
            out_ext->useMaxQp = in_ext->useMaxQp;
            out_ext->maxQp = in_ext->maxQp;
            out_ext->useMaxFrameSize = in_ext->useMaxFrameSize;
            out_ext->maxFrameSize = in_ext->maxFrameSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkVideoEncodeRateControlLayerInfoKHR *convert_VkVideoEncodeRateControlLayerInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkVideoEncodeRateControlLayerInfoKHR32 *in, uint32_t count)
{
    VkVideoEncodeRateControlLayerInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVideoEncodeRateControlLayerInfoKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoBeginCodingInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoBeginCodingInfoKHR32 *in, VkVideoBeginCodingInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->videoSession = in->videoSession;
    out->videoSessionParameters = in->videoSessionParameters;
    out->referenceSlotCount = in->referenceSlotCount;
    out->pReferenceSlots = convert_VkVideoReferenceSlotInfoKHR_array_win32_to_host(ctx, (const VkVideoReferenceSlotInfoKHR32 *)UlongToPtr(in->pReferenceSlots), in->referenceSlotCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR:
        {
            VkVideoEncodeAV1GopRemainingFrameInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeAV1GopRemainingFrameInfoKHR32 *in_ext = (const VkVideoEncodeAV1GopRemainingFrameInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->useGopRemainingFrames = in_ext->useGopRemainingFrames;
            out_ext->gopRemainingIntra = in_ext->gopRemainingIntra;
            out_ext->gopRemainingPredictive = in_ext->gopRemainingPredictive;
            out_ext->gopRemainingBipredictive = in_ext->gopRemainingBipredictive;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR:
        {
            VkVideoEncodeAV1RateControlInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeAV1RateControlInfoKHR32 *in_ext = (const VkVideoEncodeAV1RateControlInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->gopFrameCount = in_ext->gopFrameCount;
            out_ext->keyFramePeriod = in_ext->keyFramePeriod;
            out_ext->consecutiveBipredictiveFrameCount = in_ext->consecutiveBipredictiveFrameCount;
            out_ext->temporalLayerCount = in_ext->temporalLayerCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR:
        {
            VkVideoEncodeH264GopRemainingFrameInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264GopRemainingFrameInfoKHR32 *in_ext = (const VkVideoEncodeH264GopRemainingFrameInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->useGopRemainingFrames = in_ext->useGopRemainingFrames;
            out_ext->gopRemainingI = in_ext->gopRemainingI;
            out_ext->gopRemainingP = in_ext->gopRemainingP;
            out_ext->gopRemainingB = in_ext->gopRemainingB;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR:
        {
            VkVideoEncodeH264RateControlInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264RateControlInfoKHR32 *in_ext = (const VkVideoEncodeH264RateControlInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->gopFrameCount = in_ext->gopFrameCount;
            out_ext->idrPeriod = in_ext->idrPeriod;
            out_ext->consecutiveBFrameCount = in_ext->consecutiveBFrameCount;
            out_ext->temporalLayerCount = in_ext->temporalLayerCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR:
        {
            VkVideoEncodeRateControlInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeRateControlInfoKHR32 *in_ext = (const VkVideoEncodeRateControlInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->rateControlMode = in_ext->rateControlMode;
            out_ext->layerCount = in_ext->layerCount;
            out_ext->pLayers = convert_VkVideoEncodeRateControlLayerInfoKHR_array_win32_to_host(ctx, (const VkVideoEncodeRateControlLayerInfoKHR32 *)UlongToPtr(in_ext->pLayers), in_ext->layerCount);
            out_ext->virtualBufferSizeInMs = in_ext->virtualBufferSizeInMs;
            out_ext->initialVirtualBufferSizeInMs = in_ext->initialVirtualBufferSizeInMs;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkBindDescriptorBufferEmbeddedSamplersInfoEXT_win32_to_host(struct conversion_context *ctx, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT32 *in, VkBindDescriptorBufferEmbeddedSamplersInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->stageFlags = in->stageFlags;
    out->layout = in->layout;
    out->set = in->set;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {
            VkPipelineLayoutCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLayoutCreateInfo32 *in_ext = (const VkPipelineLayoutCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->setLayoutCount = in_ext->setLayoutCount;
            out_ext->pSetLayouts = UlongToPtr(in_ext->pSetLayouts);
            out_ext->pushConstantRangeCount = in_ext->pushConstantRangeCount;
            out_ext->pPushConstantRanges = UlongToPtr(in_ext->pPushConstantRanges);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkDescriptorBufferBindingInfoEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorBufferBindingInfoEXT32 *in, VkDescriptorBufferBindingInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->address = in->address;
    out->usage = in->usage;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
        {
            VkBufferUsageFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfo32 *in_ext = (const VkBufferUsageFlags2CreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT:
        {
            VkDescriptorBufferBindingPushDescriptorBufferHandleEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT32 *in_ext = (const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT;
            out_ext->pNext = NULL;
            out_ext->buffer = in_ext->buffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkDescriptorBufferBindingInfoEXT *convert_VkDescriptorBufferBindingInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorBufferBindingInfoEXT32 *in, uint32_t count)
{
    VkDescriptorBufferBindingInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorBufferBindingInfoEXT_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkBindDescriptorSetsInfo_win32_to_host(struct conversion_context *ctx, const VkBindDescriptorSetsInfo32 *in, VkBindDescriptorSetsInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->stageFlags = in->stageFlags;
    out->layout = in->layout;
    out->firstSet = in->firstSet;
    out->descriptorSetCount = in->descriptorSetCount;
    out->pDescriptorSets = UlongToPtr(in->pDescriptorSets);
    out->dynamicOffsetCount = in->dynamicOffsetCount;
    out->pDynamicOffsets = UlongToPtr(in->pDynamicOffsets);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {
            VkPipelineLayoutCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLayoutCreateInfo32 *in_ext = (const VkPipelineLayoutCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->setLayoutCount = in_ext->setLayoutCount;
            out_ext->pSetLayouts = UlongToPtr(in_ext->pSetLayouts);
            out_ext->pushConstantRangeCount = in_ext->pushConstantRangeCount;
            out_ext->pPushConstantRanges = UlongToPtr(in_ext->pPushConstantRanges);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

#ifdef _WIN64
static void convert_VkTileMemoryBindInfoQCOM_win64_to_host(const VkTileMemoryBindInfoQCOM *in, VkTileMemoryBindInfoQCOM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
}
#endif /* _WIN64 */

static void convert_VkTileMemoryBindInfoQCOM_win32_to_host(const VkTileMemoryBindInfoQCOM32 *in, VkTileMemoryBindInfoQCOM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkImageBlit2_win32_to_host(struct conversion_context *ctx, const VkImageBlit232 *in, VkImageBlit2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSubresource = in->srcSubresource;
    memcpy(out->srcOffsets, in->srcOffsets, 2 * sizeof(VkOffset3D));
    out->dstSubresource = in->dstSubresource;
    memcpy(out->dstOffsets, in->dstOffsets, 2 * sizeof(VkOffset3D));

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            VkCopyCommandTransformInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCopyCommandTransformInfoQCOM32 *in_ext = (const VkCopyCommandTransformInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->transform = in_ext->transform;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkImageBlit2 *convert_VkImageBlit2_array_win32_to_host(struct conversion_context *ctx, const VkImageBlit232 *in, uint32_t count)
{
    VkImageBlit2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageBlit2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkBlitImageInfo2_win32_to_host(struct conversion_context *ctx, const VkBlitImageInfo232 *in, VkBlitImageInfo2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkImageBlit2_array_win32_to_host(ctx, (const VkImageBlit232 *)UlongToPtr(in->pRegions), in->regionCount);
    out->filter = in->filter;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM:
        {
            VkBlitImageCubicWeightsInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBlitImageCubicWeightsInfoQCOM32 *in_ext = (const VkBlitImageCubicWeightsInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->cubicWeights = in_ext->cubicWeights;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkGeometryTrianglesNV_win32_to_host(const VkGeometryTrianglesNV32 *in, VkGeometryTrianglesNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->vertexData = in->vertexData;
    out->vertexOffset = in->vertexOffset;
    out->vertexCount = in->vertexCount;
    out->vertexStride = in->vertexStride;
    out->vertexFormat = in->vertexFormat;
    out->indexData = in->indexData;
    out->indexOffset = in->indexOffset;
    out->indexCount = in->indexCount;
    out->indexType = in->indexType;
    out->transformData = in->transformData;
    out->transformOffset = in->transformOffset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkGeometryAABBNV_win32_to_host(const VkGeometryAABBNV32 *in, VkGeometryAABBNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->aabbData = in->aabbData;
    out->numAABBs = in->numAABBs;
    out->stride = in->stride;
    out->offset = in->offset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkGeometryDataNV_win32_to_host(const VkGeometryDataNV32 *in, VkGeometryDataNV *out)
{
    if (!in) return;

    convert_VkGeometryTrianglesNV_win32_to_host(&in->triangles, &out->triangles);
    convert_VkGeometryAABBNV_win32_to_host(&in->aabbs, &out->aabbs);
}

static void convert_VkGeometryNV_win32_to_host(const VkGeometryNV32 *in, VkGeometryNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->geometryType = in->geometryType;
    convert_VkGeometryDataNV_win32_to_host(&in->geometry, &out->geometry);
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkGeometryNV *convert_VkGeometryNV_array_win32_to_host(struct conversion_context *ctx, const VkGeometryNV32 *in, uint32_t count)
{
    VkGeometryNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkGeometryNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkAccelerationStructureInfoNV_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureInfoNV32 *in, VkAccelerationStructureInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->flags = in->flags;
    out->instanceCount = in->instanceCount;
    out->geometryCount = in->geometryCount;
    out->pGeometries = convert_VkGeometryNV_array_win32_to_host(ctx, (const VkGeometryNV32 *)UlongToPtr(in->pGeometries), in->geometryCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const uint32_t * const*convert_uint32_t_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    uint32_t **out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = UlongToPtr(in[i]);
    }

    return (void *)out;
}

static void convert_uint32_t_array_host_to_win32(const uint32_t * const*in, PTR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        out[i] = PtrToUlong(in[i]);
    }
}

static void convert_VkClusterAccelerationStructureClustersBottomLevelInputNV_win32_to_host(const VkClusterAccelerationStructureClustersBottomLevelInputNV32 *in, VkClusterAccelerationStructureClustersBottomLevelInputNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->maxTotalClusterCount = in->maxTotalClusterCount;
    out->maxClusterCountPerAccelerationStructure = in->maxClusterCountPerAccelerationStructure;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkClusterAccelerationStructureClustersBottomLevelInputNV *convert_VkClusterAccelerationStructureClustersBottomLevelInputNV_array_win32_to_host(struct conversion_context *ctx, const VkClusterAccelerationStructureClustersBottomLevelInputNV32 *in, uint32_t count)
{
    VkClusterAccelerationStructureClustersBottomLevelInputNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkClusterAccelerationStructureClustersBottomLevelInputNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkClusterAccelerationStructureTriangleClusterInputNV_win32_to_host(const VkClusterAccelerationStructureTriangleClusterInputNV32 *in, VkClusterAccelerationStructureTriangleClusterInputNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->vertexFormat = in->vertexFormat;
    out->maxGeometryIndexValue = in->maxGeometryIndexValue;
    out->maxClusterUniqueGeometryCount = in->maxClusterUniqueGeometryCount;
    out->maxClusterTriangleCount = in->maxClusterTriangleCount;
    out->maxClusterVertexCount = in->maxClusterVertexCount;
    out->maxTotalTriangleCount = in->maxTotalTriangleCount;
    out->maxTotalVertexCount = in->maxTotalVertexCount;
    out->minPositionTruncateBitCount = in->minPositionTruncateBitCount;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkClusterAccelerationStructureTriangleClusterInputNV *convert_VkClusterAccelerationStructureTriangleClusterInputNV_array_win32_to_host(struct conversion_context *ctx, const VkClusterAccelerationStructureTriangleClusterInputNV32 *in, uint32_t count)
{
    VkClusterAccelerationStructureTriangleClusterInputNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkClusterAccelerationStructureTriangleClusterInputNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkClusterAccelerationStructureMoveObjectsInputNV_win32_to_host(const VkClusterAccelerationStructureMoveObjectsInputNV32 *in, VkClusterAccelerationStructureMoveObjectsInputNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->noMoveOverlap = in->noMoveOverlap;
    out->maxMovedBytes = in->maxMovedBytes;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkClusterAccelerationStructureMoveObjectsInputNV *convert_VkClusterAccelerationStructureMoveObjectsInputNV_array_win32_to_host(struct conversion_context *ctx, const VkClusterAccelerationStructureMoveObjectsInputNV32 *in, uint32_t count)
{
    VkClusterAccelerationStructureMoveObjectsInputNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkClusterAccelerationStructureMoveObjectsInputNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkClusterAccelerationStructureOpInputNV_win32_to_host(struct conversion_context *ctx, const VkClusterAccelerationStructureOpInputNV32 *in, VkClusterAccelerationStructureOpInputNV *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV)
        out->pClustersBottomLevel = convert_VkClusterAccelerationStructureClustersBottomLevelInputNV_array_win32_to_host(ctx, (VkClusterAccelerationStructureClustersBottomLevelInputNV32 *)UlongToPtr(in->pClustersBottomLevel), 1);
    if (selector == VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV || selector == VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV || selector == VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV || selector == VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV)
        out->pTriangleClusters = convert_VkClusterAccelerationStructureTriangleClusterInputNV_array_win32_to_host(ctx, (VkClusterAccelerationStructureTriangleClusterInputNV32 *)UlongToPtr(in->pTriangleClusters), 1);
    if (selector == VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV)
        out->pMoveObjects = convert_VkClusterAccelerationStructureMoveObjectsInputNV_array_win32_to_host(ctx, (VkClusterAccelerationStructureMoveObjectsInputNV32 *)UlongToPtr(in->pMoveObjects), 1);
}

static void convert_VkClusterAccelerationStructureInputInfoNV_win32_to_host(struct conversion_context *ctx, const VkClusterAccelerationStructureInputInfoNV32 *in, VkClusterAccelerationStructureInputInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->maxAccelerationStructureCount = in->maxAccelerationStructureCount;
    out->flags = in->flags;
    out->opType = in->opType;
    out->opMode = in->opMode;
    convert_VkClusterAccelerationStructureOpInputNV_win32_to_host(ctx, &in->opInput, &out->opInput, in->opType);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkStridedDeviceAddressRegionKHR_win32_to_host(const VkStridedDeviceAddressRegionKHR32 *in, VkStridedDeviceAddressRegionKHR *out)
{
    if (!in) return;

    out->deviceAddress = in->deviceAddress;
    out->stride = in->stride;
    out->size = in->size;
}

static void convert_VkClusterAccelerationStructureCommandsInfoNV_win32_to_host(struct conversion_context *ctx, const VkClusterAccelerationStructureCommandsInfoNV32 *in, VkClusterAccelerationStructureCommandsInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    convert_VkClusterAccelerationStructureInputInfoNV_win32_to_host(ctx, &in->input, &out->input);
    out->dstImplicitData = in->dstImplicitData;
    out->scratchData = in->scratchData;
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host(&in->dstAddressesArray, &out->dstAddressesArray);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host(&in->dstSizesArray, &out->dstSizesArray);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host(&in->srcInfosArray, &out->srcInfosArray);
    out->srcInfosCount = in->srcInfosCount;
    out->addressResolutionFlags = in->addressResolutionFlags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPartitionedAccelerationStructureInstancesInputNV_win32_to_host(struct conversion_context *ctx, const VkPartitionedAccelerationStructureInstancesInputNV32 *in, VkPartitionedAccelerationStructureInstancesInputNV *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->instanceCount = in->instanceCount;
    out->maxInstancePerPartitionCount = in->maxInstancePerPartitionCount;
    out->partitionCount = in->partitionCount;
    out->maxInstanceInGlobalPartitionCount = in->maxInstanceInGlobalPartitionCount;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV:
        {
            VkPartitionedAccelerationStructureFlagsNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPartitionedAccelerationStructureFlagsNV32 *in_ext = (const VkPartitionedAccelerationStructureFlagsNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV;
            out_ext->pNext = NULL;
            out_ext->enablePartitionTranslation = in_ext->enablePartitionTranslation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkBuildPartitionedAccelerationStructureInfoNV_win32_to_host(struct conversion_context *ctx, const VkBuildPartitionedAccelerationStructureInfoNV32 *in, VkBuildPartitionedAccelerationStructureInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    convert_VkPartitionedAccelerationStructureInstancesInputNV_win32_to_host(ctx, &in->input, &out->input);
    out->srcAccelerationStructureData = in->srcAccelerationStructureData;
    out->dstAccelerationStructureData = in->dstAccelerationStructureData;
    out->scratchData = in->scratchData;
    out->srcInfos = in->srcInfos;
    out->srcInfosCount = in->srcInfosCount;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkVideoCodingControlInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoCodingControlInfoKHR32 *in, VkVideoCodingControlInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR:
        {
            VkVideoEncodeAV1RateControlInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeAV1RateControlInfoKHR32 *in_ext = (const VkVideoEncodeAV1RateControlInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->gopFrameCount = in_ext->gopFrameCount;
            out_ext->keyFramePeriod = in_ext->keyFramePeriod;
            out_ext->consecutiveBipredictiveFrameCount = in_ext->consecutiveBipredictiveFrameCount;
            out_ext->temporalLayerCount = in_ext->temporalLayerCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR:
        {
            VkVideoEncodeH264RateControlInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264RateControlInfoKHR32 *in_ext = (const VkVideoEncodeH264RateControlInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->gopFrameCount = in_ext->gopFrameCount;
            out_ext->idrPeriod = in_ext->idrPeriod;
            out_ext->consecutiveBFrameCount = in_ext->consecutiveBFrameCount;
            out_ext->temporalLayerCount = in_ext->temporalLayerCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR:
        {
            VkVideoEncodeQualityLevelInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeQualityLevelInfoKHR32 *in_ext = (const VkVideoEncodeQualityLevelInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->qualityLevel = in_ext->qualityLevel;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR:
        {
            VkVideoEncodeRateControlInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeRateControlInfoKHR32 *in_ext = (const VkVideoEncodeRateControlInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->rateControlMode = in_ext->rateControlMode;
            out_ext->layerCount = in_ext->layerCount;
            out_ext->pLayers = convert_VkVideoEncodeRateControlLayerInfoKHR_array_win32_to_host(ctx, (const VkVideoEncodeRateControlLayerInfoKHR32 *)UlongToPtr(in_ext->pLayers), in_ext->layerCount);
            out_ext->virtualBufferSizeInMs = in_ext->virtualBufferSizeInMs;
            out_ext->initialVirtualBufferSizeInMs = in_ext->initialVirtualBufferSizeInMs;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkConvertCooperativeVectorMatrixInfoNV_win32_to_host(const VkConvertCooperativeVectorMatrixInfoNV32 *in, VkConvertCooperativeVectorMatrixInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSize = in->srcSize;
    out->srcData = in->srcData;
    out->pDstSize = UlongToPtr(in->pDstSize);
    out->dstData = in->dstData;
    out->srcComponentType = in->srcComponentType;
    out->dstComponentType = in->dstComponentType;
    out->numRows = in->numRows;
    out->numColumns = in->numColumns;
    out->srcLayout = in->srcLayout;
    out->srcStride = in->srcStride;
    out->dstLayout = in->dstLayout;
    out->dstStride = in->dstStride;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkConvertCooperativeVectorMatrixInfoNV *convert_VkConvertCooperativeVectorMatrixInfoNV_array_win32_to_host(struct conversion_context *ctx, const VkConvertCooperativeVectorMatrixInfoNV32 *in, uint32_t count)
{
    VkConvertCooperativeVectorMatrixInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkConvertCooperativeVectorMatrixInfoNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCopyAccelerationStructureInfoKHR_win32_to_host(const VkCopyAccelerationStructureInfoKHR32 *in, VkCopyAccelerationStructureInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCopyAccelerationStructureToMemoryInfoKHR_win32_to_host(const VkCopyAccelerationStructureToMemoryInfoKHR32 *in, VkCopyAccelerationStructureToMemoryInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkBufferCopy_win32_to_host(const VkBufferCopy32 *in, VkBufferCopy *out)
{
    if (!in) return;

    out->srcOffset = in->srcOffset;
    out->dstOffset = in->dstOffset;
    out->size = in->size;
}

static const VkBufferCopy *convert_VkBufferCopy_array_win32_to_host(struct conversion_context *ctx, const VkBufferCopy32 *in, uint32_t count)
{
    VkBufferCopy *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferCopy_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkBufferCopy2_win32_to_host(const VkBufferCopy232 *in, VkBufferCopy2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcOffset = in->srcOffset;
    out->dstOffset = in->dstOffset;
    out->size = in->size;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkBufferCopy2 *convert_VkBufferCopy2_array_win32_to_host(struct conversion_context *ctx, const VkBufferCopy232 *in, uint32_t count)
{
    VkBufferCopy2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferCopy2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCopyBufferInfo2_win32_to_host(struct conversion_context *ctx, const VkCopyBufferInfo232 *in, VkCopyBufferInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcBuffer = in->srcBuffer;
    out->dstBuffer = in->dstBuffer;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkBufferCopy2_array_win32_to_host(ctx, (const VkBufferCopy232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkBufferImageCopy_win32_to_host(const VkBufferImageCopy32 *in, VkBufferImageCopy *out)
{
    if (!in) return;

    out->bufferOffset = in->bufferOffset;
    out->bufferRowLength = in->bufferRowLength;
    out->bufferImageHeight = in->bufferImageHeight;
    out->imageSubresource = in->imageSubresource;
    out->imageOffset = in->imageOffset;
    out->imageExtent = in->imageExtent;
}

static const VkBufferImageCopy *convert_VkBufferImageCopy_array_win32_to_host(struct conversion_context *ctx, const VkBufferImageCopy32 *in, uint32_t count)
{
    VkBufferImageCopy *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferImageCopy_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkBufferImageCopy2_win32_to_host(struct conversion_context *ctx, const VkBufferImageCopy232 *in, VkBufferImageCopy2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->bufferOffset = in->bufferOffset;
    out->bufferRowLength = in->bufferRowLength;
    out->bufferImageHeight = in->bufferImageHeight;
    out->imageSubresource = in->imageSubresource;
    out->imageOffset = in->imageOffset;
    out->imageExtent = in->imageExtent;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {
            VkCopyCommandTransformInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCopyCommandTransformInfoQCOM32 *in_ext = (const VkCopyCommandTransformInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->transform = in_ext->transform;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkBufferImageCopy2 *convert_VkBufferImageCopy2_array_win32_to_host(struct conversion_context *ctx, const VkBufferImageCopy232 *in, uint32_t count)
{
    VkBufferImageCopy2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferImageCopy2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkCopyBufferToImageInfo2_win32_to_host(struct conversion_context *ctx, const VkCopyBufferToImageInfo232 *in, VkCopyBufferToImageInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcBuffer = in->srcBuffer;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkBufferImageCopy2_array_win32_to_host(ctx, (const VkBufferImageCopy232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkImageCopy2_win32_to_host(const VkImageCopy232 *in, VkImageCopy2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSubresource = in->srcSubresource;
    out->srcOffset = in->srcOffset;
    out->dstSubresource = in->dstSubresource;
    out->dstOffset = in->dstOffset;
    out->extent = in->extent;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkImageCopy2 *convert_VkImageCopy2_array_win32_to_host(struct conversion_context *ctx, const VkImageCopy232 *in, uint32_t count)
{
    VkImageCopy2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageCopy2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCopyImageInfo2_win32_to_host(struct conversion_context *ctx, const VkCopyImageInfo232 *in, VkCopyImageInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkImageCopy2_array_win32_to_host(ctx, (const VkImageCopy232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCopyImageToBufferInfo2_win32_to_host(struct conversion_context *ctx, const VkCopyImageToBufferInfo232 *in, VkCopyImageToBufferInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->dstBuffer = in->dstBuffer;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkBufferImageCopy2_array_win32_to_host(ctx, (const VkBufferImageCopy232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCopyMemoryToAccelerationStructureInfoKHR_win32_to_host(const VkCopyMemoryToAccelerationStructureInfoKHR32 *in, VkCopyMemoryToAccelerationStructureInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCopyMemoryToMicromapInfoEXT_win32_to_host(const VkCopyMemoryToMicromapInfoEXT32 *in, VkCopyMemoryToMicromapInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCopyMicromapInfoEXT_win32_to_host(const VkCopyMicromapInfoEXT32 *in, VkCopyMicromapInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCopyMicromapToMemoryInfoEXT_win32_to_host(const VkCopyMicromapToMemoryInfoEXT32 *in, VkCopyMicromapToMemoryInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->src = in->src;
    out->dst = in->dst;
    out->mode = in->mode;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkTensorCopyARM_win32_to_host(const VkTensorCopyARM32 *in, VkTensorCopyARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->dimensionCount = in->dimensionCount;
    out->pSrcOffset = UlongToPtr(in->pSrcOffset);
    out->pDstOffset = UlongToPtr(in->pDstOffset);
    out->pExtent = UlongToPtr(in->pExtent);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkTensorCopyARM *convert_VkTensorCopyARM_array_win32_to_host(struct conversion_context *ctx, const VkTensorCopyARM32 *in, uint32_t count)
{
    VkTensorCopyARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkTensorCopyARM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCopyTensorInfoARM_win32_to_host(struct conversion_context *ctx, const VkCopyTensorInfoARM32 *in, VkCopyTensorInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcTensor = in->srcTensor;
    out->dstTensor = in->dstTensor;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkTensorCopyARM_array_win32_to_host(ctx, (const VkTensorCopyARM32 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCuLaunchInfoNVX_win32_to_host(const VkCuLaunchInfoNVX32 *in, VkCuLaunchInfoNVX *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->function = in->function;
    out->gridDimX = in->gridDimX;
    out->gridDimY = in->gridDimY;
    out->gridDimZ = in->gridDimZ;
    out->blockDimX = in->blockDimX;
    out->blockDimY = in->blockDimY;
    out->blockDimZ = in->blockDimZ;
    out->sharedMemBytes = in->sharedMemBytes;
    out->paramCount = in->paramCount;
    out->pParams = UlongToPtr(in->pParams);
    out->extraCount = in->extraCount;
    out->pExtras = UlongToPtr(in->pExtras);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDebugMarkerMarkerInfoEXT_win32_to_host(const VkDebugMarkerMarkerInfoEXT32 *in, VkDebugMarkerMarkerInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pMarkerName = UlongToPtr(in->pMarkerName);
    memcpy(out->color, in->color, 4 * sizeof(float));
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_StdVideoAV1TileInfo_win32_to_host(const StdVideoAV1TileInfo32 *in, StdVideoAV1TileInfo *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->TileCols = in->TileCols;
    out->TileRows = in->TileRows;
    out->context_update_tile_id = in->context_update_tile_id;
    out->tile_size_bytes_minus_1 = in->tile_size_bytes_minus_1;
    memcpy(out->reserved1, in->reserved1, 7 * sizeof(uint8_t));
    out->pMiColStarts = UlongToPtr(in->pMiColStarts);
    out->pMiRowStarts = UlongToPtr(in->pMiRowStarts);
    out->pWidthInSbsMinus1 = UlongToPtr(in->pWidthInSbsMinus1);
    out->pHeightInSbsMinus1 = UlongToPtr(in->pHeightInSbsMinus1);
}

static const StdVideoAV1TileInfo *convert_StdVideoAV1TileInfo_array_win32_to_host(struct conversion_context *ctx, const StdVideoAV1TileInfo32 *in, uint32_t count)
{
    StdVideoAV1TileInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoAV1TileInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_StdVideoDecodeAV1PictureInfo_win32_to_host(struct conversion_context *ctx, const StdVideoDecodeAV1PictureInfo32 *in, StdVideoDecodeAV1PictureInfo *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->frame_type = in->frame_type;
    out->current_frame_id = in->current_frame_id;
    out->OrderHint = in->OrderHint;
    out->primary_ref_frame = in->primary_ref_frame;
    out->refresh_frame_flags = in->refresh_frame_flags;
    out->reserved1 = in->reserved1;
    out->interpolation_filter = in->interpolation_filter;
    out->TxMode = in->TxMode;
    out->delta_q_res = in->delta_q_res;
    out->delta_lf_res = in->delta_lf_res;
    memcpy(out->SkipModeFrame, in->SkipModeFrame, STD_VIDEO_AV1_SKIP_MODE_FRAMES * sizeof(uint8_t));
    out->coded_denom = in->coded_denom;
    memcpy(out->reserved2, in->reserved2, 3 * sizeof(uint8_t));
    memcpy(out->OrderHints, in->OrderHints, STD_VIDEO_AV1_NUM_REF_FRAMES * sizeof(uint8_t));
    memcpy(out->expectedFrameId, in->expectedFrameId, STD_VIDEO_AV1_NUM_REF_FRAMES * sizeof(uint32_t));
    out->pTileInfo = convert_StdVideoAV1TileInfo_array_win32_to_host(ctx, (const StdVideoAV1TileInfo32 *)UlongToPtr(in->pTileInfo), 1);
    out->pQuantization = UlongToPtr(in->pQuantization);
    out->pSegmentation = UlongToPtr(in->pSegmentation);
    out->pLoopFilter = UlongToPtr(in->pLoopFilter);
    out->pCDEF = UlongToPtr(in->pCDEF);
    out->pLoopRestoration = UlongToPtr(in->pLoopRestoration);
    out->pGlobalMotion = UlongToPtr(in->pGlobalMotion);
    out->pFilmGrain = UlongToPtr(in->pFilmGrain);
}

static const StdVideoDecodeAV1PictureInfo *convert_StdVideoDecodeAV1PictureInfo_array_win32_to_host(struct conversion_context *ctx, const StdVideoDecodeAV1PictureInfo32 *in, uint32_t count)
{
    StdVideoDecodeAV1PictureInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoDecodeAV1PictureInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_StdVideoDecodeVP9PictureInfo_win32_to_host(const StdVideoDecodeVP9PictureInfo32 *in, StdVideoDecodeVP9PictureInfo *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->profile = in->profile;
    out->frame_type = in->frame_type;
    out->frame_context_idx = in->frame_context_idx;
    out->reset_frame_context = in->reset_frame_context;
    out->refresh_frame_flags = in->refresh_frame_flags;
    out->ref_frame_sign_bias_mask = in->ref_frame_sign_bias_mask;
    out->interpolation_filter = in->interpolation_filter;
    out->base_q_idx = in->base_q_idx;
    out->delta_q_y_dc = in->delta_q_y_dc;
    out->delta_q_uv_dc = in->delta_q_uv_dc;
    out->delta_q_uv_ac = in->delta_q_uv_ac;
    out->tile_cols_log2 = in->tile_cols_log2;
    out->tile_rows_log2 = in->tile_rows_log2;
    memcpy(out->reserved1, in->reserved1, 3 * sizeof(uint16_t));
    out->pColorConfig = UlongToPtr(in->pColorConfig);
    out->pLoopFilter = UlongToPtr(in->pLoopFilter);
    out->pSegmentation = UlongToPtr(in->pSegmentation);
}

static const StdVideoDecodeVP9PictureInfo *convert_StdVideoDecodeVP9PictureInfo_array_win32_to_host(struct conversion_context *ctx, const StdVideoDecodeVP9PictureInfo32 *in, uint32_t count)
{
    StdVideoDecodeVP9PictureInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoDecodeVP9PictureInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoDecodeInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoDecodeInfoKHR32 *in, VkVideoDecodeInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->srcBuffer = in->srcBuffer;
    out->srcBufferOffset = in->srcBufferOffset;
    out->srcBufferRange = in->srcBufferRange;
    convert_VkVideoPictureResourceInfoKHR_win32_to_host(&in->dstPictureResource, &out->dstPictureResource);
    out->pSetupReferenceSlot = convert_VkVideoReferenceSlotInfoKHR_array_win32_to_host(ctx, (const VkVideoReferenceSlotInfoKHR32 *)UlongToPtr(in->pSetupReferenceSlot), 1);
    out->referenceSlotCount = in->referenceSlotCount;
    out->pReferenceSlots = convert_VkVideoReferenceSlotInfoKHR_array_win32_to_host(ctx, (const VkVideoReferenceSlotInfoKHR32 *)UlongToPtr(in->pReferenceSlots), in->referenceSlotCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR:
        {
            VkVideoDecodeAV1PictureInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeAV1PictureInfoKHR32 *in_ext = (const VkVideoDecodeAV1PictureInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pStdPictureInfo = convert_StdVideoDecodeAV1PictureInfo_array_win32_to_host(ctx, (const StdVideoDecodeAV1PictureInfo32 *)UlongToPtr(in_ext->pStdPictureInfo), 1);
            memcpy(out_ext->referenceNameSlotIndices, in_ext->referenceNameSlotIndices, VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR * sizeof(int32_t));
            out_ext->frameHeaderOffset = in_ext->frameHeaderOffset;
            out_ext->tileCount = in_ext->tileCount;
            out_ext->pTileOffsets = UlongToPtr(in_ext->pTileOffsets);
            out_ext->pTileSizes = UlongToPtr(in_ext->pTileSizes);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR:
        {
            VkVideoDecodeH264PictureInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeH264PictureInfoKHR32 *in_ext = (const VkVideoDecodeH264PictureInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pStdPictureInfo = UlongToPtr(in_ext->pStdPictureInfo);
            out_ext->sliceCount = in_ext->sliceCount;
            out_ext->pSliceOffsets = UlongToPtr(in_ext->pSliceOffsets);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR:
        {
            VkVideoDecodeVP9PictureInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeVP9PictureInfoKHR32 *in_ext = (const VkVideoDecodeVP9PictureInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pStdPictureInfo = convert_StdVideoDecodeVP9PictureInfo_array_win32_to_host(ctx, (const StdVideoDecodeVP9PictureInfo32 *)UlongToPtr(in_ext->pStdPictureInfo), 1);
            memcpy(out_ext->referenceNameSlotIndices, in_ext->referenceNameSlotIndices, VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR * sizeof(int32_t));
            out_ext->uncompressedHeaderOffset = in_ext->uncompressedHeaderOffset;
            out_ext->compressedHeaderOffset = in_ext->compressedHeaderOffset;
            out_ext->tilesOffset = in_ext->tilesOffset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR:
        {
            VkVideoInlineQueryInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoInlineQueryInfoKHR32 *in_ext = (const VkVideoInlineQueryInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->queryPool = in_ext->queryPool;
            out_ext->firstQuery = in_ext->firstQuery;
            out_ext->queryCount = in_ext->queryCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkDecompressMemoryRegionNV_win32_to_host(const VkDecompressMemoryRegionNV32 *in, VkDecompressMemoryRegionNV *out)
{
    if (!in) return;

    out->srcAddress = in->srcAddress;
    out->dstAddress = in->dstAddress;
    out->compressedSize = in->compressedSize;
    out->decompressedSize = in->decompressedSize;
    out->decompressionMethod = in->decompressionMethod;
}

static const VkDecompressMemoryRegionNV *convert_VkDecompressMemoryRegionNV_array_win32_to_host(struct conversion_context *ctx, const VkDecompressMemoryRegionNV32 *in, uint32_t count)
{
    VkDecompressMemoryRegionNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDecompressMemoryRegionNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDataGraphPipelineDispatchInfoARM_win32_to_host(const VkDataGraphPipelineDispatchInfoARM32 *in, VkDataGraphPipelineDispatchInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDispatchTileInfoQCOM_win32_to_host(const VkDispatchTileInfoQCOM32 *in, VkDispatchTileInfoQCOM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_StdVideoEncodeAV1PictureInfo_win32_to_host(struct conversion_context *ctx, const StdVideoEncodeAV1PictureInfo32 *in, StdVideoEncodeAV1PictureInfo *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->frame_type = in->frame_type;
    out->frame_presentation_time = in->frame_presentation_time;
    out->current_frame_id = in->current_frame_id;
    out->order_hint = in->order_hint;
    out->primary_ref_frame = in->primary_ref_frame;
    out->refresh_frame_flags = in->refresh_frame_flags;
    out->coded_denom = in->coded_denom;
    out->render_width_minus_1 = in->render_width_minus_1;
    out->render_height_minus_1 = in->render_height_minus_1;
    out->interpolation_filter = in->interpolation_filter;
    out->TxMode = in->TxMode;
    out->delta_q_res = in->delta_q_res;
    out->delta_lf_res = in->delta_lf_res;
    memcpy(out->ref_order_hint, in->ref_order_hint, STD_VIDEO_AV1_NUM_REF_FRAMES * sizeof(uint8_t));
    memcpy(out->ref_frame_idx, in->ref_frame_idx, STD_VIDEO_AV1_REFS_PER_FRAME * sizeof(int8_t));
    memcpy(out->reserved1, in->reserved1, 3 * sizeof(uint8_t));
    memcpy(out->delta_frame_id_minus_1, in->delta_frame_id_minus_1, STD_VIDEO_AV1_REFS_PER_FRAME * sizeof(uint32_t));
    out->pTileInfo = convert_StdVideoAV1TileInfo_array_win32_to_host(ctx, (const StdVideoAV1TileInfo32 *)UlongToPtr(in->pTileInfo), 1);
    out->pQuantization = UlongToPtr(in->pQuantization);
    out->pSegmentation = UlongToPtr(in->pSegmentation);
    out->pLoopFilter = UlongToPtr(in->pLoopFilter);
    out->pCDEF = UlongToPtr(in->pCDEF);
    out->pLoopRestoration = UlongToPtr(in->pLoopRestoration);
    out->pGlobalMotion = UlongToPtr(in->pGlobalMotion);
    out->pExtensionHeader = UlongToPtr(in->pExtensionHeader);
    out->pBufferRemovalTimes = UlongToPtr(in->pBufferRemovalTimes);
}

static const StdVideoEncodeAV1PictureInfo *convert_StdVideoEncodeAV1PictureInfo_array_win32_to_host(struct conversion_context *ctx, const StdVideoEncodeAV1PictureInfo32 *in, uint32_t count)
{
    StdVideoEncodeAV1PictureInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoEncodeAV1PictureInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_StdVideoEncodeH264SliceHeader_win32_to_host(const StdVideoEncodeH264SliceHeader32 *in, StdVideoEncodeH264SliceHeader *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->first_mb_in_slice = in->first_mb_in_slice;
    out->slice_type = in->slice_type;
    out->slice_alpha_c0_offset_div2 = in->slice_alpha_c0_offset_div2;
    out->slice_beta_offset_div2 = in->slice_beta_offset_div2;
    out->slice_qp_delta = in->slice_qp_delta;
    out->reserved1 = in->reserved1;
    out->cabac_init_idc = in->cabac_init_idc;
    out->disable_deblocking_filter_idc = in->disable_deblocking_filter_idc;
    out->pWeightTable = UlongToPtr(in->pWeightTable);
}

static const StdVideoEncodeH264SliceHeader *convert_StdVideoEncodeH264SliceHeader_array_win32_to_host(struct conversion_context *ctx, const StdVideoEncodeH264SliceHeader32 *in, uint32_t count)
{
    StdVideoEncodeH264SliceHeader *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoEncodeH264SliceHeader_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoEncodeH264NaluSliceInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoEncodeH264NaluSliceInfoKHR32 *in, VkVideoEncodeH264NaluSliceInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->constantQp = in->constantQp;
    out->pStdSliceHeader = convert_StdVideoEncodeH264SliceHeader_array_win32_to_host(ctx, (const StdVideoEncodeH264SliceHeader32 *)UlongToPtr(in->pStdSliceHeader), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkVideoEncodeH264NaluSliceInfoKHR *convert_VkVideoEncodeH264NaluSliceInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkVideoEncodeH264NaluSliceInfoKHR32 *in, uint32_t count)
{
    VkVideoEncodeH264NaluSliceInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVideoEncodeH264NaluSliceInfoKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_StdVideoEncodeH264ReferenceListsInfo_win32_to_host(const StdVideoEncodeH264ReferenceListsInfo32 *in, StdVideoEncodeH264ReferenceListsInfo *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->num_ref_idx_l0_active_minus1 = in->num_ref_idx_l0_active_minus1;
    out->num_ref_idx_l1_active_minus1 = in->num_ref_idx_l1_active_minus1;
    memcpy(out->RefPicList0, in->RefPicList0, STD_VIDEO_H264_MAX_NUM_LIST_REF * sizeof(uint8_t));
    memcpy(out->RefPicList1, in->RefPicList1, STD_VIDEO_H264_MAX_NUM_LIST_REF * sizeof(uint8_t));
    out->refList0ModOpCount = in->refList0ModOpCount;
    out->refList1ModOpCount = in->refList1ModOpCount;
    out->refPicMarkingOpCount = in->refPicMarkingOpCount;
    memcpy(out->reserved1, in->reserved1, 7 * sizeof(uint8_t));
    out->pRefList0ModOperations = UlongToPtr(in->pRefList0ModOperations);
    out->pRefList1ModOperations = UlongToPtr(in->pRefList1ModOperations);
    out->pRefPicMarkingOperations = UlongToPtr(in->pRefPicMarkingOperations);
}

static const StdVideoEncodeH264ReferenceListsInfo *convert_StdVideoEncodeH264ReferenceListsInfo_array_win32_to_host(struct conversion_context *ctx, const StdVideoEncodeH264ReferenceListsInfo32 *in, uint32_t count)
{
    StdVideoEncodeH264ReferenceListsInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoEncodeH264ReferenceListsInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_StdVideoEncodeH264PictureInfo_win32_to_host(struct conversion_context *ctx, const StdVideoEncodeH264PictureInfo32 *in, StdVideoEncodeH264PictureInfo *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->seq_parameter_set_id = in->seq_parameter_set_id;
    out->pic_parameter_set_id = in->pic_parameter_set_id;
    out->idr_pic_id = in->idr_pic_id;
    out->primary_pic_type = in->primary_pic_type;
    out->frame_num = in->frame_num;
    out->PicOrderCnt = in->PicOrderCnt;
    out->temporal_id = in->temporal_id;
    memcpy(out->reserved1, in->reserved1, 3 * sizeof(uint8_t));
    out->pRefLists = convert_StdVideoEncodeH264ReferenceListsInfo_array_win32_to_host(ctx, (const StdVideoEncodeH264ReferenceListsInfo32 *)UlongToPtr(in->pRefLists), 1);
}

static const StdVideoEncodeH264PictureInfo *convert_StdVideoEncodeH264PictureInfo_array_win32_to_host(struct conversion_context *ctx, const StdVideoEncodeH264PictureInfo32 *in, uint32_t count)
{
    StdVideoEncodeH264PictureInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoEncodeH264PictureInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoEncodeInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoEncodeInfoKHR32 *in, VkVideoEncodeInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->dstBuffer = in->dstBuffer;
    out->dstBufferOffset = in->dstBufferOffset;
    out->dstBufferRange = in->dstBufferRange;
    convert_VkVideoPictureResourceInfoKHR_win32_to_host(&in->srcPictureResource, &out->srcPictureResource);
    out->pSetupReferenceSlot = convert_VkVideoReferenceSlotInfoKHR_array_win32_to_host(ctx, (const VkVideoReferenceSlotInfoKHR32 *)UlongToPtr(in->pSetupReferenceSlot), 1);
    out->referenceSlotCount = in->referenceSlotCount;
    out->pReferenceSlots = convert_VkVideoReferenceSlotInfoKHR_array_win32_to_host(ctx, (const VkVideoReferenceSlotInfoKHR32 *)UlongToPtr(in->pReferenceSlots), in->referenceSlotCount);
    out->precedingExternallyEncodedBytes = in->precedingExternallyEncodedBytes;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR:
        {
            VkVideoEncodeAV1PictureInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeAV1PictureInfoKHR32 *in_ext = (const VkVideoEncodeAV1PictureInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->predictionMode = in_ext->predictionMode;
            out_ext->rateControlGroup = in_ext->rateControlGroup;
            out_ext->constantQIndex = in_ext->constantQIndex;
            out_ext->pStdPictureInfo = convert_StdVideoEncodeAV1PictureInfo_array_win32_to_host(ctx, (const StdVideoEncodeAV1PictureInfo32 *)UlongToPtr(in_ext->pStdPictureInfo), 1);
            memcpy(out_ext->referenceNameSlotIndices, in_ext->referenceNameSlotIndices, VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR * sizeof(int32_t));
            out_ext->primaryReferenceCdfOnly = in_ext->primaryReferenceCdfOnly;
            out_ext->generateObuExtensionHeader = in_ext->generateObuExtensionHeader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR:
        {
            VkVideoEncodeH264PictureInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264PictureInfoKHR32 *in_ext = (const VkVideoEncodeH264PictureInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->naluSliceEntryCount = in_ext->naluSliceEntryCount;
            out_ext->pNaluSliceEntries = convert_VkVideoEncodeH264NaluSliceInfoKHR_array_win32_to_host(ctx, (const VkVideoEncodeH264NaluSliceInfoKHR32 *)UlongToPtr(in_ext->pNaluSliceEntries), in_ext->naluSliceEntryCount);
            out_ext->pStdPictureInfo = convert_StdVideoEncodeH264PictureInfo_array_win32_to_host(ctx, (const StdVideoEncodeH264PictureInfo32 *)UlongToPtr(in_ext->pStdPictureInfo), 1);
            out_ext->generatePrefixNalu = in_ext->generatePrefixNalu;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR:
        {
            VkVideoEncodeIntraRefreshInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeIntraRefreshInfoKHR32 *in_ext = (const VkVideoEncodeIntraRefreshInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->intraRefreshCycleDuration = in_ext->intraRefreshCycleDuration;
            out_ext->intraRefreshIndex = in_ext->intraRefreshIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR:
        {
            VkVideoEncodeQuantizationMapInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeQuantizationMapInfoKHR32 *in_ext = (const VkVideoEncodeQuantizationMapInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->quantizationMap = in_ext->quantizationMap;
            out_ext->quantizationMapExtent = in_ext->quantizationMapExtent;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR:
        {
            VkVideoInlineQueryInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoInlineQueryInfoKHR32 *in_ext = (const VkVideoInlineQueryInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->queryPool = in_ext->queryPool;
            out_ext->firstQuery = in_ext->firstQuery;
            out_ext->queryCount = in_ext->queryCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkPerTileEndInfoQCOM_win32_to_host(const VkPerTileEndInfoQCOM32 *in, VkPerTileEndInfoQCOM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkSubpassEndInfo_win32_to_host(struct conversion_context *ctx, const VkSubpassEndInfo32 *in, VkSubpassEndInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT:
        {
            VkRenderPassFragmentDensityMapOffsetEndInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassFragmentDensityMapOffsetEndInfoEXT32 *in_ext = (const VkRenderPassFragmentDensityMapOffsetEndInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityOffsetCount = in_ext->fragmentDensityOffsetCount;
            out_ext->pFragmentDensityOffsets = UlongToPtr(in_ext->pFragmentDensityOffsets);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkRenderingEndInfoEXT_win32_to_host(struct conversion_context *ctx, const VkRenderingEndInfoEXT32 *in, VkRenderingEndInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT:
        {
            VkRenderPassFragmentDensityMapOffsetEndInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassFragmentDensityMapOffsetEndInfoEXT32 *in_ext = (const VkRenderPassFragmentDensityMapOffsetEndInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityOffsetCount = in_ext->fragmentDensityOffsetCount;
            out_ext->pFragmentDensityOffsets = UlongToPtr(in_ext->pFragmentDensityOffsets);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkVideoEndCodingInfoKHR_win32_to_host(const VkVideoEndCodingInfoKHR32 *in, VkVideoEndCodingInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static const VkCommandBuffer *convert_VkCommandBuffer_array_win64_to_host(struct conversion_context *ctx, const VkCommandBuffer *in, uint32_t count)
{
    VkCommandBuffer *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_command_buffer_from_handle(in[i])->host.command_buffer;
    }

    return out;
}
#endif /* _WIN64 */

static const VkCommandBuffer *convert_VkCommandBuffer_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkCommandBuffer *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_command_buffer_from_handle(UlongToPtr(in[i]))->host.command_buffer;
    }

    return out;
}

static void convert_VkGeneratedCommandsInfoEXT_win32_to_host(struct conversion_context *ctx, const VkGeneratedCommandsInfoEXT32 *in, VkGeneratedCommandsInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->shaderStages = in->shaderStages;
    out->indirectExecutionSet = in->indirectExecutionSet;
    out->indirectCommandsLayout = in->indirectCommandsLayout;
    out->indirectAddress = in->indirectAddress;
    out->indirectAddressSize = in->indirectAddressSize;
    out->preprocessAddress = in->preprocessAddress;
    out->preprocessSize = in->preprocessSize;
    out->maxSequenceCount = in->maxSequenceCount;
    out->sequenceCountAddress = in->sequenceCountAddress;
    out->maxDrawCount = in->maxDrawCount;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT:
        {
            VkGeneratedCommandsPipelineInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGeneratedCommandsPipelineInfoEXT32 *in_ext = (const VkGeneratedCommandsPipelineInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->pipeline = in_ext->pipeline;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT:
        {
            VkGeneratedCommandsShaderInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGeneratedCommandsShaderInfoEXT32 *in_ext = (const VkGeneratedCommandsShaderInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderCount = in_ext->shaderCount;
            out_ext->pShaders = UlongToPtr(in_ext->pShaders);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkIndirectCommandsStreamNV_win32_to_host(const VkIndirectCommandsStreamNV32 *in, VkIndirectCommandsStreamNV *out)
{
    if (!in) return;

    out->buffer = in->buffer;
    out->offset = in->offset;
}

static const VkIndirectCommandsStreamNV *convert_VkIndirectCommandsStreamNV_array_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsStreamNV32 *in, uint32_t count)
{
    VkIndirectCommandsStreamNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkIndirectCommandsStreamNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkGeneratedCommandsInfoNV_win32_to_host(struct conversion_context *ctx, const VkGeneratedCommandsInfoNV32 *in, VkGeneratedCommandsInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->pipeline = in->pipeline;
    out->indirectCommandsLayout = in->indirectCommandsLayout;
    out->streamCount = in->streamCount;
    out->pStreams = convert_VkIndirectCommandsStreamNV_array_win32_to_host(ctx, (const VkIndirectCommandsStreamNV32 *)UlongToPtr(in->pStreams), in->streamCount);
    out->sequencesCount = in->sequencesCount;
    out->preprocessBuffer = in->preprocessBuffer;
    out->preprocessOffset = in->preprocessOffset;
    out->preprocessSize = in->preprocessSize;
    out->sequencesCountBuffer = in->sequencesCountBuffer;
    out->sequencesCountOffset = in->sequencesCountOffset;
    out->sequencesIndexBuffer = in->sequencesIndexBuffer;
    out->sequencesIndexOffset = in->sequencesIndexOffset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkOpticalFlowExecuteInfoNV_win32_to_host(const VkOpticalFlowExecuteInfoNV32 *in, VkOpticalFlowExecuteInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->regionCount = in->regionCount;
    out->pRegions = UlongToPtr(in->pRegions);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMemoryBarrier_win32_to_host(const VkMemoryBarrier32 *in, VkMemoryBarrier *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcAccessMask = in->srcAccessMask;
    out->dstAccessMask = in->dstAccessMask;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkMemoryBarrier *convert_VkMemoryBarrier_array_win32_to_host(struct conversion_context *ctx, const VkMemoryBarrier32 *in, uint32_t count)
{
    VkMemoryBarrier *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMemoryBarrier_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkBufferMemoryBarrier_win32_to_host(struct conversion_context *ctx, const VkBufferMemoryBarrier32 *in, VkBufferMemoryBarrier *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcAccessMask = in->srcAccessMask;
    out->dstAccessMask = in->dstAccessMask;
    out->srcQueueFamilyIndex = in->srcQueueFamilyIndex;
    out->dstQueueFamilyIndex = in->dstQueueFamilyIndex;
    out->buffer = in->buffer;
    out->offset = in->offset;
    out->size = in->size;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
            VkExternalMemoryAcquireUnmodifiedEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryAcquireUnmodifiedEXT32 *in_ext = (const VkExternalMemoryAcquireUnmodifiedEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT;
            out_ext->pNext = NULL;
            out_ext->acquireUnmodifiedMemory = in_ext->acquireUnmodifiedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkBufferMemoryBarrier *convert_VkBufferMemoryBarrier_array_win32_to_host(struct conversion_context *ctx, const VkBufferMemoryBarrier32 *in, uint32_t count)
{
    VkBufferMemoryBarrier *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferMemoryBarrier_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkImageMemoryBarrier_win32_to_host(struct conversion_context *ctx, const VkImageMemoryBarrier32 *in, VkImageMemoryBarrier *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcAccessMask = in->srcAccessMask;
    out->dstAccessMask = in->dstAccessMask;
    out->oldLayout = in->oldLayout;
    out->newLayout = in->newLayout;
    out->srcQueueFamilyIndex = in->srcQueueFamilyIndex;
    out->dstQueueFamilyIndex = in->dstQueueFamilyIndex;
    out->image = in->image;
    out->subresourceRange = in->subresourceRange;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
            VkExternalMemoryAcquireUnmodifiedEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryAcquireUnmodifiedEXT32 *in_ext = (const VkExternalMemoryAcquireUnmodifiedEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT;
            out_ext->pNext = NULL;
            out_ext->acquireUnmodifiedMemory = in_ext->acquireUnmodifiedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            VkSampleLocationsInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSampleLocationsInfoEXT32 *in_ext = (const VkSampleLocationsInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->sampleLocationsPerPixel = in_ext->sampleLocationsPerPixel;
            out_ext->sampleLocationGridSize = in_ext->sampleLocationGridSize;
            out_ext->sampleLocationsCount = in_ext->sampleLocationsCount;
            out_ext->pSampleLocations = UlongToPtr(in_ext->pSampleLocations);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkImageMemoryBarrier *convert_VkImageMemoryBarrier_array_win32_to_host(struct conversion_context *ctx, const VkImageMemoryBarrier32 *in, uint32_t count)
{
    VkImageMemoryBarrier *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageMemoryBarrier_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkMemoryBarrier2_win32_to_host(const VkMemoryBarrier232 *in, VkMemoryBarrier2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcStageMask = in->srcStageMask;
    out->srcAccessMask = in->srcAccessMask;
    out->dstStageMask = in->dstStageMask;
    out->dstAccessMask = in->dstAccessMask;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkMemoryBarrier2 *convert_VkMemoryBarrier2_array_win32_to_host(struct conversion_context *ctx, const VkMemoryBarrier232 *in, uint32_t count)
{
    VkMemoryBarrier2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMemoryBarrier2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkBufferMemoryBarrier2_win32_to_host(struct conversion_context *ctx, const VkBufferMemoryBarrier232 *in, VkBufferMemoryBarrier2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcStageMask = in->srcStageMask;
    out->srcAccessMask = in->srcAccessMask;
    out->dstStageMask = in->dstStageMask;
    out->dstAccessMask = in->dstAccessMask;
    out->srcQueueFamilyIndex = in->srcQueueFamilyIndex;
    out->dstQueueFamilyIndex = in->dstQueueFamilyIndex;
    out->buffer = in->buffer;
    out->offset = in->offset;
    out->size = in->size;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
            VkExternalMemoryAcquireUnmodifiedEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryAcquireUnmodifiedEXT32 *in_ext = (const VkExternalMemoryAcquireUnmodifiedEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT;
            out_ext->pNext = NULL;
            out_ext->acquireUnmodifiedMemory = in_ext->acquireUnmodifiedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR:
        {
            VkMemoryBarrierAccessFlags3KHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryBarrierAccessFlags3KHR32 *in_ext = (const VkMemoryBarrierAccessFlags3KHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR;
            out_ext->pNext = NULL;
            out_ext->srcAccessMask3 = in_ext->srcAccessMask3;
            out_ext->dstAccessMask3 = in_ext->dstAccessMask3;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkBufferMemoryBarrier2 *convert_VkBufferMemoryBarrier2_array_win32_to_host(struct conversion_context *ctx, const VkBufferMemoryBarrier232 *in, uint32_t count)
{
    VkBufferMemoryBarrier2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferMemoryBarrier2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkImageMemoryBarrier2_win32_to_host(struct conversion_context *ctx, const VkImageMemoryBarrier232 *in, VkImageMemoryBarrier2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcStageMask = in->srcStageMask;
    out->srcAccessMask = in->srcAccessMask;
    out->dstStageMask = in->dstStageMask;
    out->dstAccessMask = in->dstAccessMask;
    out->oldLayout = in->oldLayout;
    out->newLayout = in->newLayout;
    out->srcQueueFamilyIndex = in->srcQueueFamilyIndex;
    out->dstQueueFamilyIndex = in->dstQueueFamilyIndex;
    out->image = in->image;
    out->subresourceRange = in->subresourceRange;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
        {
            VkExternalMemoryAcquireUnmodifiedEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryAcquireUnmodifiedEXT32 *in_ext = (const VkExternalMemoryAcquireUnmodifiedEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT;
            out_ext->pNext = NULL;
            out_ext->acquireUnmodifiedMemory = in_ext->acquireUnmodifiedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR:
        {
            VkMemoryBarrierAccessFlags3KHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryBarrierAccessFlags3KHR32 *in_ext = (const VkMemoryBarrierAccessFlags3KHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR;
            out_ext->pNext = NULL;
            out_ext->srcAccessMask3 = in_ext->srcAccessMask3;
            out_ext->dstAccessMask3 = in_ext->dstAccessMask3;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {
            VkSampleLocationsInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSampleLocationsInfoEXT32 *in_ext = (const VkSampleLocationsInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->sampleLocationsPerPixel = in_ext->sampleLocationsPerPixel;
            out_ext->sampleLocationGridSize = in_ext->sampleLocationGridSize;
            out_ext->sampleLocationsCount = in_ext->sampleLocationsCount;
            out_ext->pSampleLocations = UlongToPtr(in_ext->pSampleLocations);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkImageMemoryBarrier2 *convert_VkImageMemoryBarrier2_array_win32_to_host(struct conversion_context *ctx, const VkImageMemoryBarrier232 *in, uint32_t count)
{
    VkImageMemoryBarrier2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageMemoryBarrier2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkTensorMemoryBarrierARM_win32_to_host(const VkTensorMemoryBarrierARM32 *in, VkTensorMemoryBarrierARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcStageMask = in->srcStageMask;
    out->srcAccessMask = in->srcAccessMask;
    out->dstStageMask = in->dstStageMask;
    out->dstAccessMask = in->dstAccessMask;
    out->srcQueueFamilyIndex = in->srcQueueFamilyIndex;
    out->dstQueueFamilyIndex = in->dstQueueFamilyIndex;
    out->tensor = in->tensor;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkTensorMemoryBarrierARM *convert_VkTensorMemoryBarrierARM_array_win32_to_host(struct conversion_context *ctx, const VkTensorMemoryBarrierARM32 *in, uint32_t count)
{
    VkTensorMemoryBarrierARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkTensorMemoryBarrierARM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDependencyInfo_win32_to_host(struct conversion_context *ctx, const VkDependencyInfo32 *in, VkDependencyInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->dependencyFlags = in->dependencyFlags;
    out->memoryBarrierCount = in->memoryBarrierCount;
    out->pMemoryBarriers = convert_VkMemoryBarrier2_array_win32_to_host(ctx, (const VkMemoryBarrier232 *)UlongToPtr(in->pMemoryBarriers), in->memoryBarrierCount);
    out->bufferMemoryBarrierCount = in->bufferMemoryBarrierCount;
    out->pBufferMemoryBarriers = convert_VkBufferMemoryBarrier2_array_win32_to_host(ctx, (const VkBufferMemoryBarrier232 *)UlongToPtr(in->pBufferMemoryBarriers), in->bufferMemoryBarrierCount);
    out->imageMemoryBarrierCount = in->imageMemoryBarrierCount;
    out->pImageMemoryBarriers = convert_VkImageMemoryBarrier2_array_win32_to_host(ctx, (const VkImageMemoryBarrier232 *)UlongToPtr(in->pImageMemoryBarriers), in->imageMemoryBarrierCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM:
        {
            VkTensorDependencyInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTensorDependencyInfoARM32 *in_ext = (const VkTensorDependencyInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorMemoryBarrierCount = in_ext->tensorMemoryBarrierCount;
            out_ext->pTensorMemoryBarriers = convert_VkTensorMemoryBarrierARM_array_win32_to_host(ctx, (const VkTensorMemoryBarrierARM32 *)UlongToPtr(in_ext->pTensorMemoryBarriers), 1);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM:
        {
            VkTensorMemoryBarrierARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTensorMemoryBarrierARM32 *in_ext = (const VkTensorMemoryBarrierARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM;
            out_ext->pNext = NULL;
            out_ext->srcStageMask = in_ext->srcStageMask;
            out_ext->srcAccessMask = in_ext->srcAccessMask;
            out_ext->dstStageMask = in_ext->dstStageMask;
            out_ext->dstAccessMask = in_ext->dstAccessMask;
            out_ext->srcQueueFamilyIndex = in_ext->srcQueueFamilyIndex;
            out_ext->dstQueueFamilyIndex = in_ext->dstQueueFamilyIndex;
            out_ext->tensor = in_ext->tensor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkPushConstantsInfo_win32_to_host(struct conversion_context *ctx, const VkPushConstantsInfo32 *in, VkPushConstantsInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->layout = in->layout;
    out->stageFlags = in->stageFlags;
    out->offset = in->offset;
    out->size = in->size;
    out->pValues = UlongToPtr(in->pValues);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {
            VkPipelineLayoutCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLayoutCreateInfo32 *in_ext = (const VkPipelineLayoutCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->setLayoutCount = in_ext->setLayoutCount;
            out_ext->pSetLayouts = UlongToPtr(in_ext->pSetLayouts);
            out_ext->pushConstantRangeCount = in_ext->pushConstantRangeCount;
            out_ext->pPushConstantRanges = UlongToPtr(in_ext->pPushConstantRanges);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkDescriptorImageInfo_win32_to_host(const VkDescriptorImageInfo32 *in, VkDescriptorImageInfo *out)
{
    if (!in) return;

    out->sampler = in->sampler;
    out->imageView = in->imageView;
    out->imageLayout = in->imageLayout;
}

static const VkDescriptorImageInfo *convert_VkDescriptorImageInfo_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorImageInfo32 *in, uint32_t count)
{
    VkDescriptorImageInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorImageInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDescriptorBufferInfo_win32_to_host(const VkDescriptorBufferInfo32 *in, VkDescriptorBufferInfo *out)
{
    if (!in) return;

    out->buffer = in->buffer;
    out->offset = in->offset;
    out->range = in->range;
}

static const VkDescriptorBufferInfo *convert_VkDescriptorBufferInfo_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorBufferInfo32 *in, uint32_t count)
{
    VkDescriptorBufferInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorBufferInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkWriteDescriptorSet_win32_to_host(struct conversion_context *ctx, const VkWriteDescriptorSet32 *in, VkWriteDescriptorSet *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->dstSet = in->dstSet;
    out->dstBinding = in->dstBinding;
    out->dstArrayElement = in->dstArrayElement;
    out->descriptorCount = in->descriptorCount;
    out->descriptorType = in->descriptorType;
    out->pImageInfo = convert_VkDescriptorImageInfo_array_win32_to_host(ctx, (const VkDescriptorImageInfo32 *)UlongToPtr(in->pImageInfo), in->descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER || in->descriptorType == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER || in->descriptorType == VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE || in->descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE || in->descriptorType == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT || in->descriptorType == VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM || in->descriptorType == VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM ? in->descriptorCount : 0);
    out->pBufferInfo = convert_VkDescriptorBufferInfo_array_win32_to_host(ctx, (const VkDescriptorBufferInfo32 *)UlongToPtr(in->pBufferInfo), in->descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER || in->descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER || in->descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC || in->descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC ? in->descriptorCount : 0);
    out->pTexelBufferView = UlongToPtr(in->pTexelBufferView);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {
            VkWriteDescriptorSetAccelerationStructureKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWriteDescriptorSetAccelerationStructureKHR32 *in_ext = (const VkWriteDescriptorSetAccelerationStructureKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR;
            out_ext->pNext = NULL;
            out_ext->accelerationStructureCount = in_ext->accelerationStructureCount;
            out_ext->pAccelerationStructures = UlongToPtr(in_ext->pAccelerationStructures);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {
            VkWriteDescriptorSetAccelerationStructureNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWriteDescriptorSetAccelerationStructureNV32 *in_ext = (const VkWriteDescriptorSetAccelerationStructureNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV;
            out_ext->pNext = NULL;
            out_ext->accelerationStructureCount = in_ext->accelerationStructureCount;
            out_ext->pAccelerationStructures = UlongToPtr(in_ext->pAccelerationStructures);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
        {
            VkWriteDescriptorSetInlineUniformBlock *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWriteDescriptorSetInlineUniformBlock32 *in_ext = (const VkWriteDescriptorSetInlineUniformBlock32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK;
            out_ext->pNext = NULL;
            out_ext->dataSize = in_ext->dataSize;
            out_ext->pData = UlongToPtr(in_ext->pData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV:
        {
            VkWriteDescriptorSetPartitionedAccelerationStructureNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWriteDescriptorSetPartitionedAccelerationStructureNV32 *in_ext = (const VkWriteDescriptorSetPartitionedAccelerationStructureNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV;
            out_ext->pNext = NULL;
            out_ext->accelerationStructureCount = in_ext->accelerationStructureCount;
            out_ext->pAccelerationStructures = UlongToPtr(in_ext->pAccelerationStructures);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM:
        {
            VkWriteDescriptorSetTensorARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWriteDescriptorSetTensorARM32 *in_ext = (const VkWriteDescriptorSetTensorARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorViewCount = in_ext->tensorViewCount;
            out_ext->pTensorViews = UlongToPtr(in_ext->pTensorViews);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkWriteDescriptorSet *convert_VkWriteDescriptorSet_array_win32_to_host(struct conversion_context *ctx, const VkWriteDescriptorSet32 *in, uint32_t count)
{
    VkWriteDescriptorSet *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkWriteDescriptorSet_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPushDescriptorSetInfo_win32_to_host(struct conversion_context *ctx, const VkPushDescriptorSetInfo32 *in, VkPushDescriptorSetInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->stageFlags = in->stageFlags;
    out->layout = in->layout;
    out->set = in->set;
    out->descriptorWriteCount = in->descriptorWriteCount;
    out->pDescriptorWrites = convert_VkWriteDescriptorSet_array_win32_to_host(ctx, (const VkWriteDescriptorSet32 *)UlongToPtr(in->pDescriptorWrites), in->descriptorWriteCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {
            VkPipelineLayoutCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLayoutCreateInfo32 *in_ext = (const VkPipelineLayoutCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->setLayoutCount = in_ext->setLayoutCount;
            out_ext->pSetLayouts = UlongToPtr(in_ext->pSetLayouts);
            out_ext->pushConstantRangeCount = in_ext->pushConstantRangeCount;
            out_ext->pPushConstantRanges = UlongToPtr(in_ext->pPushConstantRanges);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkPushDescriptorSetWithTemplateInfo_win32_to_host(struct conversion_context *ctx, const VkPushDescriptorSetWithTemplateInfo32 *in, VkPushDescriptorSetWithTemplateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->descriptorUpdateTemplate = in->descriptorUpdateTemplate;
    out->layout = in->layout;
    out->set = in->set;
    out->pData = UlongToPtr(in->pData);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {
            VkPipelineLayoutCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLayoutCreateInfo32 *in_ext = (const VkPipelineLayoutCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->setLayoutCount = in_ext->setLayoutCount;
            out_ext->pSetLayouts = UlongToPtr(in_ext->pSetLayouts);
            out_ext->pushConstantRangeCount = in_ext->pushConstantRangeCount;
            out_ext->pPushConstantRanges = UlongToPtr(in_ext->pPushConstantRanges);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkImageResolve2_win32_to_host(const VkImageResolve232 *in, VkImageResolve2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSubresource = in->srcSubresource;
    out->srcOffset = in->srcOffset;
    out->dstSubresource = in->dstSubresource;
    out->dstOffset = in->dstOffset;
    out->extent = in->extent;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkImageResolve2 *convert_VkImageResolve2_array_win32_to_host(struct conversion_context *ctx, const VkImageResolve232 *in, uint32_t count)
{
    VkImageResolve2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageResolve2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkResolveImageInfo2_win32_to_host(struct conversion_context *ctx, const VkResolveImageInfo232 *in, VkResolveImageInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkImageResolve2_array_win32_to_host(ctx, (const VkImageResolve232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCoarseSampleOrderCustomNV_win32_to_host(const VkCoarseSampleOrderCustomNV32 *in, VkCoarseSampleOrderCustomNV *out)
{
    if (!in) return;

    out->shadingRate = in->shadingRate;
    out->sampleCount = in->sampleCount;
    out->sampleLocationCount = in->sampleLocationCount;
    out->pSampleLocations = UlongToPtr(in->pSampleLocations);
}

static const VkCoarseSampleOrderCustomNV *convert_VkCoarseSampleOrderCustomNV_array_win32_to_host(struct conversion_context *ctx, const VkCoarseSampleOrderCustomNV32 *in, uint32_t count)
{
    VkCoarseSampleOrderCustomNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCoarseSampleOrderCustomNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDepthBiasInfoEXT_win32_to_host(struct conversion_context *ctx, const VkDepthBiasInfoEXT32 *in, VkDepthBiasInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->depthBiasConstantFactor = in->depthBiasConstantFactor;
    out->depthBiasClamp = in->depthBiasClamp;
    out->depthBiasSlopeFactor = in->depthBiasSlopeFactor;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
        {
            VkDepthBiasRepresentationInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDepthBiasRepresentationInfoEXT32 *in_ext = (const VkDepthBiasRepresentationInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->depthBiasRepresentation = in_ext->depthBiasRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkSetDescriptorBufferOffsetsInfoEXT_win32_to_host(struct conversion_context *ctx, const VkSetDescriptorBufferOffsetsInfoEXT32 *in, VkSetDescriptorBufferOffsetsInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->stageFlags = in->stageFlags;
    out->layout = in->layout;
    out->firstSet = in->firstSet;
    out->setCount = in->setCount;
    out->pBufferIndices = UlongToPtr(in->pBufferIndices);
    out->pOffsets = UlongToPtr(in->pOffsets);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {
            VkPipelineLayoutCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLayoutCreateInfo32 *in_ext = (const VkPipelineLayoutCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->setLayoutCount = in_ext->setLayoutCount;
            out_ext->pSetLayouts = UlongToPtr(in_ext->pSetLayouts);
            out_ext->pushConstantRangeCount = in_ext->pushConstantRangeCount;
            out_ext->pPushConstantRanges = UlongToPtr(in_ext->pPushConstantRanges);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkPerformanceMarkerInfoINTEL_win32_to_host(const VkPerformanceMarkerInfoINTEL32 *in, VkPerformanceMarkerInfoINTEL *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->marker = in->marker;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPerformanceOverrideInfoINTEL_win32_to_host(const VkPerformanceOverrideInfoINTEL32 *in, VkPerformanceOverrideInfoINTEL *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->enable = in->enable;
    out->parameter = in->parameter;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPerformanceStreamMarkerInfoINTEL_win32_to_host(const VkPerformanceStreamMarkerInfoINTEL32 *in, VkPerformanceStreamMarkerInfoINTEL *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->marker = in->marker;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkRenderingAttachmentLocationInfo_win32_to_host(const VkRenderingAttachmentLocationInfo32 *in, VkRenderingAttachmentLocationInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->colorAttachmentCount = in->colorAttachmentCount;
    out->pColorAttachmentLocations = UlongToPtr(in->pColorAttachmentLocations);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkRenderingInputAttachmentIndexInfo_win32_to_host(const VkRenderingInputAttachmentIndexInfo32 *in, VkRenderingInputAttachmentIndexInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->colorAttachmentCount = in->colorAttachmentCount;
    out->pColorAttachmentInputIndices = UlongToPtr(in->pColorAttachmentInputIndices);
    out->pDepthInputAttachmentIndex = UlongToPtr(in->pDepthInputAttachmentIndex);
    out->pStencilInputAttachmentIndex = UlongToPtr(in->pStencilInputAttachmentIndex);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkVertexInputBindingDescription2EXT_win32_to_host(const VkVertexInputBindingDescription2EXT32 *in, VkVertexInputBindingDescription2EXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->binding = in->binding;
    out->stride = in->stride;
    out->inputRate = in->inputRate;
    out->divisor = in->divisor;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkVertexInputBindingDescription2EXT *convert_VkVertexInputBindingDescription2EXT_array_win32_to_host(struct conversion_context *ctx, const VkVertexInputBindingDescription2EXT32 *in, uint32_t count)
{
    VkVertexInputBindingDescription2EXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVertexInputBindingDescription2EXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkVertexInputAttributeDescription2EXT_win32_to_host(const VkVertexInputAttributeDescription2EXT32 *in, VkVertexInputAttributeDescription2EXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->location = in->location;
    out->binding = in->binding;
    out->format = in->format;
    out->offset = in->offset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkVertexInputAttributeDescription2EXT *convert_VkVertexInputAttributeDescription2EXT_array_win32_to_host(struct conversion_context *ctx, const VkVertexInputAttributeDescription2EXT32 *in, uint32_t count)
{
    VkVertexInputAttributeDescription2EXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVertexInputAttributeDescription2EXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkShadingRatePaletteNV_win32_to_host(const VkShadingRatePaletteNV32 *in, VkShadingRatePaletteNV *out)
{
    if (!in) return;

    out->shadingRatePaletteEntryCount = in->shadingRatePaletteEntryCount;
    out->pShadingRatePaletteEntries = UlongToPtr(in->pShadingRatePaletteEntries);
}

static const VkShadingRatePaletteNV *convert_VkShadingRatePaletteNV_array_win32_to_host(struct conversion_context *ctx, const VkShadingRatePaletteNV32 *in, uint32_t count)
{
    VkShadingRatePaletteNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkShadingRatePaletteNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static const VkDependencyInfo *convert_VkDependencyInfo_array_win32_to_host(struct conversion_context *ctx, const VkDependencyInfo32 *in, uint32_t count)
{
    VkDependencyInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDependencyInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkCopyImageToImageInfo_win32_to_host(struct conversion_context *ctx, const VkCopyImageToImageInfo32 *in, VkCopyImageToImageInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkImageCopy2_array_win32_to_host(ctx, (const VkImageCopy232 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkImageToMemoryCopy_win32_to_host(const VkImageToMemoryCopy32 *in, VkImageToMemoryCopy *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pHostPointer = UlongToPtr(in->pHostPointer);
    out->memoryRowLength = in->memoryRowLength;
    out->memoryImageHeight = in->memoryImageHeight;
    out->imageSubresource = in->imageSubresource;
    out->imageOffset = in->imageOffset;
    out->imageExtent = in->imageExtent;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkImageToMemoryCopy *convert_VkImageToMemoryCopy_array_win32_to_host(struct conversion_context *ctx, const VkImageToMemoryCopy32 *in, uint32_t count)
{
    VkImageToMemoryCopy *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageToMemoryCopy_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCopyImageToMemoryInfo_win32_to_host(struct conversion_context *ctx, const VkCopyImageToMemoryInfo32 *in, VkCopyImageToMemoryInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->srcImage = in->srcImage;
    out->srcImageLayout = in->srcImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkImageToMemoryCopy_array_win32_to_host(ctx, (const VkImageToMemoryCopy32 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMemoryToImageCopy_win32_to_host(const VkMemoryToImageCopy32 *in, VkMemoryToImageCopy *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pHostPointer = UlongToPtr(in->pHostPointer);
    out->memoryRowLength = in->memoryRowLength;
    out->memoryImageHeight = in->memoryImageHeight;
    out->imageSubresource = in->imageSubresource;
    out->imageOffset = in->imageOffset;
    out->imageExtent = in->imageExtent;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkMemoryToImageCopy *convert_VkMemoryToImageCopy_array_win32_to_host(struct conversion_context *ctx, const VkMemoryToImageCopy32 *in, uint32_t count)
{
    VkMemoryToImageCopy *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMemoryToImageCopy_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCopyMemoryToImageInfo_win32_to_host(struct conversion_context *ctx, const VkCopyMemoryToImageInfo32 *in, VkCopyMemoryToImageInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->dstImage = in->dstImage;
    out->dstImageLayout = in->dstImageLayout;
    out->regionCount = in->regionCount;
    out->pRegions = convert_VkMemoryToImageCopy_array_win32_to_host(ctx, (const VkMemoryToImageCopy32 *)UlongToPtr(in->pRegions), in->regionCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkAccelerationStructureCreateInfoKHR_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureCreateInfoKHR32 *in, VkAccelerationStructureCreateInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->createFlags = in->createFlags;
    out->buffer = in->buffer;
    out->offset = in->offset;
    out->size = in->size;
    out->type = in->type;
    out->deviceAddress = in->deviceAddress;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
        {
            VkAccelerationStructureMotionInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAccelerationStructureMotionInfoNV32 *in_ext = (const VkAccelerationStructureMotionInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->maxInstances = in_ext->maxInstances;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkAccelerationStructureCreateInfoNV_win32_to_host(struct conversion_context *ctx, const VkAccelerationStructureCreateInfoNV32 *in, VkAccelerationStructureCreateInfoNV *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->compactedSize = in->compactedSize;
    convert_VkAccelerationStructureInfoNV_win32_to_host(ctx, &in->info, &out->info);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

#ifdef _WIN64
static void convert_VkBufferCreateInfo_win64_to_host(struct conversion_context *ctx, const VkBufferCreateInfo *in, VkBufferCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->size = in->size;
    out->usage = in->usage;
    out->sharingMode = in->sharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = in->pQueueFamilyIndices;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            VkBufferDeviceAddressCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferDeviceAddressCreateInfoEXT *in_ext = (const VkBufferDeviceAddressCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceAddress = in_ext->deviceAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            VkBufferOpaqueCaptureAddressCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferOpaqueCaptureAddressCreateInfo *in_ext = (const VkBufferOpaqueCaptureAddressCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureAddress = in_ext->opaqueCaptureAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
        {
            VkBufferUsageFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfo *in_ext = (const VkBufferUsageFlags2CreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            VkDedicatedAllocationBufferCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationBufferCreateInfoNV *in_ext = (const VkDedicatedAllocationBufferCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocation = in_ext->dedicatedAllocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            VkExternalMemoryBufferCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryBufferCreateInfo *in_ext = (const VkExternalMemoryBufferCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = in_ext->opaqueCaptureDescriptorData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
        {
            VkVideoProfileListInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoProfileListInfoKHR *in_ext = (const VkVideoProfileListInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->profileCount = in_ext->profileCount;
            out_ext->pProfiles = in_ext->pProfiles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

static void convert_VkVideoProfileInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoProfileInfoKHR32 *in, VkVideoProfileInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->videoCodecOperation = in->videoCodecOperation;
    out->chromaSubsampling = in->chromaSubsampling;
    out->lumaBitDepth = in->lumaBitDepth;
    out->chromaBitDepth = in->chromaBitDepth;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR:
        {
            VkVideoDecodeAV1ProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeAV1ProfileInfoKHR32 *in_ext = (const VkVideoDecodeAV1ProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdProfile = in_ext->stdProfile;
            out_ext->filmGrainSupport = in_ext->filmGrainSupport;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR:
        {
            VkVideoDecodeH264ProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeH264ProfileInfoKHR32 *in_ext = (const VkVideoDecodeH264ProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdProfileIdc = in_ext->stdProfileIdc;
            out_ext->pictureLayout = in_ext->pictureLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR:
        {
            VkVideoDecodeUsageInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeUsageInfoKHR32 *in_ext = (const VkVideoDecodeUsageInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->videoUsageHints = in_ext->videoUsageHints;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR:
        {
            VkVideoDecodeVP9ProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeVP9ProfileInfoKHR32 *in_ext = (const VkVideoDecodeVP9ProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdProfile = in_ext->stdProfile;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR:
        {
            VkVideoEncodeAV1ProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeAV1ProfileInfoKHR32 *in_ext = (const VkVideoEncodeAV1ProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdProfile = in_ext->stdProfile;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR:
        {
            VkVideoEncodeH264ProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264ProfileInfoKHR32 *in_ext = (const VkVideoEncodeH264ProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdProfileIdc = in_ext->stdProfileIdc;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR:
        {
            VkVideoEncodeUsageInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeUsageInfoKHR32 *in_ext = (const VkVideoEncodeUsageInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->videoUsageHints = in_ext->videoUsageHints;
            out_ext->videoContentHints = in_ext->videoContentHints;
            out_ext->tuningMode = in_ext->tuningMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkVideoProfileInfoKHR *convert_VkVideoProfileInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkVideoProfileInfoKHR32 *in, uint32_t count)
{
    VkVideoProfileInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVideoProfileInfoKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkBufferCreateInfo_win32_to_host(struct conversion_context *ctx, const VkBufferCreateInfo32 *in, VkBufferCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->size = in->size;
    out->usage = in->usage;
    out->sharingMode = in->sharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = UlongToPtr(in->pQueueFamilyIndices);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {
            VkBufferDeviceAddressCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferDeviceAddressCreateInfoEXT32 *in_ext = (const VkBufferDeviceAddressCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceAddress = in_ext->deviceAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {
            VkBufferOpaqueCaptureAddressCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferOpaqueCaptureAddressCreateInfo32 *in_ext = (const VkBufferOpaqueCaptureAddressCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureAddress = in_ext->opaqueCaptureAddress;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
        {
            VkBufferUsageFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfo32 *in_ext = (const VkBufferUsageFlags2CreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {
            VkDedicatedAllocationBufferCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationBufferCreateInfoNV32 *in_ext = (const VkDedicatedAllocationBufferCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocation = in_ext->dedicatedAllocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {
            VkExternalMemoryBufferCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryBufferCreateInfo32 *in_ext = (const VkExternalMemoryBufferCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
        {
            VkVideoProfileListInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoProfileListInfoKHR32 *in_ext = (const VkVideoProfileListInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->profileCount = in_ext->profileCount;
            out_ext->pProfiles = convert_VkVideoProfileInfoKHR_array_win32_to_host(ctx, (const VkVideoProfileInfoKHR32 *)UlongToPtr(in_ext->pProfiles), in_ext->profileCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkBufferViewCreateInfo_win32_to_host(struct conversion_context *ctx, const VkBufferViewCreateInfo32 *in, VkBufferViewCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->buffer = in->buffer;
    out->format = in->format;
    out->offset = in->offset;
    out->range = in->range;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
        {
            VkBufferUsageFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfo32 *in_ext = (const VkBufferUsageFlags2CreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkCommandPoolCreateInfo_win32_to_host(struct conversion_context *ctx, const VkCommandPoolCreateInfo32 *in, VkCommandPoolCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queueFamilyIndex = in->queueFamilyIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM:
        {
            VkDataGraphProcessingEngineCreateInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDataGraphProcessingEngineCreateInfoARM32 *in_ext = (const VkDataGraphProcessingEngineCreateInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->processingEngineCount = in_ext->processingEngineCount;
            out_ext->pProcessingEngines = UlongToPtr(in_ext->pProcessingEngines);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

#ifdef _WIN64
static void convert_VkPipelineShaderStageCreateInfo_win64_to_host(struct conversion_context *ctx, const VkPipelineShaderStageCreateInfo *in, VkPipelineShaderStageCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stage = in->stage;
    out->module = in->module;
    out->pName = in->pName;
    out->pSpecializationInfo = in->pSpecializationInfo;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
        {
            VkDebugUtilsObjectNameInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugUtilsObjectNameInfoEXT *in_ext = (const VkDebugUtilsObjectNameInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->objectType = in_ext->objectType;
            out_ext->objectHandle = wine_vk_unwrap_handle(in_ext->objectType, in_ext->objectHandle);
            out_ext->pObjectName = in_ext->pObjectName;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO:
        {
            VkPipelineRobustnessCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfo *in_ext = (const VkPipelineRobustnessCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
        {
            VkPipelineShaderStageModuleIdentifierCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineShaderStageModuleIdentifierCreateInfoEXT *in_ext = (const VkPipelineShaderStageModuleIdentifierCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->identifierSize = in_ext->identifierSize;
            out_ext->pIdentifier = in_ext->pIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
        {
            VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *in_ext = (const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->requiredSubgroupSize = in_ext->requiredSubgroupSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
        {
            VkShaderModuleCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkShaderModuleCreateInfo *in_ext = (const VkShaderModuleCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->codeSize = in_ext->codeSize;
            out_ext->pCode = in_ext->pCode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            VkShaderModuleValidationCacheCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkShaderModuleValidationCacheCreateInfoEXT *in_ext = (const VkShaderModuleValidationCacheCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->validationCache = in_ext->validationCache;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkComputePipelineCreateInfo_win64_to_host(struct conversion_context *ctx, const VkComputePipelineCreateInfo *in, VkComputePipelineCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    convert_VkPipelineShaderStageCreateInfo_win64_to_host(ctx, &in->stage, &out->stage);
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkComputePipelineCreateInfo *convert_VkComputePipelineCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkComputePipelineCreateInfo *in, uint32_t count)
{
    VkComputePipelineCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkComputePipelineCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkSpecializationMapEntry_win32_to_host(const VkSpecializationMapEntry32 *in, VkSpecializationMapEntry *out)
{
    if (!in) return;

    out->constantID = in->constantID;
    out->offset = in->offset;
    out->size = in->size;
}

static const VkSpecializationMapEntry *convert_VkSpecializationMapEntry_array_win32_to_host(struct conversion_context *ctx, const VkSpecializationMapEntry32 *in, uint32_t count)
{
    VkSpecializationMapEntry *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSpecializationMapEntry_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkSpecializationInfo_win32_to_host(struct conversion_context *ctx, const VkSpecializationInfo32 *in, VkSpecializationInfo *out)
{
    if (!in) return;

    out->mapEntryCount = in->mapEntryCount;
    out->pMapEntries = convert_VkSpecializationMapEntry_array_win32_to_host(ctx, (const VkSpecializationMapEntry32 *)UlongToPtr(in->pMapEntries), in->mapEntryCount);
    out->dataSize = in->dataSize;
    out->pData = UlongToPtr(in->pData);
}

static const VkSpecializationInfo *convert_VkSpecializationInfo_array_win32_to_host(struct conversion_context *ctx, const VkSpecializationInfo32 *in, uint32_t count)
{
    VkSpecializationInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSpecializationInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineShaderStageCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineShaderStageCreateInfo32 *in, VkPipelineShaderStageCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stage = in->stage;
    out->module = in->module;
    out->pName = UlongToPtr(in->pName);
    out->pSpecializationInfo = convert_VkSpecializationInfo_array_win32_to_host(ctx, (const VkSpecializationInfo32 *)UlongToPtr(in->pSpecializationInfo), 1);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
        {
            VkDebugUtilsObjectNameInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugUtilsObjectNameInfoEXT32 *in_ext = (const VkDebugUtilsObjectNameInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->objectType = in_ext->objectType;
            out_ext->objectHandle = wine_vk_unwrap_handle(in_ext->objectType, in_ext->objectHandle);
            out_ext->pObjectName = UlongToPtr(in_ext->pObjectName);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO:
        {
            VkPipelineRobustnessCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfo32 *in_ext = (const VkPipelineRobustnessCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
        {
            VkPipelineShaderStageModuleIdentifierCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineShaderStageModuleIdentifierCreateInfoEXT32 *in_ext = (const VkPipelineShaderStageModuleIdentifierCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->identifierSize = in_ext->identifierSize;
            out_ext->pIdentifier = UlongToPtr(in_ext->pIdentifier);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
        {
            VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 *in_ext = (const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->requiredSubgroupSize = in_ext->requiredSubgroupSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
        {
            VkShaderModuleCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkShaderModuleCreateInfo32 *in_ext = (const VkShaderModuleCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->codeSize = in_ext->codeSize;
            out_ext->pCode = UlongToPtr(in_ext->pCode);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            VkShaderModuleValidationCacheCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkShaderModuleValidationCacheCreateInfoEXT32 *in_ext = (const VkShaderModuleValidationCacheCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->validationCache = in_ext->validationCache;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static VkPipelineCreationFeedback *convert_VkPipelineCreationFeedback_array_win32_to_host(struct conversion_context *ctx, const VkPipelineCreationFeedback32 *in, uint32_t count)
{
    VkPipelineCreationFeedback *out;
    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));

    return out;
}

static void convert_VkComputePipelineCreateInfo_win32_to_host(struct conversion_context *ctx, const VkComputePipelineCreateInfo32 *in, VkComputePipelineCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    convert_VkPipelineShaderStageCreateInfo_win32_to_host(ctx, &in->stage, &out->stage);
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV:
        {
            VkComputePipelineIndirectBufferInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkComputePipelineIndirectBufferInfoNV32 *in_ext = (const VkComputePipelineIndirectBufferInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->deviceAddress = in_ext->deviceAddress;
            out_ext->size = in_ext->size;
            out_ext->pipelineDeviceAddressCaptureReplay = in_ext->pipelineDeviceAddressCaptureReplay;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR:
        {
            VkPipelineBinaryInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineBinaryInfoKHR32 *in_ext = (const VkPipelineBinaryInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->binaryCount = in_ext->binaryCount;
            out_ext->pPipelineBinaries = UlongToPtr(in_ext->pPipelineBinaries);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            VkPipelineCompilerControlCreateInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCompilerControlCreateInfoAMD32 *in_ext = (const VkPipelineCompilerControlCreateInfoAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->compilerControlFlags = in_ext->compilerControlFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO:
        {
            VkPipelineCreateFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreateFlags2CreateInfo32 *in_ext = (const VkPipelineCreateFlags2CreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo32 *in_ext = (const VkPipelineCreationFeedbackCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineCreationFeedback), 1);
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO:
        {
            VkPipelineRobustnessCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfo32 *in_ext = (const VkPipelineRobustnessCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI:
        {
            VkSubpassShadingPipelineCreateInfoHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSubpassShadingPipelineCreateInfoHUAWEI32 *in_ext = (const VkSubpassShadingPipelineCreateInfoHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->renderPass = in_ext->renderPass;
            out_ext->subpass = in_ext->subpass;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkComputePipelineCreateInfo *convert_VkComputePipelineCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkComputePipelineCreateInfo32 *in, uint32_t count)
{
    VkComputePipelineCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkComputePipelineCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineCreationFeedback_host_to_win32(const VkPipelineCreationFeedback *in, VkPipelineCreationFeedback32 *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->duration = in->duration;
}

static void convert_VkPipelineCreationFeedback_array_host_to_win32(const VkPipelineCreationFeedback *in, VkPipelineCreationFeedback32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPipelineCreationFeedback_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkComputePipelineCreateInfo_host_to_win32(const VkComputePipelineCreateInfo *in, const VkComputePipelineCreateInfo32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;


    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineCreationFeedback, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineCreationFeedback), 1);
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineStageCreationFeedbacks, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkComputePipelineCreateInfo_array_host_to_win32(const VkComputePipelineCreateInfo *in, const VkComputePipelineCreateInfo32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkComputePipelineCreateInfo_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkCuFunctionCreateInfoNVX_win32_to_host(const VkCuFunctionCreateInfoNVX32 *in, VkCuFunctionCreateInfoNVX *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->module = in->module;
    out->pName = UlongToPtr(in->pName);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCuModuleCreateInfoNVX_win32_to_host(struct conversion_context *ctx, const VkCuModuleCreateInfoNVX32 *in, VkCuModuleCreateInfoNVX *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->dataSize = in->dataSize;
    out->pData = UlongToPtr(in->pData);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX:
        {
            VkCuModuleTexturingModeCreateInfoNVX *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkCuModuleTexturingModeCreateInfoNVX32 *in_ext = (const VkCuModuleTexturingModeCreateInfoNVX32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX;
            out_ext->pNext = NULL;
            out_ext->use64bitTexturing = in_ext->use64bitTexturing;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkDataGraphPipelineSessionCreateInfoARM_win32_to_host(const VkDataGraphPipelineSessionCreateInfoARM32 *in, VkDataGraphPipelineSessionCreateInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->dataGraphPipeline = in->dataGraphPipeline;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDataGraphPipelineResourceInfoARM_win32_to_host(struct conversion_context *ctx, const VkDataGraphPipelineResourceInfoARM32 *in, VkDataGraphPipelineResourceInfoARM *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->descriptorSet = in->descriptorSet;
    out->binding = in->binding;
    out->arrayElement = in->arrayElement;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM:
        {
            VkTensorDescriptionARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTensorDescriptionARM32 *in_ext = (const VkTensorDescriptionARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM;
            out_ext->pNext = NULL;
            out_ext->tiling = in_ext->tiling;
            out_ext->format = in_ext->format;
            out_ext->dimensionCount = in_ext->dimensionCount;
            out_ext->pDimensions = UlongToPtr(in_ext->pDimensions);
            out_ext->pStrides = UlongToPtr(in_ext->pStrides);
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkDataGraphPipelineResourceInfoARM *convert_VkDataGraphPipelineResourceInfoARM_array_win32_to_host(struct conversion_context *ctx, const VkDataGraphPipelineResourceInfoARM32 *in, uint32_t count)
{
    VkDataGraphPipelineResourceInfoARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDataGraphPipelineResourceInfoARM_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkDataGraphPipelineConstantARM_win32_to_host(struct conversion_context *ctx, const VkDataGraphPipelineConstantARM32 *in, VkDataGraphPipelineConstantARM *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->id = in->id;
    out->pConstantData = UlongToPtr(in->pConstantData);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM:
        {
            VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM32 *in_ext = (const VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->dimension = in_ext->dimension;
            out_ext->zeroCount = in_ext->zeroCount;
            out_ext->groupSize = in_ext->groupSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM:
        {
            VkTensorDescriptionARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTensorDescriptionARM32 *in_ext = (const VkTensorDescriptionARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM;
            out_ext->pNext = NULL;
            out_ext->tiling = in_ext->tiling;
            out_ext->format = in_ext->format;
            out_ext->dimensionCount = in_ext->dimensionCount;
            out_ext->pDimensions = UlongToPtr(in_ext->pDimensions);
            out_ext->pStrides = UlongToPtr(in_ext->pStrides);
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkDataGraphPipelineConstantARM *convert_VkDataGraphPipelineConstantARM_array_win32_to_host(struct conversion_context *ctx, const VkDataGraphPipelineConstantARM32 *in, uint32_t count)
{
    VkDataGraphPipelineConstantARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDataGraphPipelineConstantARM_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkDataGraphPipelineCreateInfoARM_win32_to_host(struct conversion_context *ctx, const VkDataGraphPipelineCreateInfoARM32 *in, VkDataGraphPipelineCreateInfoARM *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->layout = in->layout;
    out->resourceInfoCount = in->resourceInfoCount;
    out->pResourceInfos = convert_VkDataGraphPipelineResourceInfoARM_array_win32_to_host(ctx, (const VkDataGraphPipelineResourceInfoARM32 *)UlongToPtr(in->pResourceInfos), in->resourceInfoCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM:
        {
            VkDataGraphPipelineCompilerControlCreateInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDataGraphPipelineCompilerControlCreateInfoARM32 *in_ext = (const VkDataGraphPipelineCompilerControlCreateInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->pVendorOptions = UlongToPtr(in_ext->pVendorOptions);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM:
        {
            VkDataGraphPipelineIdentifierCreateInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDataGraphPipelineIdentifierCreateInfoARM32 *in_ext = (const VkDataGraphPipelineIdentifierCreateInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->identifierSize = in_ext->identifierSize;
            out_ext->pIdentifier = UlongToPtr(in_ext->pIdentifier);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM:
        {
            VkDataGraphPipelineShaderModuleCreateInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDataGraphPipelineShaderModuleCreateInfoARM32 *in_ext = (const VkDataGraphPipelineShaderModuleCreateInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->module = in_ext->module;
            out_ext->pName = UlongToPtr(in_ext->pName);
            out_ext->pSpecializationInfo = convert_VkSpecializationInfo_array_win32_to_host(ctx, (const VkSpecializationInfo32 *)UlongToPtr(in_ext->pSpecializationInfo), 1);
            out_ext->constantCount = in_ext->constantCount;
            out_ext->pConstants = convert_VkDataGraphPipelineConstantARM_array_win32_to_host(ctx, (const VkDataGraphPipelineConstantARM32 *)UlongToPtr(in_ext->pConstants), in_ext->constantCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM:
        {
            VkDataGraphProcessingEngineCreateInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDataGraphProcessingEngineCreateInfoARM32 *in_ext = (const VkDataGraphProcessingEngineCreateInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->processingEngineCount = in_ext->processingEngineCount;
            out_ext->pProcessingEngines = UlongToPtr(in_ext->pProcessingEngines);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo32 *in_ext = (const VkPipelineCreationFeedbackCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineCreationFeedback), 1);
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkDataGraphPipelineCreateInfoARM *convert_VkDataGraphPipelineCreateInfoARM_array_win32_to_host(struct conversion_context *ctx, const VkDataGraphPipelineCreateInfoARM32 *in, uint32_t count)
{
    VkDataGraphPipelineCreateInfoARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDataGraphPipelineCreateInfoARM_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkDataGraphPipelineCreateInfoARM_host_to_win32(const VkDataGraphPipelineCreateInfoARM *in, const VkDataGraphPipelineCreateInfoARM32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;


    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM:
        {
            VkDataGraphProcessingEngineCreateInfoARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM);
            const VkDataGraphProcessingEngineCreateInfoARM *in_ext = (const VkDataGraphProcessingEngineCreateInfoARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM;
            out_ext->pProcessingEngines = PtrToUlong(in_ext->pProcessingEngines);
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineCreationFeedback, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineCreationFeedback), 1);
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineStageCreationFeedbacks, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkDataGraphPipelineCreateInfoARM_array_host_to_win32(const VkDataGraphPipelineCreateInfoARM *in, const VkDataGraphPipelineCreateInfoARM32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkDataGraphPipelineCreateInfoARM_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkDebugReportCallbackCreateInfoEXT_win32_to_host(const VkDebugReportCallbackCreateInfoEXT32 *in, VkDebugReportCallbackCreateInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pfnCallback = (PFN_vkDebugReportCallbackEXT)UlongToPtr(in->pfnCallback);
    out->pUserData = UlongToPtr(in->pUserData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDebugUtilsMessengerCreateInfoEXT_win32_to_host(const VkDebugUtilsMessengerCreateInfoEXT32 *in, VkDebugUtilsMessengerCreateInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->messageSeverity = in->messageSeverity;
    out->messageType = in->messageType;
    out->pfnUserCallback = (PFN_vkDebugUtilsMessengerCallbackEXT)UlongToPtr(in->pfnUserCallback);
    out->pUserData = UlongToPtr(in->pUserData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMutableDescriptorTypeListEXT_win32_to_host(const VkMutableDescriptorTypeListEXT32 *in, VkMutableDescriptorTypeListEXT *out)
{
    if (!in) return;

    out->descriptorTypeCount = in->descriptorTypeCount;
    out->pDescriptorTypes = UlongToPtr(in->pDescriptorTypes);
}

static const VkMutableDescriptorTypeListEXT *convert_VkMutableDescriptorTypeListEXT_array_win32_to_host(struct conversion_context *ctx, const VkMutableDescriptorTypeListEXT32 *in, uint32_t count)
{
    VkMutableDescriptorTypeListEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMutableDescriptorTypeListEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDescriptorPoolCreateInfo_win32_to_host(struct conversion_context *ctx, const VkDescriptorPoolCreateInfo32 *in, VkDescriptorPoolCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->maxSets = in->maxSets;
    out->poolSizeCount = in->poolSizeCount;
    out->pPoolSizes = UlongToPtr(in->pPoolSizes);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM:
        {
            VkDataGraphProcessingEngineCreateInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDataGraphProcessingEngineCreateInfoARM32 *in_ext = (const VkDataGraphProcessingEngineCreateInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->processingEngineCount = in_ext->processingEngineCount;
            out_ext->pProcessingEngines = UlongToPtr(in_ext->pProcessingEngines);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
        {
            VkDescriptorPoolInlineUniformBlockCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDescriptorPoolInlineUniformBlockCreateInfo32 *in_ext = (const VkDescriptorPoolInlineUniformBlockCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->maxInlineUniformBlockBindings = in_ext->maxInlineUniformBlockBindings;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
        {
            VkMutableDescriptorTypeCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMutableDescriptorTypeCreateInfoEXT32 *in_ext = (const VkMutableDescriptorTypeCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->mutableDescriptorTypeListCount = in_ext->mutableDescriptorTypeListCount;
            out_ext->pMutableDescriptorTypeLists = convert_VkMutableDescriptorTypeListEXT_array_win32_to_host(ctx, (const VkMutableDescriptorTypeListEXT32 *)UlongToPtr(in_ext->pMutableDescriptorTypeLists), in_ext->mutableDescriptorTypeListCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkDescriptorSetLayoutBinding_win32_to_host(const VkDescriptorSetLayoutBinding32 *in, VkDescriptorSetLayoutBinding *out)
{
    if (!in) return;

    out->binding = in->binding;
    out->descriptorType = in->descriptorType;
    out->descriptorCount = in->descriptorCount;
    out->stageFlags = in->stageFlags;
    out->pImmutableSamplers = UlongToPtr(in->pImmutableSamplers);
}

static const VkDescriptorSetLayoutBinding *convert_VkDescriptorSetLayoutBinding_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorSetLayoutBinding32 *in, uint32_t count)
{
    VkDescriptorSetLayoutBinding *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorSetLayoutBinding_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDescriptorSetLayoutCreateInfo_win32_to_host(struct conversion_context *ctx, const VkDescriptorSetLayoutCreateInfo32 *in, VkDescriptorSetLayoutCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->bindingCount = in->bindingCount;
    out->pBindings = convert_VkDescriptorSetLayoutBinding_array_win32_to_host(ctx, (const VkDescriptorSetLayoutBinding32 *)UlongToPtr(in->pBindings), in->bindingCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {
            VkDescriptorSetLayoutBindingFlagsCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDescriptorSetLayoutBindingFlagsCreateInfo32 *in_ext = (const VkDescriptorSetLayoutBindingFlagsCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->bindingCount = in_ext->bindingCount;
            out_ext->pBindingFlags = UlongToPtr(in_ext->pBindingFlags);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
        {
            VkMutableDescriptorTypeCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMutableDescriptorTypeCreateInfoEXT32 *in_ext = (const VkMutableDescriptorTypeCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->mutableDescriptorTypeListCount = in_ext->mutableDescriptorTypeListCount;
            out_ext->pMutableDescriptorTypeLists = convert_VkMutableDescriptorTypeListEXT_array_win32_to_host(ctx, (const VkMutableDescriptorTypeListEXT32 *)UlongToPtr(in_ext->pMutableDescriptorTypeLists), in_ext->mutableDescriptorTypeListCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkDescriptorUpdateTemplateEntry_win32_to_host(const VkDescriptorUpdateTemplateEntry32 *in, VkDescriptorUpdateTemplateEntry *out)
{
    if (!in) return;

    out->dstBinding = in->dstBinding;
    out->dstArrayElement = in->dstArrayElement;
    out->descriptorCount = in->descriptorCount;
    out->descriptorType = in->descriptorType;
    out->offset = in->offset;
    out->stride = in->stride;
}

static const VkDescriptorUpdateTemplateEntry *convert_VkDescriptorUpdateTemplateEntry_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorUpdateTemplateEntry32 *in, uint32_t count)
{
    VkDescriptorUpdateTemplateEntry *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorUpdateTemplateEntry_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDescriptorUpdateTemplateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkDescriptorUpdateTemplateCreateInfo32 *in, VkDescriptorUpdateTemplateCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->descriptorUpdateEntryCount = in->descriptorUpdateEntryCount;
    out->pDescriptorUpdateEntries = convert_VkDescriptorUpdateTemplateEntry_array_win32_to_host(ctx, (const VkDescriptorUpdateTemplateEntry32 *)UlongToPtr(in->pDescriptorUpdateEntries), in->descriptorUpdateEntryCount);
    out->templateType = in->templateType;
    out->descriptorSetLayout = in->descriptorSetLayout;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->pipelineLayout = in->pipelineLayout;
    out->set = in->set;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static const VkPhysicalDevice *convert_VkPhysicalDevice_array_win64_to_host(struct conversion_context *ctx, const VkPhysicalDevice *in, uint32_t count)
{
    VkPhysicalDevice *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_physical_device_from_handle(in[i])->host.physical_device;
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkDeviceCreateInfo_win64_to_host(struct conversion_context *ctx, const VkDeviceCreateInfo *in, VkDeviceCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queueCreateInfoCount = in->queueCreateInfoCount;
    out->pQueueCreateInfos = in->pQueueCreateInfos;
    out->enabledLayerCount = in->enabledLayerCount;
    out->ppEnabledLayerNames = in->ppEnabledLayerNames;
    out->enabledExtensionCount = in->enabledExtensionCount;
    out->ppEnabledExtensionNames = in->ppEnabledExtensionNames;
    out->pEnabledFeatures = in->pEnabledFeatures;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO:
            break;
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            VkDeviceDiagnosticsConfigCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceDiagnosticsConfigCreateInfoNV *in_ext = (const VkDeviceDiagnosticsConfigCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            VkDeviceGroupDeviceCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupDeviceCreateInfo *in_ext = (const VkDeviceGroupDeviceCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->physicalDeviceCount = in_ext->physicalDeviceCount;
            out_ext->pPhysicalDevices = convert_VkPhysicalDevice_array_win64_to_host(ctx, in_ext->pPhysicalDevices, in_ext->physicalDeviceCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            VkDeviceMemoryOverallocationCreateInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceMemoryOverallocationCreateInfoAMD *in_ext = (const VkDeviceMemoryOverallocationCreateInfoAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->overallocationBehavior = in_ext->overallocationBehavior;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR:
        {
            VkDevicePipelineBinaryInternalCacheControlKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDevicePipelineBinaryInternalCacheControlKHR *in_ext = (const VkDevicePipelineBinaryInternalCacheControlKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR;
            out_ext->pNext = NULL;
            out_ext->disableInternalCache = in_ext->disableInternalCache;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
        {
            VkDevicePrivateDataCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDevicePrivateDataCreateInfo *in_ext = (const VkDevicePrivateDataCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->privateDataSlotRequestCount = in_ext->privateDataSlotRequestCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM:
        {
            VkDeviceQueueShaderCoreControlCreateInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceQueueShaderCoreControlCreateInfoARM *in_ext = (const VkDeviceQueueShaderCoreControlCreateInfoARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->shaderCoreCount = in_ext->shaderCoreCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR:
        {
            VkPerformanceQueryReservationInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQueryReservationInfoKHR *in_ext = (const VkPerformanceQueryReservationInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->maxPerformanceQueriesPerPool = in_ext->maxPerformanceQueriesPerPool;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice16BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice16BitStorageFeatures *in_ext = (const VkPhysicalDevice16BitStorageFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDevice4444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice4444FormatsFeaturesEXT *in_ext = (const VkPhysicalDevice4444FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatA4R4G4B4 = in_ext->formatA4R4G4B4;
            out_ext->formatA4B4G4R4 = in_ext->formatA4B4G4R4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice8BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice8BitStorageFeatures *in_ext = (const VkPhysicalDevice8BitStorageFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            VkPhysicalDeviceASTCDecodeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceASTCDecodeFeaturesEXT *in_ext = (const VkPhysicalDeviceASTCDecodeFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->decodeModeSharedExponent = in_ext->decodeModeSharedExponent;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            VkPhysicalDeviceAccelerationStructureFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAccelerationStructureFeaturesKHR *in_ext = (const VkPhysicalDeviceAccelerationStructureFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->accelerationStructure = in_ext->accelerationStructure;
            out_ext->accelerationStructureCaptureReplay = in_ext->accelerationStructureCaptureReplay;
            out_ext->accelerationStructureIndirectBuild = in_ext->accelerationStructureIndirectBuild;
            out_ext->accelerationStructureHostCommands = in_ext->accelerationStructureHostCommands;
            out_ext->descriptorBindingAccelerationStructureUpdateAfterBind = in_ext->descriptorBindingAccelerationStructureUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
            VkPhysicalDeviceAddressBindingReportFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAddressBindingReportFeaturesEXT *in_ext = (const VkPhysicalDeviceAddressBindingReportFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->reportAddressBinding = in_ext->reportAddressBinding;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD:
        {
            VkPhysicalDeviceAntiLagFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAntiLagFeaturesAMD *in_ext = (const VkPhysicalDeviceAntiLagFeaturesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->antiLag = in_ext->antiLag;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopDynamicState = in_ext->attachmentFeedbackLoopDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopLayout = in_ext->attachmentFeedbackLoopLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *in_ext = (const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->advancedBlendCoherentOperations = in_ext->advancedBlendCoherentOperations;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
            VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *in_ext = (const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->borderColorSwizzle = in_ext->borderColorSwizzle;
            out_ext->borderColorSwizzleFromImage = in_ext->borderColorSwizzleFromImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            VkPhysicalDeviceBufferDeviceAddressFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeatures *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV:
        {
            VkPhysicalDeviceClusterAccelerationStructureFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV *in_ext = (const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->clusterAccelerationStructure = in_ext->clusterAccelerationStructure;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->clustercullingShader = in_ext->clustercullingShader;
            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            VkPhysicalDeviceCoherentMemoryFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoherentMemoryFeaturesAMD *in_ext = (const VkPhysicalDeviceCoherentMemoryFeaturesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->deviceCoherentMemory = in_ext->deviceCoherentMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceColorWriteEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceColorWriteEnableFeaturesEXT *in_ext = (const VkPhysicalDeviceColorWriteEnableFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->colorWriteEnable = in_ext->colorWriteEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV:
        {
            VkPhysicalDeviceCommandBufferInheritanceFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV *in_ext = (const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->commandBufferInheritance = in_ext->commandBufferInheritance;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR:
        {
            VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR *in_ext = (const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->computeDerivativeGroupQuads = in_ext->computeDerivativeGroupQuads;
            out_ext->computeDerivativeGroupLinear = in_ext->computeDerivativeGroupLinear;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            VkPhysicalDeviceConditionalRenderingFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceConditionalRenderingFeaturesEXT *in_ext = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->conditionalRendering = in_ext->conditionalRendering;
            out_ext->inheritedConditionalRendering = in_ext->inheritedConditionalRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrix2FeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrix2FeaturesNV *in_ext = (const VkPhysicalDeviceCooperativeMatrix2FeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrixWorkgroupScope = in_ext->cooperativeMatrixWorkgroupScope;
            out_ext->cooperativeMatrixFlexibleDimensions = in_ext->cooperativeMatrixFlexibleDimensions;
            out_ext->cooperativeMatrixReductions = in_ext->cooperativeMatrixReductions;
            out_ext->cooperativeMatrixConversions = in_ext->cooperativeMatrixConversions;
            out_ext->cooperativeMatrixPerElementOperations = in_ext->cooperativeMatrixPerElementOperations;
            out_ext->cooperativeMatrixTensorAddressing = in_ext->cooperativeMatrixTensorAddressing;
            out_ext->cooperativeMatrixBlockLoads = in_ext->cooperativeMatrixBlockLoads;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesKHR *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesNV *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeVectorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeVectorFeaturesNV *in_ext = (const VkPhysicalDeviceCooperativeVectorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeVector = in_ext->cooperativeVector;
            out_ext->cooperativeVectorTraining = in_ext->cooperativeVectorTraining;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *in_ext = (const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->indirectCopy = in_ext->indirectCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceCornerSampledImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCornerSampledImageFeaturesNV *in_ext = (const VkPhysicalDeviceCornerSampledImageFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cornerSampledImage = in_ext->cornerSampledImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            VkPhysicalDeviceCoverageReductionModeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoverageReductionModeFeaturesNV *in_ext = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->coverageReductionMode = in_ext->coverageReductionMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicClampFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicClampFeaturesQCOM *in_ext = (const VkPhysicalDeviceCubicClampFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->cubicRangeClamp = in_ext->cubicRangeClamp;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicWeightsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicWeightsFeaturesQCOM *in_ext = (const VkPhysicalDeviceCubicWeightsFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->selectableCubicWeights = in_ext->selectableCubicWeights;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCustomBorderColorFeaturesEXT *in_ext = (const VkPhysicalDeviceCustomBorderColorFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->customBorderColors = in_ext->customBorderColors;
            out_ext->customBorderColorWithoutFormat = in_ext->customBorderColorWithoutFormat;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM:
        {
            VkPhysicalDeviceDataGraphFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDataGraphFeaturesARM *in_ext = (const VkPhysicalDeviceDataGraphFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->dataGraph = in_ext->dataGraph;
            out_ext->dataGraphUpdateAfterBind = in_ext->dataGraphUpdateAfterBind;
            out_ext->dataGraphSpecializationConstants = in_ext->dataGraphSpecializationConstants;
            out_ext->dataGraphDescriptorBuffer = in_ext->dataGraphDescriptorBuffer;
            out_ext->dataGraphShaderModule = in_ext->dataGraphShaderModule;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *in_ext = (const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocationImageAliasing = in_ext->dedicatedAllocationImageAliasing;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthBiasControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthBiasControlFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthBiasControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthBiasControl = in_ext->depthBiasControl;
            out_ext->leastRepresentableValueForceUnormRepresentation = in_ext->leastRepresentableValueForceUnormRepresentation;
            out_ext->floatRepresentation = in_ext->floatRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClampControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClampControlFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClampControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClampControl = in_ext->depthClampControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR:
        {
            VkPhysicalDeviceDepthClampZeroOneFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR *in_ext = (const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->depthClampZeroOne = in_ext->depthClampZeroOne;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipControlFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClipControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipControl = in_ext->depthClipControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipEnableFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClipEnableFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipEnable = in_ext->depthClipEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorBufferFeaturesEXT *in_ext = (const VkPhysicalDeviceDescriptorBufferFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->descriptorBuffer = in_ext->descriptorBuffer;
            out_ext->descriptorBufferCaptureReplay = in_ext->descriptorBufferCaptureReplay;
            out_ext->descriptorBufferImageLayoutIgnored = in_ext->descriptorBufferImageLayoutIgnored;
            out_ext->descriptorBufferPushDescriptors = in_ext->descriptorBufferPushDescriptors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM:
        {
            VkPhysicalDeviceDescriptorBufferTensorFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM *in_ext = (const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->descriptorBufferTensorDescriptors = in_ext->descriptorBufferTensorDescriptors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            VkPhysicalDeviceDescriptorIndexingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorIndexingFeatures *in_ext = (const VkPhysicalDeviceDescriptorIndexingFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
            VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *in_ext = (const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->descriptorPoolOverallocation = in_ext->descriptorPoolOverallocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
            VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *in_ext = (const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
            out_ext->pNext = NULL;
            out_ext->descriptorSetHostMapping = in_ext->descriptorSetHostMapping;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCompute = in_ext->deviceGeneratedCompute;
            out_ext->deviceGeneratedComputePipelines = in_ext->deviceGeneratedComputePipelines;
            out_ext->deviceGeneratedComputeCaptureReplay = in_ext->deviceGeneratedComputeCaptureReplay;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_ext->dynamicGeneratedPipelineLayout = in_ext->dynamicGeneratedPipelineLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDiagnosticsConfigFeaturesNV *in_ext = (const VkPhysicalDeviceDiagnosticsConfigFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->diagnosticsConfig = in_ext->diagnosticsConfig;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingFeatures *in_ext = (const VkPhysicalDeviceDynamicRenderingFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingLocalReadFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingLocalReadFeatures *in_ext = (const VkPhysicalDeviceDynamicRenderingLocalReadFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
            out_ext->pNext = NULL;
            out_ext->dynamicRenderingLocalRead = in_ext->dynamicRenderingLocalRead;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
            VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *in_ext = (const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->dynamicRenderingUnusedAttachments = in_ext->dynamicRenderingUnusedAttachments;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceExclusiveScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExclusiveScissorFeaturesNV *in_ext = (const VkPhysicalDeviceExclusiveScissorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->exclusiveScissor = in_ext->exclusiveScissor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState2 = in_ext->extendedDynamicState2;
            out_ext->extendedDynamicState2LogicOp = in_ext->extendedDynamicState2LogicOp;
            out_ext->extendedDynamicState2PatchControlPoints = in_ext->extendedDynamicState2PatchControlPoints;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState3TessellationDomainOrigin = in_ext->extendedDynamicState3TessellationDomainOrigin;
            out_ext->extendedDynamicState3DepthClampEnable = in_ext->extendedDynamicState3DepthClampEnable;
            out_ext->extendedDynamicState3PolygonMode = in_ext->extendedDynamicState3PolygonMode;
            out_ext->extendedDynamicState3RasterizationSamples = in_ext->extendedDynamicState3RasterizationSamples;
            out_ext->extendedDynamicState3SampleMask = in_ext->extendedDynamicState3SampleMask;
            out_ext->extendedDynamicState3AlphaToCoverageEnable = in_ext->extendedDynamicState3AlphaToCoverageEnable;
            out_ext->extendedDynamicState3AlphaToOneEnable = in_ext->extendedDynamicState3AlphaToOneEnable;
            out_ext->extendedDynamicState3LogicOpEnable = in_ext->extendedDynamicState3LogicOpEnable;
            out_ext->extendedDynamicState3ColorBlendEnable = in_ext->extendedDynamicState3ColorBlendEnable;
            out_ext->extendedDynamicState3ColorBlendEquation = in_ext->extendedDynamicState3ColorBlendEquation;
            out_ext->extendedDynamicState3ColorWriteMask = in_ext->extendedDynamicState3ColorWriteMask;
            out_ext->extendedDynamicState3RasterizationStream = in_ext->extendedDynamicState3RasterizationStream;
            out_ext->extendedDynamicState3ConservativeRasterizationMode = in_ext->extendedDynamicState3ConservativeRasterizationMode;
            out_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize = in_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize;
            out_ext->extendedDynamicState3DepthClipEnable = in_ext->extendedDynamicState3DepthClipEnable;
            out_ext->extendedDynamicState3SampleLocationsEnable = in_ext->extendedDynamicState3SampleLocationsEnable;
            out_ext->extendedDynamicState3ColorBlendAdvanced = in_ext->extendedDynamicState3ColorBlendAdvanced;
            out_ext->extendedDynamicState3ProvokingVertexMode = in_ext->extendedDynamicState3ProvokingVertexMode;
            out_ext->extendedDynamicState3LineRasterizationMode = in_ext->extendedDynamicState3LineRasterizationMode;
            out_ext->extendedDynamicState3LineStippleEnable = in_ext->extendedDynamicState3LineStippleEnable;
            out_ext->extendedDynamicState3DepthClipNegativeOneToOne = in_ext->extendedDynamicState3DepthClipNegativeOneToOne;
            out_ext->extendedDynamicState3ViewportWScalingEnable = in_ext->extendedDynamicState3ViewportWScalingEnable;
            out_ext->extendedDynamicState3ViewportSwizzle = in_ext->extendedDynamicState3ViewportSwizzle;
            out_ext->extendedDynamicState3CoverageToColorEnable = in_ext->extendedDynamicState3CoverageToColorEnable;
            out_ext->extendedDynamicState3CoverageToColorLocation = in_ext->extendedDynamicState3CoverageToColorLocation;
            out_ext->extendedDynamicState3CoverageModulationMode = in_ext->extendedDynamicState3CoverageModulationMode;
            out_ext->extendedDynamicState3CoverageModulationTableEnable = in_ext->extendedDynamicState3CoverageModulationTableEnable;
            out_ext->extendedDynamicState3CoverageModulationTable = in_ext->extendedDynamicState3CoverageModulationTable;
            out_ext->extendedDynamicState3CoverageReductionMode = in_ext->extendedDynamicState3CoverageReductionMode;
            out_ext->extendedDynamicState3RepresentativeFragmentTestEnable = in_ext->extendedDynamicState3RepresentativeFragmentTestEnable;
            out_ext->extendedDynamicState3ShadingRateImageEnable = in_ext->extendedDynamicState3ShadingRateImageEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState = in_ext->extendedDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *in_ext = (const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->extendedSparseAddressSpace = in_ext->extendedSparseAddressSpace;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
            VkPhysicalDeviceFaultFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFaultFeaturesEXT *in_ext = (const VkPhysicalDeviceFaultFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceFault = in_ext->deviceFault;
            out_ext->deviceFaultVendorBinary = in_ext->deviceFaultVendorBinary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            VkPhysicalDeviceFeatures2 *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFeatures2 *in_ext = (const VkPhysicalDeviceFeatures2 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
            out_ext->pNext = NULL;
            out_ext->features = in_ext->features;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM:
        {
            VkPhysicalDeviceFormatPackFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFormatPackFeaturesARM *in_ext = (const VkPhysicalDeviceFormatPackFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->formatPack = in_ext->formatPack;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapDeferred = in_ext->fragmentDensityMapDeferred;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMap = in_ext->fragmentDensityMap;
            out_ext->fragmentDensityMapDynamic = in_ext->fragmentDensityMapDynamic;
            out_ext->fragmentDensityMapNonSubsampledImages = in_ext->fragmentDensityMapNonSubsampledImages;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE:
        {
            VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapOffset = in_ext->fragmentDensityMapOffset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *in_ext = (const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderBarycentric = in_ext->fragmentShaderBarycentric;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderSampleInterlock = in_ext->fragmentShaderSampleInterlock;
            out_ext->fragmentShaderPixelInterlock = in_ext->fragmentShaderPixelInterlock;
            out_ext->fragmentShaderShadingRateInterlock = in_ext->fragmentShaderShadingRateInterlock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->fragmentShadingRateEnums = in_ext->fragmentShadingRateEnums;
            out_ext->supersampleFragmentShadingRates = in_ext->supersampleFragmentShadingRates;
            out_ext->noInvocationFragmentShadingRates = in_ext->noInvocationFragmentShadingRates;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *in_ext = (const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineFragmentShadingRate = in_ext->pipelineFragmentShadingRate;
            out_ext->primitiveFragmentShadingRate = in_ext->primitiveFragmentShadingRate;
            out_ext->attachmentFragmentShadingRate = in_ext->attachmentFragmentShadingRate;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
            VkPhysicalDeviceFrameBoundaryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFrameBoundaryFeaturesEXT *in_ext = (const VkPhysicalDeviceFrameBoundaryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->frameBoundary = in_ext->frameBoundary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES:
        {
            VkPhysicalDeviceGlobalPriorityQueryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGlobalPriorityQueryFeatures *in_ext = (const VkPhysicalDeviceGlobalPriorityQueryFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->graphicsPipelineLibrary = in_ext->graphicsPipelineLibrary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceHdrVividFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHdrVividFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceHdrVividFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->hdrVivid = in_ext->hdrVivid;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES:
        {
            VkPhysicalDeviceHostImageCopyFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostImageCopyFeatures *in_ext = (const VkPhysicalDeviceHostImageCopyFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            VkPhysicalDeviceHostQueryResetFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostQueryResetFeatures *in_ext = (const VkPhysicalDeviceHostQueryResetFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
            out_ext->pNext = NULL;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *in_ext = (const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->image2DViewOf3D = in_ext->image2DViewOf3D;
            out_ext->sampler2DViewOf3D = in_ext->sampler2DViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA:
        {
            VkPhysicalDeviceImageAlignmentControlFeaturesMESA *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageAlignmentControlFeaturesMESA *in_ext = (const VkPhysicalDeviceImageAlignmentControlFeaturesMESA *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA;
            out_ext->pNext = NULL;
            out_ext->imageAlignmentControl = in_ext->imageAlignmentControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlFeaturesEXT *in_ext = (const VkPhysicalDeviceImageCompressionControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControl = in_ext->imageCompressionControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *in_ext = (const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControlSwapchain = in_ext->imageCompressionControlSwapchain;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2FeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessing2FeaturesQCOM *in_ext = (const VkPhysicalDeviceImageProcessing2FeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureBlockMatch2 = in_ext->textureBlockMatch2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessingFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessingFeaturesQCOM *in_ext = (const VkPhysicalDeviceImageProcessingFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureSampleWeighted = in_ext->textureSampleWeighted;
            out_ext->textureBoxFilter = in_ext->textureBoxFilter;
            out_ext->textureBlockMatch = in_ext->textureBlockMatch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDeviceImageRobustnessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageRobustnessFeatures *in_ext = (const VkPhysicalDeviceImageRobustnessFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *in_ext = (const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageSlicedViewOf3D = in_ext->imageSlicedViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
            VkPhysicalDeviceImageViewMinLodFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageViewMinLodFeaturesEXT *in_ext = (const VkPhysicalDeviceImageViewMinLodFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->minLod = in_ext->minLod;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            VkPhysicalDeviceImagelessFramebufferFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImagelessFramebufferFeatures *in_ext = (const VkPhysicalDeviceImagelessFramebufferFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
            out_ext->pNext = NULL;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES:
        {
            VkPhysicalDeviceIndexTypeUint8Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceIndexTypeUint8Features *in_ext = (const VkPhysicalDeviceIndexTypeUint8Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
            out_ext->pNext = NULL;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInheritedViewportScissorFeaturesNV *in_ext = (const VkPhysicalDeviceInheritedViewportScissorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->inheritedViewportScissor2D = in_ext->inheritedViewportScissor2D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
            VkPhysicalDeviceInlineUniformBlockFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInlineUniformBlockFeatures *in_ext = (const VkPhysicalDeviceInlineUniformBlockFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
            out_ext->pNext = NULL;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->invocationMask = in_ext->invocationMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyDitheringFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLegacyDitheringFeaturesEXT *in_ext = (const VkPhysicalDeviceLegacyDitheringFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->legacyDithering = in_ext->legacyDithering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT *in_ext = (const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->legacyVertexAttributes = in_ext->legacyVertexAttributes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES:
        {
            VkPhysicalDeviceLineRasterizationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLineRasterizationFeatures *in_ext = (const VkPhysicalDeviceLineRasterizationFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
            VkPhysicalDeviceLinearColorAttachmentFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLinearColorAttachmentFeaturesNV *in_ext = (const VkPhysicalDeviceLinearColorAttachmentFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->linearColorAttachment = in_ext->linearColorAttachment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
            VkPhysicalDeviceMaintenance4Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance4Features *in_ext = (const VkPhysicalDeviceMaintenance4Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES:
        {
            VkPhysicalDeviceMaintenance5Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance5Features *in_ext = (const VkPhysicalDeviceMaintenance5Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES:
        {
            VkPhysicalDeviceMaintenance6Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance6Features *in_ext = (const VkPhysicalDeviceMaintenance6Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance6 = in_ext->maintenance6;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance8FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance8FeaturesKHR *in_ext = (const VkPhysicalDeviceMaintenance8FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->maintenance8 = in_ext->maintenance8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance9FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance9FeaturesKHR *in_ext = (const VkPhysicalDeviceMaintenance9FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->maintenance9 = in_ext->maintenance9;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryDecompressionFeaturesNV *in_ext = (const VkPhysicalDeviceMemoryDecompressionFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->memoryDecompression = in_ext->memoryDecompression;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            VkPhysicalDeviceMemoryPriorityFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryPriorityFeaturesEXT *in_ext = (const VkPhysicalDeviceMemoryPriorityFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->memoryPriority = in_ext->memoryPriority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
            VkPhysicalDeviceMeshShaderFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesEXT *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_ext->multiviewMeshShader = in_ext->multiviewMeshShader;
            out_ext->primitiveFragmentShadingRateMeshShader = in_ext->primitiveFragmentShadingRateMeshShader;
            out_ext->meshShaderQueries = in_ext->meshShaderQueries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            VkPhysicalDeviceMeshShaderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesNV *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
            VkPhysicalDeviceMultiDrawFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiDrawFeaturesEXT *in_ext = (const VkPhysicalDeviceMultiDrawFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multiDraw = in_ext->multiDraw;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
            VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *in_ext = (const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multisampledRenderToSingleSampled = in_ext->multisampledRenderToSingleSampled;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            VkPhysicalDeviceMultiviewFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewFeatures *in_ext = (const VkPhysicalDeviceMultiviewFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
            out_ext->pNext = NULL;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *in_ext = (const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewRenderAreas = in_ext->multiviewPerViewRenderAreas;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *in_ext = (const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewViewports = in_ext->multiviewPerViewViewports;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
            VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *in_ext = (const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->mutableDescriptorType = in_ext->mutableDescriptorType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNestedCommandBufferFeaturesEXT *in_ext = (const VkPhysicalDeviceNestedCommandBufferFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nestedCommandBuffer = in_ext->nestedCommandBuffer;
            out_ext->nestedCommandBufferRendering = in_ext->nestedCommandBufferRendering;
            out_ext->nestedCommandBufferSimultaneousUse = in_ext->nestedCommandBufferSimultaneousUse;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *in_ext = (const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nonSeamlessCubeMap = in_ext->nonSeamlessCubeMap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpacityMicromapFeaturesEXT *in_ext = (const VkPhysicalDeviceOpacityMicromapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->micromap = in_ext->micromap;
            out_ext->micromapCaptureReplay = in_ext->micromapCaptureReplay;
            out_ext->micromapHostCommands = in_ext->micromapHostCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
            VkPhysicalDeviceOpticalFlowFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpticalFlowFeaturesNV *in_ext = (const VkPhysicalDeviceOpticalFlowFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->opticalFlow = in_ext->opticalFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *in_ext = (const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pageableDeviceLocalMemory = in_ext->pageableDeviceLocalMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV:
        {
            VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV *in_ext = (const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->partitionedAccelerationStructure = in_ext->partitionedAccelerationStructure;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV:
        {
            VkPhysicalDevicePerStageDescriptorSetFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePerStageDescriptorSetFeaturesNV *in_ext = (const VkPhysicalDevicePerStageDescriptorSetFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->perStageDescriptorSet = in_ext->perStageDescriptorSet;
            out_ext->dynamicPipelineLayout = in_ext->dynamicPipelineLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            VkPhysicalDevicePerformanceQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePerformanceQueryFeaturesKHR *in_ext = (const VkPhysicalDevicePerformanceQueryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->performanceCounterQueryPools = in_ext->performanceCounterQueryPools;
            out_ext->performanceCounterMultipleQueryPools = in_ext->performanceCounterMultipleQueryPools;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineBinaryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineBinaryFeaturesKHR *in_ext = (const VkPhysicalDevicePipelineBinaryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineBinaries = in_ext->pipelineBinaries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC:
        {
            VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC *in_ext = (const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC;
            out_ext->pNext = NULL;
            out_ext->pipelineCacheIncrementalMode = in_ext->pipelineCacheIncrementalMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
            VkPhysicalDevicePipelineCreationCacheControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineCreationCacheControlFeatures *in_ext = (const VkPhysicalDevicePipelineCreationCacheControlFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *in_ext = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineExecutableInfo = in_ext->pipelineExecutableInfo;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM:
        {
            VkPhysicalDevicePipelineOpacityMicromapFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM *in_ext = (const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->pipelineOpacityMicromap = in_ext->pipelineOpacityMicromap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelinePropertiesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelinePropertiesFeaturesEXT *in_ext = (const VkPhysicalDevicePipelinePropertiesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelinePropertiesIdentifier = in_ext->pipelinePropertiesIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES:
        {
            VkPhysicalDevicePipelineProtectedAccessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineProtectedAccessFeatures *in_ext = (const VkPhysicalDevicePipelineProtectedAccessFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDevicePipelineRobustnessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineRobustnessFeatures *in_ext = (const VkPhysicalDevicePipelineRobustnessFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
            VkPhysicalDevicePresentBarrierFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentBarrierFeaturesNV *in_ext = (const VkPhysicalDevicePresentBarrierFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->presentBarrier = in_ext->presentBarrier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR:
        {
            VkPhysicalDevicePresentId2FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentId2FeaturesKHR *in_ext = (const VkPhysicalDevicePresentId2FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentId2 = in_ext->presentId2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
            VkPhysicalDevicePresentIdFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentIdFeaturesKHR *in_ext = (const VkPhysicalDevicePresentIdFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentId = in_ext->presentId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR:
        {
            VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR *in_ext = (const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentModeFifoLatestReady = in_ext->presentModeFifoLatestReady;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWait2FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentWait2FeaturesKHR *in_ext = (const VkPhysicalDevicePresentWait2FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentWait2 = in_ext->presentWait2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWaitFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentWaitFeaturesKHR *in_ext = (const VkPhysicalDevicePresentWaitFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentWait = in_ext->presentWait;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *in_ext = (const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitiveTopologyListRestart = in_ext->primitiveTopologyListRestart;
            out_ext->primitiveTopologyPatchListRestart = in_ext->primitiveTopologyPatchListRestart;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *in_ext = (const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitivesGeneratedQuery = in_ext->primitivesGeneratedQuery;
            out_ext->primitivesGeneratedQueryWithRasterizerDiscard = in_ext->primitivesGeneratedQueryWithRasterizerDiscard;
            out_ext->primitivesGeneratedQueryWithNonZeroStreams = in_ext->primitivesGeneratedQueryWithNonZeroStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
            VkPhysicalDevicePrivateDataFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrivateDataFeatures *in_ext = (const VkPhysicalDevicePrivateDataFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
            out_ext->pNext = NULL;
            out_ext->privateData = in_ext->privateData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            VkPhysicalDeviceProtectedMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProtectedMemoryFeatures *in_ext = (const VkPhysicalDeviceProtectedMemoryFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
            VkPhysicalDeviceProvokingVertexFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProvokingVertexFeaturesEXT *in_ext = (const VkPhysicalDeviceProvokingVertexFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->provokingVertexLast = in_ext->provokingVertexLast;
            out_ext->transformFeedbackPreservesProvokingVertex = in_ext->transformFeedbackPreservesProvokingVertex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *in_ext = (const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatRgba10x6WithoutYCbCrSampler = in_ext->formatRgba10x6WithoutYCbCrSampler;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *in_ext = (const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->rasterizationOrderColorAttachmentAccess = in_ext->rasterizationOrderColorAttachmentAccess;
            out_ext->rasterizationOrderDepthAttachmentAccess = in_ext->rasterizationOrderDepthAttachmentAccess;
            out_ext->rasterizationOrderStencilAttachmentAccess = in_ext->rasterizationOrderStencilAttachmentAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV:
        {
            VkPhysicalDeviceRawAccessChainsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRawAccessChainsFeaturesNV *in_ext = (const VkPhysicalDeviceRawAccessChainsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderRawAccessChains = in_ext->shaderRawAccessChains;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceRayQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayQueryFeaturesKHR *in_ext = (const VkPhysicalDeviceRayQueryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayQuery = in_ext->rayQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingInvocationReorder = in_ext->rayTracingInvocationReorder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->spheres = in_ext->spheres;
            out_ext->linearSweptSpheres = in_ext->linearSweptSpheres;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingMaintenance1 = in_ext->rayTracingMaintenance1;
            out_ext->rayTracingPipelineTraceRaysIndirect2 = in_ext->rayTracingPipelineTraceRaysIndirect2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingMotionBlur = in_ext->rayTracingMotionBlur;
            out_ext->rayTracingMotionBlurPipelineTraceRaysIndirect = in_ext->rayTracingMotionBlurPipelineTraceRaysIndirect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPipeline = in_ext->rayTracingPipeline;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplay = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplay;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
            out_ext->rayTracingPipelineTraceRaysIndirect = in_ext->rayTracingPipelineTraceRaysIndirect;
            out_ext->rayTraversalPrimitiveCulling = in_ext->rayTraversalPrimitiveCulling;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPositionFetch = in_ext->rayTracingPositionFetch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingValidationFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingValidationFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingValidationFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingValidation = in_ext->rayTracingValidation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG:
        {
            VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG *in_ext = (const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG;
            out_ext->pNext = NULL;
            out_ext->relaxedLineRasterization = in_ext->relaxedLineRasterization;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM:
        {
            VkPhysicalDeviceRenderPassStripedFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRenderPassStripedFeaturesARM *in_ext = (const VkPhysicalDeviceRenderPassStripedFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->renderPassStriped = in_ext->renderPassStriped;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *in_ext = (const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->representativeFragmentTest = in_ext->representativeFragmentTest;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR:
        {
            VkPhysicalDeviceRobustness2FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRobustness2FeaturesKHR *in_ext = (const VkPhysicalDeviceRobustness2FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->robustBufferAccess2 = in_ext->robustBufferAccess2;
            out_ext->robustImageAccess2 = in_ext->robustImageAccess2;
            out_ext->nullDescriptor = in_ext->nullDescriptor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            VkPhysicalDeviceSamplerYcbcrConversionFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSamplerYcbcrConversionFeatures *in_ext = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceScalarBlockLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceScalarBlockLayoutFeatures *in_ext = (const VkPhysicalDeviceScalarBlockLayoutFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM:
        {
            VkPhysicalDeviceSchedulingControlsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSchedulingControlsFeaturesARM *in_ext = (const VkPhysicalDeviceSchedulingControlsFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->schedulingControls = in_ext->schedulingControls;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *in_ext = (const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV:
        {
            VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV *in_ext = (const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderFloat16VectorAtomics = in_ext->shaderFloat16VectorAtomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *in_ext = (const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat16Atomics = in_ext->shaderBufferFloat16Atomics;
            out_ext->shaderBufferFloat16AtomicAdd = in_ext->shaderBufferFloat16AtomicAdd;
            out_ext->shaderBufferFloat16AtomicMinMax = in_ext->shaderBufferFloat16AtomicMinMax;
            out_ext->shaderBufferFloat32AtomicMinMax = in_ext->shaderBufferFloat32AtomicMinMax;
            out_ext->shaderBufferFloat64AtomicMinMax = in_ext->shaderBufferFloat64AtomicMinMax;
            out_ext->shaderSharedFloat16Atomics = in_ext->shaderSharedFloat16Atomics;
            out_ext->shaderSharedFloat16AtomicAdd = in_ext->shaderSharedFloat16AtomicAdd;
            out_ext->shaderSharedFloat16AtomicMinMax = in_ext->shaderSharedFloat16AtomicMinMax;
            out_ext->shaderSharedFloat32AtomicMinMax = in_ext->shaderSharedFloat32AtomicMinMax;
            out_ext->shaderSharedFloat64AtomicMinMax = in_ext->shaderSharedFloat64AtomicMinMax;
            out_ext->shaderImageFloat32AtomicMinMax = in_ext->shaderImageFloat32AtomicMinMax;
            out_ext->sparseImageFloat32AtomicMinMax = in_ext->sparseImageFloat32AtomicMinMax;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat32Atomics = in_ext->shaderBufferFloat32Atomics;
            out_ext->shaderBufferFloat32AtomicAdd = in_ext->shaderBufferFloat32AtomicAdd;
            out_ext->shaderBufferFloat64Atomics = in_ext->shaderBufferFloat64Atomics;
            out_ext->shaderBufferFloat64AtomicAdd = in_ext->shaderBufferFloat64AtomicAdd;
            out_ext->shaderSharedFloat32Atomics = in_ext->shaderSharedFloat32Atomics;
            out_ext->shaderSharedFloat32AtomicAdd = in_ext->shaderSharedFloat32AtomicAdd;
            out_ext->shaderSharedFloat64Atomics = in_ext->shaderSharedFloat64Atomics;
            out_ext->shaderSharedFloat64AtomicAdd = in_ext->shaderSharedFloat64AtomicAdd;
            out_ext->shaderImageFloat32Atomics = in_ext->shaderImageFloat32Atomics;
            out_ext->shaderImageFloat32AtomicAdd = in_ext->shaderImageFloat32AtomicAdd;
            out_ext->sparseImageFloat32Atomics = in_ext->sparseImageFloat32Atomics;
            out_ext->sparseImageFloat32AtomicAdd = in_ext->sparseImageFloat32AtomicAdd;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            VkPhysicalDeviceShaderAtomicInt64Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicInt64Features *in_ext = (const VkPhysicalDeviceShaderAtomicInt64Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderBfloat16FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderBfloat16FeaturesKHR *in_ext = (const VkPhysicalDeviceShaderBfloat16FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderBFloat16Type = in_ext->shaderBFloat16Type;
            out_ext->shaderBFloat16DotProduct = in_ext->shaderBFloat16DotProduct;
            out_ext->shaderBFloat16CooperativeMatrix = in_ext->shaderBFloat16CooperativeMatrix;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderClockFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderClockFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderClockFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupClock = in_ext->shaderSubgroupClock;
            out_ext->shaderDeviceClock = in_ext->shaderDeviceClock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *in_ext = (const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->shaderCoreBuiltins = in_ext->shaderCoreBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *in_ext = (const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            VkPhysicalDeviceShaderDrawParametersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDrawParametersFeatures *in_ext = (const VkPhysicalDeviceShaderDrawParametersFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
            VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *in_ext = (const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->shaderEarlyAndLateFragmentTests = in_ext->shaderEarlyAndLateFragmentTests;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES:
        {
            VkPhysicalDeviceShaderExpectAssumeFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderExpectAssumeFeatures *in_ext = (const VkPhysicalDeviceShaderExpectAssumeFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderExpectAssume = in_ext->shaderExpectAssume;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            VkPhysicalDeviceShaderFloat16Int8Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloat16Int8Features *in_ext = (const VkPhysicalDeviceShaderFloat16Int8Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderFloat8FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloat8FeaturesEXT *in_ext = (const VkPhysicalDeviceShaderFloat8FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderFloat8 = in_ext->shaderFloat8;
            out_ext->shaderFloat8CooperativeMatrix = in_ext->shaderFloat8CooperativeMatrix;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES:
        {
            VkPhysicalDeviceShaderFloatControls2Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloatControls2Features *in_ext = (const VkPhysicalDeviceShaderFloatControls2Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderFloatControls2 = in_ext->shaderFloatControls2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *in_ext = (const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderImageInt64Atomics = in_ext->shaderImageInt64Atomics;
            out_ext->sparseImageInt64Atomics = in_ext->sparseImageInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            VkPhysicalDeviceShaderImageFootprintFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageFootprintFeaturesNV *in_ext = (const VkPhysicalDeviceShaderImageFootprintFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->imageFootprint = in_ext->imageFootprint;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
            VkPhysicalDeviceShaderIntegerDotProductFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerDotProductFeatures *in_ext = (const VkPhysicalDeviceShaderIntegerDotProductFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *in_ext = (const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerFunctions2 = in_ext->shaderIntegerFunctions2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderMaximalReconvergence = in_ext->shaderMaximalReconvergence;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderModuleIdentifier = in_ext->shaderModuleIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderObjectFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderObjectFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderObjectFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderObject = in_ext->shaderObject;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderQuadControlFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderQuadControlFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderQuadControlFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderQuadControl = in_ext->shaderQuadControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderRelaxedExtendedInstruction = in_ext->shaderRelaxedExtendedInstruction;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderReplicatedComposites = in_ext->shaderReplicatedComposites;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *in_ext = (const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderSMBuiltins = in_ext->shaderSMBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *in_ext = (const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupRotateFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupRotateFeatures *in_ext = (const VkPhysicalDeviceShaderSubgroupRotateFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupRotate = in_ext->shaderSubgroupRotate;
            out_ext->shaderSubgroupRotateClustered = in_ext->shaderSubgroupRotateClustered;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupUniformControlFlow = in_ext->shaderSubgroupUniformControlFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderTerminateInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTerminateInvocationFeatures *in_ext = (const VkPhysicalDeviceShaderTerminateInvocationFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderTileImageFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTileImageFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderTileImageFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderTileImageColorReadAccess = in_ext->shaderTileImageColorReadAccess;
            out_ext->shaderTileImageDepthReadAccess = in_ext->shaderTileImageDepthReadAccess;
            out_ext->shaderTileImageStencilReadAccess = in_ext->shaderTileImageStencilReadAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderUntypedPointersFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderUntypedPointers = in_ext->shaderUntypedPointers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceShadingRateImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShadingRateImageFeaturesNV *in_ext = (const VkPhysicalDeviceShadingRateImageFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateImage = in_ext->shadingRateImage;
            out_ext->shadingRateCoarseSampleOrder = in_ext->shadingRateCoarseSampleOrder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
            VkPhysicalDeviceSubgroupSizeControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubgroupSizeControlFeatures *in_ext = (const VkPhysicalDeviceSubgroupSizeControlFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *in_ext = (const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->subpassMergeFeedback = in_ext->subpassMergeFeedback;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->subpassShading = in_ext->subpassShading;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR *in_ext = (const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainMaintenance1 = in_ext->swapchainMaintenance1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
            VkPhysicalDeviceSynchronization2Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSynchronization2Features *in_ext = (const VkPhysicalDeviceSynchronization2Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM:
        {
            VkPhysicalDeviceTensorFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTensorFeaturesARM *in_ext = (const VkPhysicalDeviceTensorFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorNonPacked = in_ext->tensorNonPacked;
            out_ext->shaderTensorAccess = in_ext->shaderTensorAccess;
            out_ext->shaderStorageTensorArrayDynamicIndexing = in_ext->shaderStorageTensorArrayDynamicIndexing;
            out_ext->shaderStorageTensorArrayNonUniformIndexing = in_ext->shaderStorageTensorArrayNonUniformIndexing;
            out_ext->descriptorBindingStorageTensorUpdateAfterBind = in_ext->descriptorBindingStorageTensorUpdateAfterBind;
            out_ext->tensors = in_ext->tensors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *in_ext = (const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->texelBufferAlignment = in_ext->texelBufferAlignment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
            VkPhysicalDeviceTextureCompressionASTCHDRFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTextureCompressionASTCHDRFeatures *in_ext = (const VkPhysicalDeviceTextureCompressionASTCHDRFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
            out_ext->pNext = NULL;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM:
        {
            VkPhysicalDeviceTileMemoryHeapFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM *in_ext = (const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileMemoryHeap = in_ext->tileMemoryHeap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
            VkPhysicalDeviceTilePropertiesFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTilePropertiesFeaturesQCOM *in_ext = (const VkPhysicalDeviceTilePropertiesFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileProperties = in_ext->tileProperties;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM:
        {
            VkPhysicalDeviceTileShadingFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTileShadingFeaturesQCOM *in_ext = (const VkPhysicalDeviceTileShadingFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileShading = in_ext->tileShading;
            out_ext->tileShadingFragmentStage = in_ext->tileShadingFragmentStage;
            out_ext->tileShadingColorAttachments = in_ext->tileShadingColorAttachments;
            out_ext->tileShadingDepthAttachments = in_ext->tileShadingDepthAttachments;
            out_ext->tileShadingStencilAttachments = in_ext->tileShadingStencilAttachments;
            out_ext->tileShadingInputAttachments = in_ext->tileShadingInputAttachments;
            out_ext->tileShadingSampledAttachments = in_ext->tileShadingSampledAttachments;
            out_ext->tileShadingPerTileDraw = in_ext->tileShadingPerTileDraw;
            out_ext->tileShadingPerTileDispatch = in_ext->tileShadingPerTileDispatch;
            out_ext->tileShadingDispatchTile = in_ext->tileShadingDispatchTile;
            out_ext->tileShadingApron = in_ext->tileShadingApron;
            out_ext->tileShadingAnisotropicApron = in_ext->tileShadingAnisotropicApron;
            out_ext->tileShadingAtomicOps = in_ext->tileShadingAtomicOps;
            out_ext->tileShadingImageProcessing = in_ext->tileShadingImageProcessing;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            VkPhysicalDeviceTimelineSemaphoreFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTimelineSemaphoreFeatures *in_ext = (const VkPhysicalDeviceTimelineSemaphoreFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTransformFeedbackFeaturesEXT *in_ext = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->transformFeedback = in_ext->transformFeedback;
            out_ext->geometryStreams = in_ext->geometryStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR:
        {
            VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR *in_ext = (const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->unifiedImageLayouts = in_ext->unifiedImageLayouts;
            out_ext->unifiedImageLayoutsVideo = in_ext->unifiedImageLayoutsVideo;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *in_ext = (const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            VkPhysicalDeviceVariablePointersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVariablePointersFeatures *in_ext = (const VkPhysicalDeviceVariablePointersFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES:
        {
            VkPhysicalDeviceVertexAttributeDivisorFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexAttributeDivisorFeatures *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
            out_ext->pNext = NULL;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT *in_ext = (const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexAttributeRobustness = in_ext->vertexAttributeRobustness;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexInputDynamicState = in_ext->vertexInputDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoDecodeVP9FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR *in_ext = (const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoDecodeVP9 = in_ext->videoDecodeVP9;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeAV1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR *in_ext = (const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoEncodeAV1 = in_ext->videoEncodeAV1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR *in_ext = (const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoEncodeIntraRefresh = in_ext->videoEncodeIntraRefresh;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR *in_ext = (const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoEncodeQuantizationMap = in_ext->videoEncodeQuantizationMap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoMaintenance1FeaturesKHR *in_ext = (const VkPhysicalDeviceVideoMaintenance1FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoMaintenance1 = in_ext->videoMaintenance1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            VkPhysicalDeviceVulkan11Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan11Features *in_ext = (const VkPhysicalDeviceVulkan11Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            VkPhysicalDeviceVulkan12Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan12Features *in_ext = (const VkPhysicalDeviceVulkan12Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerMirrorClampToEdge = in_ext->samplerMirrorClampToEdge;
            out_ext->drawIndirectCount = in_ext->drawIndirectCount;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_ext->descriptorIndexing = in_ext->descriptorIndexing;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_ext->samplerFilterMinmax = in_ext->samplerFilterMinmax;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_ext->shaderOutputViewportIndex = in_ext->shaderOutputViewportIndex;
            out_ext->shaderOutputLayer = in_ext->shaderOutputLayer;
            out_ext->subgroupBroadcastDynamicId = in_ext->subgroupBroadcastDynamicId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
            VkPhysicalDeviceVulkan13Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan13Features *in_ext = (const VkPhysicalDeviceVulkan13Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_ext->privateData = in_ext->privateData;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES:
        {
            VkPhysicalDeviceVulkan14Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan14Features *in_ext = (const VkPhysicalDeviceVulkan14Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES;
            out_ext->pNext = NULL;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_ext->shaderSubgroupRotate = in_ext->shaderSubgroupRotate;
            out_ext->shaderSubgroupRotateClustered = in_ext->shaderSubgroupRotateClustered;
            out_ext->shaderFloatControls2 = in_ext->shaderFloatControls2;
            out_ext->shaderExpectAssume = in_ext->shaderExpectAssume;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_ext->dynamicRenderingLocalRead = in_ext->dynamicRenderingLocalRead;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_ext->maintenance6 = in_ext->maintenance6;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_ext->pushDescriptor = in_ext->pushDescriptor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            VkPhysicalDeviceVulkanMemoryModelFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkanMemoryModelFeatures *in_ext = (const VkPhysicalDeviceVulkanMemoryModelFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *in_ext = (const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->workgroupMemoryExplicitLayout = in_ext->workgroupMemoryExplicitLayout;
            out_ext->workgroupMemoryExplicitLayoutScalarBlockLayout = in_ext->workgroupMemoryExplicitLayoutScalarBlockLayout;
            out_ext->workgroupMemoryExplicitLayout8BitAccess = in_ext->workgroupMemoryExplicitLayout8BitAccess;
            out_ext->workgroupMemoryExplicitLayout16BitAccess = in_ext->workgroupMemoryExplicitLayout16BitAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *in_ext = (const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcr2plane444Formats = in_ext->ycbcr2plane444Formats;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
            VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *in_ext = (const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->ycbcrDegamma = in_ext->ycbcrDegamma;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *in_ext = (const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcrImageArrays = in_ext->ycbcrImageArrays;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT *in_ext = (const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->zeroInitializeDeviceMemory = in_ext->zeroInitializeDeviceMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *in_ext = (const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

static void convert_VkDeviceQueueCreateInfo_win32_to_host(struct conversion_context *ctx, const VkDeviceQueueCreateInfo32 *in, VkDeviceQueueCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queueFamilyIndex = in->queueFamilyIndex;
    out->queueCount = in->queueCount;
    out->pQueuePriorities = UlongToPtr(in->pQueuePriorities);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO:
        {
            VkDeviceQueueGlobalPriorityCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceQueueGlobalPriorityCreateInfo32 *in_ext = (const VkDeviceQueueGlobalPriorityCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->globalPriority = in_ext->globalPriority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM:
        {
            VkDeviceQueueShaderCoreControlCreateInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceQueueShaderCoreControlCreateInfoARM32 *in_ext = (const VkDeviceQueueShaderCoreControlCreateInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->shaderCoreCount = in_ext->shaderCoreCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkDeviceQueueCreateInfo *convert_VkDeviceQueueCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkDeviceQueueCreateInfo32 *in, uint32_t count)
{
    VkDeviceQueueCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDeviceQueueCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static const char * const*convert_char_pointer_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    char **out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = UlongToPtr(in[i]);
    }

    return (void *)out;
}

static const VkPhysicalDevice *convert_VkPhysicalDevice_array_win32_to_host(struct conversion_context *ctx, const PTR32 *in, uint32_t count)
{
    VkPhysicalDevice *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_physical_device_from_handle(UlongToPtr(in[i]))->host.physical_device;
    }

    return out;
}

static void convert_VkDeviceCreateInfo_win32_to_host(struct conversion_context *ctx, const VkDeviceCreateInfo32 *in, VkDeviceCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queueCreateInfoCount = in->queueCreateInfoCount;
    out->pQueueCreateInfos = convert_VkDeviceQueueCreateInfo_array_win32_to_host(ctx, (const VkDeviceQueueCreateInfo32 *)UlongToPtr(in->pQueueCreateInfos), in->queueCreateInfoCount);
    out->enabledLayerCount = in->enabledLayerCount;
    out->ppEnabledLayerNames = convert_char_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppEnabledLayerNames), in->enabledLayerCount);
    out->enabledExtensionCount = in->enabledExtensionCount;
    out->ppEnabledExtensionNames = convert_char_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppEnabledExtensionNames), in->enabledExtensionCount);
    out->pEnabledFeatures = UlongToPtr(in->pEnabledFeatures);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO:
            break;
        case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {
            VkDeviceDiagnosticsConfigCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceDiagnosticsConfigCreateInfoNV32 *in_ext = (const VkDeviceDiagnosticsConfigCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {
            VkDeviceGroupDeviceCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupDeviceCreateInfo32 *in_ext = (const VkDeviceGroupDeviceCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->physicalDeviceCount = in_ext->physicalDeviceCount;
            out_ext->pPhysicalDevices = convert_VkPhysicalDevice_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in_ext->pPhysicalDevices), in_ext->physicalDeviceCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {
            VkDeviceMemoryOverallocationCreateInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceMemoryOverallocationCreateInfoAMD32 *in_ext = (const VkDeviceMemoryOverallocationCreateInfoAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->overallocationBehavior = in_ext->overallocationBehavior;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR:
        {
            VkDevicePipelineBinaryInternalCacheControlKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDevicePipelineBinaryInternalCacheControlKHR32 *in_ext = (const VkDevicePipelineBinaryInternalCacheControlKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR;
            out_ext->pNext = NULL;
            out_ext->disableInternalCache = in_ext->disableInternalCache;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
        {
            VkDevicePrivateDataCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDevicePrivateDataCreateInfo32 *in_ext = (const VkDevicePrivateDataCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->privateDataSlotRequestCount = in_ext->privateDataSlotRequestCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM:
        {
            VkDeviceQueueShaderCoreControlCreateInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceQueueShaderCoreControlCreateInfoARM32 *in_ext = (const VkDeviceQueueShaderCoreControlCreateInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->shaderCoreCount = in_ext->shaderCoreCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR:
        {
            VkPerformanceQueryReservationInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQueryReservationInfoKHR32 *in_ext = (const VkPerformanceQueryReservationInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->maxPerformanceQueriesPerPool = in_ext->maxPerformanceQueriesPerPool;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice16BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice16BitStorageFeatures32 *in_ext = (const VkPhysicalDevice16BitStorageFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDevice4444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice4444FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDevice4444FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatA4R4G4B4 = in_ext->formatA4R4G4B4;
            out_ext->formatA4B4G4R4 = in_ext->formatA4B4G4R4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice8BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice8BitStorageFeatures32 *in_ext = (const VkPhysicalDevice8BitStorageFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            VkPhysicalDeviceASTCDecodeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceASTCDecodeFeaturesEXT32 *in_ext = (const VkPhysicalDeviceASTCDecodeFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->decodeModeSharedExponent = in_ext->decodeModeSharedExponent;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            VkPhysicalDeviceAccelerationStructureFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAccelerationStructureFeaturesKHR32 *in_ext = (const VkPhysicalDeviceAccelerationStructureFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->accelerationStructure = in_ext->accelerationStructure;
            out_ext->accelerationStructureCaptureReplay = in_ext->accelerationStructureCaptureReplay;
            out_ext->accelerationStructureIndirectBuild = in_ext->accelerationStructureIndirectBuild;
            out_ext->accelerationStructureHostCommands = in_ext->accelerationStructureHostCommands;
            out_ext->descriptorBindingAccelerationStructureUpdateAfterBind = in_ext->descriptorBindingAccelerationStructureUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
            VkPhysicalDeviceAddressBindingReportFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAddressBindingReportFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAddressBindingReportFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->reportAddressBinding = in_ext->reportAddressBinding;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD:
        {
            VkPhysicalDeviceAntiLagFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAntiLagFeaturesAMD32 *in_ext = (const VkPhysicalDeviceAntiLagFeaturesAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->antiLag = in_ext->antiLag;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopDynamicState = in_ext->attachmentFeedbackLoopDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopLayout = in_ext->attachmentFeedbackLoopLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->advancedBlendCoherentOperations = in_ext->advancedBlendCoherentOperations;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
            VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->borderColorSwizzle = in_ext->borderColorSwizzle;
            out_ext->borderColorSwizzleFromImage = in_ext->borderColorSwizzleFromImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            VkPhysicalDeviceBufferDeviceAddressFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeatures32 *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV:
        {
            VkPhysicalDeviceClusterAccelerationStructureFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV32 *in_ext = (const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->clusterAccelerationStructure = in_ext->clusterAccelerationStructure;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->clustercullingShader = in_ext->clustercullingShader;
            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            VkPhysicalDeviceCoherentMemoryFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoherentMemoryFeaturesAMD32 *in_ext = (const VkPhysicalDeviceCoherentMemoryFeaturesAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->deviceCoherentMemory = in_ext->deviceCoherentMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceColorWriteEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceColorWriteEnableFeaturesEXT32 *in_ext = (const VkPhysicalDeviceColorWriteEnableFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->colorWriteEnable = in_ext->colorWriteEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV:
        {
            VkPhysicalDeviceCommandBufferInheritanceFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV32 *in_ext = (const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->commandBufferInheritance = in_ext->commandBufferInheritance;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR:
        {
            VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR32 *in_ext = (const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->computeDerivativeGroupQuads = in_ext->computeDerivativeGroupQuads;
            out_ext->computeDerivativeGroupLinear = in_ext->computeDerivativeGroupLinear;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            VkPhysicalDeviceConditionalRenderingFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceConditionalRenderingFeaturesEXT32 *in_ext = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->conditionalRendering = in_ext->conditionalRendering;
            out_ext->inheritedConditionalRendering = in_ext->inheritedConditionalRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrix2FeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrix2FeaturesNV32 *in_ext = (const VkPhysicalDeviceCooperativeMatrix2FeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrixWorkgroupScope = in_ext->cooperativeMatrixWorkgroupScope;
            out_ext->cooperativeMatrixFlexibleDimensions = in_ext->cooperativeMatrixFlexibleDimensions;
            out_ext->cooperativeMatrixReductions = in_ext->cooperativeMatrixReductions;
            out_ext->cooperativeMatrixConversions = in_ext->cooperativeMatrixConversions;
            out_ext->cooperativeMatrixPerElementOperations = in_ext->cooperativeMatrixPerElementOperations;
            out_ext->cooperativeMatrixTensorAddressing = in_ext->cooperativeMatrixTensorAddressing;
            out_ext->cooperativeMatrixBlockLoads = in_ext->cooperativeMatrixBlockLoads;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesKHR32 *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesNV32 *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeVectorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeVectorFeaturesNV32 *in_ext = (const VkPhysicalDeviceCooperativeVectorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeVector = in_ext->cooperativeVector;
            out_ext->cooperativeVectorTraining = in_ext->cooperativeVectorTraining;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32 *in_ext = (const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->indirectCopy = in_ext->indirectCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceCornerSampledImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCornerSampledImageFeaturesNV32 *in_ext = (const VkPhysicalDeviceCornerSampledImageFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cornerSampledImage = in_ext->cornerSampledImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            VkPhysicalDeviceCoverageReductionModeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoverageReductionModeFeaturesNV32 *in_ext = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->coverageReductionMode = in_ext->coverageReductionMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicClampFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicClampFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceCubicClampFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->cubicRangeClamp = in_ext->cubicRangeClamp;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicWeightsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicWeightsFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceCubicWeightsFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->selectableCubicWeights = in_ext->selectableCubicWeights;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCustomBorderColorFeaturesEXT32 *in_ext = (const VkPhysicalDeviceCustomBorderColorFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->customBorderColors = in_ext->customBorderColors;
            out_ext->customBorderColorWithoutFormat = in_ext->customBorderColorWithoutFormat;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM:
        {
            VkPhysicalDeviceDataGraphFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDataGraphFeaturesARM32 *in_ext = (const VkPhysicalDeviceDataGraphFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->dataGraph = in_ext->dataGraph;
            out_ext->dataGraphUpdateAfterBind = in_ext->dataGraphUpdateAfterBind;
            out_ext->dataGraphSpecializationConstants = in_ext->dataGraphSpecializationConstants;
            out_ext->dataGraphDescriptorBuffer = in_ext->dataGraphDescriptorBuffer;
            out_ext->dataGraphShaderModule = in_ext->dataGraphShaderModule;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32 *in_ext = (const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocationImageAliasing = in_ext->dedicatedAllocationImageAliasing;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthBiasControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthBiasControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthBiasControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthBiasControl = in_ext->depthBiasControl;
            out_ext->leastRepresentableValueForceUnormRepresentation = in_ext->leastRepresentableValueForceUnormRepresentation;
            out_ext->floatRepresentation = in_ext->floatRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClampControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClampControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClampControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClampControl = in_ext->depthClampControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR:
        {
            VkPhysicalDeviceDepthClampZeroOneFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR32 *in_ext = (const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->depthClampZeroOne = in_ext->depthClampZeroOne;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClipControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipControl = in_ext->depthClipControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipEnableFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClipEnableFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipEnable = in_ext->depthClipEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorBufferFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDescriptorBufferFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->descriptorBuffer = in_ext->descriptorBuffer;
            out_ext->descriptorBufferCaptureReplay = in_ext->descriptorBufferCaptureReplay;
            out_ext->descriptorBufferImageLayoutIgnored = in_ext->descriptorBufferImageLayoutIgnored;
            out_ext->descriptorBufferPushDescriptors = in_ext->descriptorBufferPushDescriptors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM:
        {
            VkPhysicalDeviceDescriptorBufferTensorFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM32 *in_ext = (const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->descriptorBufferTensorDescriptors = in_ext->descriptorBufferTensorDescriptors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            VkPhysicalDeviceDescriptorIndexingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorIndexingFeatures32 *in_ext = (const VkPhysicalDeviceDescriptorIndexingFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
            VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32 *in_ext = (const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->descriptorPoolOverallocation = in_ext->descriptorPoolOverallocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
            VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32 *in_ext = (const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
            out_ext->pNext = NULL;
            out_ext->descriptorSetHostMapping = in_ext->descriptorSetHostMapping;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32 *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCompute = in_ext->deviceGeneratedCompute;
            out_ext->deviceGeneratedComputePipelines = in_ext->deviceGeneratedComputePipelines;
            out_ext->deviceGeneratedComputeCaptureReplay = in_ext->deviceGeneratedComputeCaptureReplay;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_ext->dynamicGeneratedPipelineLayout = in_ext->dynamicGeneratedPipelineLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32 *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDiagnosticsConfigFeaturesNV32 *in_ext = (const VkPhysicalDeviceDiagnosticsConfigFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->diagnosticsConfig = in_ext->diagnosticsConfig;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingFeatures32 *in_ext = (const VkPhysicalDeviceDynamicRenderingFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingLocalReadFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingLocalReadFeatures32 *in_ext = (const VkPhysicalDeviceDynamicRenderingLocalReadFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
            out_ext->pNext = NULL;
            out_ext->dynamicRenderingLocalRead = in_ext->dynamicRenderingLocalRead;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
            VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->dynamicRenderingUnusedAttachments = in_ext->dynamicRenderingUnusedAttachments;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceExclusiveScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExclusiveScissorFeaturesNV32 *in_ext = (const VkPhysicalDeviceExclusiveScissorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->exclusiveScissor = in_ext->exclusiveScissor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState2 = in_ext->extendedDynamicState2;
            out_ext->extendedDynamicState2LogicOp = in_ext->extendedDynamicState2LogicOp;
            out_ext->extendedDynamicState2PatchControlPoints = in_ext->extendedDynamicState2PatchControlPoints;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState3TessellationDomainOrigin = in_ext->extendedDynamicState3TessellationDomainOrigin;
            out_ext->extendedDynamicState3DepthClampEnable = in_ext->extendedDynamicState3DepthClampEnable;
            out_ext->extendedDynamicState3PolygonMode = in_ext->extendedDynamicState3PolygonMode;
            out_ext->extendedDynamicState3RasterizationSamples = in_ext->extendedDynamicState3RasterizationSamples;
            out_ext->extendedDynamicState3SampleMask = in_ext->extendedDynamicState3SampleMask;
            out_ext->extendedDynamicState3AlphaToCoverageEnable = in_ext->extendedDynamicState3AlphaToCoverageEnable;
            out_ext->extendedDynamicState3AlphaToOneEnable = in_ext->extendedDynamicState3AlphaToOneEnable;
            out_ext->extendedDynamicState3LogicOpEnable = in_ext->extendedDynamicState3LogicOpEnable;
            out_ext->extendedDynamicState3ColorBlendEnable = in_ext->extendedDynamicState3ColorBlendEnable;
            out_ext->extendedDynamicState3ColorBlendEquation = in_ext->extendedDynamicState3ColorBlendEquation;
            out_ext->extendedDynamicState3ColorWriteMask = in_ext->extendedDynamicState3ColorWriteMask;
            out_ext->extendedDynamicState3RasterizationStream = in_ext->extendedDynamicState3RasterizationStream;
            out_ext->extendedDynamicState3ConservativeRasterizationMode = in_ext->extendedDynamicState3ConservativeRasterizationMode;
            out_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize = in_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize;
            out_ext->extendedDynamicState3DepthClipEnable = in_ext->extendedDynamicState3DepthClipEnable;
            out_ext->extendedDynamicState3SampleLocationsEnable = in_ext->extendedDynamicState3SampleLocationsEnable;
            out_ext->extendedDynamicState3ColorBlendAdvanced = in_ext->extendedDynamicState3ColorBlendAdvanced;
            out_ext->extendedDynamicState3ProvokingVertexMode = in_ext->extendedDynamicState3ProvokingVertexMode;
            out_ext->extendedDynamicState3LineRasterizationMode = in_ext->extendedDynamicState3LineRasterizationMode;
            out_ext->extendedDynamicState3LineStippleEnable = in_ext->extendedDynamicState3LineStippleEnable;
            out_ext->extendedDynamicState3DepthClipNegativeOneToOne = in_ext->extendedDynamicState3DepthClipNegativeOneToOne;
            out_ext->extendedDynamicState3ViewportWScalingEnable = in_ext->extendedDynamicState3ViewportWScalingEnable;
            out_ext->extendedDynamicState3ViewportSwizzle = in_ext->extendedDynamicState3ViewportSwizzle;
            out_ext->extendedDynamicState3CoverageToColorEnable = in_ext->extendedDynamicState3CoverageToColorEnable;
            out_ext->extendedDynamicState3CoverageToColorLocation = in_ext->extendedDynamicState3CoverageToColorLocation;
            out_ext->extendedDynamicState3CoverageModulationMode = in_ext->extendedDynamicState3CoverageModulationMode;
            out_ext->extendedDynamicState3CoverageModulationTableEnable = in_ext->extendedDynamicState3CoverageModulationTableEnable;
            out_ext->extendedDynamicState3CoverageModulationTable = in_ext->extendedDynamicState3CoverageModulationTable;
            out_ext->extendedDynamicState3CoverageReductionMode = in_ext->extendedDynamicState3CoverageReductionMode;
            out_ext->extendedDynamicState3RepresentativeFragmentTestEnable = in_ext->extendedDynamicState3RepresentativeFragmentTestEnable;
            out_ext->extendedDynamicState3ShadingRateImageEnable = in_ext->extendedDynamicState3ShadingRateImageEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState = in_ext->extendedDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32 *in_ext = (const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->extendedSparseAddressSpace = in_ext->extendedSparseAddressSpace;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
            VkPhysicalDeviceFaultFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFaultFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFaultFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceFault = in_ext->deviceFault;
            out_ext->deviceFaultVendorBinary = in_ext->deviceFaultVendorBinary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {
            VkPhysicalDeviceFeatures2 *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFeatures232 *in_ext = (const VkPhysicalDeviceFeatures232 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
            out_ext->pNext = NULL;
            out_ext->features = in_ext->features;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM:
        {
            VkPhysicalDeviceFormatPackFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFormatPackFeaturesARM32 *in_ext = (const VkPhysicalDeviceFormatPackFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->formatPack = in_ext->formatPack;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapDeferred = in_ext->fragmentDensityMapDeferred;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentDensityMapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMap = in_ext->fragmentDensityMap;
            out_ext->fragmentDensityMapDynamic = in_ext->fragmentDensityMapDynamic;
            out_ext->fragmentDensityMapNonSubsampledImages = in_ext->fragmentDensityMapNonSubsampledImages;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE:
        {
            VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapOffset = in_ext->fragmentDensityMapOffset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 *in_ext = (const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderBarycentric = in_ext->fragmentShaderBarycentric;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderSampleInterlock = in_ext->fragmentShaderSampleInterlock;
            out_ext->fragmentShaderPixelInterlock = in_ext->fragmentShaderPixelInterlock;
            out_ext->fragmentShaderShadingRateInterlock = in_ext->fragmentShaderShadingRateInterlock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32 *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->fragmentShadingRateEnums = in_ext->fragmentShadingRateEnums;
            out_ext->supersampleFragmentShadingRates = in_ext->supersampleFragmentShadingRates;
            out_ext->noInvocationFragmentShadingRates = in_ext->noInvocationFragmentShadingRates;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateFeaturesKHR32 *in_ext = (const VkPhysicalDeviceFragmentShadingRateFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineFragmentShadingRate = in_ext->pipelineFragmentShadingRate;
            out_ext->primitiveFragmentShadingRate = in_ext->primitiveFragmentShadingRate;
            out_ext->attachmentFragmentShadingRate = in_ext->attachmentFragmentShadingRate;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
            VkPhysicalDeviceFrameBoundaryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFrameBoundaryFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFrameBoundaryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->frameBoundary = in_ext->frameBoundary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES:
        {
            VkPhysicalDeviceGlobalPriorityQueryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGlobalPriorityQueryFeatures32 *in_ext = (const VkPhysicalDeviceGlobalPriorityQueryFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32 *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->graphicsPipelineLibrary = in_ext->graphicsPipelineLibrary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceHdrVividFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHdrVividFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceHdrVividFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->hdrVivid = in_ext->hdrVivid;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES:
        {
            VkPhysicalDeviceHostImageCopyFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostImageCopyFeatures32 *in_ext = (const VkPhysicalDeviceHostImageCopyFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            VkPhysicalDeviceHostQueryResetFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostQueryResetFeatures32 *in_ext = (const VkPhysicalDeviceHostQueryResetFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
            out_ext->pNext = NULL;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->image2DViewOf3D = in_ext->image2DViewOf3D;
            out_ext->sampler2DViewOf3D = in_ext->sampler2DViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA:
        {
            VkPhysicalDeviceImageAlignmentControlFeaturesMESA *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageAlignmentControlFeaturesMESA32 *in_ext = (const VkPhysicalDeviceImageAlignmentControlFeaturesMESA32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA;
            out_ext->pNext = NULL;
            out_ext->imageAlignmentControl = in_ext->imageAlignmentControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageCompressionControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControl = in_ext->imageCompressionControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControlSwapchain = in_ext->imageCompressionControlSwapchain;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2FeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessing2FeaturesQCOM32 *in_ext = (const VkPhysicalDeviceImageProcessing2FeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureBlockMatch2 = in_ext->textureBlockMatch2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessingFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessingFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceImageProcessingFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureSampleWeighted = in_ext->textureSampleWeighted;
            out_ext->textureBoxFilter = in_ext->textureBoxFilter;
            out_ext->textureBlockMatch = in_ext->textureBlockMatch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDeviceImageRobustnessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageRobustnessFeatures32 *in_ext = (const VkPhysicalDeviceImageRobustnessFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageSlicedViewOf3D = in_ext->imageSlicedViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
            VkPhysicalDeviceImageViewMinLodFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageViewMinLodFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageViewMinLodFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->minLod = in_ext->minLod;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            VkPhysicalDeviceImagelessFramebufferFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImagelessFramebufferFeatures32 *in_ext = (const VkPhysicalDeviceImagelessFramebufferFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
            out_ext->pNext = NULL;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES:
        {
            VkPhysicalDeviceIndexTypeUint8Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceIndexTypeUint8Features32 *in_ext = (const VkPhysicalDeviceIndexTypeUint8Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
            out_ext->pNext = NULL;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInheritedViewportScissorFeaturesNV32 *in_ext = (const VkPhysicalDeviceInheritedViewportScissorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->inheritedViewportScissor2D = in_ext->inheritedViewportScissor2D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
            VkPhysicalDeviceInlineUniformBlockFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInlineUniformBlockFeatures32 *in_ext = (const VkPhysicalDeviceInlineUniformBlockFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
            out_ext->pNext = NULL;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->invocationMask = in_ext->invocationMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyDitheringFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLegacyDitheringFeaturesEXT32 *in_ext = (const VkPhysicalDeviceLegacyDitheringFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->legacyDithering = in_ext->legacyDithering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT32 *in_ext = (const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->legacyVertexAttributes = in_ext->legacyVertexAttributes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES:
        {
            VkPhysicalDeviceLineRasterizationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLineRasterizationFeatures32 *in_ext = (const VkPhysicalDeviceLineRasterizationFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
            VkPhysicalDeviceLinearColorAttachmentFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLinearColorAttachmentFeaturesNV32 *in_ext = (const VkPhysicalDeviceLinearColorAttachmentFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->linearColorAttachment = in_ext->linearColorAttachment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
            VkPhysicalDeviceMaintenance4Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance4Features32 *in_ext = (const VkPhysicalDeviceMaintenance4Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES:
        {
            VkPhysicalDeviceMaintenance5Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance5Features32 *in_ext = (const VkPhysicalDeviceMaintenance5Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES:
        {
            VkPhysicalDeviceMaintenance6Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance6Features32 *in_ext = (const VkPhysicalDeviceMaintenance6Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance6 = in_ext->maintenance6;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance8FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance8FeaturesKHR32 *in_ext = (const VkPhysicalDeviceMaintenance8FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->maintenance8 = in_ext->maintenance8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance9FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance9FeaturesKHR32 *in_ext = (const VkPhysicalDeviceMaintenance9FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->maintenance9 = in_ext->maintenance9;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryDecompressionFeaturesNV32 *in_ext = (const VkPhysicalDeviceMemoryDecompressionFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->memoryDecompression = in_ext->memoryDecompression;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            VkPhysicalDeviceMemoryPriorityFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryPriorityFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMemoryPriorityFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->memoryPriority = in_ext->memoryPriority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
            VkPhysicalDeviceMeshShaderFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_ext->multiviewMeshShader = in_ext->multiviewMeshShader;
            out_ext->primitiveFragmentShadingRateMeshShader = in_ext->primitiveFragmentShadingRateMeshShader;
            out_ext->meshShaderQueries = in_ext->meshShaderQueries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            VkPhysicalDeviceMeshShaderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesNV32 *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
            VkPhysicalDeviceMultiDrawFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiDrawFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMultiDrawFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multiDraw = in_ext->multiDraw;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
            VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multisampledRenderToSingleSampled = in_ext->multisampledRenderToSingleSampled;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            VkPhysicalDeviceMultiviewFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewFeatures32 *in_ext = (const VkPhysicalDeviceMultiviewFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
            out_ext->pNext = NULL;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewRenderAreas = in_ext->multiviewPerViewRenderAreas;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewViewports = in_ext->multiviewPerViewViewports;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
            VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->mutableDescriptorType = in_ext->mutableDescriptorType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNestedCommandBufferFeaturesEXT32 *in_ext = (const VkPhysicalDeviceNestedCommandBufferFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nestedCommandBuffer = in_ext->nestedCommandBuffer;
            out_ext->nestedCommandBufferRendering = in_ext->nestedCommandBufferRendering;
            out_ext->nestedCommandBufferSimultaneousUse = in_ext->nestedCommandBufferSimultaneousUse;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nonSeamlessCubeMap = in_ext->nonSeamlessCubeMap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpacityMicromapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceOpacityMicromapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->micromap = in_ext->micromap;
            out_ext->micromapCaptureReplay = in_ext->micromapCaptureReplay;
            out_ext->micromapHostCommands = in_ext->micromapHostCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
            VkPhysicalDeviceOpticalFlowFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpticalFlowFeaturesNV32 *in_ext = (const VkPhysicalDeviceOpticalFlowFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->opticalFlow = in_ext->opticalFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32 *in_ext = (const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pageableDeviceLocalMemory = in_ext->pageableDeviceLocalMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV:
        {
            VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV32 *in_ext = (const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->partitionedAccelerationStructure = in_ext->partitionedAccelerationStructure;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV:
        {
            VkPhysicalDevicePerStageDescriptorSetFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePerStageDescriptorSetFeaturesNV32 *in_ext = (const VkPhysicalDevicePerStageDescriptorSetFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->perStageDescriptorSet = in_ext->perStageDescriptorSet;
            out_ext->dynamicPipelineLayout = in_ext->dynamicPipelineLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            VkPhysicalDevicePerformanceQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePerformanceQueryFeaturesKHR32 *in_ext = (const VkPhysicalDevicePerformanceQueryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->performanceCounterQueryPools = in_ext->performanceCounterQueryPools;
            out_ext->performanceCounterMultipleQueryPools = in_ext->performanceCounterMultipleQueryPools;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineBinaryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineBinaryFeaturesKHR32 *in_ext = (const VkPhysicalDevicePipelineBinaryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineBinaries = in_ext->pipelineBinaries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC:
        {
            VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC32 *in_ext = (const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC;
            out_ext->pNext = NULL;
            out_ext->pipelineCacheIncrementalMode = in_ext->pipelineCacheIncrementalMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
            VkPhysicalDevicePipelineCreationCacheControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineCreationCacheControlFeatures32 *in_ext = (const VkPhysicalDevicePipelineCreationCacheControlFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32 *in_ext = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineExecutableInfo = in_ext->pipelineExecutableInfo;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM:
        {
            VkPhysicalDevicePipelineOpacityMicromapFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM32 *in_ext = (const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->pipelineOpacityMicromap = in_ext->pipelineOpacityMicromap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelinePropertiesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelinePropertiesFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelinePropertiesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelinePropertiesIdentifier = in_ext->pipelinePropertiesIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES:
        {
            VkPhysicalDevicePipelineProtectedAccessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineProtectedAccessFeatures32 *in_ext = (const VkPhysicalDevicePipelineProtectedAccessFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDevicePipelineRobustnessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineRobustnessFeatures32 *in_ext = (const VkPhysicalDevicePipelineRobustnessFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
            VkPhysicalDevicePresentBarrierFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentBarrierFeaturesNV32 *in_ext = (const VkPhysicalDevicePresentBarrierFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->presentBarrier = in_ext->presentBarrier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR:
        {
            VkPhysicalDevicePresentId2FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentId2FeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentId2FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentId2 = in_ext->presentId2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
            VkPhysicalDevicePresentIdFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentIdFeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentIdFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentId = in_ext->presentId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR:
        {
            VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentModeFifoLatestReady = in_ext->presentModeFifoLatestReady;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWait2FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentWait2FeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentWait2FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentWait2 = in_ext->presentWait2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWaitFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentWaitFeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentWaitFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentWait = in_ext->presentWait;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32 *in_ext = (const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitiveTopologyListRestart = in_ext->primitiveTopologyListRestart;
            out_ext->primitiveTopologyPatchListRestart = in_ext->primitiveTopologyPatchListRestart;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32 *in_ext = (const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitivesGeneratedQuery = in_ext->primitivesGeneratedQuery;
            out_ext->primitivesGeneratedQueryWithRasterizerDiscard = in_ext->primitivesGeneratedQueryWithRasterizerDiscard;
            out_ext->primitivesGeneratedQueryWithNonZeroStreams = in_ext->primitivesGeneratedQueryWithNonZeroStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
            VkPhysicalDevicePrivateDataFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrivateDataFeatures32 *in_ext = (const VkPhysicalDevicePrivateDataFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
            out_ext->pNext = NULL;
            out_ext->privateData = in_ext->privateData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            VkPhysicalDeviceProtectedMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProtectedMemoryFeatures32 *in_ext = (const VkPhysicalDeviceProtectedMemoryFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
            VkPhysicalDeviceProvokingVertexFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProvokingVertexFeaturesEXT32 *in_ext = (const VkPhysicalDeviceProvokingVertexFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->provokingVertexLast = in_ext->provokingVertexLast;
            out_ext->transformFeedbackPreservesProvokingVertex = in_ext->transformFeedbackPreservesProvokingVertex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatRgba10x6WithoutYCbCrSampler = in_ext->formatRgba10x6WithoutYCbCrSampler;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 *in_ext = (const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->rasterizationOrderColorAttachmentAccess = in_ext->rasterizationOrderColorAttachmentAccess;
            out_ext->rasterizationOrderDepthAttachmentAccess = in_ext->rasterizationOrderDepthAttachmentAccess;
            out_ext->rasterizationOrderStencilAttachmentAccess = in_ext->rasterizationOrderStencilAttachmentAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV:
        {
            VkPhysicalDeviceRawAccessChainsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRawAccessChainsFeaturesNV32 *in_ext = (const VkPhysicalDeviceRawAccessChainsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderRawAccessChains = in_ext->shaderRawAccessChains;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceRayQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayQueryFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayQueryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayQuery = in_ext->rayQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingInvocationReorder = in_ext->rayTracingInvocationReorder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->spheres = in_ext->spheres;
            out_ext->linearSweptSpheres = in_ext->linearSweptSpheres;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingMaintenance1 = in_ext->rayTracingMaintenance1;
            out_ext->rayTracingPipelineTraceRaysIndirect2 = in_ext->rayTracingPipelineTraceRaysIndirect2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingMotionBlur = in_ext->rayTracingMotionBlur;
            out_ext->rayTracingMotionBlurPipelineTraceRaysIndirect = in_ext->rayTracingMotionBlurPipelineTraceRaysIndirect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPipelineFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingPipelineFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPipeline = in_ext->rayTracingPipeline;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplay = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplay;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
            out_ext->rayTracingPipelineTraceRaysIndirect = in_ext->rayTracingPipelineTraceRaysIndirect;
            out_ext->rayTraversalPrimitiveCulling = in_ext->rayTraversalPrimitiveCulling;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPositionFetch = in_ext->rayTracingPositionFetch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingValidationFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingValidationFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingValidationFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingValidation = in_ext->rayTracingValidation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG:
        {
            VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG32 *in_ext = (const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG;
            out_ext->pNext = NULL;
            out_ext->relaxedLineRasterization = in_ext->relaxedLineRasterization;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM:
        {
            VkPhysicalDeviceRenderPassStripedFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRenderPassStripedFeaturesARM32 *in_ext = (const VkPhysicalDeviceRenderPassStripedFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->renderPassStriped = in_ext->renderPassStriped;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32 *in_ext = (const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->representativeFragmentTest = in_ext->representativeFragmentTest;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR:
        {
            VkPhysicalDeviceRobustness2FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRobustness2FeaturesKHR32 *in_ext = (const VkPhysicalDeviceRobustness2FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->robustBufferAccess2 = in_ext->robustBufferAccess2;
            out_ext->robustImageAccess2 = in_ext->robustImageAccess2;
            out_ext->nullDescriptor = in_ext->nullDescriptor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            VkPhysicalDeviceSamplerYcbcrConversionFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSamplerYcbcrConversionFeatures32 *in_ext = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceScalarBlockLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceScalarBlockLayoutFeatures32 *in_ext = (const VkPhysicalDeviceScalarBlockLayoutFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM:
        {
            VkPhysicalDeviceSchedulingControlsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSchedulingControlsFeaturesARM32 *in_ext = (const VkPhysicalDeviceSchedulingControlsFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->schedulingControls = in_ext->schedulingControls;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 *in_ext = (const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV:
        {
            VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV32 *in_ext = (const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderFloat16VectorAtomics = in_ext->shaderFloat16VectorAtomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat16Atomics = in_ext->shaderBufferFloat16Atomics;
            out_ext->shaderBufferFloat16AtomicAdd = in_ext->shaderBufferFloat16AtomicAdd;
            out_ext->shaderBufferFloat16AtomicMinMax = in_ext->shaderBufferFloat16AtomicMinMax;
            out_ext->shaderBufferFloat32AtomicMinMax = in_ext->shaderBufferFloat32AtomicMinMax;
            out_ext->shaderBufferFloat64AtomicMinMax = in_ext->shaderBufferFloat64AtomicMinMax;
            out_ext->shaderSharedFloat16Atomics = in_ext->shaderSharedFloat16Atomics;
            out_ext->shaderSharedFloat16AtomicAdd = in_ext->shaderSharedFloat16AtomicAdd;
            out_ext->shaderSharedFloat16AtomicMinMax = in_ext->shaderSharedFloat16AtomicMinMax;
            out_ext->shaderSharedFloat32AtomicMinMax = in_ext->shaderSharedFloat32AtomicMinMax;
            out_ext->shaderSharedFloat64AtomicMinMax = in_ext->shaderSharedFloat64AtomicMinMax;
            out_ext->shaderImageFloat32AtomicMinMax = in_ext->shaderImageFloat32AtomicMinMax;
            out_ext->sparseImageFloat32AtomicMinMax = in_ext->sparseImageFloat32AtomicMinMax;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat32Atomics = in_ext->shaderBufferFloat32Atomics;
            out_ext->shaderBufferFloat32AtomicAdd = in_ext->shaderBufferFloat32AtomicAdd;
            out_ext->shaderBufferFloat64Atomics = in_ext->shaderBufferFloat64Atomics;
            out_ext->shaderBufferFloat64AtomicAdd = in_ext->shaderBufferFloat64AtomicAdd;
            out_ext->shaderSharedFloat32Atomics = in_ext->shaderSharedFloat32Atomics;
            out_ext->shaderSharedFloat32AtomicAdd = in_ext->shaderSharedFloat32AtomicAdd;
            out_ext->shaderSharedFloat64Atomics = in_ext->shaderSharedFloat64Atomics;
            out_ext->shaderSharedFloat64AtomicAdd = in_ext->shaderSharedFloat64AtomicAdd;
            out_ext->shaderImageFloat32Atomics = in_ext->shaderImageFloat32Atomics;
            out_ext->shaderImageFloat32AtomicAdd = in_ext->shaderImageFloat32AtomicAdd;
            out_ext->sparseImageFloat32Atomics = in_ext->sparseImageFloat32Atomics;
            out_ext->sparseImageFloat32AtomicAdd = in_ext->sparseImageFloat32AtomicAdd;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            VkPhysicalDeviceShaderAtomicInt64Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicInt64Features32 *in_ext = (const VkPhysicalDeviceShaderAtomicInt64Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderBfloat16FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderBfloat16FeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderBfloat16FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderBFloat16Type = in_ext->shaderBFloat16Type;
            out_ext->shaderBFloat16DotProduct = in_ext->shaderBFloat16DotProduct;
            out_ext->shaderBFloat16CooperativeMatrix = in_ext->shaderBFloat16CooperativeMatrix;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderClockFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderClockFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderClockFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupClock = in_ext->shaderSubgroupClock;
            out_ext->shaderDeviceClock = in_ext->shaderDeviceClock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *in_ext = (const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->shaderCoreBuiltins = in_ext->shaderCoreBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 *in_ext = (const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            VkPhysicalDeviceShaderDrawParametersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDrawParametersFeatures32 *in_ext = (const VkPhysicalDeviceShaderDrawParametersFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
            VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32 *in_ext = (const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->shaderEarlyAndLateFragmentTests = in_ext->shaderEarlyAndLateFragmentTests;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES:
        {
            VkPhysicalDeviceShaderExpectAssumeFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderExpectAssumeFeatures32 *in_ext = (const VkPhysicalDeviceShaderExpectAssumeFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderExpectAssume = in_ext->shaderExpectAssume;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            VkPhysicalDeviceShaderFloat16Int8Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloat16Int8Features32 *in_ext = (const VkPhysicalDeviceShaderFloat16Int8Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderFloat8FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloat8FeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderFloat8FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderFloat8 = in_ext->shaderFloat8;
            out_ext->shaderFloat8CooperativeMatrix = in_ext->shaderFloat8CooperativeMatrix;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES:
        {
            VkPhysicalDeviceShaderFloatControls2Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloatControls2Features32 *in_ext = (const VkPhysicalDeviceShaderFloatControls2Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderFloatControls2 = in_ext->shaderFloatControls2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderImageInt64Atomics = in_ext->shaderImageInt64Atomics;
            out_ext->sparseImageInt64Atomics = in_ext->sparseImageInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            VkPhysicalDeviceShaderImageFootprintFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageFootprintFeaturesNV32 *in_ext = (const VkPhysicalDeviceShaderImageFootprintFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->imageFootprint = in_ext->imageFootprint;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
            VkPhysicalDeviceShaderIntegerDotProductFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerDotProductFeatures32 *in_ext = (const VkPhysicalDeviceShaderIntegerDotProductFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32 *in_ext = (const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerFunctions2 = in_ext->shaderIntegerFunctions2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderMaximalReconvergence = in_ext->shaderMaximalReconvergence;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderModuleIdentifier = in_ext->shaderModuleIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderObjectFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderObjectFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderObjectFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderObject = in_ext->shaderObject;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderQuadControlFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderQuadControlFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderQuadControlFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderQuadControl = in_ext->shaderQuadControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderRelaxedExtendedInstruction = in_ext->shaderRelaxedExtendedInstruction;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderReplicatedComposites = in_ext->shaderReplicatedComposites;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32 *in_ext = (const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderSMBuiltins = in_ext->shaderSMBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 *in_ext = (const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupRotateFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupRotateFeatures32 *in_ext = (const VkPhysicalDeviceShaderSubgroupRotateFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupRotate = in_ext->shaderSubgroupRotate;
            out_ext->shaderSubgroupRotateClustered = in_ext->shaderSubgroupRotateClustered;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupUniformControlFlow = in_ext->shaderSubgroupUniformControlFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderTerminateInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTerminateInvocationFeatures32 *in_ext = (const VkPhysicalDeviceShaderTerminateInvocationFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderTileImageFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTileImageFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderTileImageFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderTileImageColorReadAccess = in_ext->shaderTileImageColorReadAccess;
            out_ext->shaderTileImageDepthReadAccess = in_ext->shaderTileImageDepthReadAccess;
            out_ext->shaderTileImageStencilReadAccess = in_ext->shaderTileImageStencilReadAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderUntypedPointersFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderUntypedPointers = in_ext->shaderUntypedPointers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceShadingRateImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShadingRateImageFeaturesNV32 *in_ext = (const VkPhysicalDeviceShadingRateImageFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateImage = in_ext->shadingRateImage;
            out_ext->shadingRateCoarseSampleOrder = in_ext->shadingRateCoarseSampleOrder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
            VkPhysicalDeviceSubgroupSizeControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubgroupSizeControlFeatures32 *in_ext = (const VkPhysicalDeviceSubgroupSizeControlFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32 *in_ext = (const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->subpassMergeFeedback = in_ext->subpassMergeFeedback;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->subpassShading = in_ext->subpassShading;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR32 *in_ext = (const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainMaintenance1 = in_ext->swapchainMaintenance1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
            VkPhysicalDeviceSynchronization2Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSynchronization2Features32 *in_ext = (const VkPhysicalDeviceSynchronization2Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM:
        {
            VkPhysicalDeviceTensorFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTensorFeaturesARM32 *in_ext = (const VkPhysicalDeviceTensorFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorNonPacked = in_ext->tensorNonPacked;
            out_ext->shaderTensorAccess = in_ext->shaderTensorAccess;
            out_ext->shaderStorageTensorArrayDynamicIndexing = in_ext->shaderStorageTensorArrayDynamicIndexing;
            out_ext->shaderStorageTensorArrayNonUniformIndexing = in_ext->shaderStorageTensorArrayNonUniformIndexing;
            out_ext->descriptorBindingStorageTensorUpdateAfterBind = in_ext->descriptorBindingStorageTensorUpdateAfterBind;
            out_ext->tensors = in_ext->tensors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32 *in_ext = (const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->texelBufferAlignment = in_ext->texelBufferAlignment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
            VkPhysicalDeviceTextureCompressionASTCHDRFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 *in_ext = (const VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
            out_ext->pNext = NULL;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM:
        {
            VkPhysicalDeviceTileMemoryHeapFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileMemoryHeap = in_ext->tileMemoryHeap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
            VkPhysicalDeviceTilePropertiesFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTilePropertiesFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceTilePropertiesFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileProperties = in_ext->tileProperties;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM:
        {
            VkPhysicalDeviceTileShadingFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTileShadingFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceTileShadingFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileShading = in_ext->tileShading;
            out_ext->tileShadingFragmentStage = in_ext->tileShadingFragmentStage;
            out_ext->tileShadingColorAttachments = in_ext->tileShadingColorAttachments;
            out_ext->tileShadingDepthAttachments = in_ext->tileShadingDepthAttachments;
            out_ext->tileShadingStencilAttachments = in_ext->tileShadingStencilAttachments;
            out_ext->tileShadingInputAttachments = in_ext->tileShadingInputAttachments;
            out_ext->tileShadingSampledAttachments = in_ext->tileShadingSampledAttachments;
            out_ext->tileShadingPerTileDraw = in_ext->tileShadingPerTileDraw;
            out_ext->tileShadingPerTileDispatch = in_ext->tileShadingPerTileDispatch;
            out_ext->tileShadingDispatchTile = in_ext->tileShadingDispatchTile;
            out_ext->tileShadingApron = in_ext->tileShadingApron;
            out_ext->tileShadingAnisotropicApron = in_ext->tileShadingAnisotropicApron;
            out_ext->tileShadingAtomicOps = in_ext->tileShadingAtomicOps;
            out_ext->tileShadingImageProcessing = in_ext->tileShadingImageProcessing;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            VkPhysicalDeviceTimelineSemaphoreFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTimelineSemaphoreFeatures32 *in_ext = (const VkPhysicalDeviceTimelineSemaphoreFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTransformFeedbackFeaturesEXT32 *in_ext = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->transformFeedback = in_ext->transformFeedback;
            out_ext->geometryStreams = in_ext->geometryStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR:
        {
            VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR32 *in_ext = (const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->unifiedImageLayouts = in_ext->unifiedImageLayouts;
            out_ext->unifiedImageLayoutsVideo = in_ext->unifiedImageLayoutsVideo;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 *in_ext = (const VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            VkPhysicalDeviceVariablePointersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVariablePointersFeatures32 *in_ext = (const VkPhysicalDeviceVariablePointersFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES:
        {
            VkPhysicalDeviceVertexAttributeDivisorFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexAttributeDivisorFeatures32 *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
            out_ext->pNext = NULL;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT32 *in_ext = (const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexAttributeRobustness = in_ext->vertexAttributeRobustness;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexInputDynamicState = in_ext->vertexInputDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoDecodeVP9FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR32 *in_ext = (const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoDecodeVP9 = in_ext->videoDecodeVP9;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeAV1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR32 *in_ext = (const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoEncodeAV1 = in_ext->videoEncodeAV1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR32 *in_ext = (const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoEncodeIntraRefresh = in_ext->videoEncodeIntraRefresh;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR32 *in_ext = (const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoEncodeQuantizationMap = in_ext->videoEncodeQuantizationMap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoMaintenance1FeaturesKHR32 *in_ext = (const VkPhysicalDeviceVideoMaintenance1FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoMaintenance1 = in_ext->videoMaintenance1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            VkPhysicalDeviceVulkan11Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan11Features32 *in_ext = (const VkPhysicalDeviceVulkan11Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            VkPhysicalDeviceVulkan12Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan12Features32 *in_ext = (const VkPhysicalDeviceVulkan12Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerMirrorClampToEdge = in_ext->samplerMirrorClampToEdge;
            out_ext->drawIndirectCount = in_ext->drawIndirectCount;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_ext->descriptorIndexing = in_ext->descriptorIndexing;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_ext->samplerFilterMinmax = in_ext->samplerFilterMinmax;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_ext->shaderOutputViewportIndex = in_ext->shaderOutputViewportIndex;
            out_ext->shaderOutputLayer = in_ext->shaderOutputLayer;
            out_ext->subgroupBroadcastDynamicId = in_ext->subgroupBroadcastDynamicId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
            VkPhysicalDeviceVulkan13Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan13Features32 *in_ext = (const VkPhysicalDeviceVulkan13Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_ext->privateData = in_ext->privateData;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES:
        {
            VkPhysicalDeviceVulkan14Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan14Features32 *in_ext = (const VkPhysicalDeviceVulkan14Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES;
            out_ext->pNext = NULL;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_ext->shaderSubgroupRotate = in_ext->shaderSubgroupRotate;
            out_ext->shaderSubgroupRotateClustered = in_ext->shaderSubgroupRotateClustered;
            out_ext->shaderFloatControls2 = in_ext->shaderFloatControls2;
            out_ext->shaderExpectAssume = in_ext->shaderExpectAssume;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_ext->dynamicRenderingLocalRead = in_ext->dynamicRenderingLocalRead;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_ext->maintenance6 = in_ext->maintenance6;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_ext->pushDescriptor = in_ext->pushDescriptor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            VkPhysicalDeviceVulkanMemoryModelFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkanMemoryModelFeatures32 *in_ext = (const VkPhysicalDeviceVulkanMemoryModelFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32 *in_ext = (const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->workgroupMemoryExplicitLayout = in_ext->workgroupMemoryExplicitLayout;
            out_ext->workgroupMemoryExplicitLayoutScalarBlockLayout = in_ext->workgroupMemoryExplicitLayoutScalarBlockLayout;
            out_ext->workgroupMemoryExplicitLayout8BitAccess = in_ext->workgroupMemoryExplicitLayout8BitAccess;
            out_ext->workgroupMemoryExplicitLayout16BitAccess = in_ext->workgroupMemoryExplicitLayout16BitAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcr2plane444Formats = in_ext->ycbcr2plane444Formats;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
            VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->ycbcrDegamma = in_ext->ycbcrDegamma;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32 *in_ext = (const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcrImageArrays = in_ext->ycbcrImageArrays;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT32 *in_ext = (const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->zeroInitializeDeviceMemory = in_ext->zeroInitializeDeviceMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 *in_ext = (const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkEventCreateInfo_win32_to_host(const VkEventCreateInfo32 *in, VkEventCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkFenceCreateInfo_win64_to_host(struct conversion_context *ctx, const VkFenceCreateInfo *in, VkFenceCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            VkExportFenceCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportFenceCreateInfo *in_ext = (const VkExportFenceCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            VkExportFenceWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportFenceWin32HandleInfoKHR *in_ext = (const VkExportFenceWin32HandleInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pAttributes = in_ext->pAttributes;
            out_ext->dwAccess = in_ext->dwAccess;
            out_ext->name = in_ext->name;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

static void convert_VkFenceCreateInfo_win32_to_host(struct conversion_context *ctx, const VkFenceCreateInfo32 *in, VkFenceCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {
            VkExportFenceCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportFenceCreateInfo32 *in_ext = (const VkExportFenceCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {
            VkExportFenceWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportFenceWin32HandleInfoKHR32 *in_ext = (const VkExportFenceWin32HandleInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
            out_ext->dwAccess = in_ext->dwAccess;
            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkFramebufferAttachmentImageInfo_win32_to_host(const VkFramebufferAttachmentImageInfo32 *in, VkFramebufferAttachmentImageInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->usage = in->usage;
    out->width = in->width;
    out->height = in->height;
    out->layerCount = in->layerCount;
    out->viewFormatCount = in->viewFormatCount;
    out->pViewFormats = UlongToPtr(in->pViewFormats);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkFramebufferAttachmentImageInfo *convert_VkFramebufferAttachmentImageInfo_array_win32_to_host(struct conversion_context *ctx, const VkFramebufferAttachmentImageInfo32 *in, uint32_t count)
{
    VkFramebufferAttachmentImageInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkFramebufferAttachmentImageInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkFramebufferCreateInfo_win32_to_host(struct conversion_context *ctx, const VkFramebufferCreateInfo32 *in, VkFramebufferCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->renderPass = in->renderPass;
    out->attachmentCount = in->attachmentCount;
    out->pAttachments = UlongToPtr(in->pAttachments);
    out->width = in->width;
    out->height = in->height;
    out->layers = in->layers;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {
            VkFramebufferAttachmentsCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFramebufferAttachmentsCreateInfo32 *in_ext = (const VkFramebufferAttachmentsCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->attachmentImageInfoCount = in_ext->attachmentImageInfoCount;
            out_ext->pAttachmentImageInfos = convert_VkFramebufferAttachmentImageInfo_array_win32_to_host(ctx, (const VkFramebufferAttachmentImageInfo32 *)UlongToPtr(in_ext->pAttachmentImageInfos), in_ext->attachmentImageInfoCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

#ifdef _WIN64
static const VkPipelineShaderStageCreateInfo *convert_VkPipelineShaderStageCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkPipelineShaderStageCreateInfo *in, uint32_t count)
{
    VkPipelineShaderStageCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineShaderStageCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkGraphicsShaderGroupCreateInfoNV_win64_to_host(struct conversion_context *ctx, const VkGraphicsShaderGroupCreateInfoNV *in, VkGraphicsShaderGroupCreateInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win64_to_host(ctx, in->pStages, in->stageCount);
    out->pVertexInputState = in->pVertexInputState;
    out->pTessellationState = in->pTessellationState;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkGraphicsShaderGroupCreateInfoNV *convert_VkGraphicsShaderGroupCreateInfoNV_array_win64_to_host(struct conversion_context *ctx, const VkGraphicsShaderGroupCreateInfoNV *in, uint32_t count)
{
    VkGraphicsShaderGroupCreateInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkGraphicsShaderGroupCreateInfoNV_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkGraphicsPipelineCreateInfo_win64_to_host(struct conversion_context *ctx, const VkGraphicsPipelineCreateInfo *in, VkGraphicsPipelineCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win64_to_host(ctx, in->pStages, in->stageCount);
    out->pVertexInputState = in->pVertexInputState;
    out->pInputAssemblyState = in->pInputAssemblyState;
    out->pTessellationState = in->pTessellationState;
    out->pViewportState = in->pViewportState;
    out->pRasterizationState = in->pRasterizationState;
    out->pMultisampleState = in->pMultisampleState;
    out->pDepthStencilState = in->pDepthStencilState;
    out->pColorBlendState = in->pColorBlendState;
    out->pDynamicState = in->pDynamicState;
    out->layout = in->layout;
    out->renderPass = in->renderPass;
    out->subpass = in->subpass;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
            VkAttachmentSampleCountInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentSampleCountInfoAMD *in_ext = (const VkAttachmentSampleCountInfoAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentSamples = in_ext->pColorAttachmentSamples;
            out_ext->depthStencilAttachmentSamples = in_ext->depthStencilAttachmentSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
        {
            VkGraphicsPipelineLibraryCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGraphicsPipelineLibraryCreateInfoEXT *in_ext = (const VkGraphicsPipelineLibraryCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            VkGraphicsPipelineShaderGroupsCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGraphicsPipelineShaderGroupsCreateInfoNV *in_ext = (const VkGraphicsPipelineShaderGroupsCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->groupCount = in_ext->groupCount;
            out_ext->pGroups = convert_VkGraphicsShaderGroupCreateInfoNV_array_win64_to_host(ctx, in_ext->pGroups, in_ext->groupCount);
            out_ext->pipelineCount = in_ext->pipelineCount;
            out_ext->pPipelines = in_ext->pPipelines;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR:
        {
            VkPipelineBinaryInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineBinaryInfoKHR *in_ext = (const VkPipelineBinaryInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->binaryCount = in_ext->binaryCount;
            out_ext->pPipelineBinaries = in_ext->pPipelineBinaries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            VkPipelineCompilerControlCreateInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCompilerControlCreateInfoAMD *in_ext = (const VkPipelineCompilerControlCreateInfoAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->compilerControlFlags = in_ext->compilerControlFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO:
        {
            VkPipelineCreateFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreateFlags2CreateInfo *in_ext = (const VkPipelineCreateFlags2CreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = in_ext->pPipelineCreationFeedback;
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = in_ext->pPipelineStageCreationFeedbacks;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            VkPipelineDiscardRectangleStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineDiscardRectangleStateCreateInfoEXT *in_ext = (const VkPipelineDiscardRectangleStateCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->discardRectangleMode = in_ext->discardRectangleMode;
            out_ext->discardRectangleCount = in_ext->discardRectangleCount;
            out_ext->pDiscardRectangles = in_ext->pDiscardRectangles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE:
        {
            VkPipelineFragmentDensityMapLayeredCreateInfoVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineFragmentDensityMapLayeredCreateInfoVALVE *in_ext = (const VkPipelineFragmentDensityMapLayeredCreateInfoVALVE *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE;
            out_ext->pNext = NULL;
            out_ext->maxFragmentDensityMapLayers = in_ext->maxFragmentDensityMapLayers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            VkPipelineFragmentShadingRateEnumStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineFragmentShadingRateEnumStateCreateInfoNV *in_ext = (const VkPipelineFragmentShadingRateEnumStateCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateType = in_ext->shadingRateType;
            out_ext->shadingRate = in_ext->shadingRate;
            memcpy(out_ext->combinerOps, in_ext->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            VkPipelineFragmentShadingRateStateCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineFragmentShadingRateStateCreateInfoKHR *in_ext = (const VkPipelineFragmentShadingRateStateCreateInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->fragmentSize = in_ext->fragmentSize;
            memcpy(out_ext->combinerOps, in_ext->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
        {
            VkPipelineLibraryCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLibraryCreateInfoKHR *in_ext = (const VkPipelineLibraryCreateInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->libraryCount = in_ext->libraryCount;
            out_ext->pLibraries = in_ext->pLibraries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
        {
            VkPipelineRenderingCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRenderingCreateInfo *in_ext = (const VkPipelineRenderingCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewMask = in_ext->viewMask;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentFormats = in_ext->pColorAttachmentFormats;
            out_ext->depthAttachmentFormat = in_ext->depthAttachmentFormat;
            out_ext->stencilAttachmentFormat = in_ext->stencilAttachmentFormat;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            VkPipelineRepresentativeFragmentTestStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRepresentativeFragmentTestStateCreateInfoNV *in_ext = (const VkPipelineRepresentativeFragmentTestStateCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->representativeFragmentTestEnable = in_ext->representativeFragmentTestEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO:
        {
            VkPipelineRobustnessCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfo *in_ext = (const VkPipelineRobustnessCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO:
        {
            VkRenderingAttachmentLocationInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingAttachmentLocationInfo *in_ext = (const VkRenderingAttachmentLocationInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentLocations = in_ext->pColorAttachmentLocations;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO:
        {
            VkRenderingInputAttachmentIndexInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingInputAttachmentIndexInfo *in_ext = (const VkRenderingInputAttachmentIndexInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentInputIndices = in_ext->pColorAttachmentInputIndices;
            out_ext->pDepthInputAttachmentIndex = in_ext->pDepthInputAttachmentIndex;
            out_ext->pStencilInputAttachmentIndex = in_ext->pStencilInputAttachmentIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkGraphicsPipelineCreateInfo *convert_VkGraphicsPipelineCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkGraphicsPipelineCreateInfo *in, uint32_t count)
{
    VkGraphicsPipelineCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkGraphicsPipelineCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static const VkPipelineShaderStageCreateInfo *convert_VkPipelineShaderStageCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineShaderStageCreateInfo32 *in, uint32_t count)
{
    VkPipelineShaderStageCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineShaderStageCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineVertexInputStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineVertexInputStateCreateInfo32 *in, VkPipelineVertexInputStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->vertexBindingDescriptionCount = in->vertexBindingDescriptionCount;
    out->pVertexBindingDescriptions = UlongToPtr(in->pVertexBindingDescriptions);
    out->vertexAttributeDescriptionCount = in->vertexAttributeDescriptionCount;
    out->pVertexAttributeDescriptions = UlongToPtr(in->pVertexAttributeDescriptions);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO:
        {
            VkPipelineVertexInputDivisorStateCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineVertexInputDivisorStateCreateInfo32 *in_ext = (const VkPipelineVertexInputDivisorStateCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->vertexBindingDivisorCount = in_ext->vertexBindingDivisorCount;
            out_ext->pVertexBindingDivisors = UlongToPtr(in_ext->pVertexBindingDivisors);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkPipelineVertexInputStateCreateInfo *convert_VkPipelineVertexInputStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineVertexInputStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineVertexInputStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineVertexInputStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineInputAssemblyStateCreateInfo_win32_to_host(const VkPipelineInputAssemblyStateCreateInfo32 *in, VkPipelineInputAssemblyStateCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->topology = in->topology;
    out->primitiveRestartEnable = in->primitiveRestartEnable;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkPipelineInputAssemblyStateCreateInfo *convert_VkPipelineInputAssemblyStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineInputAssemblyStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineInputAssemblyStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineInputAssemblyStateCreateInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineTessellationStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineTessellationStateCreateInfo32 *in, VkPipelineTessellationStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->patchControlPoints = in->patchControlPoints;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {
            VkPipelineTessellationDomainOriginStateCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineTessellationDomainOriginStateCreateInfo32 *in_ext = (const VkPipelineTessellationDomainOriginStateCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->domainOrigin = in_ext->domainOrigin;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkPipelineTessellationStateCreateInfo *convert_VkPipelineTessellationStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineTessellationStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineTessellationStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineTessellationStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineViewportStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineViewportStateCreateInfo32 *in, VkPipelineViewportStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->viewportCount = in->viewportCount;
    out->pViewports = UlongToPtr(in->pViewports);
    out->scissorCount = in->scissorCount;
    out->pScissors = UlongToPtr(in->pScissors);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {
            VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV32 *in_ext = (const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->sampleOrderType = in_ext->sampleOrderType;
            out_ext->customSampleOrderCount = in_ext->customSampleOrderCount;
            out_ext->pCustomSampleOrders = convert_VkCoarseSampleOrderCustomNV_array_win32_to_host(ctx, (const VkCoarseSampleOrderCustomNV32 *)UlongToPtr(in_ext->pCustomSampleOrders), in_ext->customSampleOrderCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT:
        {
            VkPipelineViewportDepthClampControlCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportDepthClampControlCreateInfoEXT32 *in_ext = (const VkPipelineViewportDepthClampControlCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClampMode = in_ext->depthClampMode;
            out_ext->pDepthClampRange = UlongToPtr(in_ext->pDepthClampRange);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
        {
            VkPipelineViewportDepthClipControlCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportDepthClipControlCreateInfoEXT32 *in_ext = (const VkPipelineViewportDepthClipControlCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->negativeOneToOne = in_ext->negativeOneToOne;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {
            VkPipelineViewportExclusiveScissorStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportExclusiveScissorStateCreateInfoNV32 *in_ext = (const VkPipelineViewportExclusiveScissorStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->exclusiveScissorCount = in_ext->exclusiveScissorCount;
            out_ext->pExclusiveScissors = UlongToPtr(in_ext->pExclusiveScissors);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {
            VkPipelineViewportShadingRateImageStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportShadingRateImageStateCreateInfoNV32 *in_ext = (const VkPipelineViewportShadingRateImageStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateImageEnable = in_ext->shadingRateImageEnable;
            out_ext->viewportCount = in_ext->viewportCount;
            out_ext->pShadingRatePalettes = convert_VkShadingRatePaletteNV_array_win32_to_host(ctx, (const VkShadingRatePaletteNV32 *)UlongToPtr(in_ext->pShadingRatePalettes), in_ext->viewportCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {
            VkPipelineViewportSwizzleStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportSwizzleStateCreateInfoNV32 *in_ext = (const VkPipelineViewportSwizzleStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->viewportCount = in_ext->viewportCount;
            out_ext->pViewportSwizzles = UlongToPtr(in_ext->pViewportSwizzles);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {
            VkPipelineViewportWScalingStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineViewportWScalingStateCreateInfoNV32 *in_ext = (const VkPipelineViewportWScalingStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->viewportWScalingEnable = in_ext->viewportWScalingEnable;
            out_ext->viewportCount = in_ext->viewportCount;
            out_ext->pViewportWScalings = UlongToPtr(in_ext->pViewportWScalings);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkPipelineViewportStateCreateInfo *convert_VkPipelineViewportStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineViewportStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineViewportStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineViewportStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineRasterizationStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineRasterizationStateCreateInfo32 *in, VkPipelineRasterizationStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->depthClampEnable = in->depthClampEnable;
    out->rasterizerDiscardEnable = in->rasterizerDiscardEnable;
    out->polygonMode = in->polygonMode;
    out->cullMode = in->cullMode;
    out->frontFace = in->frontFace;
    out->depthBiasEnable = in->depthBiasEnable;
    out->depthBiasConstantFactor = in->depthBiasConstantFactor;
    out->depthBiasClamp = in->depthBiasClamp;
    out->depthBiasSlopeFactor = in->depthBiasSlopeFactor;
    out->lineWidth = in->lineWidth;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
        {
            VkDepthBiasRepresentationInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDepthBiasRepresentationInfoEXT32 *in_ext = (const VkDepthBiasRepresentationInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->depthBiasRepresentation = in_ext->depthBiasRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {
            VkPipelineRasterizationConservativeStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationConservativeStateCreateInfoEXT32 *in_ext = (const VkPipelineRasterizationConservativeStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->conservativeRasterizationMode = in_ext->conservativeRasterizationMode;
            out_ext->extraPrimitiveOverestimationSize = in_ext->extraPrimitiveOverestimationSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {
            VkPipelineRasterizationDepthClipStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationDepthClipStateCreateInfoEXT32 *in_ext = (const VkPipelineRasterizationDepthClipStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->depthClipEnable = in_ext->depthClipEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO:
        {
            VkPipelineRasterizationLineStateCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationLineStateCreateInfo32 *in_ext = (const VkPipelineRasterizationLineStateCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->lineRasterizationMode = in_ext->lineRasterizationMode;
            out_ext->stippledLineEnable = in_ext->stippledLineEnable;
            out_ext->lineStippleFactor = in_ext->lineStippleFactor;
            out_ext->lineStipplePattern = in_ext->lineStipplePattern;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
        {
            VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT32 *in_ext = (const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->provokingVertexMode = in_ext->provokingVertexMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {
            VkPipelineRasterizationStateRasterizationOrderAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationStateRasterizationOrderAMD32 *in_ext = (const VkPipelineRasterizationStateRasterizationOrderAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
            out_ext->pNext = NULL;
            out_ext->rasterizationOrder = in_ext->rasterizationOrder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {
            VkPipelineRasterizationStateStreamCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRasterizationStateStreamCreateInfoEXT32 *in_ext = (const VkPipelineRasterizationStateStreamCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->rasterizationStream = in_ext->rasterizationStream;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkPipelineRasterizationStateCreateInfo *convert_VkPipelineRasterizationStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineRasterizationStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineRasterizationStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineRasterizationStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineMultisampleStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineMultisampleStateCreateInfo32 *in, VkPipelineMultisampleStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->rasterizationSamples = in->rasterizationSamples;
    out->sampleShadingEnable = in->sampleShadingEnable;
    out->minSampleShading = in->minSampleShading;
    out->pSampleMask = UlongToPtr(in->pSampleMask);
    out->alphaToCoverageEnable = in->alphaToCoverageEnable;
    out->alphaToOneEnable = in->alphaToOneEnable;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {
            VkPipelineCoverageModulationStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCoverageModulationStateCreateInfoNV32 *in_ext = (const VkPipelineCoverageModulationStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->coverageModulationMode = in_ext->coverageModulationMode;
            out_ext->coverageModulationTableEnable = in_ext->coverageModulationTableEnable;
            out_ext->coverageModulationTableCount = in_ext->coverageModulationTableCount;
            out_ext->pCoverageModulationTable = UlongToPtr(in_ext->pCoverageModulationTable);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {
            VkPipelineCoverageReductionStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCoverageReductionStateCreateInfoNV32 *in_ext = (const VkPipelineCoverageReductionStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->coverageReductionMode = in_ext->coverageReductionMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {
            VkPipelineCoverageToColorStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCoverageToColorStateCreateInfoNV32 *in_ext = (const VkPipelineCoverageToColorStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->coverageToColorEnable = in_ext->coverageToColorEnable;
            out_ext->coverageToColorLocation = in_ext->coverageToColorLocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {
            VkPipelineSampleLocationsStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineSampleLocationsStateCreateInfoEXT32 *in_ext = (const VkPipelineSampleLocationsStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->sampleLocationsEnable = in_ext->sampleLocationsEnable;
            convert_VkSampleLocationsInfoEXT_win32_to_host(&in_ext->sampleLocationsInfo, &out_ext->sampleLocationsInfo);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkPipelineMultisampleStateCreateInfo *convert_VkPipelineMultisampleStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineMultisampleStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineMultisampleStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineMultisampleStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineDepthStencilStateCreateInfo_win32_to_host(const VkPipelineDepthStencilStateCreateInfo32 *in, VkPipelineDepthStencilStateCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->depthTestEnable = in->depthTestEnable;
    out->depthWriteEnable = in->depthWriteEnable;
    out->depthCompareOp = in->depthCompareOp;
    out->depthBoundsTestEnable = in->depthBoundsTestEnable;
    out->stencilTestEnable = in->stencilTestEnable;
    out->front = in->front;
    out->back = in->back;
    out->minDepthBounds = in->minDepthBounds;
    out->maxDepthBounds = in->maxDepthBounds;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkPipelineDepthStencilStateCreateInfo *convert_VkPipelineDepthStencilStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineDepthStencilStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineDepthStencilStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineDepthStencilStateCreateInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineColorBlendStateCreateInfo_win32_to_host(struct conversion_context *ctx, const VkPipelineColorBlendStateCreateInfo32 *in, VkPipelineColorBlendStateCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->logicOpEnable = in->logicOpEnable;
    out->logicOp = in->logicOp;
    out->attachmentCount = in->attachmentCount;
    out->pAttachments = UlongToPtr(in->pAttachments);
    memcpy(out->blendConstants, in->blendConstants, 4 * sizeof(float));

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {
            VkPipelineColorBlendAdvancedStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineColorBlendAdvancedStateCreateInfoEXT32 *in_ext = (const VkPipelineColorBlendAdvancedStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->srcPremultiplied = in_ext->srcPremultiplied;
            out_ext->dstPremultiplied = in_ext->dstPremultiplied;
            out_ext->blendOverlap = in_ext->blendOverlap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
        {
            VkPipelineColorWriteCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineColorWriteCreateInfoEXT32 *in_ext = (const VkPipelineColorWriteCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentCount = in_ext->attachmentCount;
            out_ext->pColorWriteEnables = UlongToPtr(in_ext->pColorWriteEnables);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkPipelineColorBlendStateCreateInfo *convert_VkPipelineColorBlendStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineColorBlendStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineColorBlendStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineColorBlendStateCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineDynamicStateCreateInfo_win32_to_host(const VkPipelineDynamicStateCreateInfo32 *in, VkPipelineDynamicStateCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->dynamicStateCount = in->dynamicStateCount;
    out->pDynamicStates = UlongToPtr(in->pDynamicStates);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkPipelineDynamicStateCreateInfo *convert_VkPipelineDynamicStateCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkPipelineDynamicStateCreateInfo32 *in, uint32_t count)
{
    VkPipelineDynamicStateCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineDynamicStateCreateInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkGraphicsShaderGroupCreateInfoNV_win32_to_host(struct conversion_context *ctx, const VkGraphicsShaderGroupCreateInfoNV32 *in, VkGraphicsShaderGroupCreateInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win32_to_host(ctx, (const VkPipelineShaderStageCreateInfo32 *)UlongToPtr(in->pStages), in->stageCount);
    out->pVertexInputState = convert_VkPipelineVertexInputStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineVertexInputStateCreateInfo32 *)UlongToPtr(in->pVertexInputState), 1);
    out->pTessellationState = convert_VkPipelineTessellationStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineTessellationStateCreateInfo32 *)UlongToPtr(in->pTessellationState), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkGraphicsShaderGroupCreateInfoNV *convert_VkGraphicsShaderGroupCreateInfoNV_array_win32_to_host(struct conversion_context *ctx, const VkGraphicsShaderGroupCreateInfoNV32 *in, uint32_t count)
{
    VkGraphicsShaderGroupCreateInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkGraphicsShaderGroupCreateInfoNV_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkGraphicsPipelineCreateInfo_win32_to_host(struct conversion_context *ctx, const VkGraphicsPipelineCreateInfo32 *in, VkGraphicsPipelineCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win32_to_host(ctx, (const VkPipelineShaderStageCreateInfo32 *)UlongToPtr(in->pStages), in->stageCount);
    out->pVertexInputState = convert_VkPipelineVertexInputStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineVertexInputStateCreateInfo32 *)UlongToPtr(in->pVertexInputState), 1);
    out->pInputAssemblyState = convert_VkPipelineInputAssemblyStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineInputAssemblyStateCreateInfo32 *)UlongToPtr(in->pInputAssemblyState), 1);
    out->pTessellationState = convert_VkPipelineTessellationStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineTessellationStateCreateInfo32 *)UlongToPtr(in->pTessellationState), 1);
    out->pViewportState = convert_VkPipelineViewportStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineViewportStateCreateInfo32 *)UlongToPtr(in->pViewportState), 1);
    out->pRasterizationState = convert_VkPipelineRasterizationStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineRasterizationStateCreateInfo32 *)UlongToPtr(in->pRasterizationState), 1);
    out->pMultisampleState = convert_VkPipelineMultisampleStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineMultisampleStateCreateInfo32 *)UlongToPtr(in->pMultisampleState), 1);
    out->pDepthStencilState = convert_VkPipelineDepthStencilStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineDepthStencilStateCreateInfo32 *)UlongToPtr(in->pDepthStencilState), 1);
    out->pColorBlendState = convert_VkPipelineColorBlendStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineColorBlendStateCreateInfo32 *)UlongToPtr(in->pColorBlendState), 1);
    out->pDynamicState = convert_VkPipelineDynamicStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineDynamicStateCreateInfo32 *)UlongToPtr(in->pDynamicState), 1);
    out->layout = in->layout;
    out->renderPass = in->renderPass;
    out->subpass = in->subpass;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
        {
            VkAttachmentSampleCountInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentSampleCountInfoAMD32 *in_ext = (const VkAttachmentSampleCountInfoAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentSamples = UlongToPtr(in_ext->pColorAttachmentSamples);
            out_ext->depthStencilAttachmentSamples = in_ext->depthStencilAttachmentSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
        {
            VkGraphicsPipelineLibraryCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGraphicsPipelineLibraryCreateInfoEXT32 *in_ext = (const VkGraphicsPipelineLibraryCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {
            VkGraphicsPipelineShaderGroupsCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGraphicsPipelineShaderGroupsCreateInfoNV32 *in_ext = (const VkGraphicsPipelineShaderGroupsCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->groupCount = in_ext->groupCount;
            out_ext->pGroups = convert_VkGraphicsShaderGroupCreateInfoNV_array_win32_to_host(ctx, (const VkGraphicsShaderGroupCreateInfoNV32 *)UlongToPtr(in_ext->pGroups), in_ext->groupCount);
            out_ext->pipelineCount = in_ext->pipelineCount;
            out_ext->pPipelines = UlongToPtr(in_ext->pPipelines);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR:
        {
            VkPipelineBinaryInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineBinaryInfoKHR32 *in_ext = (const VkPipelineBinaryInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->binaryCount = in_ext->binaryCount;
            out_ext->pPipelineBinaries = UlongToPtr(in_ext->pPipelineBinaries);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {
            VkPipelineCompilerControlCreateInfoAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCompilerControlCreateInfoAMD32 *in_ext = (const VkPipelineCompilerControlCreateInfoAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
            out_ext->pNext = NULL;
            out_ext->compilerControlFlags = in_ext->compilerControlFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO:
        {
            VkPipelineCreateFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreateFlags2CreateInfo32 *in_ext = (const VkPipelineCreateFlags2CreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo32 *in_ext = (const VkPipelineCreationFeedbackCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineCreationFeedback), 1);
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {
            VkPipelineDiscardRectangleStateCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineDiscardRectangleStateCreateInfoEXT32 *in_ext = (const VkPipelineDiscardRectangleStateCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->discardRectangleMode = in_ext->discardRectangleMode;
            out_ext->discardRectangleCount = in_ext->discardRectangleCount;
            out_ext->pDiscardRectangles = UlongToPtr(in_ext->pDiscardRectangles);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE:
        {
            VkPipelineFragmentDensityMapLayeredCreateInfoVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineFragmentDensityMapLayeredCreateInfoVALVE32 *in_ext = (const VkPipelineFragmentDensityMapLayeredCreateInfoVALVE32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE;
            out_ext->pNext = NULL;
            out_ext->maxFragmentDensityMapLayers = in_ext->maxFragmentDensityMapLayers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {
            VkPipelineFragmentShadingRateEnumStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineFragmentShadingRateEnumStateCreateInfoNV32 *in_ext = (const VkPipelineFragmentShadingRateEnumStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateType = in_ext->shadingRateType;
            out_ext->shadingRate = in_ext->shadingRate;
            memcpy(out_ext->combinerOps, in_ext->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {
            VkPipelineFragmentShadingRateStateCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineFragmentShadingRateStateCreateInfoKHR32 *in_ext = (const VkPipelineFragmentShadingRateStateCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->fragmentSize = in_ext->fragmentSize;
            memcpy(out_ext->combinerOps, in_ext->combinerOps, 2 * sizeof(VkFragmentShadingRateCombinerOpKHR));
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
        {
            VkPipelineLibraryCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLibraryCreateInfoKHR32 *in_ext = (const VkPipelineLibraryCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->libraryCount = in_ext->libraryCount;
            out_ext->pLibraries = UlongToPtr(in_ext->pLibraries);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
        {
            VkPipelineRenderingCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRenderingCreateInfo32 *in_ext = (const VkPipelineRenderingCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewMask = in_ext->viewMask;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentFormats = UlongToPtr(in_ext->pColorAttachmentFormats);
            out_ext->depthAttachmentFormat = in_ext->depthAttachmentFormat;
            out_ext->stencilAttachmentFormat = in_ext->stencilAttachmentFormat;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {
            VkPipelineRepresentativeFragmentTestStateCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRepresentativeFragmentTestStateCreateInfoNV32 *in_ext = (const VkPipelineRepresentativeFragmentTestStateCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->representativeFragmentTestEnable = in_ext->representativeFragmentTestEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO:
        {
            VkPipelineRobustnessCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfo32 *in_ext = (const VkPipelineRobustnessCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO:
        {
            VkRenderingAttachmentLocationInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingAttachmentLocationInfo32 *in_ext = (const VkRenderingAttachmentLocationInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentLocations = UlongToPtr(in_ext->pColorAttachmentLocations);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO:
        {
            VkRenderingInputAttachmentIndexInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderingInputAttachmentIndexInfo32 *in_ext = (const VkRenderingInputAttachmentIndexInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO;
            out_ext->pNext = NULL;
            out_ext->colorAttachmentCount = in_ext->colorAttachmentCount;
            out_ext->pColorAttachmentInputIndices = UlongToPtr(in_ext->pColorAttachmentInputIndices);
            out_ext->pDepthInputAttachmentIndex = UlongToPtr(in_ext->pDepthInputAttachmentIndex);
            out_ext->pStencilInputAttachmentIndex = UlongToPtr(in_ext->pStencilInputAttachmentIndex);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkGraphicsPipelineCreateInfo *convert_VkGraphicsPipelineCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkGraphicsPipelineCreateInfo32 *in, uint32_t count)
{
    VkGraphicsPipelineCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkGraphicsPipelineCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkGraphicsPipelineCreateInfo_host_to_win32(const VkGraphicsPipelineCreateInfo *in, const VkGraphicsPipelineCreateInfo32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;


    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineCreationFeedback, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineCreationFeedback), 1);
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineStageCreationFeedbacks, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkGraphicsPipelineCreateInfo_array_host_to_win32(const VkGraphicsPipelineCreateInfo *in, const VkGraphicsPipelineCreateInfo32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkGraphicsPipelineCreateInfo_host_to_win32(&in[i], &out[i]);
    }
}

#ifdef _WIN64
static void convert_VkImageCreateInfo_win64_to_host(struct conversion_context *ctx, const VkImageCreateInfo *in, VkImageCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->imageType = in->imageType;
    out->format = in->format;
    out->extent = in->extent;
    out->mipLevels = in->mipLevels;
    out->arrayLayers = in->arrayLayers;
    out->samples = in->samples;
    out->tiling = in->tiling;
    out->usage = in->usage;
    out->sharingMode = in->sharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = in->pQueueFamilyIndices;
    out->initialLayout = in->initialLayout;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            VkDedicatedAllocationImageCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationImageCreateInfoNV *in_ext = (const VkDedicatedAllocationImageCreateInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocation = in_ext->dedicatedAllocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            VkExternalMemoryImageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryImageCreateInfo *in_ext = (const VkExternalMemoryImageCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA:
        {
            VkImageAlignmentControlCreateInfoMESA *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageAlignmentControlCreateInfoMESA *in_ext = (const VkImageAlignmentControlCreateInfoMESA *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA;
            out_ext->pNext = NULL;
            out_ext->maximumRequestedAlignment = in_ext->maximumRequestedAlignment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageCompressionControlEXT *in_ext = (const VkImageCompressionControlEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
            out_ext->pFixedRateFlags = in_ext->pFixedRateFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageFormatListCreateInfo *in_ext = (const VkImageFormatListCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewFormatCount = in_ext->viewFormatCount;
            out_ext->pViewFormats = in_ext->pViewFormats;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageStencilUsageCreateInfo *in_ext = (const VkImageStencilUsageCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->stencilUsage = in_ext->stencilUsage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            VkImageSwapchainCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageSwapchainCreateInfoKHR *in_ext = (const VkImageSwapchainCreateInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchain = in_ext->swapchain ? vulkan_swapchain_from_handle(in_ext->swapchain)->host.swapchain : 0;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = in_ext->opaqueCaptureDescriptorData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
            VkOpticalFlowImageFormatInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpticalFlowImageFormatInfoNV *in_ext = (const VkOpticalFlowImageFormatInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
        {
            VkVideoProfileListInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoProfileListInfoKHR *in_ext = (const VkVideoProfileListInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->profileCount = in_ext->profileCount;
            out_ext->pProfiles = in_ext->pProfiles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

static void convert_VkImageCreateInfo_win32_to_host(struct conversion_context *ctx, const VkImageCreateInfo32 *in, VkImageCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->imageType = in->imageType;
    out->format = in->format;
    out->extent = in->extent;
    out->mipLevels = in->mipLevels;
    out->arrayLayers = in->arrayLayers;
    out->samples = in->samples;
    out->tiling = in->tiling;
    out->usage = in->usage;
    out->sharingMode = in->sharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = UlongToPtr(in->pQueueFamilyIndices);
    out->initialLayout = in->initialLayout;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {
            VkDedicatedAllocationImageCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDedicatedAllocationImageCreateInfoNV32 *in_ext = (const VkDedicatedAllocationImageCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocation = in_ext->dedicatedAllocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {
            VkExternalMemoryImageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryImageCreateInfo32 *in_ext = (const VkExternalMemoryImageCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA:
        {
            VkImageAlignmentControlCreateInfoMESA *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageAlignmentControlCreateInfoMESA32 *in_ext = (const VkImageAlignmentControlCreateInfoMESA32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA;
            out_ext->pNext = NULL;
            out_ext->maximumRequestedAlignment = in_ext->maximumRequestedAlignment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageCompressionControlEXT32 *in_ext = (const VkImageCompressionControlEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
            out_ext->pFixedRateFlags = UlongToPtr(in_ext->pFixedRateFlags);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageFormatListCreateInfo32 *in_ext = (const VkImageFormatListCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewFormatCount = in_ext->viewFormatCount;
            out_ext->pViewFormats = UlongToPtr(in_ext->pViewFormats);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageStencilUsageCreateInfo32 *in_ext = (const VkImageStencilUsageCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->stencilUsage = in_ext->stencilUsage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {
            VkImageSwapchainCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageSwapchainCreateInfoKHR32 *in_ext = (const VkImageSwapchainCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchain = in_ext->swapchain ? vulkan_swapchain_from_handle(in_ext->swapchain)->host.swapchain : 0;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
            VkOpticalFlowImageFormatInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpticalFlowImageFormatInfoNV32 *in_ext = (const VkOpticalFlowImageFormatInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
        {
            VkVideoProfileListInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoProfileListInfoKHR32 *in_ext = (const VkVideoProfileListInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->profileCount = in_ext->profileCount;
            out_ext->pProfiles = convert_VkVideoProfileInfoKHR_array_win32_to_host(ctx, (const VkVideoProfileInfoKHR32 *)UlongToPtr(in_ext->pProfiles), in_ext->profileCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkImageViewCreateInfo_win32_to_host(struct conversion_context *ctx, const VkImageViewCreateInfo32 *in, VkImageViewCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->image = in->image;
    out->viewType = in->viewType;
    out->format = in->format;
    out->components = in->components;
    out->subresourceRange = in->subresourceRange;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {
            VkImageViewASTCDecodeModeEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageViewASTCDecodeModeEXT32 *in_ext = (const VkImageViewASTCDecodeModeEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT;
            out_ext->pNext = NULL;
            out_ext->decodeMode = in_ext->decodeMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT:
        {
            VkImageViewMinLodCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageViewMinLodCreateInfoEXT32 *in_ext = (const VkImageViewMinLodCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->minLod = in_ext->minLod;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
        {
            VkImageViewSampleWeightCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageViewSampleWeightCreateInfoQCOM32 *in_ext = (const VkImageViewSampleWeightCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->filterCenter = in_ext->filterCenter;
            out_ext->filterSize = in_ext->filterSize;
            out_ext->numPhases = in_ext->numPhases;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT:
        {
            VkImageViewSlicedCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageViewSlicedCreateInfoEXT32 *in_ext = (const VkImageViewSlicedCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->sliceOffset = in_ext->sliceOffset;
            out_ext->sliceCount = in_ext->sliceCount;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {
            VkImageViewUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageViewUsageCreateInfo32 *in_ext = (const VkImageViewUsageCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            VkSamplerYcbcrConversionInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerYcbcrConversionInfo32 *in_ext = (const VkSamplerYcbcrConversionInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
            out_ext->pNext = NULL;
            out_ext->conversion = in_ext->conversion;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkIndirectCommandsTokenDataEXT_win32_to_host(const VkIndirectCommandsTokenDataEXT32 *in, VkIndirectCommandsTokenDataEXT *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT || selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT)
        out->pPushConstant = UlongToPtr(in->pPushConstant);
    if (selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT)
        out->pVertexBuffer = UlongToPtr(in->pVertexBuffer);
    if (selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT)
        out->pIndexBuffer = UlongToPtr(in->pIndexBuffer);
    if (selector == VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT)
        out->pExecutionSet = UlongToPtr(in->pExecutionSet);
}

static void convert_VkIndirectCommandsLayoutTokenEXT_win32_to_host(const VkIndirectCommandsLayoutTokenEXT32 *in, VkIndirectCommandsLayoutTokenEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    convert_VkIndirectCommandsTokenDataEXT_win32_to_host(&in->data, &out->data, in->type);
    out->offset = in->offset;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkIndirectCommandsLayoutTokenEXT *convert_VkIndirectCommandsLayoutTokenEXT_array_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsLayoutTokenEXT32 *in, uint32_t count)
{
    VkIndirectCommandsLayoutTokenEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkIndirectCommandsLayoutTokenEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkIndirectCommandsLayoutCreateInfoEXT_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsLayoutCreateInfoEXT32 *in, VkIndirectCommandsLayoutCreateInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->shaderStages = in->shaderStages;
    out->indirectStride = in->indirectStride;
    out->pipelineLayout = in->pipelineLayout;
    out->tokenCount = in->tokenCount;
    out->pTokens = convert_VkIndirectCommandsLayoutTokenEXT_array_win32_to_host(ctx, (const VkIndirectCommandsLayoutTokenEXT32 *)UlongToPtr(in->pTokens), in->tokenCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {
            VkPipelineLayoutCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineLayoutCreateInfo32 *in_ext = (const VkPipelineLayoutCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->setLayoutCount = in_ext->setLayoutCount;
            out_ext->pSetLayouts = UlongToPtr(in_ext->pSetLayouts);
            out_ext->pushConstantRangeCount = in_ext->pushConstantRangeCount;
            out_ext->pPushConstantRanges = UlongToPtr(in_ext->pPushConstantRanges);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkIndirectCommandsLayoutTokenNV_win32_to_host(const VkIndirectCommandsLayoutTokenNV32 *in, VkIndirectCommandsLayoutTokenNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->tokenType = in->tokenType;
    out->stream = in->stream;
    out->offset = in->offset;
    out->vertexBindingUnit = in->vertexBindingUnit;
    out->vertexDynamicStride = in->vertexDynamicStride;
    out->pushconstantPipelineLayout = in->pushconstantPipelineLayout;
    out->pushconstantShaderStageFlags = in->pushconstantShaderStageFlags;
    out->pushconstantOffset = in->pushconstantOffset;
    out->pushconstantSize = in->pushconstantSize;
    out->indirectStateFlags = in->indirectStateFlags;
    out->indexTypeCount = in->indexTypeCount;
    out->pIndexTypes = UlongToPtr(in->pIndexTypes);
    out->pIndexTypeValues = UlongToPtr(in->pIndexTypeValues);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkIndirectCommandsLayoutTokenNV *convert_VkIndirectCommandsLayoutTokenNV_array_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsLayoutTokenNV32 *in, uint32_t count)
{
    VkIndirectCommandsLayoutTokenNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkIndirectCommandsLayoutTokenNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkIndirectCommandsLayoutCreateInfoNV_win32_to_host(struct conversion_context *ctx, const VkIndirectCommandsLayoutCreateInfoNV32 *in, VkIndirectCommandsLayoutCreateInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->tokenCount = in->tokenCount;
    out->pTokens = convert_VkIndirectCommandsLayoutTokenNV_array_win32_to_host(ctx, (const VkIndirectCommandsLayoutTokenNV32 *)UlongToPtr(in->pTokens), in->tokenCount);
    out->streamCount = in->streamCount;
    out->pStreamStrides = UlongToPtr(in->pStreamStrides);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkIndirectExecutionSetPipelineInfoEXT_win32_to_host(const VkIndirectExecutionSetPipelineInfoEXT32 *in, VkIndirectExecutionSetPipelineInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->initialPipeline = in->initialPipeline;
    out->maxPipelineCount = in->maxPipelineCount;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkIndirectExecutionSetPipelineInfoEXT *convert_VkIndirectExecutionSetPipelineInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkIndirectExecutionSetPipelineInfoEXT32 *in, uint32_t count)
{
    VkIndirectExecutionSetPipelineInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkIndirectExecutionSetPipelineInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkIndirectExecutionSetShaderLayoutInfoEXT_win32_to_host(const VkIndirectExecutionSetShaderLayoutInfoEXT32 *in, VkIndirectExecutionSetShaderLayoutInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->setLayoutCount = in->setLayoutCount;
    out->pSetLayouts = UlongToPtr(in->pSetLayouts);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkIndirectExecutionSetShaderLayoutInfoEXT *convert_VkIndirectExecutionSetShaderLayoutInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkIndirectExecutionSetShaderLayoutInfoEXT32 *in, uint32_t count)
{
    VkIndirectExecutionSetShaderLayoutInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkIndirectExecutionSetShaderLayoutInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkIndirectExecutionSetShaderInfoEXT_win32_to_host(struct conversion_context *ctx, const VkIndirectExecutionSetShaderInfoEXT32 *in, VkIndirectExecutionSetShaderInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->shaderCount = in->shaderCount;
    out->pInitialShaders = UlongToPtr(in->pInitialShaders);
    out->pSetLayoutInfos = convert_VkIndirectExecutionSetShaderLayoutInfoEXT_array_win32_to_host(ctx, (const VkIndirectExecutionSetShaderLayoutInfoEXT32 *)UlongToPtr(in->pSetLayoutInfos), in->shaderCount);
    out->maxShaderCount = in->maxShaderCount;
    out->pushConstantRangeCount = in->pushConstantRangeCount;
    out->pPushConstantRanges = UlongToPtr(in->pPushConstantRanges);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkIndirectExecutionSetShaderInfoEXT *convert_VkIndirectExecutionSetShaderInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkIndirectExecutionSetShaderInfoEXT32 *in, uint32_t count)
{
    VkIndirectExecutionSetShaderInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkIndirectExecutionSetShaderInfoEXT_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkIndirectExecutionSetInfoEXT_win32_to_host(struct conversion_context *ctx, const VkIndirectExecutionSetInfoEXT32 *in, VkIndirectExecutionSetInfoEXT *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT)
        out->pPipelineInfo = convert_VkIndirectExecutionSetPipelineInfoEXT_array_win32_to_host(ctx, (const VkIndirectExecutionSetPipelineInfoEXT32 *)UlongToPtr(in->pPipelineInfo), 1);
    if (selector == VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT)
        out->pShaderInfo = convert_VkIndirectExecutionSetShaderInfoEXT_array_win32_to_host(ctx, (const VkIndirectExecutionSetShaderInfoEXT32 *)UlongToPtr(in->pShaderInfo), 1);
}

static void convert_VkIndirectExecutionSetCreateInfoEXT_win32_to_host(struct conversion_context *ctx, const VkIndirectExecutionSetCreateInfoEXT32 *in, VkIndirectExecutionSetCreateInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    convert_VkIndirectExecutionSetInfoEXT_win32_to_host(ctx, &in->info, &out->info, in->type);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkInstanceCreateInfo_win64_to_host(struct conversion_context *ctx, const VkInstanceCreateInfo *in, VkInstanceCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pApplicationInfo = in->pApplicationInfo;
    out->enabledLayerCount = in->enabledLayerCount;
    out->ppEnabledLayerNames = in->ppEnabledLayerNames;
    out->enabledExtensionCount = in->enabledExtensionCount;
    out->ppEnabledExtensionNames = in->ppEnabledExtensionNames;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO:
            break;
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            VkDebugReportCallbackCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugReportCallbackCreateInfoEXT *in_ext = (const VkDebugReportCallbackCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->pfnCallback = in_ext->pfnCallback;
            out_ext->pUserData = in_ext->pUserData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            VkDebugUtilsMessengerCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugUtilsMessengerCreateInfoEXT *in_ext = (const VkDebugUtilsMessengerCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->messageSeverity = in_ext->messageSeverity;
            out_ext->messageType = in_ext->messageType;
            out_ext->pfnUserCallback = in_ext->pfnUserCallback;
            out_ext->pUserData = in_ext->pUserData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT:
        {
            VkLayerSettingsCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLayerSettingsCreateInfoEXT *in_ext = (const VkLayerSettingsCreateInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->settingCount = in_ext->settingCount;
            out_ext->pSettings = in_ext->pSettings;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            VkValidationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkValidationFeaturesEXT *in_ext = (const VkValidationFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->enabledValidationFeatureCount = in_ext->enabledValidationFeatureCount;
            out_ext->pEnabledValidationFeatures = in_ext->pEnabledValidationFeatures;
            out_ext->disabledValidationFeatureCount = in_ext->disabledValidationFeatureCount;
            out_ext->pDisabledValidationFeatures = in_ext->pDisabledValidationFeatures;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            VkValidationFlagsEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkValidationFlagsEXT *in_ext = (const VkValidationFlagsEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
            out_ext->pNext = NULL;
            out_ext->disabledValidationCheckCount = in_ext->disabledValidationCheckCount;
            out_ext->pDisabledValidationChecks = in_ext->pDisabledValidationChecks;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

static void convert_VkApplicationInfo_win32_to_host(const VkApplicationInfo32 *in, VkApplicationInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pApplicationName = UlongToPtr(in->pApplicationName);
    out->applicationVersion = in->applicationVersion;
    out->pEngineName = UlongToPtr(in->pEngineName);
    out->engineVersion = in->engineVersion;
    out->apiVersion = in->apiVersion;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkApplicationInfo *convert_VkApplicationInfo_array_win32_to_host(struct conversion_context *ctx, const VkApplicationInfo32 *in, uint32_t count)
{
    VkApplicationInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkApplicationInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkLayerSettingEXT_win32_to_host(const VkLayerSettingEXT32 *in, VkLayerSettingEXT *out)
{
    if (!in) return;

    out->pLayerName = UlongToPtr(in->pLayerName);
    out->pSettingName = UlongToPtr(in->pSettingName);
    out->type = in->type;
    out->valueCount = in->valueCount;
    out->pValues = UlongToPtr(in->pValues);
}

static const VkLayerSettingEXT *convert_VkLayerSettingEXT_array_win32_to_host(struct conversion_context *ctx, const VkLayerSettingEXT32 *in, uint32_t count)
{
    VkLayerSettingEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkLayerSettingEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkInstanceCreateInfo_win32_to_host(struct conversion_context *ctx, const VkInstanceCreateInfo32 *in, VkInstanceCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pApplicationInfo = convert_VkApplicationInfo_array_win32_to_host(ctx, (const VkApplicationInfo32 *)UlongToPtr(in->pApplicationInfo), 1);
    out->enabledLayerCount = in->enabledLayerCount;
    out->ppEnabledLayerNames = convert_char_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppEnabledLayerNames), in->enabledLayerCount);
    out->enabledExtensionCount = in->enabledExtensionCount;
    out->ppEnabledExtensionNames = convert_char_pointer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(in->ppEnabledExtensionNames), in->enabledExtensionCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO:
            break;
        case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {
            VkDebugReportCallbackCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugReportCallbackCreateInfoEXT32 *in_ext = (const VkDebugReportCallbackCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->pfnCallback = (PFN_vkDebugReportCallbackEXT)UlongToPtr(in_ext->pfnCallback);
            out_ext->pUserData = UlongToPtr(in_ext->pUserData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {
            VkDebugUtilsMessengerCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDebugUtilsMessengerCreateInfoEXT32 *in_ext = (const VkDebugUtilsMessengerCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->messageSeverity = in_ext->messageSeverity;
            out_ext->messageType = in_ext->messageType;
            out_ext->pfnUserCallback = (PFN_vkDebugUtilsMessengerCallbackEXT)UlongToPtr(in_ext->pfnUserCallback);
            out_ext->pUserData = UlongToPtr(in_ext->pUserData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT:
        {
            VkLayerSettingsCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLayerSettingsCreateInfoEXT32 *in_ext = (const VkLayerSettingsCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->settingCount = in_ext->settingCount;
            out_ext->pSettings = convert_VkLayerSettingEXT_array_win32_to_host(ctx, (const VkLayerSettingEXT32 *)UlongToPtr(in_ext->pSettings), in_ext->settingCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            VkValidationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkValidationFeaturesEXT32 *in_ext = (const VkValidationFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->enabledValidationFeatureCount = in_ext->enabledValidationFeatureCount;
            out_ext->pEnabledValidationFeatures = UlongToPtr(in_ext->pEnabledValidationFeatures);
            out_ext->disabledValidationFeatureCount = in_ext->disabledValidationFeatureCount;
            out_ext->pDisabledValidationFeatures = UlongToPtr(in_ext->pDisabledValidationFeatures);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {
            VkValidationFlagsEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkValidationFlagsEXT32 *in_ext = (const VkValidationFlagsEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
            out_ext->pNext = NULL;
            out_ext->disabledValidationCheckCount = in_ext->disabledValidationCheckCount;
            out_ext->pDisabledValidationChecks = UlongToPtr(in_ext->pDisabledValidationChecks);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkMicromapCreateInfoEXT_win32_to_host(const VkMicromapCreateInfoEXT32 *in, VkMicromapCreateInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->createFlags = in->createFlags;
    out->buffer = in->buffer;
    out->offset = in->offset;
    out->size = in->size;
    out->type = in->type;
    out->deviceAddress = in->deviceAddress;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkOpticalFlowSessionCreateInfoNV_win32_to_host(struct conversion_context *ctx, const VkOpticalFlowSessionCreateInfoNV32 *in, VkOpticalFlowSessionCreateInfoNV *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->width = in->width;
    out->height = in->height;
    out->imageFormat = in->imageFormat;
    out->flowVectorFormat = in->flowVectorFormat;
    out->costFormat = in->costFormat;
    out->outputGridSize = in->outputGridSize;
    out->hintGridSize = in->hintGridSize;
    out->performanceLevel = in->performanceLevel;
    out->flags = in->flags;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV:
        {
            VkOpticalFlowSessionCreatePrivateDataInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpticalFlowSessionCreatePrivateDataInfoNV32 *in_ext = (const VkOpticalFlowSessionCreatePrivateDataInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->id = in_ext->id;
            out_ext->size = in_ext->size;
            out_ext->pPrivateData = UlongToPtr(in_ext->pPrivateData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkPipelineBinaryKeyKHR_win32_to_host(const VkPipelineBinaryKeyKHR32 *in, VkPipelineBinaryKeyKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->keySize = in->keySize;
    memcpy(out->key, in->key, VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR * sizeof(uint8_t));
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkPipelineBinaryKeyKHR *convert_VkPipelineBinaryKeyKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineBinaryKeyKHR32 *in, uint32_t count)
{
    VkPipelineBinaryKeyKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineBinaryKeyKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineBinaryDataKHR_win32_to_host(const VkPipelineBinaryDataKHR32 *in, VkPipelineBinaryDataKHR *out)
{
    if (!in) return;

    out->dataSize = in->dataSize;
    out->pData = UlongToPtr(in->pData);
}

static const VkPipelineBinaryDataKHR *convert_VkPipelineBinaryDataKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineBinaryDataKHR32 *in, uint32_t count)
{
    VkPipelineBinaryDataKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineBinaryDataKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineBinaryKeysAndDataKHR_win32_to_host(struct conversion_context *ctx, const VkPipelineBinaryKeysAndDataKHR32 *in, VkPipelineBinaryKeysAndDataKHR *out)
{
    if (!in) return;

    out->binaryCount = in->binaryCount;
    out->pPipelineBinaryKeys = convert_VkPipelineBinaryKeyKHR_array_win32_to_host(ctx, (const VkPipelineBinaryKeyKHR32 *)UlongToPtr(in->pPipelineBinaryKeys), in->binaryCount);
    out->pPipelineBinaryData = convert_VkPipelineBinaryDataKHR_array_win32_to_host(ctx, (const VkPipelineBinaryDataKHR32 *)UlongToPtr(in->pPipelineBinaryData), in->binaryCount);
}

static const VkPipelineBinaryKeysAndDataKHR *convert_VkPipelineBinaryKeysAndDataKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineBinaryKeysAndDataKHR32 *in, uint32_t count)
{
    VkPipelineBinaryKeysAndDataKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineBinaryKeysAndDataKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineCreateInfoKHR_win32_to_host(const VkPipelineCreateInfoKHR32 *in, VkPipelineCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkPipelineCreateInfoKHR *convert_VkPipelineCreateInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineCreateInfoKHR32 *in, uint32_t count)
{
    VkPipelineCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineCreateInfoKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineBinaryCreateInfoKHR_win32_to_host(struct conversion_context *ctx, const VkPipelineBinaryCreateInfoKHR32 *in, VkPipelineBinaryCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pKeysAndDataInfo = convert_VkPipelineBinaryKeysAndDataKHR_array_win32_to_host(ctx, (const VkPipelineBinaryKeysAndDataKHR32 *)UlongToPtr(in->pKeysAndDataInfo), 1);
    out->pipeline = in->pipeline;
    out->pPipelineCreateInfo = convert_VkPipelineCreateInfoKHR_array_win32_to_host(ctx, (const VkPipelineCreateInfoKHR32 *)UlongToPtr(in->pPipelineCreateInfo), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPipelineBinaryHandlesInfoKHR_win32_to_host(const VkPipelineBinaryHandlesInfoKHR32 *in, VkPipelineBinaryHandlesInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipelineBinaryCount = in->pipelineBinaryCount;
    out->pPipelineBinaries = UlongToPtr(in->pPipelineBinaries);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPipelineBinaryHandlesInfoKHR_host_to_win32(const VkPipelineBinaryHandlesInfoKHR *in, VkPipelineBinaryHandlesInfoKHR32 *out)
{
    if (!in) return;

    out->pipelineBinaryCount = in->pipelineBinaryCount;
    out->pPipelineBinaries = PtrToUlong(in->pPipelineBinaries);
}

static void convert_VkPipelineCacheCreateInfo_win32_to_host(const VkPipelineCacheCreateInfo32 *in, VkPipelineCacheCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->initialDataSize = in->initialDataSize;
    out->pInitialData = UlongToPtr(in->pInitialData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPipelineLayoutCreateInfo_win32_to_host(const VkPipelineLayoutCreateInfo32 *in, VkPipelineLayoutCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->setLayoutCount = in->setLayoutCount;
    out->pSetLayouts = UlongToPtr(in->pSetLayouts);
    out->pushConstantRangeCount = in->pushConstantRangeCount;
    out->pPushConstantRanges = UlongToPtr(in->pPushConstantRanges);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPrivateDataSlotCreateInfo_win32_to_host(const VkPrivateDataSlotCreateInfo32 *in, VkPrivateDataSlotCreateInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkQueryPoolCreateInfo_win32_to_host(struct conversion_context *ctx, const VkQueryPoolCreateInfo32 *in, VkQueryPoolCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queryType = in->queryType;
    out->queryCount = in->queryCount;
    out->pipelineStatistics = in->pipelineStatistics;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {
            VkQueryPoolPerformanceCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkQueryPoolPerformanceCreateInfoKHR32 *in_ext = (const VkQueryPoolPerformanceCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->queueFamilyIndex = in_ext->queueFamilyIndex;
            out_ext->counterIndexCount = in_ext->counterIndexCount;
            out_ext->pCounterIndices = UlongToPtr(in_ext->pCounterIndices);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {
            VkQueryPoolPerformanceQueryCreateInfoINTEL *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkQueryPoolPerformanceQueryCreateInfoINTEL32 *in_ext = (const VkQueryPoolPerformanceQueryCreateInfoINTEL32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL;
            out_ext->pNext = NULL;
            out_ext->performanceCountersSampling = in_ext->performanceCountersSampling;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR:
        {
            VkQueryPoolVideoEncodeFeedbackCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR32 *in_ext = (const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->encodeFeedbackFlags = in_ext->encodeFeedbackFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR:
        {
            VkVideoDecodeAV1ProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeAV1ProfileInfoKHR32 *in_ext = (const VkVideoDecodeAV1ProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdProfile = in_ext->stdProfile;
            out_ext->filmGrainSupport = in_ext->filmGrainSupport;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR:
        {
            VkVideoDecodeH264ProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeH264ProfileInfoKHR32 *in_ext = (const VkVideoDecodeH264ProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdProfileIdc = in_ext->stdProfileIdc;
            out_ext->pictureLayout = in_ext->pictureLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR:
        {
            VkVideoDecodeUsageInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeUsageInfoKHR32 *in_ext = (const VkVideoDecodeUsageInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->videoUsageHints = in_ext->videoUsageHints;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR:
        {
            VkVideoDecodeVP9ProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeVP9ProfileInfoKHR32 *in_ext = (const VkVideoDecodeVP9ProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdProfile = in_ext->stdProfile;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR:
        {
            VkVideoEncodeAV1ProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeAV1ProfileInfoKHR32 *in_ext = (const VkVideoEncodeAV1ProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdProfile = in_ext->stdProfile;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR:
        {
            VkVideoEncodeH264ProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264ProfileInfoKHR32 *in_ext = (const VkVideoEncodeH264ProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdProfileIdc = in_ext->stdProfileIdc;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR:
        {
            VkVideoEncodeUsageInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeUsageInfoKHR32 *in_ext = (const VkVideoEncodeUsageInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->videoUsageHints = in_ext->videoUsageHints;
            out_ext->videoContentHints = in_ext->videoContentHints;
            out_ext->tuningMode = in_ext->tuningMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR:
        {
            VkVideoProfileInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoProfileInfoKHR32 *in_ext = (const VkVideoProfileInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->videoCodecOperation = in_ext->videoCodecOperation;
            out_ext->chromaSubsampling = in_ext->chromaSubsampling;
            out_ext->lumaBitDepth = in_ext->lumaBitDepth;
            out_ext->chromaBitDepth = in_ext->chromaBitDepth;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

#ifdef _WIN64
static void convert_VkRayTracingPipelineCreateInfoKHR_win64_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoKHR *in, VkRayTracingPipelineCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win64_to_host(ctx, in->pStages, in->stageCount);
    out->groupCount = in->groupCount;
    out->pGroups = in->pGroups;
    out->maxPipelineRayRecursionDepth = in->maxPipelineRayRecursionDepth;
    out->pLibraryInfo = in->pLibraryInfo;
    out->pLibraryInterface = in->pLibraryInterface;
    out->pDynamicState = in->pDynamicState;
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkRayTracingPipelineCreateInfoKHR *convert_VkRayTracingPipelineCreateInfoKHR_array_win64_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoKHR *in, uint32_t count)
{
    VkRayTracingPipelineCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoKHR_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkRayTracingShaderGroupCreateInfoKHR_win32_to_host(const VkRayTracingShaderGroupCreateInfoKHR32 *in, VkRayTracingShaderGroupCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->generalShader = in->generalShader;
    out->closestHitShader = in->closestHitShader;
    out->anyHitShader = in->anyHitShader;
    out->intersectionShader = in->intersectionShader;
    out->pShaderGroupCaptureReplayHandle = UlongToPtr(in->pShaderGroupCaptureReplayHandle);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkRayTracingShaderGroupCreateInfoKHR *convert_VkRayTracingShaderGroupCreateInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkRayTracingShaderGroupCreateInfoKHR32 *in, uint32_t count)
{
    VkRayTracingShaderGroupCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingShaderGroupCreateInfoKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineLibraryCreateInfoKHR_win32_to_host(const VkPipelineLibraryCreateInfoKHR32 *in, VkPipelineLibraryCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->libraryCount = in->libraryCount;
    out->pLibraries = UlongToPtr(in->pLibraries);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkPipelineLibraryCreateInfoKHR *convert_VkPipelineLibraryCreateInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineLibraryCreateInfoKHR32 *in, uint32_t count)
{
    VkPipelineLibraryCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineLibraryCreateInfoKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkRayTracingPipelineInterfaceCreateInfoKHR_win32_to_host(const VkRayTracingPipelineInterfaceCreateInfoKHR32 *in, VkRayTracingPipelineInterfaceCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->maxPipelineRayPayloadSize = in->maxPipelineRayPayloadSize;
    out->maxPipelineRayHitAttributeSize = in->maxPipelineRayHitAttributeSize;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkRayTracingPipelineInterfaceCreateInfoKHR *convert_VkRayTracingPipelineInterfaceCreateInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkRayTracingPipelineInterfaceCreateInfoKHR32 *in, uint32_t count)
{
    VkRayTracingPipelineInterfaceCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineInterfaceCreateInfoKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkRayTracingPipelineCreateInfoKHR_win32_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoKHR32 *in, VkRayTracingPipelineCreateInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win32_to_host(ctx, (const VkPipelineShaderStageCreateInfo32 *)UlongToPtr(in->pStages), in->stageCount);
    out->groupCount = in->groupCount;
    out->pGroups = convert_VkRayTracingShaderGroupCreateInfoKHR_array_win32_to_host(ctx, (const VkRayTracingShaderGroupCreateInfoKHR32 *)UlongToPtr(in->pGroups), in->groupCount);
    out->maxPipelineRayRecursionDepth = in->maxPipelineRayRecursionDepth;
    out->pLibraryInfo = convert_VkPipelineLibraryCreateInfoKHR_array_win32_to_host(ctx, (const VkPipelineLibraryCreateInfoKHR32 *)UlongToPtr(in->pLibraryInfo), 1);
    out->pLibraryInterface = convert_VkRayTracingPipelineInterfaceCreateInfoKHR_array_win32_to_host(ctx, (const VkRayTracingPipelineInterfaceCreateInfoKHR32 *)UlongToPtr(in->pLibraryInterface), 1);
    out->pDynamicState = convert_VkPipelineDynamicStateCreateInfo_array_win32_to_host(ctx, (const VkPipelineDynamicStateCreateInfo32 *)UlongToPtr(in->pDynamicState), 1);
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR:
        {
            VkPipelineBinaryInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineBinaryInfoKHR32 *in_ext = (const VkPipelineBinaryInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->binaryCount = in_ext->binaryCount;
            out_ext->pPipelineBinaries = UlongToPtr(in_ext->pPipelineBinaries);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO:
        {
            VkPipelineCreateFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreateFlags2CreateInfo32 *in_ext = (const VkPipelineCreateFlags2CreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo32 *in_ext = (const VkPipelineCreationFeedbackCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineCreationFeedback), 1);
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO:
        {
            VkPipelineRobustnessCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineRobustnessCreateInfo32 *in_ext = (const VkPipelineRobustnessCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->storageBuffers = in_ext->storageBuffers;
            out_ext->uniformBuffers = in_ext->uniformBuffers;
            out_ext->vertexInputs = in_ext->vertexInputs;
            out_ext->images = in_ext->images;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV:
        {
            VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV32 *in_ext = (const VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->allowClusterAccelerationStructure = in_ext->allowClusterAccelerationStructure;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkRayTracingPipelineCreateInfoKHR *convert_VkRayTracingPipelineCreateInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoKHR32 *in, uint32_t count)
{
    VkRayTracingPipelineCreateInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkRayTracingPipelineCreateInfoKHR_host_to_win32(const VkRayTracingPipelineCreateInfoKHR *in, const VkRayTracingPipelineCreateInfoKHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;


    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineCreationFeedback, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineCreationFeedback), 1);
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineStageCreationFeedbacks, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkRayTracingPipelineCreateInfoKHR_array_host_to_win32(const VkRayTracingPipelineCreateInfoKHR *in, const VkRayTracingPipelineCreateInfoKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoKHR_host_to_win32(&in[i], &out[i]);
    }
}

#ifdef _WIN64
static void convert_VkRayTracingPipelineCreateInfoNV_win64_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoNV *in, VkRayTracingPipelineCreateInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win64_to_host(ctx, in->pStages, in->stageCount);
    out->groupCount = in->groupCount;
    out->pGroups = in->pGroups;
    out->maxRecursionDepth = in->maxRecursionDepth;
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkRayTracingPipelineCreateInfoNV *convert_VkRayTracingPipelineCreateInfoNV_array_win64_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoNV *in, uint32_t count)
{
    VkRayTracingPipelineCreateInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoNV_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkRayTracingShaderGroupCreateInfoNV_win32_to_host(const VkRayTracingShaderGroupCreateInfoNV32 *in, VkRayTracingShaderGroupCreateInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->generalShader = in->generalShader;
    out->closestHitShader = in->closestHitShader;
    out->anyHitShader = in->anyHitShader;
    out->intersectionShader = in->intersectionShader;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkRayTracingShaderGroupCreateInfoNV *convert_VkRayTracingShaderGroupCreateInfoNV_array_win32_to_host(struct conversion_context *ctx, const VkRayTracingShaderGroupCreateInfoNV32 *in, uint32_t count)
{
    VkRayTracingShaderGroupCreateInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingShaderGroupCreateInfoNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkRayTracingPipelineCreateInfoNV_win32_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoNV32 *in, VkRayTracingPipelineCreateInfoNV *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stageCount = in->stageCount;
    out->pStages = convert_VkPipelineShaderStageCreateInfo_array_win32_to_host(ctx, (const VkPipelineShaderStageCreateInfo32 *)UlongToPtr(in->pStages), in->stageCount);
    out->groupCount = in->groupCount;
    out->pGroups = convert_VkRayTracingShaderGroupCreateInfoNV_array_win32_to_host(ctx, (const VkRayTracingShaderGroupCreateInfoNV32 *)UlongToPtr(in->pGroups), in->groupCount);
    out->maxRecursionDepth = in->maxRecursionDepth;
    out->layout = in->layout;
    out->basePipelineHandle = in->basePipelineHandle;
    out->basePipelineIndex = in->basePipelineIndex;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO:
        {
            VkPipelineCreateFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreateFlags2CreateInfo32 *in_ext = (const VkPipelineCreateFlags2CreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineCreationFeedbackCreateInfo32 *in_ext = (const VkPipelineCreationFeedbackCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->pPipelineCreationFeedback = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineCreationFeedback), 1);
            out_ext->pipelineStageCreationFeedbackCount = in_ext->pipelineStageCreationFeedbackCount;
            out_ext->pPipelineStageCreationFeedbacks = convert_VkPipelineCreationFeedback_array_win32_to_host(ctx, (VkPipelineCreationFeedback32 *)UlongToPtr(in_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkRayTracingPipelineCreateInfoNV *convert_VkRayTracingPipelineCreateInfoNV_array_win32_to_host(struct conversion_context *ctx, const VkRayTracingPipelineCreateInfoNV32 *in, uint32_t count)
{
    VkRayTracingPipelineCreateInfoNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoNV_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkRayTracingPipelineCreateInfoNV_host_to_win32(const VkRayTracingPipelineCreateInfoNV *in, const VkRayTracingPipelineCreateInfoNV32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;


    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
        {
            VkPipelineCreationFeedbackCreateInfo32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO);
            const VkPipelineCreationFeedbackCreateInfo *in_ext = (const VkPipelineCreationFeedbackCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO;
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineCreationFeedback, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineCreationFeedback), 1);
            convert_VkPipelineCreationFeedback_array_host_to_win32(in_ext->pPipelineStageCreationFeedbacks, (VkPipelineCreationFeedback32 *)UlongToPtr(out_ext->pPipelineStageCreationFeedbacks), in_ext->pipelineStageCreationFeedbackCount);
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkRayTracingPipelineCreateInfoNV_array_host_to_win32(const VkRayTracingPipelineCreateInfoNV *in, const VkRayTracingPipelineCreateInfoNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkRayTracingPipelineCreateInfoNV_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkSubpassDescription_win32_to_host(const VkSubpassDescription32 *in, VkSubpassDescription *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->inputAttachmentCount = in->inputAttachmentCount;
    out->pInputAttachments = UlongToPtr(in->pInputAttachments);
    out->colorAttachmentCount = in->colorAttachmentCount;
    out->pColorAttachments = UlongToPtr(in->pColorAttachments);
    out->pResolveAttachments = UlongToPtr(in->pResolveAttachments);
    out->pDepthStencilAttachment = UlongToPtr(in->pDepthStencilAttachment);
    out->preserveAttachmentCount = in->preserveAttachmentCount;
    out->pPreserveAttachments = UlongToPtr(in->pPreserveAttachments);
}

static const VkSubpassDescription *convert_VkSubpassDescription_array_win32_to_host(struct conversion_context *ctx, const VkSubpassDescription32 *in, uint32_t count)
{
    VkSubpassDescription *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubpassDescription_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkRenderPassCreateInfo_win32_to_host(struct conversion_context *ctx, const VkRenderPassCreateInfo32 *in, VkRenderPassCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->attachmentCount = in->attachmentCount;
    out->pAttachments = UlongToPtr(in->pAttachments);
    out->subpassCount = in->subpassCount;
    out->pSubpasses = convert_VkSubpassDescription_array_win32_to_host(ctx, (const VkSubpassDescription32 *)UlongToPtr(in->pSubpasses), in->subpassCount);
    out->dependencyCount = in->dependencyCount;
    out->pDependencies = UlongToPtr(in->pDependencies);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
            VkRenderPassFragmentDensityMapCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassFragmentDensityMapCreateInfoEXT32 *in_ext = (const VkRenderPassFragmentDensityMapCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapAttachment = in_ext->fragmentDensityMapAttachment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {
            VkRenderPassInputAttachmentAspectCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassInputAttachmentAspectCreateInfo32 *in_ext = (const VkRenderPassInputAttachmentAspectCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->aspectReferenceCount = in_ext->aspectReferenceCount;
            out_ext->pAspectReferences = UlongToPtr(in_ext->pAspectReferences);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {
            VkRenderPassMultiviewCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassMultiviewCreateInfo32 *in_ext = (const VkRenderPassMultiviewCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->subpassCount = in_ext->subpassCount;
            out_ext->pViewMasks = UlongToPtr(in_ext->pViewMasks);
            out_ext->dependencyCount = in_ext->dependencyCount;
            out_ext->pViewOffsets = UlongToPtr(in_ext->pViewOffsets);
            out_ext->correlationMaskCount = in_ext->correlationMaskCount;
            out_ext->pCorrelationMasks = UlongToPtr(in_ext->pCorrelationMasks);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM:
        {
            VkRenderPassTileShadingCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassTileShadingCreateInfoQCOM32 *in_ext = (const VkRenderPassTileShadingCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->tileApronSize = in_ext->tileApronSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM:
        {
            VkTileMemorySizeInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTileMemorySizeInfoQCOM32 *in_ext = (const VkTileMemorySizeInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->size = in_ext->size;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkAttachmentDescription2_win32_to_host(struct conversion_context *ctx, const VkAttachmentDescription232 *in, VkAttachmentDescription2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->format = in->format;
    out->samples = in->samples;
    out->loadOp = in->loadOp;
    out->storeOp = in->storeOp;
    out->stencilLoadOp = in->stencilLoadOp;
    out->stencilStoreOp = in->stencilStoreOp;
    out->initialLayout = in->initialLayout;
    out->finalLayout = in->finalLayout;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {
            VkAttachmentDescriptionStencilLayout *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentDescriptionStencilLayout32 *in_ext = (const VkAttachmentDescriptionStencilLayout32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT;
            out_ext->pNext = NULL;
            out_ext->stencilInitialLayout = in_ext->stencilInitialLayout;
            out_ext->stencilFinalLayout = in_ext->stencilFinalLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkAttachmentDescription2 *convert_VkAttachmentDescription2_array_win32_to_host(struct conversion_context *ctx, const VkAttachmentDescription232 *in, uint32_t count)
{
    VkAttachmentDescription2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAttachmentDescription2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkAttachmentReference2_win32_to_host(struct conversion_context *ctx, const VkAttachmentReference232 *in, VkAttachmentReference2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->attachment = in->attachment;
    out->layout = in->layout;
    out->aspectMask = in->aspectMask;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {
            VkAttachmentReferenceStencilLayout *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkAttachmentReferenceStencilLayout32 *in_ext = (const VkAttachmentReferenceStencilLayout32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT;
            out_ext->pNext = NULL;
            out_ext->stencilLayout = in_ext->stencilLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkAttachmentReference2 *convert_VkAttachmentReference2_array_win32_to_host(struct conversion_context *ctx, const VkAttachmentReference232 *in, uint32_t count)
{
    VkAttachmentReference2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkAttachmentReference2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkSubpassDescription2_win32_to_host(struct conversion_context *ctx, const VkSubpassDescription232 *in, VkSubpassDescription2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->viewMask = in->viewMask;
    out->inputAttachmentCount = in->inputAttachmentCount;
    out->pInputAttachments = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in->pInputAttachments), in->inputAttachmentCount);
    out->colorAttachmentCount = in->colorAttachmentCount;
    out->pColorAttachments = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in->pColorAttachments), in->colorAttachmentCount);
    out->pResolveAttachments = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in->pResolveAttachments), in->colorAttachmentCount);
    out->pDepthStencilAttachment = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in->pDepthStencilAttachment), 1);
    out->preserveAttachmentCount = in->preserveAttachmentCount;
    out->pPreserveAttachments = UlongToPtr(in->pPreserveAttachments);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {
            VkFragmentShadingRateAttachmentInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFragmentShadingRateAttachmentInfoKHR32 *in_ext = (const VkFragmentShadingRateAttachmentInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pFragmentShadingRateAttachment = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in_ext->pFragmentShadingRateAttachment), 1);
            out_ext->shadingRateAttachmentTexelSize = in_ext->shadingRateAttachmentTexelSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
        {
            VkMultisampledRenderToSingleSampledInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMultisampledRenderToSingleSampledInfoEXT32 *in_ext = (const VkMultisampledRenderToSingleSampledInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->multisampledRenderToSingleSampledEnable = in_ext->multisampledRenderToSingleSampledEnable;
            out_ext->rasterizationSamples = in_ext->rasterizationSamples;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
        {
            VkRenderPassCreationControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassCreationControlEXT32 *in_ext = (const VkRenderPassCreationControlEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->disallowMerging = in_ext->disallowMerging;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
        {
            VkRenderPassSubpassFeedbackCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassSubpassFeedbackCreateInfoEXT32 *in_ext = (const VkRenderPassSubpassFeedbackCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->pSubpassFeedback = UlongToPtr(in_ext->pSubpassFeedback);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {
            VkSubpassDescriptionDepthStencilResolve *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSubpassDescriptionDepthStencilResolve32 *in_ext = (const VkSubpassDescriptionDepthStencilResolve32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE;
            out_ext->pNext = NULL;
            out_ext->depthResolveMode = in_ext->depthResolveMode;
            out_ext->stencilResolveMode = in_ext->stencilResolveMode;
            out_ext->pDepthStencilResolveAttachment = convert_VkAttachmentReference2_array_win32_to_host(ctx, (const VkAttachmentReference232 *)UlongToPtr(in_ext->pDepthStencilResolveAttachment), 1);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkSubpassDescription2 *convert_VkSubpassDescription2_array_win32_to_host(struct conversion_context *ctx, const VkSubpassDescription232 *in, uint32_t count)
{
    VkSubpassDescription2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubpassDescription2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkSubpassDependency2_win32_to_host(struct conversion_context *ctx, const VkSubpassDependency232 *in, VkSubpassDependency2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSubpass = in->srcSubpass;
    out->dstSubpass = in->dstSubpass;
    out->srcStageMask = in->srcStageMask;
    out->dstStageMask = in->dstStageMask;
    out->srcAccessMask = in->srcAccessMask;
    out->dstAccessMask = in->dstAccessMask;
    out->dependencyFlags = in->dependencyFlags;
    out->viewOffset = in->viewOffset;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2:
        {
            VkMemoryBarrier2 *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryBarrier232 *in_ext = (const VkMemoryBarrier232 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_2;
            out_ext->pNext = NULL;
            out_ext->srcStageMask = in_ext->srcStageMask;
            out_ext->srcAccessMask = in_ext->srcAccessMask;
            out_ext->dstStageMask = in_ext->dstStageMask;
            out_ext->dstAccessMask = in_ext->dstAccessMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR:
        {
            VkMemoryBarrierAccessFlags3KHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkMemoryBarrierAccessFlags3KHR32 *in_ext = (const VkMemoryBarrierAccessFlags3KHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR;
            out_ext->pNext = NULL;
            out_ext->srcAccessMask3 = in_ext->srcAccessMask3;
            out_ext->dstAccessMask3 = in_ext->dstAccessMask3;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkSubpassDependency2 *convert_VkSubpassDependency2_array_win32_to_host(struct conversion_context *ctx, const VkSubpassDependency232 *in, uint32_t count)
{
    VkSubpassDependency2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubpassDependency2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkRenderPassCreateInfo2_win32_to_host(struct conversion_context *ctx, const VkRenderPassCreateInfo232 *in, VkRenderPassCreateInfo2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->attachmentCount = in->attachmentCount;
    out->pAttachments = convert_VkAttachmentDescription2_array_win32_to_host(ctx, (const VkAttachmentDescription232 *)UlongToPtr(in->pAttachments), in->attachmentCount);
    out->subpassCount = in->subpassCount;
    out->pSubpasses = convert_VkSubpassDescription2_array_win32_to_host(ctx, (const VkSubpassDescription232 *)UlongToPtr(in->pSubpasses), in->subpassCount);
    out->dependencyCount = in->dependencyCount;
    out->pDependencies = convert_VkSubpassDependency2_array_win32_to_host(ctx, (const VkSubpassDependency232 *)UlongToPtr(in->pDependencies), in->dependencyCount);
    out->correlatedViewMaskCount = in->correlatedViewMaskCount;
    out->pCorrelatedViewMasks = UlongToPtr(in->pCorrelatedViewMasks);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
        {
            VkRenderPassCreationControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassCreationControlEXT32 *in_ext = (const VkRenderPassCreationControlEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->disallowMerging = in_ext->disallowMerging;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {
            VkRenderPassCreationFeedbackCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassCreationFeedbackCreateInfoEXT32 *in_ext = (const VkRenderPassCreationFeedbackCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->pRenderPassFeedback = UlongToPtr(in_ext->pRenderPassFeedback);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {
            VkRenderPassFragmentDensityMapCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassFragmentDensityMapCreateInfoEXT32 *in_ext = (const VkRenderPassFragmentDensityMapCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapAttachment = in_ext->fragmentDensityMapAttachment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM:
        {
            VkRenderPassTileShadingCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassTileShadingCreateInfoQCOM32 *in_ext = (const VkRenderPassTileShadingCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->tileApronSize = in_ext->tileApronSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM:
        {
            VkTileMemorySizeInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTileMemorySizeInfoQCOM32 *in_ext = (const VkTileMemorySizeInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->size = in_ext->size;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkSamplerCreateInfo_win32_to_host(struct conversion_context *ctx, const VkSamplerCreateInfo32 *in, VkSamplerCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->magFilter = in->magFilter;
    out->minFilter = in->minFilter;
    out->mipmapMode = in->mipmapMode;
    out->addressModeU = in->addressModeU;
    out->addressModeV = in->addressModeV;
    out->addressModeW = in->addressModeW;
    out->mipLodBias = in->mipLodBias;
    out->anisotropyEnable = in->anisotropyEnable;
    out->maxAnisotropy = in->maxAnisotropy;
    out->compareEnable = in->compareEnable;
    out->compareOp = in->compareOp;
    out->minLod = in->minLod;
    out->maxLod = in->maxLod;
    out->borderColor = in->borderColor;
    out->unnormalizedCoordinates = in->unnormalizedCoordinates;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
        {
            VkSamplerBlockMatchWindowCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerBlockMatchWindowCreateInfoQCOM32 *in_ext = (const VkSamplerBlockMatchWindowCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->windowExtent = in_ext->windowExtent;
            out_ext->windowCompareMode = in_ext->windowCompareMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
        {
            VkSamplerBorderColorComponentMappingCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerBorderColorComponentMappingCreateInfoEXT32 *in_ext = (const VkSamplerBorderColorComponentMappingCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->components = in_ext->components;
            out_ext->srgb = in_ext->srgb;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
        {
            VkSamplerCubicWeightsCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerCubicWeightsCreateInfoQCOM32 *in_ext = (const VkSamplerCubicWeightsCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->cubicWeights = in_ext->cubicWeights;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {
            VkSamplerCustomBorderColorCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerCustomBorderColorCreateInfoEXT32 *in_ext = (const VkSamplerCustomBorderColorCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->customBorderColor = in_ext->customBorderColor;
            out_ext->format = in_ext->format;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {
            VkSamplerReductionModeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerReductionModeCreateInfo32 *in_ext = (const VkSamplerReductionModeCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->reductionMode = in_ext->reductionMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {
            VkSamplerYcbcrConversionInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerYcbcrConversionInfo32 *in_ext = (const VkSamplerYcbcrConversionInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
            out_ext->pNext = NULL;
            out_ext->conversion = in_ext->conversion;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkSamplerYcbcrConversionCreateInfo_win32_to_host(struct conversion_context *ctx, const VkSamplerYcbcrConversionCreateInfo32 *in, VkSamplerYcbcrConversionCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->format = in->format;
    out->ycbcrModel = in->ycbcrModel;
    out->ycbcrRange = in->ycbcrRange;
    out->components = in->components;
    out->xChromaOffset = in->xChromaOffset;
    out->yChromaOffset = in->yChromaOffset;
    out->chromaFilter = in->chromaFilter;
    out->forceExplicitReconstruction = in->forceExplicitReconstruction;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM:
        {
            VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM32 *in_ext = (const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM;
            out_ext->pNext = NULL;
            out_ext->enableYDegamma = in_ext->enableYDegamma;
            out_ext->enableCbCrDegamma = in_ext->enableCbCrDegamma;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

#ifdef _WIN64
static void convert_VkSemaphoreCreateInfo_win64_to_host(struct conversion_context *ctx, const VkSemaphoreCreateInfo *in, VkSemaphoreCreateInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            VkExportSemaphoreCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportSemaphoreCreateInfo *in_ext = (const VkExportSemaphoreCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            VkExportSemaphoreWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportSemaphoreWin32HandleInfoKHR *in_ext = (const VkExportSemaphoreWin32HandleInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pAttributes = in_ext->pAttributes;
            out_ext->dwAccess = in_ext->dwAccess;
            out_ext->name = in_ext->name;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
        {
            VkQueryLowLatencySupportNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkQueryLowLatencySupportNV *in_ext = (const VkQueryLowLatencySupportNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV;
            out_ext->pNext = NULL;
            out_ext->pQueriedLowLatencyData = in_ext->pQueriedLowLatencyData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            VkSemaphoreTypeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSemaphoreTypeCreateInfo *in_ext = (const VkSemaphoreTypeCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->semaphoreType = in_ext->semaphoreType;
            out_ext->initialValue = in_ext->initialValue;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

static void convert_VkSemaphoreCreateInfo_win32_to_host(struct conversion_context *ctx, const VkSemaphoreCreateInfo32 *in, VkSemaphoreCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {
            VkExportSemaphoreCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportSemaphoreCreateInfo32 *in_ext = (const VkExportSemaphoreCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {
            VkExportSemaphoreWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExportSemaphoreWin32HandleInfoKHR32 *in_ext = (const VkExportSemaphoreWin32HandleInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
            out_ext->dwAccess = in_ext->dwAccess;
            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
        {
            VkQueryLowLatencySupportNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkQueryLowLatencySupportNV32 *in_ext = (const VkQueryLowLatencySupportNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV;
            out_ext->pNext = NULL;
            out_ext->pQueriedLowLatencyData = UlongToPtr(in_ext->pQueriedLowLatencyData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            VkSemaphoreTypeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSemaphoreTypeCreateInfo32 *in_ext = (const VkSemaphoreTypeCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->semaphoreType = in_ext->semaphoreType;
            out_ext->initialValue = in_ext->initialValue;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkShaderModuleCreateInfo_win32_to_host(struct conversion_context *ctx, const VkShaderModuleCreateInfo32 *in, VkShaderModuleCreateInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->codeSize = in->codeSize;
    out->pCode = UlongToPtr(in->pCode);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {
            VkShaderModuleValidationCacheCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkShaderModuleValidationCacheCreateInfoEXT32 *in_ext = (const VkShaderModuleValidationCacheCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->validationCache = in_ext->validationCache;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            VkValidationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkValidationFeaturesEXT32 *in_ext = (const VkValidationFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->enabledValidationFeatureCount = in_ext->enabledValidationFeatureCount;
            out_ext->pEnabledValidationFeatures = UlongToPtr(in_ext->pEnabledValidationFeatures);
            out_ext->disabledValidationFeatureCount = in_ext->disabledValidationFeatureCount;
            out_ext->pDisabledValidationFeatures = UlongToPtr(in_ext->pDisabledValidationFeatures);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkShaderCreateInfoEXT_win32_to_host(struct conversion_context *ctx, const VkShaderCreateInfoEXT32 *in, VkShaderCreateInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->stage = in->stage;
    out->nextStage = in->nextStage;
    out->codeType = in->codeType;
    out->codeSize = in->codeSize;
    out->pCode = UlongToPtr(in->pCode);
    out->pName = UlongToPtr(in->pName);
    out->setLayoutCount = in->setLayoutCount;
    out->pSetLayouts = UlongToPtr(in->pSetLayouts);
    out->pushConstantRangeCount = in->pushConstantRangeCount;
    out->pPushConstantRanges = UlongToPtr(in->pPushConstantRanges);
    out->pSpecializationInfo = convert_VkSpecializationInfo_array_win32_to_host(ctx, (const VkSpecializationInfo32 *)UlongToPtr(in->pSpecializationInfo), 1);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
        {
            VkPipelineShaderStageRequiredSubgroupSizeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 *in_ext = (const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->requiredSubgroupSize = in_ext->requiredSubgroupSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {
            VkValidationFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkValidationFeaturesEXT32 *in_ext = (const VkValidationFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->enabledValidationFeatureCount = in_ext->enabledValidationFeatureCount;
            out_ext->pEnabledValidationFeatures = UlongToPtr(in_ext->pEnabledValidationFeatures);
            out_ext->disabledValidationFeatureCount = in_ext->disabledValidationFeatureCount;
            out_ext->pDisabledValidationFeatures = UlongToPtr(in_ext->pDisabledValidationFeatures);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkShaderCreateInfoEXT *convert_VkShaderCreateInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkShaderCreateInfoEXT32 *in, uint32_t count)
{
    VkShaderCreateInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkShaderCreateInfoEXT_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkSwapchainCreateInfoKHR_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSwapchainCreateInfoKHR32 *in, VkSwapchainCreateInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->surface = in->surface;
    out->minImageCount = in->minImageCount;
    out->imageFormat = in->imageFormat;
    out->imageColorSpace = in->imageColorSpace;
    out->imageExtent = in->imageExtent;
    out->imageArrayLayers = in->imageArrayLayers;
    out->imageUsage = in->imageUsage;
    out->imageSharingMode = in->imageSharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = UlongToPtr(in->pQueueFamilyIndices);
    out->preTransform = in->preTransform;
    out->compositeAlpha = in->compositeAlpha;
    out->presentMode = in->presentMode;
    out->clipped = in->clipped;
    out->oldSwapchain = in->oldSwapchain;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {
            VkDeviceGroupSwapchainCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupSwapchainCreateInfoKHR32 *in_ext = (const VkDeviceGroupSwapchainCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->modes = in_ext->modes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageCompressionControlEXT32 *in_ext = (const VkImageCompressionControlEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
            out_ext->pFixedRateFlags = UlongToPtr(in_ext->pFixedRateFlags);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageFormatListCreateInfo32 *in_ext = (const VkImageFormatListCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewFormatCount = in_ext->viewFormatCount;
            out_ext->pViewFormats = UlongToPtr(in_ext->pViewFormats);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV:
        {
            VkSwapchainLatencyCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainLatencyCreateInfoNV32 *in_ext = (const VkSwapchainLatencyCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->latencyModeEnable = in_ext->latencyModeEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV:
        {
            VkSwapchainPresentBarrierCreateInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentBarrierCreateInfoNV32 *in_ext = (const VkSwapchainPresentBarrierCreateInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->presentBarrierEnable = in_ext->presentBarrierEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR:
        {
            VkSwapchainPresentModesCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentModesCreateInfoKHR32 *in_ext = (const VkSwapchainPresentModesCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->presentModeCount = in_ext->presentModeCount;
            out_ext->pPresentModes = UlongToPtr(in_ext->pPresentModes);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR:
        {
            VkSwapchainPresentScalingCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentScalingCreateInfoKHR32 *in_ext = (const VkSwapchainPresentScalingCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->scalingBehavior = in_ext->scalingBehavior;
            out_ext->presentGravityX = in_ext->presentGravityX;
            out_ext->presentGravityY = in_ext->presentGravityY;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkTensorDescriptionARM_win32_to_host(const VkTensorDescriptionARM32 *in, VkTensorDescriptionARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->tiling = in->tiling;
    out->format = in->format;
    out->dimensionCount = in->dimensionCount;
    out->pDimensions = UlongToPtr(in->pDimensions);
    out->pStrides = UlongToPtr(in->pStrides);
    out->usage = in->usage;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkTensorDescriptionARM *convert_VkTensorDescriptionARM_array_win32_to_host(struct conversion_context *ctx, const VkTensorDescriptionARM32 *in, uint32_t count)
{
    VkTensorDescriptionARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkTensorDescriptionARM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkTensorCreateInfoARM_win32_to_host(struct conversion_context *ctx, const VkTensorCreateInfoARM32 *in, VkTensorCreateInfoARM *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pDescription = convert_VkTensorDescriptionARM_array_win32_to_host(ctx, (const VkTensorDescriptionARM32 *)UlongToPtr(in->pDescription), 1);
    out->sharingMode = in->sharingMode;
    out->queueFamilyIndexCount = in->queueFamilyIndexCount;
    out->pQueueFamilyIndices = UlongToPtr(in->pQueueFamilyIndices);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM:
        {
            VkExternalMemoryTensorCreateInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkExternalMemoryTensorCreateInfoARM32 *in_ext = (const VkExternalMemoryTensorCreateInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->handleTypes = in_ext->handleTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkTensorViewCreateInfoARM_win32_to_host(struct conversion_context *ctx, const VkTensorViewCreateInfoARM32 *in, VkTensorViewCreateInfoARM *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->tensor = in->tensor;
    out->format = in->format;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT:
        {
            VkOpaqueCaptureDescriptorDataCreateInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *in_ext = (const VkOpaqueCaptureDescriptorDataCreateInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->opaqueCaptureDescriptorData = UlongToPtr(in_ext->opaqueCaptureDescriptorData);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkValidationCacheCreateInfoEXT_win32_to_host(const VkValidationCacheCreateInfoEXT32 *in, VkValidationCacheCreateInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->initialDataSize = in->initialDataSize;
    out->pInitialData = UlongToPtr(in->pInitialData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkVideoSessionCreateInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoSessionCreateInfoKHR32 *in, VkVideoSessionCreateInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->queueFamilyIndex = in->queueFamilyIndex;
    out->flags = in->flags;
    out->pVideoProfile = convert_VkVideoProfileInfoKHR_array_win32_to_host(ctx, (const VkVideoProfileInfoKHR32 *)UlongToPtr(in->pVideoProfile), 1);
    out->pictureFormat = in->pictureFormat;
    out->maxCodedExtent = in->maxCodedExtent;
    out->referencePictureFormat = in->referencePictureFormat;
    out->maxDpbSlots = in->maxDpbSlots;
    out->maxActiveReferencePictures = in->maxActiveReferencePictures;
    out->pStdHeaderVersion = UlongToPtr(in->pStdHeaderVersion);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR:
        {
            VkVideoEncodeAV1SessionCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeAV1SessionCreateInfoKHR32 *in_ext = (const VkVideoEncodeAV1SessionCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->useMaxLevel = in_ext->useMaxLevel;
            out_ext->maxLevel = in_ext->maxLevel;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR:
        {
            VkVideoEncodeH264SessionCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264SessionCreateInfoKHR32 *in_ext = (const VkVideoEncodeH264SessionCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->useMaxLevelIdc = in_ext->useMaxLevelIdc;
            out_ext->maxLevelIdc = in_ext->maxLevelIdc;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR:
        {
            VkVideoEncodeSessionIntraRefreshCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeSessionIntraRefreshCreateInfoKHR32 *in_ext = (const VkVideoEncodeSessionIntraRefreshCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->intraRefreshMode = in_ext->intraRefreshMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_StdVideoAV1SequenceHeader_win32_to_host(const StdVideoAV1SequenceHeader32 *in, StdVideoAV1SequenceHeader *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->seq_profile = in->seq_profile;
    out->frame_width_bits_minus_1 = in->frame_width_bits_minus_1;
    out->frame_height_bits_minus_1 = in->frame_height_bits_minus_1;
    out->max_frame_width_minus_1 = in->max_frame_width_minus_1;
    out->max_frame_height_minus_1 = in->max_frame_height_minus_1;
    out->delta_frame_id_length_minus_2 = in->delta_frame_id_length_minus_2;
    out->additional_frame_id_length_minus_1 = in->additional_frame_id_length_minus_1;
    out->order_hint_bits_minus_1 = in->order_hint_bits_minus_1;
    out->seq_force_integer_mv = in->seq_force_integer_mv;
    out->seq_force_screen_content_tools = in->seq_force_screen_content_tools;
    memcpy(out->reserved1, in->reserved1, 5 * sizeof(uint8_t));
    out->pColorConfig = UlongToPtr(in->pColorConfig);
    out->pTimingInfo = UlongToPtr(in->pTimingInfo);
}

static const StdVideoAV1SequenceHeader *convert_StdVideoAV1SequenceHeader_array_win32_to_host(struct conversion_context *ctx, const StdVideoAV1SequenceHeader32 *in, uint32_t count)
{
    StdVideoAV1SequenceHeader *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoAV1SequenceHeader_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_StdVideoH264SequenceParameterSetVui_win32_to_host(const StdVideoH264SequenceParameterSetVui32 *in, StdVideoH264SequenceParameterSetVui *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->aspect_ratio_idc = in->aspect_ratio_idc;
    out->sar_width = in->sar_width;
    out->sar_height = in->sar_height;
    out->video_format = in->video_format;
    out->colour_primaries = in->colour_primaries;
    out->transfer_characteristics = in->transfer_characteristics;
    out->matrix_coefficients = in->matrix_coefficients;
    out->num_units_in_tick = in->num_units_in_tick;
    out->time_scale = in->time_scale;
    out->max_num_reorder_frames = in->max_num_reorder_frames;
    out->max_dec_frame_buffering = in->max_dec_frame_buffering;
    out->chroma_sample_loc_type_top_field = in->chroma_sample_loc_type_top_field;
    out->chroma_sample_loc_type_bottom_field = in->chroma_sample_loc_type_bottom_field;
    out->reserved1 = in->reserved1;
    out->pHrdParameters = UlongToPtr(in->pHrdParameters);
}

static const StdVideoH264SequenceParameterSetVui *convert_StdVideoH264SequenceParameterSetVui_array_win32_to_host(struct conversion_context *ctx, const StdVideoH264SequenceParameterSetVui32 *in, uint32_t count)
{
    StdVideoH264SequenceParameterSetVui *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoH264SequenceParameterSetVui_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_StdVideoH264SequenceParameterSet_win32_to_host(struct conversion_context *ctx, const StdVideoH264SequenceParameterSet32 *in, StdVideoH264SequenceParameterSet *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->profile_idc = in->profile_idc;
    out->level_idc = in->level_idc;
    out->chroma_format_idc = in->chroma_format_idc;
    out->seq_parameter_set_id = in->seq_parameter_set_id;
    out->bit_depth_luma_minus8 = in->bit_depth_luma_minus8;
    out->bit_depth_chroma_minus8 = in->bit_depth_chroma_minus8;
    out->log2_max_frame_num_minus4 = in->log2_max_frame_num_minus4;
    out->pic_order_cnt_type = in->pic_order_cnt_type;
    out->offset_for_non_ref_pic = in->offset_for_non_ref_pic;
    out->offset_for_top_to_bottom_field = in->offset_for_top_to_bottom_field;
    out->log2_max_pic_order_cnt_lsb_minus4 = in->log2_max_pic_order_cnt_lsb_minus4;
    out->num_ref_frames_in_pic_order_cnt_cycle = in->num_ref_frames_in_pic_order_cnt_cycle;
    out->max_num_ref_frames = in->max_num_ref_frames;
    out->reserved1 = in->reserved1;
    out->pic_width_in_mbs_minus1 = in->pic_width_in_mbs_minus1;
    out->pic_height_in_map_units_minus1 = in->pic_height_in_map_units_minus1;
    out->frame_crop_left_offset = in->frame_crop_left_offset;
    out->frame_crop_right_offset = in->frame_crop_right_offset;
    out->frame_crop_top_offset = in->frame_crop_top_offset;
    out->frame_crop_bottom_offset = in->frame_crop_bottom_offset;
    out->reserved2 = in->reserved2;
    out->pOffsetForRefFrame = UlongToPtr(in->pOffsetForRefFrame);
    out->pScalingLists = UlongToPtr(in->pScalingLists);
    out->pSequenceParameterSetVui = convert_StdVideoH264SequenceParameterSetVui_array_win32_to_host(ctx, (const StdVideoH264SequenceParameterSetVui32 *)UlongToPtr(in->pSequenceParameterSetVui), 1);
}

static const StdVideoH264SequenceParameterSet *convert_StdVideoH264SequenceParameterSet_array_win32_to_host(struct conversion_context *ctx, const StdVideoH264SequenceParameterSet32 *in, uint32_t count)
{
    StdVideoH264SequenceParameterSet *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoH264SequenceParameterSet_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_StdVideoH264PictureParameterSet_win32_to_host(const StdVideoH264PictureParameterSet32 *in, StdVideoH264PictureParameterSet *out)
{
    if (!in) return;

    out->flags = in->flags;
    out->seq_parameter_set_id = in->seq_parameter_set_id;
    out->pic_parameter_set_id = in->pic_parameter_set_id;
    out->num_ref_idx_l0_default_active_minus1 = in->num_ref_idx_l0_default_active_minus1;
    out->num_ref_idx_l1_default_active_minus1 = in->num_ref_idx_l1_default_active_minus1;
    out->weighted_bipred_idc = in->weighted_bipred_idc;
    out->pic_init_qp_minus26 = in->pic_init_qp_minus26;
    out->pic_init_qs_minus26 = in->pic_init_qs_minus26;
    out->chroma_qp_index_offset = in->chroma_qp_index_offset;
    out->second_chroma_qp_index_offset = in->second_chroma_qp_index_offset;
    out->pScalingLists = UlongToPtr(in->pScalingLists);
}

static const StdVideoH264PictureParameterSet *convert_StdVideoH264PictureParameterSet_array_win32_to_host(struct conversion_context *ctx, const StdVideoH264PictureParameterSet32 *in, uint32_t count)
{
    StdVideoH264PictureParameterSet *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_StdVideoH264PictureParameterSet_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoDecodeH264SessionParametersAddInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoDecodeH264SessionParametersAddInfoKHR32 *in, VkVideoDecodeH264SessionParametersAddInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->stdSPSCount = in->stdSPSCount;
    out->pStdSPSs = convert_StdVideoH264SequenceParameterSet_array_win32_to_host(ctx, (const StdVideoH264SequenceParameterSet32 *)UlongToPtr(in->pStdSPSs), in->stdSPSCount);
    out->stdPPSCount = in->stdPPSCount;
    out->pStdPPSs = convert_StdVideoH264PictureParameterSet_array_win32_to_host(ctx, (const StdVideoH264PictureParameterSet32 *)UlongToPtr(in->pStdPPSs), in->stdPPSCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkVideoDecodeH264SessionParametersAddInfoKHR *convert_VkVideoDecodeH264SessionParametersAddInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkVideoDecodeH264SessionParametersAddInfoKHR32 *in, uint32_t count)
{
    VkVideoDecodeH264SessionParametersAddInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVideoDecodeH264SessionParametersAddInfoKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoEncodeH264SessionParametersAddInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoEncodeH264SessionParametersAddInfoKHR32 *in, VkVideoEncodeH264SessionParametersAddInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->stdSPSCount = in->stdSPSCount;
    out->pStdSPSs = convert_StdVideoH264SequenceParameterSet_array_win32_to_host(ctx, (const StdVideoH264SequenceParameterSet32 *)UlongToPtr(in->pStdSPSs), in->stdSPSCount);
    out->stdPPSCount = in->stdPPSCount;
    out->pStdPPSs = convert_StdVideoH264PictureParameterSet_array_win32_to_host(ctx, (const StdVideoH264PictureParameterSet32 *)UlongToPtr(in->pStdPPSs), in->stdPPSCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkVideoEncodeH264SessionParametersAddInfoKHR *convert_VkVideoEncodeH264SessionParametersAddInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkVideoEncodeH264SessionParametersAddInfoKHR32 *in, uint32_t count)
{
    VkVideoEncodeH264SessionParametersAddInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVideoEncodeH264SessionParametersAddInfoKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoSessionParametersCreateInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoSessionParametersCreateInfoKHR32 *in, VkVideoSessionParametersCreateInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->videoSessionParametersTemplate = in->videoSessionParametersTemplate;
    out->videoSession = in->videoSession;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
            VkVideoDecodeAV1SessionParametersCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeAV1SessionParametersCreateInfoKHR32 *in_ext = (const VkVideoDecodeAV1SessionParametersCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pStdSequenceHeader = convert_StdVideoAV1SequenceHeader_array_win32_to_host(ctx, (const StdVideoAV1SequenceHeader32 *)UlongToPtr(in_ext->pStdSequenceHeader), 1);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
            VkVideoDecodeH264SessionParametersCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeH264SessionParametersCreateInfoKHR32 *in_ext = (const VkVideoDecodeH264SessionParametersCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->maxStdSPSCount = in_ext->maxStdSPSCount;
            out_ext->maxStdPPSCount = in_ext->maxStdPPSCount;
            out_ext->pParametersAddInfo = convert_VkVideoDecodeH264SessionParametersAddInfoKHR_array_win32_to_host(ctx, (const VkVideoDecodeH264SessionParametersAddInfoKHR32 *)UlongToPtr(in_ext->pParametersAddInfo), 1);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
            VkVideoEncodeAV1SessionParametersCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeAV1SessionParametersCreateInfoKHR32 *in_ext = (const VkVideoEncodeAV1SessionParametersCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->pStdSequenceHeader = convert_StdVideoAV1SequenceHeader_array_win32_to_host(ctx, (const StdVideoAV1SequenceHeader32 *)UlongToPtr(in_ext->pStdSequenceHeader), 1);
            out_ext->pStdDecoderModelInfo = UlongToPtr(in_ext->pStdDecoderModelInfo);
            out_ext->stdOperatingPointCount = in_ext->stdOperatingPointCount;
            out_ext->pStdOperatingPoints = UlongToPtr(in_ext->pStdOperatingPoints);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
            VkVideoEncodeH264SessionParametersCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264SessionParametersCreateInfoKHR32 *in_ext = (const VkVideoEncodeH264SessionParametersCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->maxStdSPSCount = in_ext->maxStdSPSCount;
            out_ext->maxStdPPSCount = in_ext->maxStdPPSCount;
            out_ext->pParametersAddInfo = convert_VkVideoEncodeH264SessionParametersAddInfoKHR_array_win32_to_host(ctx, (const VkVideoEncodeH264SessionParametersAddInfoKHR32 *)UlongToPtr(in_ext->pParametersAddInfo), 1);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR:
        {
            VkVideoEncodeQualityLevelInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeQualityLevelInfoKHR32 *in_ext = (const VkVideoEncodeQualityLevelInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->qualityLevel = in_ext->qualityLevel;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {
            VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR32 *in_ext = (const VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->quantizationMapTexelSize = in_ext->quantizationMapTexelSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkWin32SurfaceCreateInfoKHR_win32_to_host(const VkWin32SurfaceCreateInfoKHR32 *in, VkWin32SurfaceCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->hinstance = (HINSTANCE)UlongToPtr(in->hinstance);
    out->hwnd = (HWND)UlongToPtr(in->hwnd);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkDebugMarkerObjectNameInfoEXT_win64_to_host(const VkDebugMarkerObjectNameInfoEXT *in, VkDebugMarkerObjectNameInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->objectType = in->objectType;
    out->object = wine_vk_unwrap_handle(in->objectType, in->object);
    out->pObjectName = in->pObjectName;
}
#endif /* _WIN64 */

static void convert_VkDebugMarkerObjectNameInfoEXT_win32_to_host(const VkDebugMarkerObjectNameInfoEXT32 *in, VkDebugMarkerObjectNameInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->objectType = in->objectType;
    out->object = wine_vk_unwrap_handle(in->objectType, in->object);
    out->pObjectName = UlongToPtr(in->pObjectName);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkDebugMarkerObjectTagInfoEXT_win64_to_host(const VkDebugMarkerObjectTagInfoEXT *in, VkDebugMarkerObjectTagInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->objectType = in->objectType;
    out->object = wine_vk_unwrap_handle(in->objectType, in->object);
    out->tagName = in->tagName;
    out->tagSize = in->tagSize;
    out->pTag = in->pTag;
}
#endif /* _WIN64 */

static void convert_VkDebugMarkerObjectTagInfoEXT_win32_to_host(const VkDebugMarkerObjectTagInfoEXT32 *in, VkDebugMarkerObjectTagInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->objectType = in->objectType;
    out->object = wine_vk_unwrap_handle(in->objectType, in->object);
    out->tagName = in->tagName;
    out->tagSize = in->tagSize;
    out->pTag = UlongToPtr(in->pTag);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPhysicalDeviceGroupProperties_win32_to_unwrapped_host(const VkPhysicalDeviceGroupProperties32 *in, VkPhysicalDeviceGroupProperties *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkPhysicalDeviceGroupProperties *convert_VkPhysicalDeviceGroupProperties_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkPhysicalDeviceGroupProperties32 *in, uint32_t count)
{
    VkPhysicalDeviceGroupProperties *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceGroupProperties_win32_to_unwrapped_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPhysicalDevice_array_unwrapped_host_to_win32(const VkPhysicalDevice *in, PTR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        out[i] = PtrToUlong(in[i]);
    }
}

static void convert_VkPhysicalDeviceGroupProperties_unwrapped_host_to_win32(const VkPhysicalDeviceGroupProperties *in, VkPhysicalDeviceGroupProperties32 *out)
{
    if (!in) return;

    out->physicalDeviceCount = in->physicalDeviceCount;
    convert_VkPhysicalDevice_array_unwrapped_host_to_win32(in->physicalDevices, out->physicalDevices, VK_MAX_DEVICE_GROUP_SIZE);
    out->subsetAllocation = in->subsetAllocation;
}

static void convert_VkPhysicalDeviceGroupProperties_array_unwrapped_host_to_win32(const VkPhysicalDeviceGroupProperties *in, VkPhysicalDeviceGroupProperties32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceGroupProperties_unwrapped_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPerformanceCounterKHR_win32_to_host(const VkPerformanceCounterKHR32 *in, VkPerformanceCounterKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkPerformanceCounterKHR *convert_VkPerformanceCounterKHR_array_win32_to_host(struct conversion_context *ctx, const VkPerformanceCounterKHR32 *in, uint32_t count)
{
    VkPerformanceCounterKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPerformanceCounterKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPerformanceCounterDescriptionKHR_win32_to_host(const VkPerformanceCounterDescriptionKHR32 *in, VkPerformanceCounterDescriptionKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkPerformanceCounterDescriptionKHR *convert_VkPerformanceCounterDescriptionKHR_array_win32_to_host(struct conversion_context *ctx, const VkPerformanceCounterDescriptionKHR32 *in, uint32_t count)
{
    VkPerformanceCounterDescriptionKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPerformanceCounterDescriptionKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPerformanceCounterKHR_host_to_win32(const VkPerformanceCounterKHR *in, VkPerformanceCounterKHR32 *out)
{
    if (!in) return;

    out->unit = in->unit;
    out->scope = in->scope;
    out->storage = in->storage;
    memcpy(out->uuid, in->uuid, VK_UUID_SIZE * sizeof(uint8_t));
}

static void convert_VkPerformanceCounterKHR_array_host_to_win32(const VkPerformanceCounterKHR *in, VkPerformanceCounterKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPerformanceCounterKHR_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPerformanceCounterDescriptionKHR_host_to_win32(const VkPerformanceCounterDescriptionKHR *in, VkPerformanceCounterDescriptionKHR32 *out)
{
    if (!in) return;

    out->flags = in->flags;
    memcpy(out->name, in->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->category, in->category, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
}

static void convert_VkPerformanceCounterDescriptionKHR_array_host_to_win32(const VkPerformanceCounterDescriptionKHR *in, VkPerformanceCounterDescriptionKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPerformanceCounterDescriptionKHR_host_to_win32(&in[i], &out[i]);
    }
}

#ifdef _WIN64
static void convert_VkMappedMemoryRange_win64_to_host(const VkMappedMemoryRange *in, VkMappedMemoryRange *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->offset = in->offset;
    out->size = in->size;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkMappedMemoryRange *convert_VkMappedMemoryRange_array_win64_to_host(struct conversion_context *ctx, const VkMappedMemoryRange *in, uint32_t count)
{
    VkMappedMemoryRange *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMappedMemoryRange_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkMappedMemoryRange_win32_to_host(const VkMappedMemoryRange32 *in, VkMappedMemoryRange *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->offset = in->offset;
    out->size = in->size;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkMappedMemoryRange *convert_VkMappedMemoryRange_array_win32_to_host(struct conversion_context *ctx, const VkMappedMemoryRange32 *in, uint32_t count)
{
    VkMappedMemoryRange *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkMappedMemoryRange_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkAccelerationStructureBuildSizesInfoKHR_win32_to_host(const VkAccelerationStructureBuildSizesInfoKHR32 *in, VkAccelerationStructureBuildSizesInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkAccelerationStructureBuildSizesInfoKHR_host_to_win32(const VkAccelerationStructureBuildSizesInfoKHR *in, VkAccelerationStructureBuildSizesInfoKHR32 *out)
{
    if (!in) return;

    out->accelerationStructureSize = in->accelerationStructureSize;
    out->updateScratchSize = in->updateScratchSize;
    out->buildScratchSize = in->buildScratchSize;
}

static void convert_VkAccelerationStructureDeviceAddressInfoKHR_win32_to_host(const VkAccelerationStructureDeviceAddressInfoKHR32 *in, VkAccelerationStructureDeviceAddressInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->accelerationStructure = in->accelerationStructure;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkAccelerationStructureMemoryRequirementsInfoNV_win32_to_host(const VkAccelerationStructureMemoryRequirementsInfoNV32 *in, VkAccelerationStructureMemoryRequirementsInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    out->accelerationStructure = in->accelerationStructure;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMemoryRequirements2KHR_win32_to_host(const VkMemoryRequirements2KHR32 *in, VkMemoryRequirements2KHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMemoryRequirements_host_to_win32(const VkMemoryRequirements *in, VkMemoryRequirements32 *out)
{
    if (!in) return;

    out->size = in->size;
    out->alignment = in->alignment;
    out->memoryTypeBits = in->memoryTypeBits;
}

static void convert_VkMemoryRequirements2KHR_host_to_win32(const VkMemoryRequirements2KHR *in, VkMemoryRequirements2KHR32 *out)
{
    if (!in) return;

    convert_VkMemoryRequirements_host_to_win32(&in->memoryRequirements, &out->memoryRequirements);
}

static void convert_VkAccelerationStructureCaptureDescriptorDataInfoEXT_win32_to_host(const VkAccelerationStructureCaptureDescriptorDataInfoEXT32 *in, VkAccelerationStructureCaptureDescriptorDataInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->accelerationStructure = in->accelerationStructure;
    out->accelerationStructureNV = in->accelerationStructureNV;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkBufferDeviceAddressInfo_win32_to_host(const VkBufferDeviceAddressInfo32 *in, VkBufferDeviceAddressInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->buffer = in->buffer;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkBufferMemoryRequirementsInfo2_win32_to_host(const VkBufferMemoryRequirementsInfo232 *in, VkBufferMemoryRequirementsInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->buffer = in->buffer;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMemoryRequirements2_win32_to_host(struct conversion_context *ctx, const VkMemoryRequirements232 *in, VkMemoryRequirements2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            VkMemoryDedicatedRequirements *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM:
        {
            VkTileMemoryRequirementsQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTileMemoryRequirementsQCOM32 *in_ext = (const VkTileMemoryRequirementsQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM;
            out_ext->pNext = NULL;
            out_ext->size = in_ext->size;
            out_ext->alignment = in_ext->alignment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkMemoryRequirements2_host_to_win32(const VkMemoryRequirements2 *in, VkMemoryRequirements232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    convert_VkMemoryRequirements_host_to_win32(&in->memoryRequirements, &out->memoryRequirements);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {
            VkMemoryDedicatedRequirements32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS);
            const VkMemoryDedicatedRequirements *in_ext = (const VkMemoryDedicatedRequirements *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
            out_ext->prefersDedicatedAllocation = in_ext->prefersDedicatedAllocation;
            out_ext->requiresDedicatedAllocation = in_ext->requiresDedicatedAllocation;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM:
        {
            VkTileMemoryRequirementsQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM);
            const VkTileMemoryRequirementsQCOM *in_ext = (const VkTileMemoryRequirementsQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM;
            out_ext->size = in_ext->size;
            out_ext->alignment = in_ext->alignment;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkBufferCaptureDescriptorDataInfoEXT_win32_to_host(const VkBufferCaptureDescriptorDataInfoEXT32 *in, VkBufferCaptureDescriptorDataInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->buffer = in->buffer;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCalibratedTimestampInfoKHR_win32_to_host(const VkCalibratedTimestampInfoKHR32 *in, VkCalibratedTimestampInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->timeDomain = in->timeDomain;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkCalibratedTimestampInfoKHR *convert_VkCalibratedTimestampInfoKHR_array_win32_to_host(struct conversion_context *ctx, const VkCalibratedTimestampInfoKHR32 *in, uint32_t count)
{
    VkCalibratedTimestampInfoKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCalibratedTimestampInfoKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDataGraphPipelineInfoARM_win32_to_host(const VkDataGraphPipelineInfoARM32 *in, VkDataGraphPipelineInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->dataGraphPipeline = in->dataGraphPipeline;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDataGraphPipelinePropertyQueryResultARM_win32_to_host(const VkDataGraphPipelinePropertyQueryResultARM32 *in, VkDataGraphPipelinePropertyQueryResultARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->property = in->property;
    out->isText = in->isText;
    out->dataSize = in->dataSize;
    out->pData = UlongToPtr(in->pData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkDataGraphPipelinePropertyQueryResultARM *convert_VkDataGraphPipelinePropertyQueryResultARM_array_win32_to_host(struct conversion_context *ctx, const VkDataGraphPipelinePropertyQueryResultARM32 *in, uint32_t count)
{
    VkDataGraphPipelinePropertyQueryResultARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDataGraphPipelinePropertyQueryResultARM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDataGraphPipelinePropertyQueryResultARM_host_to_win32(const VkDataGraphPipelinePropertyQueryResultARM *in, VkDataGraphPipelinePropertyQueryResultARM32 *out)
{
    if (!in) return;

    out->property = in->property;
    out->isText = in->isText;
    out->dataSize = in->dataSize;
    out->pData = PtrToUlong(in->pData);
}

static void convert_VkDataGraphPipelinePropertyQueryResultARM_array_host_to_win32(const VkDataGraphPipelinePropertyQueryResultARM *in, VkDataGraphPipelinePropertyQueryResultARM32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkDataGraphPipelinePropertyQueryResultARM_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkDataGraphPipelineSessionBindPointRequirementsInfoARM_win32_to_host(const VkDataGraphPipelineSessionBindPointRequirementsInfoARM32 *in, VkDataGraphPipelineSessionBindPointRequirementsInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->session = in->session;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDataGraphPipelineSessionBindPointRequirementARM_win32_to_host(const VkDataGraphPipelineSessionBindPointRequirementARM32 *in, VkDataGraphPipelineSessionBindPointRequirementARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->bindPoint = in->bindPoint;
    out->bindPointType = in->bindPointType;
    out->numObjects = in->numObjects;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkDataGraphPipelineSessionBindPointRequirementARM *convert_VkDataGraphPipelineSessionBindPointRequirementARM_array_win32_to_host(struct conversion_context *ctx, const VkDataGraphPipelineSessionBindPointRequirementARM32 *in, uint32_t count)
{
    VkDataGraphPipelineSessionBindPointRequirementARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDataGraphPipelineSessionBindPointRequirementARM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDataGraphPipelineSessionBindPointRequirementARM_host_to_win32(const VkDataGraphPipelineSessionBindPointRequirementARM *in, VkDataGraphPipelineSessionBindPointRequirementARM32 *out)
{
    if (!in) return;

    out->bindPoint = in->bindPoint;
    out->bindPointType = in->bindPointType;
    out->numObjects = in->numObjects;
}

static void convert_VkDataGraphPipelineSessionBindPointRequirementARM_array_host_to_win32(const VkDataGraphPipelineSessionBindPointRequirementARM *in, VkDataGraphPipelineSessionBindPointRequirementARM32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkDataGraphPipelineSessionBindPointRequirementARM_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkDataGraphPipelineSessionMemoryRequirementsInfoARM_win32_to_host(const VkDataGraphPipelineSessionMemoryRequirementsInfoARM32 *in, VkDataGraphPipelineSessionMemoryRequirementsInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->session = in->session;
    out->bindPoint = in->bindPoint;
    out->objectIndex = in->objectIndex;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDescriptorAddressInfoEXT_win32_to_host(const VkDescriptorAddressInfoEXT32 *in, VkDescriptorAddressInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->address = in->address;
    out->range = in->range;
    out->format = in->format;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkDescriptorAddressInfoEXT *convert_VkDescriptorAddressInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkDescriptorAddressInfoEXT32 *in, uint32_t count)
{
    VkDescriptorAddressInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDescriptorAddressInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDescriptorDataEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorDataEXT32 *in, VkDescriptorDataEXT *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_DESCRIPTOR_TYPE_SAMPLER)
        out->pSampler = UlongToPtr(in->pSampler);
    if (selector == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER)
        out->pCombinedImageSampler = convert_VkDescriptorImageInfo_array_win32_to_host(ctx, (const VkDescriptorImageInfo32 *)UlongToPtr(in->pCombinedImageSampler), 1);
    if (selector == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT)
        out->pInputAttachmentImage = convert_VkDescriptorImageInfo_array_win32_to_host(ctx, (const VkDescriptorImageInfo32 *)UlongToPtr(in->pInputAttachmentImage), 1);
    if (selector == VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE)
        out->pSampledImage = convert_VkDescriptorImageInfo_array_win32_to_host(ctx, (const VkDescriptorImageInfo32 *)UlongToPtr(in->pSampledImage), 1);
    if (selector == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE)
        out->pStorageImage = convert_VkDescriptorImageInfo_array_win32_to_host(ctx, (const VkDescriptorImageInfo32 *)UlongToPtr(in->pStorageImage), 1);
    if (selector == VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER)
        out->pUniformTexelBuffer = convert_VkDescriptorAddressInfoEXT_array_win32_to_host(ctx, (const VkDescriptorAddressInfoEXT32 *)UlongToPtr(in->pUniformTexelBuffer), 1);
    if (selector == VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER)
        out->pStorageTexelBuffer = convert_VkDescriptorAddressInfoEXT_array_win32_to_host(ctx, (const VkDescriptorAddressInfoEXT32 *)UlongToPtr(in->pStorageTexelBuffer), 1);
    if (selector == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER)
        out->pUniformBuffer = convert_VkDescriptorAddressInfoEXT_array_win32_to_host(ctx, (const VkDescriptorAddressInfoEXT32 *)UlongToPtr(in->pUniformBuffer), 1);
    if (selector == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER)
        out->pStorageBuffer = convert_VkDescriptorAddressInfoEXT_array_win32_to_host(ctx, (const VkDescriptorAddressInfoEXT32 *)UlongToPtr(in->pStorageBuffer), 1);
    if (selector == VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR || selector == VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV)
        out->accelerationStructure = in->accelerationStructure;
}

static void convert_VkDescriptorGetInfoEXT_win32_to_host(struct conversion_context *ctx, const VkDescriptorGetInfoEXT32 *in, VkDescriptorGetInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->type = in->type;
    convert_VkDescriptorDataEXT_win32_to_host(ctx, &in->data, &out->data, in->type);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM:
        {
            VkDescriptorGetTensorInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDescriptorGetTensorInfoARM32 *in_ext = (const VkDescriptorGetTensorInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorView = in_ext->tensorView;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkDescriptorSetBindingReferenceVALVE_win32_to_host(const VkDescriptorSetBindingReferenceVALVE32 *in, VkDescriptorSetBindingReferenceVALVE *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->descriptorSetLayout = in->descriptorSetLayout;
    out->binding = in->binding;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDescriptorSetLayoutHostMappingInfoVALVE_win32_to_host(const VkDescriptorSetLayoutHostMappingInfoVALVE32 *in, VkDescriptorSetLayoutHostMappingInfoVALVE *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->descriptorOffset = in->descriptorOffset;
    out->descriptorSize = in->descriptorSize;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDescriptorSetLayoutHostMappingInfoVALVE_host_to_win32(const VkDescriptorSetLayoutHostMappingInfoVALVE *in, VkDescriptorSetLayoutHostMappingInfoVALVE32 *out)
{
    if (!in) return;

    out->descriptorOffset = in->descriptorOffset;
    out->descriptorSize = in->descriptorSize;
}

static void convert_VkDescriptorSetLayoutSupport_win32_to_host(struct conversion_context *ctx, const VkDescriptorSetLayoutSupport32 *in, VkDescriptorSetLayoutSupport *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            VkDescriptorSetVariableDescriptorCountLayoutSupport *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkDescriptorSetLayoutSupport_host_to_win32(const VkDescriptorSetLayoutSupport *in, VkDescriptorSetLayoutSupport32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->supported = in->supported;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {
            VkDescriptorSetVariableDescriptorCountLayoutSupport32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT);
            const VkDescriptorSetVariableDescriptorCountLayoutSupport *in_ext = (const VkDescriptorSetVariableDescriptorCountLayoutSupport *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT;
            out_ext->maxVariableDescriptorCount = in_ext->maxVariableDescriptorCount;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkAccelerationStructureVersionInfoKHR_win32_to_host(const VkAccelerationStructureVersionInfoKHR32 *in, VkAccelerationStructureVersionInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pVersionData = UlongToPtr(in->pVersionData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static const VkBufferCreateInfo *convert_VkBufferCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkBufferCreateInfo *in, uint32_t count)
{
    VkBufferCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkDeviceBufferMemoryRequirements_win64_to_host(struct conversion_context *ctx, const VkDeviceBufferMemoryRequirements *in, VkDeviceBufferMemoryRequirements *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->pCreateInfo = convert_VkBufferCreateInfo_array_win64_to_host(ctx, in->pCreateInfo, 1);
}
#endif /* _WIN64 */

static const VkBufferCreateInfo *convert_VkBufferCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkBufferCreateInfo32 *in, uint32_t count)
{
    VkBufferCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBufferCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkDeviceBufferMemoryRequirements_win32_to_host(struct conversion_context *ctx, const VkDeviceBufferMemoryRequirements32 *in, VkDeviceBufferMemoryRequirements *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pCreateInfo = convert_VkBufferCreateInfo_array_win32_to_host(ctx, (const VkBufferCreateInfo32 *)UlongToPtr(in->pCreateInfo), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDeviceFaultCountsEXT_win32_to_host(const VkDeviceFaultCountsEXT32 *in, VkDeviceFaultCountsEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->addressInfoCount = in->addressInfoCount;
    out->vendorInfoCount = in->vendorInfoCount;
    out->vendorBinarySize = in->vendorBinarySize;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDeviceFaultAddressInfoEXT_win32_to_host(const VkDeviceFaultAddressInfoEXT32 *in, VkDeviceFaultAddressInfoEXT *out)
{
    if (!in) return;

    out->addressType = in->addressType;
    out->reportedAddress = in->reportedAddress;
    out->addressPrecision = in->addressPrecision;
}

static VkDeviceFaultAddressInfoEXT *convert_VkDeviceFaultAddressInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkDeviceFaultAddressInfoEXT32 *in, uint32_t count)
{
    VkDeviceFaultAddressInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDeviceFaultAddressInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDeviceFaultVendorInfoEXT_win32_to_host(const VkDeviceFaultVendorInfoEXT32 *in, VkDeviceFaultVendorInfoEXT *out)
{
    if (!in) return;

    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->vendorFaultCode = in->vendorFaultCode;
    out->vendorFaultData = in->vendorFaultData;
}

static VkDeviceFaultVendorInfoEXT *convert_VkDeviceFaultVendorInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkDeviceFaultVendorInfoEXT32 *in, uint32_t count)
{
    VkDeviceFaultVendorInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDeviceFaultVendorInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDeviceFaultInfoEXT_win32_to_host(struct conversion_context *ctx, const VkDeviceFaultInfoEXT32 *in, VkDeviceFaultInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pAddressInfos = convert_VkDeviceFaultAddressInfoEXT_array_win32_to_host(ctx, (VkDeviceFaultAddressInfoEXT32 *)UlongToPtr(in->pAddressInfos), 1);
    out->pVendorInfos = convert_VkDeviceFaultVendorInfoEXT_array_win32_to_host(ctx, (VkDeviceFaultVendorInfoEXT32 *)UlongToPtr(in->pVendorInfos), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDeviceFaultCountsEXT_host_to_win32(const VkDeviceFaultCountsEXT *in, VkDeviceFaultCountsEXT32 *out)
{
    if (!in) return;

    out->addressInfoCount = in->addressInfoCount;
    out->vendorInfoCount = in->vendorInfoCount;
    out->vendorBinarySize = in->vendorBinarySize;
}

static void convert_VkDeviceFaultAddressInfoEXT_host_to_win32(const VkDeviceFaultAddressInfoEXT *in, VkDeviceFaultAddressInfoEXT32 *out)
{
    if (!in) return;

    out->addressType = in->addressType;
    out->reportedAddress = in->reportedAddress;
    out->addressPrecision = in->addressPrecision;
}

static void convert_VkDeviceFaultAddressInfoEXT_array_host_to_win32(const VkDeviceFaultAddressInfoEXT *in, VkDeviceFaultAddressInfoEXT32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkDeviceFaultAddressInfoEXT_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkDeviceFaultVendorInfoEXT_host_to_win32(const VkDeviceFaultVendorInfoEXT *in, VkDeviceFaultVendorInfoEXT32 *out)
{
    if (!in) return;

    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->vendorFaultCode = in->vendorFaultCode;
    out->vendorFaultData = in->vendorFaultData;
}

static void convert_VkDeviceFaultVendorInfoEXT_array_host_to_win32(const VkDeviceFaultVendorInfoEXT *in, VkDeviceFaultVendorInfoEXT32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkDeviceFaultVendorInfoEXT_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkDeviceFaultInfoEXT_host_to_win32(const VkDeviceFaultInfoEXT *in, VkDeviceFaultInfoEXT32 *out)
{
    if (!in) return;

    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    convert_VkDeviceFaultAddressInfoEXT_array_host_to_win32(in->pAddressInfos, (VkDeviceFaultAddressInfoEXT32 *)UlongToPtr(out->pAddressInfos), 1);
    convert_VkDeviceFaultVendorInfoEXT_array_host_to_win32(in->pVendorInfos, (VkDeviceFaultVendorInfoEXT32 *)UlongToPtr(out->pVendorInfos), 1);
    out->pVendorBinaryData = PtrToUlong(in->pVendorBinaryData);
}

static void convert_VkDeviceGroupPresentCapabilitiesKHR_win32_to_host(const VkDeviceGroupPresentCapabilitiesKHR32 *in, VkDeviceGroupPresentCapabilitiesKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDeviceGroupPresentCapabilitiesKHR_host_to_win32(const VkDeviceGroupPresentCapabilitiesKHR *in, VkDeviceGroupPresentCapabilitiesKHR32 *out)
{
    if (!in) return;

    memcpy(out->presentMask, in->presentMask, VK_MAX_DEVICE_GROUP_SIZE * sizeof(uint32_t));
    out->modes = in->modes;
}

#ifdef _WIN64
static const VkImageCreateInfo *convert_VkImageCreateInfo_array_win64_to_host(struct conversion_context *ctx, const VkImageCreateInfo *in, uint32_t count)
{
    VkImageCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageCreateInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkDeviceImageMemoryRequirements_win64_to_host(struct conversion_context *ctx, const VkDeviceImageMemoryRequirements *in, VkDeviceImageMemoryRequirements *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->pCreateInfo = convert_VkImageCreateInfo_array_win64_to_host(ctx, in->pCreateInfo, 1);
    out->planeAspect = in->planeAspect;
}
#endif /* _WIN64 */

static const VkImageCreateInfo *convert_VkImageCreateInfo_array_win32_to_host(struct conversion_context *ctx, const VkImageCreateInfo32 *in, uint32_t count)
{
    VkImageCreateInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageCreateInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkDeviceImageMemoryRequirements_win32_to_host(struct conversion_context *ctx, const VkDeviceImageMemoryRequirements32 *in, VkDeviceImageMemoryRequirements *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pCreateInfo = convert_VkImageCreateInfo_array_win32_to_host(ctx, (const VkImageCreateInfo32 *)UlongToPtr(in->pCreateInfo), 1);
    out->planeAspect = in->planeAspect;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkSparseImageMemoryRequirements2_win32_to_host(const VkSparseImageMemoryRequirements232 *in, VkSparseImageMemoryRequirements2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkSparseImageMemoryRequirements2 *convert_VkSparseImageMemoryRequirements2_array_win32_to_host(struct conversion_context *ctx, const VkSparseImageMemoryRequirements232 *in, uint32_t count)
{
    VkSparseImageMemoryRequirements2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryRequirements2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkSparseImageMemoryRequirements_host_to_win32(const VkSparseImageMemoryRequirements *in, VkSparseImageMemoryRequirements32 *out)
{
    if (!in) return;

    out->formatProperties = in->formatProperties;
    out->imageMipTailFirstLod = in->imageMipTailFirstLod;
    out->imageMipTailSize = in->imageMipTailSize;
    out->imageMipTailOffset = in->imageMipTailOffset;
    out->imageMipTailStride = in->imageMipTailStride;
}

static void convert_VkSparseImageMemoryRequirements2_host_to_win32(const VkSparseImageMemoryRequirements2 *in, VkSparseImageMemoryRequirements232 *out)
{
    if (!in) return;

    convert_VkSparseImageMemoryRequirements_host_to_win32(&in->memoryRequirements, &out->memoryRequirements);
}

static void convert_VkSparseImageMemoryRequirements2_array_host_to_win32(const VkSparseImageMemoryRequirements2 *in, VkSparseImageMemoryRequirements232 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryRequirements2_host_to_win32(&in[i], &out[i]);
    }
}

#ifdef _WIN64
static void convert_VkDeviceImageSubresourceInfo_win64_to_host(struct conversion_context *ctx, const VkDeviceImageSubresourceInfo *in, VkDeviceImageSubresourceInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->pCreateInfo = convert_VkImageCreateInfo_array_win64_to_host(ctx, in->pCreateInfo, 1);
    out->pSubresource = in->pSubresource;
}
#endif /* _WIN64 */

static void convert_VkImageSubresource2_win32_to_host(const VkImageSubresource232 *in, VkImageSubresource2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->imageSubresource = in->imageSubresource;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkImageSubresource2 *convert_VkImageSubresource2_array_win32_to_host(struct conversion_context *ctx, const VkImageSubresource232 *in, uint32_t count)
{
    VkImageSubresource2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkImageSubresource2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDeviceImageSubresourceInfo_win32_to_host(struct conversion_context *ctx, const VkDeviceImageSubresourceInfo32 *in, VkDeviceImageSubresourceInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pCreateInfo = convert_VkImageCreateInfo_array_win32_to_host(ctx, (const VkImageCreateInfo32 *)UlongToPtr(in->pCreateInfo), 1);
    out->pSubresource = convert_VkImageSubresource2_array_win32_to_host(ctx, (const VkImageSubresource232 *)UlongToPtr(in->pSubresource), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkSubresourceLayout2_win32_to_host(struct conversion_context *ctx, const VkSubresourceLayout232 *in, VkSubresourceLayout2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE:
        {
            VkSubresourceHostMemcpySize *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkSubresourceLayout_host_to_win32(const VkSubresourceLayout *in, VkSubresourceLayout32 *out)
{
    if (!in) return;

    out->offset = in->offset;
    out->size = in->size;
    out->rowPitch = in->rowPitch;
    out->arrayPitch = in->arrayPitch;
    out->depthPitch = in->depthPitch;
}

static void convert_VkSubresourceLayout2_host_to_win32(const VkSubresourceLayout2 *in, VkSubresourceLayout232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    convert_VkSubresourceLayout_host_to_win32(&in->subresourceLayout, &out->subresourceLayout);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT);
            const VkImageCompressionPropertiesEXT *in_ext = (const VkImageCompressionPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->imageCompressionFlags = in_ext->imageCompressionFlags;
            out_ext->imageCompressionFixedRateFlags = in_ext->imageCompressionFixedRateFlags;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE:
        {
            VkSubresourceHostMemcpySize32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE);
            const VkSubresourceHostMemcpySize *in_ext = (const VkSubresourceHostMemcpySize *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE;
            out_ext->size = in_ext->size;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

#ifdef _WIN64
static void convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win64_to_host(const VkDeviceMemoryOpaqueCaptureAddressInfo *in, VkDeviceMemoryOpaqueCaptureAddressInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
}
#endif /* _WIN64 */

static void convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win32_to_host(const VkDeviceMemoryOpaqueCaptureAddressInfo32 *in, VkDeviceMemoryOpaqueCaptureAddressInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMicromapVersionInfoEXT_win32_to_host(const VkMicromapVersionInfoEXT32 *in, VkMicromapVersionInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pVersionData = UlongToPtr(in->pVersionData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkDeviceQueueInfo2_win32_to_host(const VkDeviceQueueInfo232 *in, VkDeviceQueueInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->queueFamilyIndex = in->queueFamilyIndex;
    out->queueIndex = in->queueIndex;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkTensorCreateInfoARM *convert_VkTensorCreateInfoARM_array_win32_to_host(struct conversion_context *ctx, const VkTensorCreateInfoARM32 *in, uint32_t count)
{
    VkTensorCreateInfoARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkTensorCreateInfoARM_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkDeviceTensorMemoryRequirementsARM_win32_to_host(struct conversion_context *ctx, const VkDeviceTensorMemoryRequirementsARM32 *in, VkDeviceTensorMemoryRequirementsARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pCreateInfo = convert_VkTensorCreateInfoARM_array_win32_to_host(ctx, (const VkTensorCreateInfoARM32 *)UlongToPtr(in->pCreateInfo), 1);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkTilePropertiesQCOM_win32_to_host(const VkTilePropertiesQCOM32 *in, VkTilePropertiesQCOM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->tileSize = in->tileSize;
    out->apronSize = in->apronSize;
    out->origin = in->origin;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkTilePropertiesQCOM_host_to_win32(const VkTilePropertiesQCOM *in, VkTilePropertiesQCOM32 *out)
{
    if (!in) return;

    out->tileSize = in->tileSize;
    out->apronSize = in->apronSize;
    out->origin = in->origin;
}

static void convert_VkVideoEncodeSessionParametersGetInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoEncodeSessionParametersGetInfoKHR32 *in, VkVideoEncodeSessionParametersGetInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->videoSessionParameters = in->videoSessionParameters;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR:
        {
            VkVideoEncodeH264SessionParametersGetInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264SessionParametersGetInfoKHR32 *in_ext = (const VkVideoEncodeH264SessionParametersGetInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->writeStdSPS = in_ext->writeStdSPS;
            out_ext->writeStdPPS = in_ext->writeStdPPS;
            out_ext->stdSPSId = in_ext->stdSPSId;
            out_ext->stdPPSId = in_ext->stdPPSId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkVideoEncodeSessionParametersFeedbackInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoEncodeSessionParametersFeedbackInfoKHR32 *in, VkVideoEncodeSessionParametersFeedbackInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
        {
            VkVideoEncodeH264SessionParametersFeedbackInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkVideoEncodeSessionParametersFeedbackInfoKHR_host_to_win32(const VkVideoEncodeSessionParametersFeedbackInfoKHR *in, VkVideoEncodeSessionParametersFeedbackInfoKHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->hasOverrides = in->hasOverrides;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
        {
            VkVideoEncodeH264SessionParametersFeedbackInfoKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR);
            const VkVideoEncodeH264SessionParametersFeedbackInfoKHR *in_ext = (const VkVideoEncodeH264SessionParametersFeedbackInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR;
            out_ext->hasStdSPSOverrides = in_ext->hasStdSPSOverrides;
            out_ext->hasStdPPSOverrides = in_ext->hasStdPPSOverrides;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkFenceGetWin32HandleInfoKHR_win32_to_unwrapped_host(const VkFenceGetWin32HandleInfoKHR32 *in, VkFenceGetWin32HandleInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->fence = in->fence;
    out->handleType = in->handleType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkTilePropertiesQCOM *convert_VkTilePropertiesQCOM_array_win32_to_host(struct conversion_context *ctx, const VkTilePropertiesQCOM32 *in, uint32_t count)
{
    VkTilePropertiesQCOM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkTilePropertiesQCOM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkTilePropertiesQCOM_array_host_to_win32(const VkTilePropertiesQCOM *in, VkTilePropertiesQCOM32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkTilePropertiesQCOM_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkGeneratedCommandsMemoryRequirementsInfoEXT_win32_to_host(struct conversion_context *ctx, const VkGeneratedCommandsMemoryRequirementsInfoEXT32 *in, VkGeneratedCommandsMemoryRequirementsInfoEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->indirectExecutionSet = in->indirectExecutionSet;
    out->indirectCommandsLayout = in->indirectCommandsLayout;
    out->maxSequenceCount = in->maxSequenceCount;
    out->maxDrawCount = in->maxDrawCount;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT:
        {
            VkGeneratedCommandsPipelineInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGeneratedCommandsPipelineInfoEXT32 *in_ext = (const VkGeneratedCommandsPipelineInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->pipeline = in_ext->pipeline;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT:
        {
            VkGeneratedCommandsShaderInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkGeneratedCommandsShaderInfoEXT32 *in_ext = (const VkGeneratedCommandsShaderInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderCount = in_ext->shaderCount;
            out_ext->pShaders = UlongToPtr(in_ext->pShaders);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkGeneratedCommandsMemoryRequirementsInfoNV_win32_to_host(const VkGeneratedCommandsMemoryRequirementsInfoNV32 *in, VkGeneratedCommandsMemoryRequirementsInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->pipeline = in->pipeline;
    out->indirectCommandsLayout = in->indirectCommandsLayout;
    out->maxSequencesCount = in->maxSequencesCount;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkImageMemoryRequirementsInfo2_win32_to_host(struct conversion_context *ctx, const VkImageMemoryRequirementsInfo232 *in, VkImageMemoryRequirementsInfo2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {
            VkImagePlaneMemoryRequirementsInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImagePlaneMemoryRequirementsInfo32 *in_ext = (const VkImagePlaneMemoryRequirementsInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
            out_ext->pNext = NULL;
            out_ext->planeAspect = in_ext->planeAspect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkImageCaptureDescriptorDataInfoEXT_win32_to_host(const VkImageCaptureDescriptorDataInfoEXT32 *in, VkImageCaptureDescriptorDataInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkSparseImageMemoryRequirements_array_host_to_win32(const VkSparseImageMemoryRequirements *in, VkSparseImageMemoryRequirements32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryRequirements_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkImageSparseMemoryRequirementsInfo2_win32_to_host(const VkImageSparseMemoryRequirementsInfo232 *in, VkImageSparseMemoryRequirementsInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkSubresourceLayout_win32_to_host(const VkSubresourceLayout32 *in, VkSubresourceLayout *out)
{
    if (!in) return;

    out->offset = in->offset;
    out->size = in->size;
    out->rowPitch = in->rowPitch;
    out->arrayPitch = in->arrayPitch;
    out->depthPitch = in->depthPitch;
}

static void convert_VkImageViewAddressPropertiesNVX_win32_to_host(const VkImageViewAddressPropertiesNVX32 *in, VkImageViewAddressPropertiesNVX *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkImageViewAddressPropertiesNVX_host_to_win32(const VkImageViewAddressPropertiesNVX *in, VkImageViewAddressPropertiesNVX32 *out)
{
    if (!in) return;

    out->deviceAddress = in->deviceAddress;
    out->size = in->size;
}

static void convert_VkImageViewHandleInfoNVX_win32_to_host(const VkImageViewHandleInfoNVX32 *in, VkImageViewHandleInfoNVX *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->imageView = in->imageView;
    out->descriptorType = in->descriptorType;
    out->sampler = in->sampler;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkImageViewCaptureDescriptorDataInfoEXT_win32_to_host(const VkImageViewCaptureDescriptorDataInfoEXT32 *in, VkImageViewCaptureDescriptorDataInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->imageView = in->imageView;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkLatencyTimingsFrameReportNV_win32_to_host(const VkLatencyTimingsFrameReportNV32 *in, VkLatencyTimingsFrameReportNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkLatencyTimingsFrameReportNV *convert_VkLatencyTimingsFrameReportNV_array_win32_to_host(struct conversion_context *ctx, const VkLatencyTimingsFrameReportNV32 *in, uint32_t count)
{
    VkLatencyTimingsFrameReportNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkLatencyTimingsFrameReportNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkGetLatencyMarkerInfoNV_win32_to_host(struct conversion_context *ctx, const VkGetLatencyMarkerInfoNV32 *in, VkGetLatencyMarkerInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->timingCount = in->timingCount;
    out->pTimings = convert_VkLatencyTimingsFrameReportNV_array_win32_to_host(ctx, (VkLatencyTimingsFrameReportNV32 *)UlongToPtr(in->pTimings), in->timingCount);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkLatencyTimingsFrameReportNV_host_to_win32(const VkLatencyTimingsFrameReportNV *in, VkLatencyTimingsFrameReportNV32 *out)
{
    if (!in) return;

    out->presentID = in->presentID;
    out->inputSampleTimeUs = in->inputSampleTimeUs;
    out->simStartTimeUs = in->simStartTimeUs;
    out->simEndTimeUs = in->simEndTimeUs;
    out->renderSubmitStartTimeUs = in->renderSubmitStartTimeUs;
    out->renderSubmitEndTimeUs = in->renderSubmitEndTimeUs;
    out->presentStartTimeUs = in->presentStartTimeUs;
    out->presentEndTimeUs = in->presentEndTimeUs;
    out->driverStartTimeUs = in->driverStartTimeUs;
    out->driverEndTimeUs = in->driverEndTimeUs;
    out->osRenderQueueStartTimeUs = in->osRenderQueueStartTimeUs;
    out->osRenderQueueEndTimeUs = in->osRenderQueueEndTimeUs;
    out->gpuRenderStartTimeUs = in->gpuRenderStartTimeUs;
    out->gpuRenderEndTimeUs = in->gpuRenderEndTimeUs;
}

static void convert_VkLatencyTimingsFrameReportNV_array_host_to_win32(const VkLatencyTimingsFrameReportNV *in, VkLatencyTimingsFrameReportNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkLatencyTimingsFrameReportNV_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkGetLatencyMarkerInfoNV_host_to_win32(const VkGetLatencyMarkerInfoNV *in, VkGetLatencyMarkerInfoNV32 *out)
{
    if (!in) return;

    out->timingCount = in->timingCount;
    convert_VkLatencyTimingsFrameReportNV_array_host_to_win32(in->pTimings, (VkLatencyTimingsFrameReportNV32 *)UlongToPtr(out->pTimings), in->timingCount);
}

static void convert_VkMemoryHostPointerPropertiesEXT_win32_to_host(const VkMemoryHostPointerPropertiesEXT32 *in, VkMemoryHostPointerPropertiesEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMemoryHostPointerPropertiesEXT_host_to_win32(const VkMemoryHostPointerPropertiesEXT *in, VkMemoryHostPointerPropertiesEXT32 *out)
{
    if (!in) return;

    out->memoryTypeBits = in->memoryTypeBits;
}

static void convert_VkMemoryGetWin32HandleInfoKHR_win32_to_unwrapped_host(const VkMemoryGetWin32HandleInfoKHR32 *in, VkMemoryGetWin32HandleInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->memory = in->memory;
    out->handleType = in->handleType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMemoryWin32HandlePropertiesKHR_win32_to_host(const VkMemoryWin32HandlePropertiesKHR32 *in, VkMemoryWin32HandlePropertiesKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMemoryWin32HandlePropertiesKHR_host_to_win32(const VkMemoryWin32HandlePropertiesKHR *in, VkMemoryWin32HandlePropertiesKHR32 *out)
{
    if (!in) return;

    out->memoryTypeBits = in->memoryTypeBits;
}

static void convert_VkMicromapBuildSizesInfoEXT_win32_to_host(const VkMicromapBuildSizesInfoEXT32 *in, VkMicromapBuildSizesInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->micromapSize = in->micromapSize;
    out->buildScratchSize = in->buildScratchSize;
    out->discardable = in->discardable;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMicromapBuildSizesInfoEXT_host_to_win32(const VkMicromapBuildSizesInfoEXT *in, VkMicromapBuildSizesInfoEXT32 *out)
{
    if (!in) return;

    out->micromapSize = in->micromapSize;
    out->buildScratchSize = in->buildScratchSize;
    out->discardable = in->discardable;
}

static void convert_VkPartitionedAccelerationStructureInstancesInputNV_host_to_win32(const VkPartitionedAccelerationStructureInstancesInputNV *in, const VkPartitionedAccelerationStructureInstancesInputNV32 *out)
{
    if (!in) return;

}

static void convert_VkPerformanceValueDataINTEL_host_to_win32(const VkPerformanceValueDataINTEL *in, VkPerformanceValueDataINTEL32 *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL)
        out->value32 = in->value32;
    if (selector == VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL)
        out->value64 = in->value64;
    if (selector == VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL)
        out->valueFloat = in->valueFloat;
    if (selector == VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL)
        out->valueBool = in->valueBool;
}

static void convert_VkPerformanceValueINTEL_host_to_win32(const VkPerformanceValueINTEL *in, VkPerformanceValueINTEL32 *out)
{
    if (!in) return;

    out->type = in->type;
    convert_VkPerformanceValueDataINTEL_host_to_win32(&in->data, &out->data, in->type);
}

static void convert_VkCooperativeMatrixFlexibleDimensionsPropertiesNV_win32_to_host(const VkCooperativeMatrixFlexibleDimensionsPropertiesNV32 *in, VkCooperativeMatrixFlexibleDimensionsPropertiesNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkCooperativeMatrixFlexibleDimensionsPropertiesNV *convert_VkCooperativeMatrixFlexibleDimensionsPropertiesNV_array_win32_to_host(struct conversion_context *ctx, const VkCooperativeMatrixFlexibleDimensionsPropertiesNV32 *in, uint32_t count)
{
    VkCooperativeMatrixFlexibleDimensionsPropertiesNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeMatrixFlexibleDimensionsPropertiesNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCooperativeMatrixFlexibleDimensionsPropertiesNV_host_to_win32(const VkCooperativeMatrixFlexibleDimensionsPropertiesNV *in, VkCooperativeMatrixFlexibleDimensionsPropertiesNV32 *out)
{
    if (!in) return;

    out->MGranularity = in->MGranularity;
    out->NGranularity = in->NGranularity;
    out->KGranularity = in->KGranularity;
    out->AType = in->AType;
    out->BType = in->BType;
    out->CType = in->CType;
    out->ResultType = in->ResultType;
    out->saturatingAccumulation = in->saturatingAccumulation;
    out->scope = in->scope;
    out->workgroupInvocations = in->workgroupInvocations;
}

static void convert_VkCooperativeMatrixFlexibleDimensionsPropertiesNV_array_host_to_win32(const VkCooperativeMatrixFlexibleDimensionsPropertiesNV *in, VkCooperativeMatrixFlexibleDimensionsPropertiesNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeMatrixFlexibleDimensionsPropertiesNV_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkCooperativeMatrixPropertiesKHR_win32_to_host(const VkCooperativeMatrixPropertiesKHR32 *in, VkCooperativeMatrixPropertiesKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkCooperativeMatrixPropertiesKHR *convert_VkCooperativeMatrixPropertiesKHR_array_win32_to_host(struct conversion_context *ctx, const VkCooperativeMatrixPropertiesKHR32 *in, uint32_t count)
{
    VkCooperativeMatrixPropertiesKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeMatrixPropertiesKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCooperativeMatrixPropertiesKHR_host_to_win32(const VkCooperativeMatrixPropertiesKHR *in, VkCooperativeMatrixPropertiesKHR32 *out)
{
    if (!in) return;

    out->MSize = in->MSize;
    out->NSize = in->NSize;
    out->KSize = in->KSize;
    out->AType = in->AType;
    out->BType = in->BType;
    out->CType = in->CType;
    out->ResultType = in->ResultType;
    out->saturatingAccumulation = in->saturatingAccumulation;
    out->scope = in->scope;
}

static void convert_VkCooperativeMatrixPropertiesKHR_array_host_to_win32(const VkCooperativeMatrixPropertiesKHR *in, VkCooperativeMatrixPropertiesKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeMatrixPropertiesKHR_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkCooperativeMatrixPropertiesNV_win32_to_host(const VkCooperativeMatrixPropertiesNV32 *in, VkCooperativeMatrixPropertiesNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkCooperativeMatrixPropertiesNV *convert_VkCooperativeMatrixPropertiesNV_array_win32_to_host(struct conversion_context *ctx, const VkCooperativeMatrixPropertiesNV32 *in, uint32_t count)
{
    VkCooperativeMatrixPropertiesNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeMatrixPropertiesNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCooperativeMatrixPropertiesNV_host_to_win32(const VkCooperativeMatrixPropertiesNV *in, VkCooperativeMatrixPropertiesNV32 *out)
{
    if (!in) return;

    out->MSize = in->MSize;
    out->NSize = in->NSize;
    out->KSize = in->KSize;
    out->AType = in->AType;
    out->BType = in->BType;
    out->CType = in->CType;
    out->DType = in->DType;
    out->scope = in->scope;
}

static void convert_VkCooperativeMatrixPropertiesNV_array_host_to_win32(const VkCooperativeMatrixPropertiesNV *in, VkCooperativeMatrixPropertiesNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeMatrixPropertiesNV_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkCooperativeVectorPropertiesNV_win32_to_host(const VkCooperativeVectorPropertiesNV32 *in, VkCooperativeVectorPropertiesNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->inputType = in->inputType;
    out->inputInterpretation = in->inputInterpretation;
    out->matrixInterpretation = in->matrixInterpretation;
    out->biasInterpretation = in->biasInterpretation;
    out->resultType = in->resultType;
    out->transpose = in->transpose;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkCooperativeVectorPropertiesNV *convert_VkCooperativeVectorPropertiesNV_array_win32_to_host(struct conversion_context *ctx, const VkCooperativeVectorPropertiesNV32 *in, uint32_t count)
{
    VkCooperativeVectorPropertiesNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeVectorPropertiesNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCooperativeVectorPropertiesNV_host_to_win32(const VkCooperativeVectorPropertiesNV *in, VkCooperativeVectorPropertiesNV32 *out)
{
    if (!in) return;

    out->inputType = in->inputType;
    out->inputInterpretation = in->inputInterpretation;
    out->matrixInterpretation = in->matrixInterpretation;
    out->biasInterpretation = in->biasInterpretation;
    out->resultType = in->resultType;
    out->transpose = in->transpose;
}

static void convert_VkCooperativeVectorPropertiesNV_array_host_to_win32(const VkCooperativeVectorPropertiesNV *in, VkCooperativeVectorPropertiesNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkCooperativeVectorPropertiesNV_host_to_win32(&in[i], &out[i]);
    }
}

#ifdef _WIN64
static void convert_VkPhysicalDeviceExternalBufferInfo_win64_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalBufferInfo *in, VkPhysicalDeviceExternalBufferInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->usage = in->usage;
    out->handleType = in->handleType;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
        {
            VkBufferUsageFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfo *in_ext = (const VkBufferUsageFlags2CreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

static void convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalBufferInfo32 *in, VkPhysicalDeviceExternalBufferInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->usage = in->usage;
    out->handleType = in->handleType;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
        {
            VkBufferUsageFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkBufferUsageFlags2CreateInfo32 *in_ext = (const VkBufferUsageFlags2CreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkExternalBufferProperties_win32_to_host(const VkExternalBufferProperties32 *in, VkExternalBufferProperties *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkExternalBufferProperties_host_to_win32(const VkExternalBufferProperties *in, VkExternalBufferProperties32 *out)
{
    if (!in) return;

    out->externalMemoryProperties = in->externalMemoryProperties;
}

static void convert_VkPhysicalDeviceExternalFenceInfo_win32_to_host(const VkPhysicalDeviceExternalFenceInfo32 *in, VkPhysicalDeviceExternalFenceInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->handleType = in->handleType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkExternalFenceProperties_win32_to_host(const VkExternalFenceProperties32 *in, VkExternalFenceProperties *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkExternalFenceProperties_host_to_win32(const VkExternalFenceProperties *in, VkExternalFenceProperties32 *out)
{
    if (!in) return;

    out->exportFromImportedHandleTypes = in->exportFromImportedHandleTypes;
    out->compatibleHandleTypes = in->compatibleHandleTypes;
    out->externalFenceFeatures = in->externalFenceFeatures;
}

static void convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalSemaphoreInfo32 *in, VkPhysicalDeviceExternalSemaphoreInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->handleType = in->handleType;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {
            VkSemaphoreTypeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSemaphoreTypeCreateInfo32 *in_ext = (const VkSemaphoreTypeCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->semaphoreType = in_ext->semaphoreType;
            out_ext->initialValue = in_ext->initialValue;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkExternalSemaphoreProperties_win32_to_host(const VkExternalSemaphoreProperties32 *in, VkExternalSemaphoreProperties *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkExternalSemaphoreProperties_host_to_win32(const VkExternalSemaphoreProperties *in, VkExternalSemaphoreProperties32 *out)
{
    if (!in) return;

    out->exportFromImportedHandleTypes = in->exportFromImportedHandleTypes;
    out->compatibleHandleTypes = in->compatibleHandleTypes;
    out->externalSemaphoreFeatures = in->externalSemaphoreFeatures;
}

static void convert_VkPhysicalDeviceExternalTensorInfoARM_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalTensorInfoARM32 *in, VkPhysicalDeviceExternalTensorInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pDescription = convert_VkTensorDescriptionARM_array_win32_to_host(ctx, (const VkTensorDescriptionARM32 *)UlongToPtr(in->pDescription), 1);
    out->handleType = in->handleType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkExternalTensorPropertiesARM_win32_to_host(const VkExternalTensorPropertiesARM32 *in, VkExternalTensorPropertiesARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->externalMemoryProperties = in->externalMemoryProperties;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkExternalTensorPropertiesARM_host_to_win32(const VkExternalTensorPropertiesARM *in, VkExternalTensorPropertiesARM32 *out)
{
    if (!in) return;

    out->externalMemoryProperties = in->externalMemoryProperties;
}

static void convert_VkPhysicalDeviceFeatures2_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceFeatures232 *in, VkPhysicalDeviceFeatures2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->features = in->features;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice16BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice16BitStorageFeatures32 *in_ext = (const VkPhysicalDevice16BitStorageFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDevice4444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice4444FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDevice4444FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatA4R4G4B4 = in_ext->formatA4R4G4B4;
            out_ext->formatA4B4G4R4 = in_ext->formatA4B4G4R4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice8BitStorageFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevice8BitStorageFeatures32 *in_ext = (const VkPhysicalDevice8BitStorageFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            VkPhysicalDeviceASTCDecodeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceASTCDecodeFeaturesEXT32 *in_ext = (const VkPhysicalDeviceASTCDecodeFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->decodeModeSharedExponent = in_ext->decodeModeSharedExponent;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            VkPhysicalDeviceAccelerationStructureFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAccelerationStructureFeaturesKHR32 *in_ext = (const VkPhysicalDeviceAccelerationStructureFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->accelerationStructure = in_ext->accelerationStructure;
            out_ext->accelerationStructureCaptureReplay = in_ext->accelerationStructureCaptureReplay;
            out_ext->accelerationStructureIndirectBuild = in_ext->accelerationStructureIndirectBuild;
            out_ext->accelerationStructureHostCommands = in_ext->accelerationStructureHostCommands;
            out_ext->descriptorBindingAccelerationStructureUpdateAfterBind = in_ext->descriptorBindingAccelerationStructureUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
            VkPhysicalDeviceAddressBindingReportFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAddressBindingReportFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAddressBindingReportFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->reportAddressBinding = in_ext->reportAddressBinding;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD:
        {
            VkPhysicalDeviceAntiLagFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAntiLagFeaturesAMD32 *in_ext = (const VkPhysicalDeviceAntiLagFeaturesAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->antiLag = in_ext->antiLag;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopDynamicState = in_ext->attachmentFeedbackLoopDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32 *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->attachmentFeedbackLoopLayout = in_ext->attachmentFeedbackLoopLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->advancedBlendCoherentOperations = in_ext->advancedBlendCoherentOperations;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
            VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->borderColorSwizzle = in_ext->borderColorSwizzle;
            out_ext->borderColorSwizzleFromImage = in_ext->borderColorSwizzleFromImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            VkPhysicalDeviceBufferDeviceAddressFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeatures32 *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV:
        {
            VkPhysicalDeviceClusterAccelerationStructureFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV32 *in_ext = (const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->clusterAccelerationStructure = in_ext->clusterAccelerationStructure;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->clustercullingShader = in_ext->clustercullingShader;
            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            VkPhysicalDeviceCoherentMemoryFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoherentMemoryFeaturesAMD32 *in_ext = (const VkPhysicalDeviceCoherentMemoryFeaturesAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->deviceCoherentMemory = in_ext->deviceCoherentMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceColorWriteEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceColorWriteEnableFeaturesEXT32 *in_ext = (const VkPhysicalDeviceColorWriteEnableFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->colorWriteEnable = in_ext->colorWriteEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV:
        {
            VkPhysicalDeviceCommandBufferInheritanceFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV32 *in_ext = (const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->commandBufferInheritance = in_ext->commandBufferInheritance;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR:
        {
            VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR32 *in_ext = (const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->computeDerivativeGroupQuads = in_ext->computeDerivativeGroupQuads;
            out_ext->computeDerivativeGroupLinear = in_ext->computeDerivativeGroupLinear;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            VkPhysicalDeviceConditionalRenderingFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceConditionalRenderingFeaturesEXT32 *in_ext = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->conditionalRendering = in_ext->conditionalRendering;
            out_ext->inheritedConditionalRendering = in_ext->inheritedConditionalRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrix2FeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrix2FeaturesNV32 *in_ext = (const VkPhysicalDeviceCooperativeMatrix2FeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrixWorkgroupScope = in_ext->cooperativeMatrixWorkgroupScope;
            out_ext->cooperativeMatrixFlexibleDimensions = in_ext->cooperativeMatrixFlexibleDimensions;
            out_ext->cooperativeMatrixReductions = in_ext->cooperativeMatrixReductions;
            out_ext->cooperativeMatrixConversions = in_ext->cooperativeMatrixConversions;
            out_ext->cooperativeMatrixPerElementOperations = in_ext->cooperativeMatrixPerElementOperations;
            out_ext->cooperativeMatrixTensorAddressing = in_ext->cooperativeMatrixTensorAddressing;
            out_ext->cooperativeMatrixBlockLoads = in_ext->cooperativeMatrixBlockLoads;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesKHR32 *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeMatrixFeaturesNV32 *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeVectorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCooperativeVectorFeaturesNV32 *in_ext = (const VkPhysicalDeviceCooperativeVectorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cooperativeVector = in_ext->cooperativeVector;
            out_ext->cooperativeVectorTraining = in_ext->cooperativeVectorTraining;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32 *in_ext = (const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->indirectCopy = in_ext->indirectCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceCornerSampledImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCornerSampledImageFeaturesNV32 *in_ext = (const VkPhysicalDeviceCornerSampledImageFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->cornerSampledImage = in_ext->cornerSampledImage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            VkPhysicalDeviceCoverageReductionModeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCoverageReductionModeFeaturesNV32 *in_ext = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->coverageReductionMode = in_ext->coverageReductionMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicClampFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicClampFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceCubicClampFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->cubicRangeClamp = in_ext->cubicRangeClamp;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicWeightsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCubicWeightsFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceCubicWeightsFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->selectableCubicWeights = in_ext->selectableCubicWeights;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceCustomBorderColorFeaturesEXT32 *in_ext = (const VkPhysicalDeviceCustomBorderColorFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->customBorderColors = in_ext->customBorderColors;
            out_ext->customBorderColorWithoutFormat = in_ext->customBorderColorWithoutFormat;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM:
        {
            VkPhysicalDeviceDataGraphFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDataGraphFeaturesARM32 *in_ext = (const VkPhysicalDeviceDataGraphFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->dataGraph = in_ext->dataGraph;
            out_ext->dataGraphUpdateAfterBind = in_ext->dataGraphUpdateAfterBind;
            out_ext->dataGraphSpecializationConstants = in_ext->dataGraphSpecializationConstants;
            out_ext->dataGraphDescriptorBuffer = in_ext->dataGraphDescriptorBuffer;
            out_ext->dataGraphShaderModule = in_ext->dataGraphShaderModule;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32 *in_ext = (const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->dedicatedAllocationImageAliasing = in_ext->dedicatedAllocationImageAliasing;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthBiasControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthBiasControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthBiasControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthBiasControl = in_ext->depthBiasControl;
            out_ext->leastRepresentableValueForceUnormRepresentation = in_ext->leastRepresentableValueForceUnormRepresentation;
            out_ext->floatRepresentation = in_ext->floatRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClampControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClampControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClampControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClampControl = in_ext->depthClampControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR:
        {
            VkPhysicalDeviceDepthClampZeroOneFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR32 *in_ext = (const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->depthClampZeroOne = in_ext->depthClampZeroOne;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClipControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipControl = in_ext->depthClipControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipEnableFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDepthClipEnableFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDepthClipEnableFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->depthClipEnable = in_ext->depthClipEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorBufferFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDescriptorBufferFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->descriptorBuffer = in_ext->descriptorBuffer;
            out_ext->descriptorBufferCaptureReplay = in_ext->descriptorBufferCaptureReplay;
            out_ext->descriptorBufferImageLayoutIgnored = in_ext->descriptorBufferImageLayoutIgnored;
            out_ext->descriptorBufferPushDescriptors = in_ext->descriptorBufferPushDescriptors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM:
        {
            VkPhysicalDeviceDescriptorBufferTensorFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM32 *in_ext = (const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->descriptorBufferTensorDescriptors = in_ext->descriptorBufferTensorDescriptors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            VkPhysicalDeviceDescriptorIndexingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorIndexingFeatures32 *in_ext = (const VkPhysicalDeviceDescriptorIndexingFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
            VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32 *in_ext = (const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->descriptorPoolOverallocation = in_ext->descriptorPoolOverallocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
            VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32 *in_ext = (const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
            out_ext->pNext = NULL;
            out_ext->descriptorSetHostMapping = in_ext->descriptorSetHostMapping;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32 *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCompute = in_ext->deviceGeneratedCompute;
            out_ext->deviceGeneratedComputePipelines = in_ext->deviceGeneratedComputePipelines;
            out_ext->deviceGeneratedComputeCaptureReplay = in_ext->deviceGeneratedComputeCaptureReplay;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_ext->dynamicGeneratedPipelineLayout = in_ext->dynamicGeneratedPipelineLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32 *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDiagnosticsConfigFeaturesNV32 *in_ext = (const VkPhysicalDeviceDiagnosticsConfigFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->diagnosticsConfig = in_ext->diagnosticsConfig;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingFeatures32 *in_ext = (const VkPhysicalDeviceDynamicRenderingFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
            out_ext->pNext = NULL;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingLocalReadFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingLocalReadFeatures32 *in_ext = (const VkPhysicalDeviceDynamicRenderingLocalReadFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
            out_ext->pNext = NULL;
            out_ext->dynamicRenderingLocalRead = in_ext->dynamicRenderingLocalRead;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
            VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->dynamicRenderingUnusedAttachments = in_ext->dynamicRenderingUnusedAttachments;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceExclusiveScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExclusiveScissorFeaturesNV32 *in_ext = (const VkPhysicalDeviceExclusiveScissorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->exclusiveScissor = in_ext->exclusiveScissor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState2 = in_ext->extendedDynamicState2;
            out_ext->extendedDynamicState2LogicOp = in_ext->extendedDynamicState2LogicOp;
            out_ext->extendedDynamicState2PatchControlPoints = in_ext->extendedDynamicState2PatchControlPoints;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState3TessellationDomainOrigin = in_ext->extendedDynamicState3TessellationDomainOrigin;
            out_ext->extendedDynamicState3DepthClampEnable = in_ext->extendedDynamicState3DepthClampEnable;
            out_ext->extendedDynamicState3PolygonMode = in_ext->extendedDynamicState3PolygonMode;
            out_ext->extendedDynamicState3RasterizationSamples = in_ext->extendedDynamicState3RasterizationSamples;
            out_ext->extendedDynamicState3SampleMask = in_ext->extendedDynamicState3SampleMask;
            out_ext->extendedDynamicState3AlphaToCoverageEnable = in_ext->extendedDynamicState3AlphaToCoverageEnable;
            out_ext->extendedDynamicState3AlphaToOneEnable = in_ext->extendedDynamicState3AlphaToOneEnable;
            out_ext->extendedDynamicState3LogicOpEnable = in_ext->extendedDynamicState3LogicOpEnable;
            out_ext->extendedDynamicState3ColorBlendEnable = in_ext->extendedDynamicState3ColorBlendEnable;
            out_ext->extendedDynamicState3ColorBlendEquation = in_ext->extendedDynamicState3ColorBlendEquation;
            out_ext->extendedDynamicState3ColorWriteMask = in_ext->extendedDynamicState3ColorWriteMask;
            out_ext->extendedDynamicState3RasterizationStream = in_ext->extendedDynamicState3RasterizationStream;
            out_ext->extendedDynamicState3ConservativeRasterizationMode = in_ext->extendedDynamicState3ConservativeRasterizationMode;
            out_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize = in_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize;
            out_ext->extendedDynamicState3DepthClipEnable = in_ext->extendedDynamicState3DepthClipEnable;
            out_ext->extendedDynamicState3SampleLocationsEnable = in_ext->extendedDynamicState3SampleLocationsEnable;
            out_ext->extendedDynamicState3ColorBlendAdvanced = in_ext->extendedDynamicState3ColorBlendAdvanced;
            out_ext->extendedDynamicState3ProvokingVertexMode = in_ext->extendedDynamicState3ProvokingVertexMode;
            out_ext->extendedDynamicState3LineRasterizationMode = in_ext->extendedDynamicState3LineRasterizationMode;
            out_ext->extendedDynamicState3LineStippleEnable = in_ext->extendedDynamicState3LineStippleEnable;
            out_ext->extendedDynamicState3DepthClipNegativeOneToOne = in_ext->extendedDynamicState3DepthClipNegativeOneToOne;
            out_ext->extendedDynamicState3ViewportWScalingEnable = in_ext->extendedDynamicState3ViewportWScalingEnable;
            out_ext->extendedDynamicState3ViewportSwizzle = in_ext->extendedDynamicState3ViewportSwizzle;
            out_ext->extendedDynamicState3CoverageToColorEnable = in_ext->extendedDynamicState3CoverageToColorEnable;
            out_ext->extendedDynamicState3CoverageToColorLocation = in_ext->extendedDynamicState3CoverageToColorLocation;
            out_ext->extendedDynamicState3CoverageModulationMode = in_ext->extendedDynamicState3CoverageModulationMode;
            out_ext->extendedDynamicState3CoverageModulationTableEnable = in_ext->extendedDynamicState3CoverageModulationTableEnable;
            out_ext->extendedDynamicState3CoverageModulationTable = in_ext->extendedDynamicState3CoverageModulationTable;
            out_ext->extendedDynamicState3CoverageReductionMode = in_ext->extendedDynamicState3CoverageReductionMode;
            out_ext->extendedDynamicState3RepresentativeFragmentTestEnable = in_ext->extendedDynamicState3RepresentativeFragmentTestEnable;
            out_ext->extendedDynamicState3ShadingRateImageEnable = in_ext->extendedDynamicState3ShadingRateImageEnable;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->extendedDynamicState = in_ext->extendedDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32 *in_ext = (const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->extendedSparseAddressSpace = in_ext->extendedSparseAddressSpace;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
            VkPhysicalDeviceFaultFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFaultFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFaultFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->deviceFault = in_ext->deviceFault;
            out_ext->deviceFaultVendorBinary = in_ext->deviceFaultVendorBinary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM:
        {
            VkPhysicalDeviceFormatPackFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFormatPackFeaturesARM32 *in_ext = (const VkPhysicalDeviceFormatPackFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->formatPack = in_ext->formatPack;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapDeferred = in_ext->fragmentDensityMapDeferred;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentDensityMapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMap = in_ext->fragmentDensityMap;
            out_ext->fragmentDensityMapDynamic = in_ext->fragmentDensityMapDynamic;
            out_ext->fragmentDensityMapNonSubsampledImages = in_ext->fragmentDensityMapNonSubsampledImages;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE:
        {
            VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentDensityMapOffset = in_ext->fragmentDensityMapOffset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 *in_ext = (const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderBarycentric = in_ext->fragmentShaderBarycentric;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->fragmentShaderSampleInterlock = in_ext->fragmentShaderSampleInterlock;
            out_ext->fragmentShaderPixelInterlock = in_ext->fragmentShaderPixelInterlock;
            out_ext->fragmentShaderShadingRateInterlock = in_ext->fragmentShaderShadingRateInterlock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32 *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->fragmentShadingRateEnums = in_ext->fragmentShadingRateEnums;
            out_ext->supersampleFragmentShadingRates = in_ext->supersampleFragmentShadingRates;
            out_ext->noInvocationFragmentShadingRates = in_ext->noInvocationFragmentShadingRates;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFragmentShadingRateFeaturesKHR32 *in_ext = (const VkPhysicalDeviceFragmentShadingRateFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineFragmentShadingRate = in_ext->pipelineFragmentShadingRate;
            out_ext->primitiveFragmentShadingRate = in_ext->primitiveFragmentShadingRate;
            out_ext->attachmentFragmentShadingRate = in_ext->attachmentFragmentShadingRate;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
            VkPhysicalDeviceFrameBoundaryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceFrameBoundaryFeaturesEXT32 *in_ext = (const VkPhysicalDeviceFrameBoundaryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->frameBoundary = in_ext->frameBoundary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES:
        {
            VkPhysicalDeviceGlobalPriorityQueryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGlobalPriorityQueryFeatures32 *in_ext = (const VkPhysicalDeviceGlobalPriorityQueryFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32 *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->graphicsPipelineLibrary = in_ext->graphicsPipelineLibrary;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceHdrVividFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHdrVividFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceHdrVividFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->hdrVivid = in_ext->hdrVivid;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES:
        {
            VkPhysicalDeviceHostImageCopyFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostImageCopyFeatures32 *in_ext = (const VkPhysicalDeviceHostImageCopyFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            VkPhysicalDeviceHostQueryResetFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostQueryResetFeatures32 *in_ext = (const VkPhysicalDeviceHostQueryResetFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
            out_ext->pNext = NULL;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->image2DViewOf3D = in_ext->image2DViewOf3D;
            out_ext->sampler2DViewOf3D = in_ext->sampler2DViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA:
        {
            VkPhysicalDeviceImageAlignmentControlFeaturesMESA *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageAlignmentControlFeaturesMESA32 *in_ext = (const VkPhysicalDeviceImageAlignmentControlFeaturesMESA32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA;
            out_ext->pNext = NULL;
            out_ext->imageAlignmentControl = in_ext->imageAlignmentControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageCompressionControlFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControl = in_ext->imageCompressionControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageCompressionControlSwapchain = in_ext->imageCompressionControlSwapchain;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2FeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessing2FeaturesQCOM32 *in_ext = (const VkPhysicalDeviceImageProcessing2FeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureBlockMatch2 = in_ext->textureBlockMatch2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessingFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageProcessingFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceImageProcessingFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->textureSampleWeighted = in_ext->textureSampleWeighted;
            out_ext->textureBoxFilter = in_ext->textureBoxFilter;
            out_ext->textureBlockMatch = in_ext->textureBlockMatch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDeviceImageRobustnessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageRobustnessFeatures32 *in_ext = (const VkPhysicalDeviceImageRobustnessFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->imageSlicedViewOf3D = in_ext->imageSlicedViewOf3D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
            VkPhysicalDeviceImageViewMinLodFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageViewMinLodFeaturesEXT32 *in_ext = (const VkPhysicalDeviceImageViewMinLodFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->minLod = in_ext->minLod;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            VkPhysicalDeviceImagelessFramebufferFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImagelessFramebufferFeatures32 *in_ext = (const VkPhysicalDeviceImagelessFramebufferFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
            out_ext->pNext = NULL;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES:
        {
            VkPhysicalDeviceIndexTypeUint8Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceIndexTypeUint8Features32 *in_ext = (const VkPhysicalDeviceIndexTypeUint8Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
            out_ext->pNext = NULL;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInheritedViewportScissorFeaturesNV32 *in_ext = (const VkPhysicalDeviceInheritedViewportScissorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->inheritedViewportScissor2D = in_ext->inheritedViewportScissor2D;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
            VkPhysicalDeviceInlineUniformBlockFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInlineUniformBlockFeatures32 *in_ext = (const VkPhysicalDeviceInlineUniformBlockFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
            out_ext->pNext = NULL;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->invocationMask = in_ext->invocationMask;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyDitheringFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLegacyDitheringFeaturesEXT32 *in_ext = (const VkPhysicalDeviceLegacyDitheringFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->legacyDithering = in_ext->legacyDithering;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT32 *in_ext = (const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->legacyVertexAttributes = in_ext->legacyVertexAttributes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES:
        {
            VkPhysicalDeviceLineRasterizationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLineRasterizationFeatures32 *in_ext = (const VkPhysicalDeviceLineRasterizationFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
            VkPhysicalDeviceLinearColorAttachmentFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceLinearColorAttachmentFeaturesNV32 *in_ext = (const VkPhysicalDeviceLinearColorAttachmentFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->linearColorAttachment = in_ext->linearColorAttachment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
            VkPhysicalDeviceMaintenance4Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance4Features32 *in_ext = (const VkPhysicalDeviceMaintenance4Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES:
        {
            VkPhysicalDeviceMaintenance5Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance5Features32 *in_ext = (const VkPhysicalDeviceMaintenance5Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES:
        {
            VkPhysicalDeviceMaintenance6Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance6Features32 *in_ext = (const VkPhysicalDeviceMaintenance6Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
            out_ext->pNext = NULL;
            out_ext->maintenance6 = in_ext->maintenance6;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance8FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance8FeaturesKHR32 *in_ext = (const VkPhysicalDeviceMaintenance8FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->maintenance8 = in_ext->maintenance8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance9FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMaintenance9FeaturesKHR32 *in_ext = (const VkPhysicalDeviceMaintenance9FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->maintenance9 = in_ext->maintenance9;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryDecompressionFeaturesNV32 *in_ext = (const VkPhysicalDeviceMemoryDecompressionFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->memoryDecompression = in_ext->memoryDecompression;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            VkPhysicalDeviceMemoryPriorityFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMemoryPriorityFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMemoryPriorityFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->memoryPriority = in_ext->memoryPriority;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
            VkPhysicalDeviceMeshShaderFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_ext->multiviewMeshShader = in_ext->multiviewMeshShader;
            out_ext->primitiveFragmentShadingRateMeshShader = in_ext->primitiveFragmentShadingRateMeshShader;
            out_ext->meshShaderQueries = in_ext->meshShaderQueries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            VkPhysicalDeviceMeshShaderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMeshShaderFeaturesNV32 *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
            VkPhysicalDeviceMultiDrawFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiDrawFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMultiDrawFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multiDraw = in_ext->multiDraw;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
            VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->multisampledRenderToSingleSampled = in_ext->multisampledRenderToSingleSampled;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            VkPhysicalDeviceMultiviewFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewFeatures32 *in_ext = (const VkPhysicalDeviceMultiviewFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
            out_ext->pNext = NULL;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewRenderAreas = in_ext->multiviewPerViewRenderAreas;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->multiviewPerViewViewports = in_ext->multiviewPerViewViewports;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
            VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 *in_ext = (const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->mutableDescriptorType = in_ext->mutableDescriptorType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNestedCommandBufferFeaturesEXT32 *in_ext = (const VkPhysicalDeviceNestedCommandBufferFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nestedCommandBuffer = in_ext->nestedCommandBuffer;
            out_ext->nestedCommandBufferRendering = in_ext->nestedCommandBufferRendering;
            out_ext->nestedCommandBufferSimultaneousUse = in_ext->nestedCommandBufferSimultaneousUse;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->nonSeamlessCubeMap = in_ext->nonSeamlessCubeMap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpacityMicromapFeaturesEXT32 *in_ext = (const VkPhysicalDeviceOpacityMicromapFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->micromap = in_ext->micromap;
            out_ext->micromapCaptureReplay = in_ext->micromapCaptureReplay;
            out_ext->micromapHostCommands = in_ext->micromapHostCommands;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
            VkPhysicalDeviceOpticalFlowFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceOpticalFlowFeaturesNV32 *in_ext = (const VkPhysicalDeviceOpticalFlowFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->opticalFlow = in_ext->opticalFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32 *in_ext = (const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pageableDeviceLocalMemory = in_ext->pageableDeviceLocalMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV:
        {
            VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV32 *in_ext = (const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->partitionedAccelerationStructure = in_ext->partitionedAccelerationStructure;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV:
        {
            VkPhysicalDevicePerStageDescriptorSetFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePerStageDescriptorSetFeaturesNV32 *in_ext = (const VkPhysicalDevicePerStageDescriptorSetFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->perStageDescriptorSet = in_ext->perStageDescriptorSet;
            out_ext->dynamicPipelineLayout = in_ext->dynamicPipelineLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            VkPhysicalDevicePerformanceQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePerformanceQueryFeaturesKHR32 *in_ext = (const VkPhysicalDevicePerformanceQueryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->performanceCounterQueryPools = in_ext->performanceCounterQueryPools;
            out_ext->performanceCounterMultipleQueryPools = in_ext->performanceCounterMultipleQueryPools;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineBinaryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineBinaryFeaturesKHR32 *in_ext = (const VkPhysicalDevicePipelineBinaryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineBinaries = in_ext->pipelineBinaries;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC:
        {
            VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC32 *in_ext = (const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC;
            out_ext->pNext = NULL;
            out_ext->pipelineCacheIncrementalMode = in_ext->pipelineCacheIncrementalMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
            VkPhysicalDevicePipelineCreationCacheControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineCreationCacheControlFeatures32 *in_ext = (const VkPhysicalDevicePipelineCreationCacheControlFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32 *in_ext = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->pipelineExecutableInfo = in_ext->pipelineExecutableInfo;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM:
        {
            VkPhysicalDevicePipelineOpacityMicromapFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM32 *in_ext = (const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->pipelineOpacityMicromap = in_ext->pipelineOpacityMicromap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelinePropertiesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelinePropertiesFeaturesEXT32 *in_ext = (const VkPhysicalDevicePipelinePropertiesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->pipelinePropertiesIdentifier = in_ext->pipelinePropertiesIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES:
        {
            VkPhysicalDevicePipelineProtectedAccessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineProtectedAccessFeatures32 *in_ext = (const VkPhysicalDevicePipelineProtectedAccessFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDevicePipelineRobustnessFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePipelineRobustnessFeatures32 *in_ext = (const VkPhysicalDevicePipelineRobustnessFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
            VkPhysicalDevicePresentBarrierFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentBarrierFeaturesNV32 *in_ext = (const VkPhysicalDevicePresentBarrierFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->presentBarrier = in_ext->presentBarrier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR:
        {
            VkPhysicalDevicePresentId2FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentId2FeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentId2FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentId2 = in_ext->presentId2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
            VkPhysicalDevicePresentIdFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentIdFeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentIdFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentId = in_ext->presentId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR:
        {
            VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentModeFifoLatestReady = in_ext->presentModeFifoLatestReady;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWait2FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentWait2FeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentWait2FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentWait2 = in_ext->presentWait2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWaitFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePresentWaitFeaturesKHR32 *in_ext = (const VkPhysicalDevicePresentWaitFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->presentWait = in_ext->presentWait;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32 *in_ext = (const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitiveTopologyListRestart = in_ext->primitiveTopologyListRestart;
            out_ext->primitiveTopologyPatchListRestart = in_ext->primitiveTopologyPatchListRestart;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32 *in_ext = (const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->primitivesGeneratedQuery = in_ext->primitivesGeneratedQuery;
            out_ext->primitivesGeneratedQueryWithRasterizerDiscard = in_ext->primitivesGeneratedQueryWithRasterizerDiscard;
            out_ext->primitivesGeneratedQueryWithNonZeroStreams = in_ext->primitivesGeneratedQueryWithNonZeroStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
            VkPhysicalDevicePrivateDataFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDevicePrivateDataFeatures32 *in_ext = (const VkPhysicalDevicePrivateDataFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
            out_ext->pNext = NULL;
            out_ext->privateData = in_ext->privateData;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            VkPhysicalDeviceProtectedMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProtectedMemoryFeatures32 *in_ext = (const VkPhysicalDeviceProtectedMemoryFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
            VkPhysicalDeviceProvokingVertexFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceProvokingVertexFeaturesEXT32 *in_ext = (const VkPhysicalDeviceProvokingVertexFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->provokingVertexLast = in_ext->provokingVertexLast;
            out_ext->transformFeedbackPreservesProvokingVertex = in_ext->transformFeedbackPreservesProvokingVertex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->formatRgba10x6WithoutYCbCrSampler = in_ext->formatRgba10x6WithoutYCbCrSampler;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 *in_ext = (const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->rasterizationOrderColorAttachmentAccess = in_ext->rasterizationOrderColorAttachmentAccess;
            out_ext->rasterizationOrderDepthAttachmentAccess = in_ext->rasterizationOrderDepthAttachmentAccess;
            out_ext->rasterizationOrderStencilAttachmentAccess = in_ext->rasterizationOrderStencilAttachmentAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV:
        {
            VkPhysicalDeviceRawAccessChainsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRawAccessChainsFeaturesNV32 *in_ext = (const VkPhysicalDeviceRawAccessChainsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderRawAccessChains = in_ext->shaderRawAccessChains;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceRayQueryFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayQueryFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayQueryFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayQuery = in_ext->rayQuery;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingInvocationReorder = in_ext->rayTracingInvocationReorder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->spheres = in_ext->spheres;
            out_ext->linearSweptSpheres = in_ext->linearSweptSpheres;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingMaintenance1 = in_ext->rayTracingMaintenance1;
            out_ext->rayTracingPipelineTraceRaysIndirect2 = in_ext->rayTracingPipelineTraceRaysIndirect2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingMotionBlur = in_ext->rayTracingMotionBlur;
            out_ext->rayTracingMotionBlurPipelineTraceRaysIndirect = in_ext->rayTracingMotionBlurPipelineTraceRaysIndirect;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPipelineFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingPipelineFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPipeline = in_ext->rayTracingPipeline;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplay = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplay;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
            out_ext->rayTracingPipelineTraceRaysIndirect = in_ext->rayTracingPipelineTraceRaysIndirect;
            out_ext->rayTraversalPrimitiveCulling = in_ext->rayTraversalPrimitiveCulling;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32 *in_ext = (const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->rayTracingPositionFetch = in_ext->rayTracingPositionFetch;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingValidationFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRayTracingValidationFeaturesNV32 *in_ext = (const VkPhysicalDeviceRayTracingValidationFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->rayTracingValidation = in_ext->rayTracingValidation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG:
        {
            VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG32 *in_ext = (const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG;
            out_ext->pNext = NULL;
            out_ext->relaxedLineRasterization = in_ext->relaxedLineRasterization;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM:
        {
            VkPhysicalDeviceRenderPassStripedFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRenderPassStripedFeaturesARM32 *in_ext = (const VkPhysicalDeviceRenderPassStripedFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->renderPassStriped = in_ext->renderPassStriped;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32 *in_ext = (const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->representativeFragmentTest = in_ext->representativeFragmentTest;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR:
        {
            VkPhysicalDeviceRobustness2FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceRobustness2FeaturesKHR32 *in_ext = (const VkPhysicalDeviceRobustness2FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->robustBufferAccess2 = in_ext->robustBufferAccess2;
            out_ext->robustImageAccess2 = in_ext->robustImageAccess2;
            out_ext->nullDescriptor = in_ext->nullDescriptor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            VkPhysicalDeviceSamplerYcbcrConversionFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSamplerYcbcrConversionFeatures32 *in_ext = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceScalarBlockLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceScalarBlockLayoutFeatures32 *in_ext = (const VkPhysicalDeviceScalarBlockLayoutFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM:
        {
            VkPhysicalDeviceSchedulingControlsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSchedulingControlsFeaturesARM32 *in_ext = (const VkPhysicalDeviceSchedulingControlsFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->schedulingControls = in_ext->schedulingControls;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 *in_ext = (const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV:
        {
            VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV32 *in_ext = (const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderFloat16VectorAtomics = in_ext->shaderFloat16VectorAtomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat16Atomics = in_ext->shaderBufferFloat16Atomics;
            out_ext->shaderBufferFloat16AtomicAdd = in_ext->shaderBufferFloat16AtomicAdd;
            out_ext->shaderBufferFloat16AtomicMinMax = in_ext->shaderBufferFloat16AtomicMinMax;
            out_ext->shaderBufferFloat32AtomicMinMax = in_ext->shaderBufferFloat32AtomicMinMax;
            out_ext->shaderBufferFloat64AtomicMinMax = in_ext->shaderBufferFloat64AtomicMinMax;
            out_ext->shaderSharedFloat16Atomics = in_ext->shaderSharedFloat16Atomics;
            out_ext->shaderSharedFloat16AtomicAdd = in_ext->shaderSharedFloat16AtomicAdd;
            out_ext->shaderSharedFloat16AtomicMinMax = in_ext->shaderSharedFloat16AtomicMinMax;
            out_ext->shaderSharedFloat32AtomicMinMax = in_ext->shaderSharedFloat32AtomicMinMax;
            out_ext->shaderSharedFloat64AtomicMinMax = in_ext->shaderSharedFloat64AtomicMinMax;
            out_ext->shaderImageFloat32AtomicMinMax = in_ext->shaderImageFloat32AtomicMinMax;
            out_ext->sparseImageFloat32AtomicMinMax = in_ext->sparseImageFloat32AtomicMinMax;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderBufferFloat32Atomics = in_ext->shaderBufferFloat32Atomics;
            out_ext->shaderBufferFloat32AtomicAdd = in_ext->shaderBufferFloat32AtomicAdd;
            out_ext->shaderBufferFloat64Atomics = in_ext->shaderBufferFloat64Atomics;
            out_ext->shaderBufferFloat64AtomicAdd = in_ext->shaderBufferFloat64AtomicAdd;
            out_ext->shaderSharedFloat32Atomics = in_ext->shaderSharedFloat32Atomics;
            out_ext->shaderSharedFloat32AtomicAdd = in_ext->shaderSharedFloat32AtomicAdd;
            out_ext->shaderSharedFloat64Atomics = in_ext->shaderSharedFloat64Atomics;
            out_ext->shaderSharedFloat64AtomicAdd = in_ext->shaderSharedFloat64AtomicAdd;
            out_ext->shaderImageFloat32Atomics = in_ext->shaderImageFloat32Atomics;
            out_ext->shaderImageFloat32AtomicAdd = in_ext->shaderImageFloat32AtomicAdd;
            out_ext->sparseImageFloat32Atomics = in_ext->sparseImageFloat32Atomics;
            out_ext->sparseImageFloat32AtomicAdd = in_ext->sparseImageFloat32AtomicAdd;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            VkPhysicalDeviceShaderAtomicInt64Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderAtomicInt64Features32 *in_ext = (const VkPhysicalDeviceShaderAtomicInt64Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderBfloat16FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderBfloat16FeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderBfloat16FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderBFloat16Type = in_ext->shaderBFloat16Type;
            out_ext->shaderBFloat16DotProduct = in_ext->shaderBFloat16DotProduct;
            out_ext->shaderBFloat16CooperativeMatrix = in_ext->shaderBFloat16CooperativeMatrix;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderClockFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderClockFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderClockFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupClock = in_ext->shaderSubgroupClock;
            out_ext->shaderDeviceClock = in_ext->shaderDeviceClock;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *in_ext = (const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->shaderCoreBuiltins = in_ext->shaderCoreBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 *in_ext = (const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            VkPhysicalDeviceShaderDrawParametersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderDrawParametersFeatures32 *in_ext = (const VkPhysicalDeviceShaderDrawParametersFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
            VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32 *in_ext = (const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
            out_ext->pNext = NULL;
            out_ext->shaderEarlyAndLateFragmentTests = in_ext->shaderEarlyAndLateFragmentTests;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES:
        {
            VkPhysicalDeviceShaderExpectAssumeFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderExpectAssumeFeatures32 *in_ext = (const VkPhysicalDeviceShaderExpectAssumeFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderExpectAssume = in_ext->shaderExpectAssume;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            VkPhysicalDeviceShaderFloat16Int8Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloat16Int8Features32 *in_ext = (const VkPhysicalDeviceShaderFloat16Int8Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderFloat8FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloat8FeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderFloat8FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderFloat8 = in_ext->shaderFloat8;
            out_ext->shaderFloat8CooperativeMatrix = in_ext->shaderFloat8CooperativeMatrix;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES:
        {
            VkPhysicalDeviceShaderFloatControls2Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderFloatControls2Features32 *in_ext = (const VkPhysicalDeviceShaderFloatControls2Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderFloatControls2 = in_ext->shaderFloatControls2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderImageInt64Atomics = in_ext->shaderImageInt64Atomics;
            out_ext->sparseImageInt64Atomics = in_ext->sparseImageInt64Atomics;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            VkPhysicalDeviceShaderImageFootprintFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderImageFootprintFeaturesNV32 *in_ext = (const VkPhysicalDeviceShaderImageFootprintFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->imageFootprint = in_ext->imageFootprint;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
            VkPhysicalDeviceShaderIntegerDotProductFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerDotProductFeatures32 *in_ext = (const VkPhysicalDeviceShaderIntegerDotProductFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32 *in_ext = (const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
            out_ext->pNext = NULL;
            out_ext->shaderIntegerFunctions2 = in_ext->shaderIntegerFunctions2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderMaximalReconvergence = in_ext->shaderMaximalReconvergence;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderModuleIdentifier = in_ext->shaderModuleIdentifier;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderObjectFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderObjectFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderObjectFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderObject = in_ext->shaderObject;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderQuadControlFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderQuadControlFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderQuadControlFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderQuadControl = in_ext->shaderQuadControl;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderRelaxedExtendedInstruction = in_ext->shaderRelaxedExtendedInstruction;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderReplicatedComposites = in_ext->shaderReplicatedComposites;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32 *in_ext = (const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shaderSMBuiltins = in_ext->shaderSMBuiltins;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 *in_ext = (const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupRotateFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupRotateFeatures32 *in_ext = (const VkPhysicalDeviceShaderSubgroupRotateFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupRotate = in_ext->shaderSubgroupRotate;
            out_ext->shaderSubgroupRotateClustered = in_ext->shaderSubgroupRotateClustered;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderSubgroupUniformControlFlow = in_ext->shaderSubgroupUniformControlFlow;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderTerminateInvocationFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTerminateInvocationFeatures32 *in_ext = (const VkPhysicalDeviceShaderTerminateInvocationFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderTileImageFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderTileImageFeaturesEXT32 *in_ext = (const VkPhysicalDeviceShaderTileImageFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->shaderTileImageColorReadAccess = in_ext->shaderTileImageColorReadAccess;
            out_ext->shaderTileImageDepthReadAccess = in_ext->shaderTileImageDepthReadAccess;
            out_ext->shaderTileImageStencilReadAccess = in_ext->shaderTileImageStencilReadAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderUntypedPointersFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR32 *in_ext = (const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->shaderUntypedPointers = in_ext->shaderUntypedPointers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceShadingRateImageFeaturesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceShadingRateImageFeaturesNV32 *in_ext = (const VkPhysicalDeviceShadingRateImageFeaturesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
            out_ext->pNext = NULL;
            out_ext->shadingRateImage = in_ext->shadingRateImage;
            out_ext->shadingRateCoarseSampleOrder = in_ext->shadingRateCoarseSampleOrder;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
            VkPhysicalDeviceSubgroupSizeControlFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubgroupSizeControlFeatures32 *in_ext = (const VkPhysicalDeviceSubgroupSizeControlFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32 *in_ext = (const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->subpassMergeFeedback = in_ext->subpassMergeFeedback;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32 *in_ext = (const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->subpassShading = in_ext->subpassShading;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR32 *in_ext = (const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainMaintenance1 = in_ext->swapchainMaintenance1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
            VkPhysicalDeviceSynchronization2Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceSynchronization2Features32 *in_ext = (const VkPhysicalDeviceSynchronization2Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM:
        {
            VkPhysicalDeviceTensorFeaturesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTensorFeaturesARM32 *in_ext = (const VkPhysicalDeviceTensorFeaturesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorNonPacked = in_ext->tensorNonPacked;
            out_ext->shaderTensorAccess = in_ext->shaderTensorAccess;
            out_ext->shaderStorageTensorArrayDynamicIndexing = in_ext->shaderStorageTensorArrayDynamicIndexing;
            out_ext->shaderStorageTensorArrayNonUniformIndexing = in_ext->shaderStorageTensorArrayNonUniformIndexing;
            out_ext->descriptorBindingStorageTensorUpdateAfterBind = in_ext->descriptorBindingStorageTensorUpdateAfterBind;
            out_ext->tensors = in_ext->tensors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32 *in_ext = (const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->texelBufferAlignment = in_ext->texelBufferAlignment;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
            VkPhysicalDeviceTextureCompressionASTCHDRFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 *in_ext = (const VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
            out_ext->pNext = NULL;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM:
        {
            VkPhysicalDeviceTileMemoryHeapFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileMemoryHeap = in_ext->tileMemoryHeap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
            VkPhysicalDeviceTilePropertiesFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTilePropertiesFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceTilePropertiesFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileProperties = in_ext->tileProperties;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM:
        {
            VkPhysicalDeviceTileShadingFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTileShadingFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceTileShadingFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->tileShading = in_ext->tileShading;
            out_ext->tileShadingFragmentStage = in_ext->tileShadingFragmentStage;
            out_ext->tileShadingColorAttachments = in_ext->tileShadingColorAttachments;
            out_ext->tileShadingDepthAttachments = in_ext->tileShadingDepthAttachments;
            out_ext->tileShadingStencilAttachments = in_ext->tileShadingStencilAttachments;
            out_ext->tileShadingInputAttachments = in_ext->tileShadingInputAttachments;
            out_ext->tileShadingSampledAttachments = in_ext->tileShadingSampledAttachments;
            out_ext->tileShadingPerTileDraw = in_ext->tileShadingPerTileDraw;
            out_ext->tileShadingPerTileDispatch = in_ext->tileShadingPerTileDispatch;
            out_ext->tileShadingDispatchTile = in_ext->tileShadingDispatchTile;
            out_ext->tileShadingApron = in_ext->tileShadingApron;
            out_ext->tileShadingAnisotropicApron = in_ext->tileShadingAnisotropicApron;
            out_ext->tileShadingAtomicOps = in_ext->tileShadingAtomicOps;
            out_ext->tileShadingImageProcessing = in_ext->tileShadingImageProcessing;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            VkPhysicalDeviceTimelineSemaphoreFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTimelineSemaphoreFeatures32 *in_ext = (const VkPhysicalDeviceTimelineSemaphoreFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
            out_ext->pNext = NULL;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTransformFeedbackFeaturesEXT32 *in_ext = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->transformFeedback = in_ext->transformFeedback;
            out_ext->geometryStreams = in_ext->geometryStreams;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR:
        {
            VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR32 *in_ext = (const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->unifiedImageLayouts = in_ext->unifiedImageLayouts;
            out_ext->unifiedImageLayoutsVideo = in_ext->unifiedImageLayoutsVideo;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 *in_ext = (const VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
            out_ext->pNext = NULL;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            VkPhysicalDeviceVariablePointersFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVariablePointersFeatures32 *in_ext = (const VkPhysicalDeviceVariablePointersFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
            out_ext->pNext = NULL;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES:
        {
            VkPhysicalDeviceVertexAttributeDivisorFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexAttributeDivisorFeatures32 *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
            out_ext->pNext = NULL;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT32 *in_ext = (const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexAttributeRobustness = in_ext->vertexAttributeRobustness;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32 *in_ext = (const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->vertexInputDynamicState = in_ext->vertexInputDynamicState;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoDecodeVP9FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR32 *in_ext = (const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoDecodeVP9 = in_ext->videoDecodeVP9;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeAV1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR32 *in_ext = (const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoEncodeAV1 = in_ext->videoEncodeAV1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR32 *in_ext = (const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoEncodeIntraRefresh = in_ext->videoEncodeIntraRefresh;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR32 *in_ext = (const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoEncodeQuantizationMap = in_ext->videoEncodeQuantizationMap;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoMaintenance1FeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVideoMaintenance1FeaturesKHR32 *in_ext = (const VkPhysicalDeviceVideoMaintenance1FeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->videoMaintenance1 = in_ext->videoMaintenance1;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            VkPhysicalDeviceVulkan11Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan11Features32 *in_ext = (const VkPhysicalDeviceVulkan11Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
            out_ext->pNext = NULL;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            VkPhysicalDeviceVulkan12Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan12Features32 *in_ext = (const VkPhysicalDeviceVulkan12Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
            out_ext->pNext = NULL;
            out_ext->samplerMirrorClampToEdge = in_ext->samplerMirrorClampToEdge;
            out_ext->drawIndirectCount = in_ext->drawIndirectCount;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_ext->descriptorIndexing = in_ext->descriptorIndexing;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_ext->samplerFilterMinmax = in_ext->samplerFilterMinmax;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_ext->shaderOutputViewportIndex = in_ext->shaderOutputViewportIndex;
            out_ext->shaderOutputLayer = in_ext->shaderOutputLayer;
            out_ext->subgroupBroadcastDynamicId = in_ext->subgroupBroadcastDynamicId;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
            VkPhysicalDeviceVulkan13Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan13Features32 *in_ext = (const VkPhysicalDeviceVulkan13Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
            out_ext->pNext = NULL;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_ext->privateData = in_ext->privateData;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES:
        {
            VkPhysicalDeviceVulkan14Features *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkan14Features32 *in_ext = (const VkPhysicalDeviceVulkan14Features32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES;
            out_ext->pNext = NULL;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_ext->shaderSubgroupRotate = in_ext->shaderSubgroupRotate;
            out_ext->shaderSubgroupRotateClustered = in_ext->shaderSubgroupRotateClustered;
            out_ext->shaderFloatControls2 = in_ext->shaderFloatControls2;
            out_ext->shaderExpectAssume = in_ext->shaderExpectAssume;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_ext->dynamicRenderingLocalRead = in_ext->dynamicRenderingLocalRead;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_ext->maintenance6 = in_ext->maintenance6;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_ext->pushDescriptor = in_ext->pushDescriptor;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            VkPhysicalDeviceVulkanMemoryModelFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceVulkanMemoryModelFeatures32 *in_ext = (const VkPhysicalDeviceVulkanMemoryModelFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
            out_ext->pNext = NULL;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32 *in_ext = (const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
            out_ext->pNext = NULL;
            out_ext->workgroupMemoryExplicitLayout = in_ext->workgroupMemoryExplicitLayout;
            out_ext->workgroupMemoryExplicitLayoutScalarBlockLayout = in_ext->workgroupMemoryExplicitLayoutScalarBlockLayout;
            out_ext->workgroupMemoryExplicitLayout8BitAccess = in_ext->workgroupMemoryExplicitLayout8BitAccess;
            out_ext->workgroupMemoryExplicitLayout16BitAccess = in_ext->workgroupMemoryExplicitLayout16BitAccess;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32 *in_ext = (const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcr2plane444Formats = in_ext->ycbcr2plane444Formats;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
            VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32 *in_ext = (const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM;
            out_ext->pNext = NULL;
            out_ext->ycbcrDegamma = in_ext->ycbcrDegamma;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32 *in_ext = (const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->ycbcrImageArrays = in_ext->ycbcrImageArrays;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT32 *in_ext = (const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT;
            out_ext->pNext = NULL;
            out_ext->zeroInitializeDeviceMemory = in_ext->zeroInitializeDeviceMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 *in_ext = (const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
            out_ext->pNext = NULL;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkPhysicalDeviceFeatures2_host_to_win32(const VkPhysicalDeviceFeatures2 *in, VkPhysicalDeviceFeatures232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->features = in->features;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice16BitStorageFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES);
            const VkPhysicalDevice16BitStorageFeatures *in_ext = (const VkPhysicalDevice16BitStorageFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDevice4444FormatsFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT);
            const VkPhysicalDevice4444FormatsFeaturesEXT *in_ext = (const VkPhysicalDevice4444FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
            out_ext->formatA4R4G4B4 = in_ext->formatA4R4G4B4;
            out_ext->formatA4B4G4R4 = in_ext->formatA4B4G4R4;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {
            VkPhysicalDevice8BitStorageFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES);
            const VkPhysicalDevice8BitStorageFeatures *in_ext = (const VkPhysicalDevice8BitStorageFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {
            VkPhysicalDeviceASTCDecodeFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT);
            const VkPhysicalDeviceASTCDecodeFeaturesEXT *in_ext = (const VkPhysicalDeviceASTCDecodeFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
            out_ext->decodeModeSharedExponent = in_ext->decodeModeSharedExponent;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {
            VkPhysicalDeviceAccelerationStructureFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR);
            const VkPhysicalDeviceAccelerationStructureFeaturesKHR *in_ext = (const VkPhysicalDeviceAccelerationStructureFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
            out_ext->accelerationStructure = in_ext->accelerationStructure;
            out_ext->accelerationStructureCaptureReplay = in_ext->accelerationStructureCaptureReplay;
            out_ext->accelerationStructureIndirectBuild = in_ext->accelerationStructureIndirectBuild;
            out_ext->accelerationStructureHostCommands = in_ext->accelerationStructureHostCommands;
            out_ext->descriptorBindingAccelerationStructureUpdateAfterBind = in_ext->descriptorBindingAccelerationStructureUpdateAfterBind;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
        {
            VkPhysicalDeviceAddressBindingReportFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT);
            const VkPhysicalDeviceAddressBindingReportFeaturesEXT *in_ext = (const VkPhysicalDeviceAddressBindingReportFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
            out_ext->reportAddressBinding = in_ext->reportAddressBinding;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD:
        {
            VkPhysicalDeviceAntiLagFeaturesAMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD);
            const VkPhysicalDeviceAntiLagFeaturesAMD *in_ext = (const VkPhysicalDeviceAntiLagFeaturesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD;
            out_ext->antiLag = in_ext->antiLag;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT);
            const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->attachmentFeedbackLoopDynamicState = in_ext->attachmentFeedbackLoopDynamicState;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
        {
            VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT);
            const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *in_ext = (const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
            out_ext->attachmentFeedbackLoopLayout = in_ext->attachmentFeedbackLoopLayout;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT);
            const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *in_ext = (const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
            out_ext->advancedBlendCoherentOperations = in_ext->advancedBlendCoherentOperations;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
        {
            VkPhysicalDeviceBorderColorSwizzleFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT);
            const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *in_ext = (const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
            out_ext->borderColorSwizzle = in_ext->borderColorSwizzle;
            out_ext->borderColorSwizzleFromImage = in_ext->borderColorSwizzleFromImage;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {
            VkPhysicalDeviceBufferDeviceAddressFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES);
            const VkPhysicalDeviceBufferDeviceAddressFeatures *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT);
            const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *in_ext = (const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV:
        {
            VkPhysicalDeviceClusterAccelerationStructureFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV);
            const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV *in_ext = (const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV;
            out_ext->clusterAccelerationStructure = in_ext->clusterAccelerationStructure;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI);
            const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
            out_ext->clustercullingShader = in_ext->clustercullingShader;
            out_ext->multiviewClusterCullingShader = in_ext->multiviewClusterCullingShader;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {
            VkPhysicalDeviceCoherentMemoryFeaturesAMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD);
            const VkPhysicalDeviceCoherentMemoryFeaturesAMD *in_ext = (const VkPhysicalDeviceCoherentMemoryFeaturesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
            out_ext->deviceCoherentMemory = in_ext->deviceCoherentMemory;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceColorWriteEnableFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT);
            const VkPhysicalDeviceColorWriteEnableFeaturesEXT *in_ext = (const VkPhysicalDeviceColorWriteEnableFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
            out_ext->colorWriteEnable = in_ext->colorWriteEnable;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV:
        {
            VkPhysicalDeviceCommandBufferInheritanceFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV);
            const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV *in_ext = (const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV;
            out_ext->commandBufferInheritance = in_ext->commandBufferInheritance;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR:
        {
            VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR);
            const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR *in_ext = (const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR;
            out_ext->computeDerivativeGroupQuads = in_ext->computeDerivativeGroupQuads;
            out_ext->computeDerivativeGroupLinear = in_ext->computeDerivativeGroupLinear;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {
            VkPhysicalDeviceConditionalRenderingFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT);
            const VkPhysicalDeviceConditionalRenderingFeaturesEXT *in_ext = (const VkPhysicalDeviceConditionalRenderingFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
            out_ext->conditionalRendering = in_ext->conditionalRendering;
            out_ext->inheritedConditionalRendering = in_ext->inheritedConditionalRendering;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrix2FeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV);
            const VkPhysicalDeviceCooperativeMatrix2FeaturesNV *in_ext = (const VkPhysicalDeviceCooperativeMatrix2FeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV;
            out_ext->cooperativeMatrixWorkgroupScope = in_ext->cooperativeMatrixWorkgroupScope;
            out_ext->cooperativeMatrixFlexibleDimensions = in_ext->cooperativeMatrixFlexibleDimensions;
            out_ext->cooperativeMatrixReductions = in_ext->cooperativeMatrixReductions;
            out_ext->cooperativeMatrixConversions = in_ext->cooperativeMatrixConversions;
            out_ext->cooperativeMatrixPerElementOperations = in_ext->cooperativeMatrixPerElementOperations;
            out_ext->cooperativeMatrixTensorAddressing = in_ext->cooperativeMatrixTensorAddressing;
            out_ext->cooperativeMatrixBlockLoads = in_ext->cooperativeMatrixBlockLoads;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR);
            const VkPhysicalDeviceCooperativeMatrixFeaturesKHR *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV);
            const VkPhysicalDeviceCooperativeMatrixFeaturesNV *in_ext = (const VkPhysicalDeviceCooperativeMatrixFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
            out_ext->cooperativeMatrix = in_ext->cooperativeMatrix;
            out_ext->cooperativeMatrixRobustBufferAccess = in_ext->cooperativeMatrixRobustBufferAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV:
        {
            VkPhysicalDeviceCooperativeVectorFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV);
            const VkPhysicalDeviceCooperativeVectorFeaturesNV *in_ext = (const VkPhysicalDeviceCooperativeVectorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV;
            out_ext->cooperativeVector = in_ext->cooperativeVector;
            out_ext->cooperativeVectorTraining = in_ext->cooperativeVectorTraining;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV);
            const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *in_ext = (const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
            out_ext->indirectCopy = in_ext->indirectCopy;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceCornerSampledImageFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV);
            const VkPhysicalDeviceCornerSampledImageFeaturesNV *in_ext = (const VkPhysicalDeviceCornerSampledImageFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
            out_ext->cornerSampledImage = in_ext->cornerSampledImage;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {
            VkPhysicalDeviceCoverageReductionModeFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV);
            const VkPhysicalDeviceCoverageReductionModeFeaturesNV *in_ext = (const VkPhysicalDeviceCoverageReductionModeFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
            out_ext->coverageReductionMode = in_ext->coverageReductionMode;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicClampFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM);
            const VkPhysicalDeviceCubicClampFeaturesQCOM *in_ext = (const VkPhysicalDeviceCubicClampFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM;
            out_ext->cubicRangeClamp = in_ext->cubicRangeClamp;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceCubicWeightsFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM);
            const VkPhysicalDeviceCubicWeightsFeaturesQCOM *in_ext = (const VkPhysicalDeviceCubicWeightsFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM;
            out_ext->selectableCubicWeights = in_ext->selectableCubicWeights;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT);
            const VkPhysicalDeviceCustomBorderColorFeaturesEXT *in_ext = (const VkPhysicalDeviceCustomBorderColorFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
            out_ext->customBorderColors = in_ext->customBorderColors;
            out_ext->customBorderColorWithoutFormat = in_ext->customBorderColorWithoutFormat;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM:
        {
            VkPhysicalDeviceDataGraphFeaturesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM);
            const VkPhysicalDeviceDataGraphFeaturesARM *in_ext = (const VkPhysicalDeviceDataGraphFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM;
            out_ext->dataGraph = in_ext->dataGraph;
            out_ext->dataGraphUpdateAfterBind = in_ext->dataGraphUpdateAfterBind;
            out_ext->dataGraphSpecializationConstants = in_ext->dataGraphSpecializationConstants;
            out_ext->dataGraphDescriptorBuffer = in_ext->dataGraphDescriptorBuffer;
            out_ext->dataGraphShaderModule = in_ext->dataGraphShaderModule;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV);
            const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *in_ext = (const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
            out_ext->dedicatedAllocationImageAliasing = in_ext->dedicatedAllocationImageAliasing;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthBiasControlFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT);
            const VkPhysicalDeviceDepthBiasControlFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthBiasControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
            out_ext->depthBiasControl = in_ext->depthBiasControl;
            out_ext->leastRepresentableValueForceUnormRepresentation = in_ext->leastRepresentableValueForceUnormRepresentation;
            out_ext->floatRepresentation = in_ext->floatRepresentation;
            out_ext->depthBiasExact = in_ext->depthBiasExact;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClampControlFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT);
            const VkPhysicalDeviceDepthClampControlFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClampControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT;
            out_ext->depthClampControl = in_ext->depthClampControl;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR:
        {
            VkPhysicalDeviceDepthClampZeroOneFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR);
            const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR *in_ext = (const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR;
            out_ext->depthClampZeroOne = in_ext->depthClampZeroOne;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipControlFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT);
            const VkPhysicalDeviceDepthClipControlFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClipControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
            out_ext->depthClipControl = in_ext->depthClipControl;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {
            VkPhysicalDeviceDepthClipEnableFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT);
            const VkPhysicalDeviceDepthClipEnableFeaturesEXT *in_ext = (const VkPhysicalDeviceDepthClipEnableFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
            out_ext->depthClipEnable = in_ext->depthClipEnable;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT);
            const VkPhysicalDeviceDescriptorBufferFeaturesEXT *in_ext = (const VkPhysicalDeviceDescriptorBufferFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
            out_ext->descriptorBuffer = in_ext->descriptorBuffer;
            out_ext->descriptorBufferCaptureReplay = in_ext->descriptorBufferCaptureReplay;
            out_ext->descriptorBufferImageLayoutIgnored = in_ext->descriptorBufferImageLayoutIgnored;
            out_ext->descriptorBufferPushDescriptors = in_ext->descriptorBufferPushDescriptors;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM:
        {
            VkPhysicalDeviceDescriptorBufferTensorFeaturesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM);
            const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM *in_ext = (const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM;
            out_ext->descriptorBufferTensorDescriptors = in_ext->descriptorBufferTensorDescriptors;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {
            VkPhysicalDeviceDescriptorIndexingFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES);
            const VkPhysicalDeviceDescriptorIndexingFeatures *in_ext = (const VkPhysicalDeviceDescriptorIndexingFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
        {
            VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV);
            const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *in_ext = (const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV;
            out_ext->descriptorPoolOverallocation = in_ext->descriptorPoolOverallocation;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
        {
            VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE);
            const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *in_ext = (const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
            out_ext->descriptorSetHostMapping = in_ext->descriptorSetHostMapping;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV);
            const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV;
            out_ext->deviceGeneratedCompute = in_ext->deviceGeneratedCompute;
            out_ext->deviceGeneratedComputePipelines = in_ext->deviceGeneratedComputePipelines;
            out_ext->deviceGeneratedComputeCaptureReplay = in_ext->deviceGeneratedComputeCaptureReplay;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT);
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_ext->dynamicGeneratedPipelineLayout = in_ext->dynamicGeneratedPipelineLayout;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV);
            const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
            out_ext->deviceGeneratedCommands = in_ext->deviceGeneratedCommands;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV);
            const VkPhysicalDeviceDiagnosticsConfigFeaturesNV *in_ext = (const VkPhysicalDeviceDiagnosticsConfigFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
            out_ext->diagnosticsConfig = in_ext->diagnosticsConfig;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES);
            const VkPhysicalDeviceDynamicRenderingFeatures *in_ext = (const VkPhysicalDeviceDynamicRenderingFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES:
        {
            VkPhysicalDeviceDynamicRenderingLocalReadFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES);
            const VkPhysicalDeviceDynamicRenderingLocalReadFeatures *in_ext = (const VkPhysicalDeviceDynamicRenderingLocalReadFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
            out_ext->dynamicRenderingLocalRead = in_ext->dynamicRenderingLocalRead;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
        {
            VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT);
            const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *in_ext = (const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
            out_ext->dynamicRenderingUnusedAttachments = in_ext->dynamicRenderingUnusedAttachments;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceExclusiveScissorFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV);
            const VkPhysicalDeviceExclusiveScissorFeaturesNV *in_ext = (const VkPhysicalDeviceExclusiveScissorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
            out_ext->exclusiveScissor = in_ext->exclusiveScissor;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT);
            const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
            out_ext->extendedDynamicState2 = in_ext->extendedDynamicState2;
            out_ext->extendedDynamicState2LogicOp = in_ext->extendedDynamicState2LogicOp;
            out_ext->extendedDynamicState2PatchControlPoints = in_ext->extendedDynamicState2PatchControlPoints;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT);
            const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
            out_ext->extendedDynamicState3TessellationDomainOrigin = in_ext->extendedDynamicState3TessellationDomainOrigin;
            out_ext->extendedDynamicState3DepthClampEnable = in_ext->extendedDynamicState3DepthClampEnable;
            out_ext->extendedDynamicState3PolygonMode = in_ext->extendedDynamicState3PolygonMode;
            out_ext->extendedDynamicState3RasterizationSamples = in_ext->extendedDynamicState3RasterizationSamples;
            out_ext->extendedDynamicState3SampleMask = in_ext->extendedDynamicState3SampleMask;
            out_ext->extendedDynamicState3AlphaToCoverageEnable = in_ext->extendedDynamicState3AlphaToCoverageEnable;
            out_ext->extendedDynamicState3AlphaToOneEnable = in_ext->extendedDynamicState3AlphaToOneEnable;
            out_ext->extendedDynamicState3LogicOpEnable = in_ext->extendedDynamicState3LogicOpEnable;
            out_ext->extendedDynamicState3ColorBlendEnable = in_ext->extendedDynamicState3ColorBlendEnable;
            out_ext->extendedDynamicState3ColorBlendEquation = in_ext->extendedDynamicState3ColorBlendEquation;
            out_ext->extendedDynamicState3ColorWriteMask = in_ext->extendedDynamicState3ColorWriteMask;
            out_ext->extendedDynamicState3RasterizationStream = in_ext->extendedDynamicState3RasterizationStream;
            out_ext->extendedDynamicState3ConservativeRasterizationMode = in_ext->extendedDynamicState3ConservativeRasterizationMode;
            out_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize = in_ext->extendedDynamicState3ExtraPrimitiveOverestimationSize;
            out_ext->extendedDynamicState3DepthClipEnable = in_ext->extendedDynamicState3DepthClipEnable;
            out_ext->extendedDynamicState3SampleLocationsEnable = in_ext->extendedDynamicState3SampleLocationsEnable;
            out_ext->extendedDynamicState3ColorBlendAdvanced = in_ext->extendedDynamicState3ColorBlendAdvanced;
            out_ext->extendedDynamicState3ProvokingVertexMode = in_ext->extendedDynamicState3ProvokingVertexMode;
            out_ext->extendedDynamicState3LineRasterizationMode = in_ext->extendedDynamicState3LineRasterizationMode;
            out_ext->extendedDynamicState3LineStippleEnable = in_ext->extendedDynamicState3LineStippleEnable;
            out_ext->extendedDynamicState3DepthClipNegativeOneToOne = in_ext->extendedDynamicState3DepthClipNegativeOneToOne;
            out_ext->extendedDynamicState3ViewportWScalingEnable = in_ext->extendedDynamicState3ViewportWScalingEnable;
            out_ext->extendedDynamicState3ViewportSwizzle = in_ext->extendedDynamicState3ViewportSwizzle;
            out_ext->extendedDynamicState3CoverageToColorEnable = in_ext->extendedDynamicState3CoverageToColorEnable;
            out_ext->extendedDynamicState3CoverageToColorLocation = in_ext->extendedDynamicState3CoverageToColorLocation;
            out_ext->extendedDynamicState3CoverageModulationMode = in_ext->extendedDynamicState3CoverageModulationMode;
            out_ext->extendedDynamicState3CoverageModulationTableEnable = in_ext->extendedDynamicState3CoverageModulationTableEnable;
            out_ext->extendedDynamicState3CoverageModulationTable = in_ext->extendedDynamicState3CoverageModulationTable;
            out_ext->extendedDynamicState3CoverageReductionMode = in_ext->extendedDynamicState3CoverageReductionMode;
            out_ext->extendedDynamicState3RepresentativeFragmentTestEnable = in_ext->extendedDynamicState3RepresentativeFragmentTestEnable;
            out_ext->extendedDynamicState3ShadingRateImageEnable = in_ext->extendedDynamicState3ShadingRateImageEnable;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT);
            const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->extendedDynamicState = in_ext->extendedDynamicState;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV);
            const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *in_ext = (const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV;
            out_ext->extendedSparseAddressSpace = in_ext->extendedSparseAddressSpace;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
        {
            VkPhysicalDeviceFaultFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT);
            const VkPhysicalDeviceFaultFeaturesEXT *in_ext = (const VkPhysicalDeviceFaultFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
            out_ext->deviceFault = in_ext->deviceFault;
            out_ext->deviceFaultVendorBinary = in_ext->deviceFaultVendorBinary;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM:
        {
            VkPhysicalDeviceFormatPackFeaturesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM);
            const VkPhysicalDeviceFormatPackFeaturesARM *in_ext = (const VkPhysicalDeviceFormatPackFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM;
            out_ext->formatPack = in_ext->formatPack;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT);
            const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
            out_ext->fragmentDensityMapDeferred = in_ext->fragmentDensityMapDeferred;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT);
            const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
            out_ext->fragmentDensityMap = in_ext->fragmentDensityMap;
            out_ext->fragmentDensityMapDynamic = in_ext->fragmentDensityMapDynamic;
            out_ext->fragmentDensityMapNonSubsampledImages = in_ext->fragmentDensityMapNonSubsampledImages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE:
        {
            VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE);
            const VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE *in_ext = (const VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE;
            out_ext->fragmentDensityMapLayered = in_ext->fragmentDensityMapLayered;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT);
            const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT;
            out_ext->fragmentDensityMapOffset = in_ext->fragmentDensityMapOffset;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR);
            const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *in_ext = (const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
            out_ext->fragmentShaderBarycentric = in_ext->fragmentShaderBarycentric;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT);
            const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *in_ext = (const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
            out_ext->fragmentShaderSampleInterlock = in_ext->fragmentShaderSampleInterlock;
            out_ext->fragmentShaderPixelInterlock = in_ext->fragmentShaderPixelInterlock;
            out_ext->fragmentShaderShadingRateInterlock = in_ext->fragmentShaderShadingRateInterlock;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV);
            const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
            out_ext->fragmentShadingRateEnums = in_ext->fragmentShadingRateEnums;
            out_ext->supersampleFragmentShadingRates = in_ext->supersampleFragmentShadingRates;
            out_ext->noInvocationFragmentShadingRates = in_ext->noInvocationFragmentShadingRates;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR);
            const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *in_ext = (const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
            out_ext->pipelineFragmentShadingRate = in_ext->pipelineFragmentShadingRate;
            out_ext->primitiveFragmentShadingRate = in_ext->primitiveFragmentShadingRate;
            out_ext->attachmentFragmentShadingRate = in_ext->attachmentFragmentShadingRate;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
        {
            VkPhysicalDeviceFrameBoundaryFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT);
            const VkPhysicalDeviceFrameBoundaryFeaturesEXT *in_ext = (const VkPhysicalDeviceFrameBoundaryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT;
            out_ext->frameBoundary = in_ext->frameBoundary;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES:
        {
            VkPhysicalDeviceGlobalPriorityQueryFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES);
            const VkPhysicalDeviceGlobalPriorityQueryFeatures *in_ext = (const VkPhysicalDeviceGlobalPriorityQueryFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT);
            const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
            out_ext->graphicsPipelineLibrary = in_ext->graphicsPipelineLibrary;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceHdrVividFeaturesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI);
            const VkPhysicalDeviceHdrVividFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceHdrVividFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI;
            out_ext->hdrVivid = in_ext->hdrVivid;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES:
        {
            VkPhysicalDeviceHostImageCopyFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES);
            const VkPhysicalDeviceHostImageCopyFeatures *in_ext = (const VkPhysicalDeviceHostImageCopyFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {
            VkPhysicalDeviceHostQueryResetFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES);
            const VkPhysicalDeviceHostQueryResetFeatures *in_ext = (const VkPhysicalDeviceHostQueryResetFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImage2DViewOf3DFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT);
            const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *in_ext = (const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
            out_ext->image2DViewOf3D = in_ext->image2DViewOf3D;
            out_ext->sampler2DViewOf3D = in_ext->sampler2DViewOf3D;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA:
        {
            VkPhysicalDeviceImageAlignmentControlFeaturesMESA32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA);
            const VkPhysicalDeviceImageAlignmentControlFeaturesMESA *in_ext = (const VkPhysicalDeviceImageAlignmentControlFeaturesMESA *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA;
            out_ext->imageAlignmentControl = in_ext->imageAlignmentControl;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT);
            const VkPhysicalDeviceImageCompressionControlFeaturesEXT *in_ext = (const VkPhysicalDeviceImageCompressionControlFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
            out_ext->imageCompressionControl = in_ext->imageCompressionControl;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
        {
            VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT);
            const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *in_ext = (const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
            out_ext->imageCompressionControlSwapchain = in_ext->imageCompressionControlSwapchain;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2FeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM);
            const VkPhysicalDeviceImageProcessing2FeaturesQCOM *in_ext = (const VkPhysicalDeviceImageProcessing2FeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM;
            out_ext->textureBlockMatch2 = in_ext->textureBlockMatch2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
        {
            VkPhysicalDeviceImageProcessingFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM);
            const VkPhysicalDeviceImageProcessingFeaturesQCOM *in_ext = (const VkPhysicalDeviceImageProcessingFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
            out_ext->textureSampleWeighted = in_ext->textureSampleWeighted;
            out_ext->textureBoxFilter = in_ext->textureBoxFilter;
            out_ext->textureBlockMatch = in_ext->textureBlockMatch;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDeviceImageRobustnessFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES);
            const VkPhysicalDeviceImageRobustnessFeatures *in_ext = (const VkPhysicalDeviceImageRobustnessFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
        {
            VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT);
            const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *in_ext = (const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
            out_ext->imageSlicedViewOf3D = in_ext->imageSlicedViewOf3D;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
        {
            VkPhysicalDeviceImageViewMinLodFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT);
            const VkPhysicalDeviceImageViewMinLodFeaturesEXT *in_ext = (const VkPhysicalDeviceImageViewMinLodFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
            out_ext->minLod = in_ext->minLod;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {
            VkPhysicalDeviceImagelessFramebufferFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES);
            const VkPhysicalDeviceImagelessFramebufferFeatures *in_ext = (const VkPhysicalDeviceImagelessFramebufferFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES:
        {
            VkPhysicalDeviceIndexTypeUint8Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES);
            const VkPhysicalDeviceIndexTypeUint8Features *in_ext = (const VkPhysicalDeviceIndexTypeUint8Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV);
            const VkPhysicalDeviceInheritedViewportScissorFeaturesNV *in_ext = (const VkPhysicalDeviceInheritedViewportScissorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
            out_ext->inheritedViewportScissor2D = in_ext->inheritedViewportScissor2D;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
        {
            VkPhysicalDeviceInlineUniformBlockFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES);
            const VkPhysicalDeviceInlineUniformBlockFeatures *in_ext = (const VkPhysicalDeviceInlineUniformBlockFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceInvocationMaskFeaturesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI);
            const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
            out_ext->invocationMask = in_ext->invocationMask;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyDitheringFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT);
            const VkPhysicalDeviceLegacyDitheringFeaturesEXT *in_ext = (const VkPhysicalDeviceLegacyDitheringFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
            out_ext->legacyDithering = in_ext->legacyDithering;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT:
        {
            VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT);
            const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT *in_ext = (const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT;
            out_ext->legacyVertexAttributes = in_ext->legacyVertexAttributes;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES:
        {
            VkPhysicalDeviceLineRasterizationFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES);
            const VkPhysicalDeviceLineRasterizationFeatures *in_ext = (const VkPhysicalDeviceLineRasterizationFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
        {
            VkPhysicalDeviceLinearColorAttachmentFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV);
            const VkPhysicalDeviceLinearColorAttachmentFeaturesNV *in_ext = (const VkPhysicalDeviceLinearColorAttachmentFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
            out_ext->linearColorAttachment = in_ext->linearColorAttachment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
        {
            VkPhysicalDeviceMaintenance4Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES);
            const VkPhysicalDeviceMaintenance4Features *in_ext = (const VkPhysicalDeviceMaintenance4Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES:
        {
            VkPhysicalDeviceMaintenance5Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES);
            const VkPhysicalDeviceMaintenance5Features *in_ext = (const VkPhysicalDeviceMaintenance5Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES:
        {
            VkPhysicalDeviceMaintenance6Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES);
            const VkPhysicalDeviceMaintenance6Features *in_ext = (const VkPhysicalDeviceMaintenance6Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
            out_ext->maintenance6 = in_ext->maintenance6;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance8FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR);
            const VkPhysicalDeviceMaintenance8FeaturesKHR *in_ext = (const VkPhysicalDeviceMaintenance8FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR;
            out_ext->maintenance8 = in_ext->maintenance8;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR:
        {
            VkPhysicalDeviceMaintenance9FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR);
            const VkPhysicalDeviceMaintenance9FeaturesKHR *in_ext = (const VkPhysicalDeviceMaintenance9FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR;
            out_ext->maintenance9 = in_ext->maintenance9;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV);
            const VkPhysicalDeviceMemoryDecompressionFeaturesNV *in_ext = (const VkPhysicalDeviceMemoryDecompressionFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
            out_ext->memoryDecompression = in_ext->memoryDecompression;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {
            VkPhysicalDeviceMemoryPriorityFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT);
            const VkPhysicalDeviceMemoryPriorityFeaturesEXT *in_ext = (const VkPhysicalDeviceMemoryPriorityFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
            out_ext->memoryPriority = in_ext->memoryPriority;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
        {
            VkPhysicalDeviceMeshShaderFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT);
            const VkPhysicalDeviceMeshShaderFeaturesEXT *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_ext->multiviewMeshShader = in_ext->multiviewMeshShader;
            out_ext->primitiveFragmentShadingRateMeshShader = in_ext->primitiveFragmentShadingRateMeshShader;
            out_ext->meshShaderQueries = in_ext->meshShaderQueries;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {
            VkPhysicalDeviceMeshShaderFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV);
            const VkPhysicalDeviceMeshShaderFeaturesNV *in_ext = (const VkPhysicalDeviceMeshShaderFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
            out_ext->taskShader = in_ext->taskShader;
            out_ext->meshShader = in_ext->meshShader;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {
            VkPhysicalDeviceMultiDrawFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT);
            const VkPhysicalDeviceMultiDrawFeaturesEXT *in_ext = (const VkPhysicalDeviceMultiDrawFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
            out_ext->multiDraw = in_ext->multiDraw;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
        {
            VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT);
            const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *in_ext = (const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
            out_ext->multisampledRenderToSingleSampled = in_ext->multisampledRenderToSingleSampled;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {
            VkPhysicalDeviceMultiviewFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES);
            const VkPhysicalDeviceMultiviewFeatures *in_ext = (const VkPhysicalDeviceMultiviewFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM);
            const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *in_ext = (const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
            out_ext->multiviewPerViewRenderAreas = in_ext->multiviewPerViewRenderAreas;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
        {
            VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM);
            const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *in_ext = (const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
            out_ext->multiviewPerViewViewports = in_ext->multiviewPerViewViewports;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
        {
            VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT);
            const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *in_ext = (const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
            out_ext->mutableDescriptorType = in_ext->mutableDescriptorType;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT);
            const VkPhysicalDeviceNestedCommandBufferFeaturesEXT *in_ext = (const VkPhysicalDeviceNestedCommandBufferFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT;
            out_ext->nestedCommandBuffer = in_ext->nestedCommandBuffer;
            out_ext->nestedCommandBufferRendering = in_ext->nestedCommandBufferRendering;
            out_ext->nestedCommandBufferSimultaneousUse = in_ext->nestedCommandBufferSimultaneousUse;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
        {
            VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT);
            const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *in_ext = (const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
            out_ext->nonSeamlessCubeMap = in_ext->nonSeamlessCubeMap;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT);
            const VkPhysicalDeviceOpacityMicromapFeaturesEXT *in_ext = (const VkPhysicalDeviceOpacityMicromapFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
            out_ext->micromap = in_ext->micromap;
            out_ext->micromapCaptureReplay = in_ext->micromapCaptureReplay;
            out_ext->micromapHostCommands = in_ext->micromapHostCommands;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
        {
            VkPhysicalDeviceOpticalFlowFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV);
            const VkPhysicalDeviceOpticalFlowFeaturesNV *in_ext = (const VkPhysicalDeviceOpticalFlowFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
            out_ext->opticalFlow = in_ext->opticalFlow;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT);
            const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *in_ext = (const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
            out_ext->pageableDeviceLocalMemory = in_ext->pageableDeviceLocalMemory;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV:
        {
            VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV);
            const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV *in_ext = (const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV;
            out_ext->partitionedAccelerationStructure = in_ext->partitionedAccelerationStructure;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV:
        {
            VkPhysicalDevicePerStageDescriptorSetFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV);
            const VkPhysicalDevicePerStageDescriptorSetFeaturesNV *in_ext = (const VkPhysicalDevicePerStageDescriptorSetFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV;
            out_ext->perStageDescriptorSet = in_ext->perStageDescriptorSet;
            out_ext->dynamicPipelineLayout = in_ext->dynamicPipelineLayout;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {
            VkPhysicalDevicePerformanceQueryFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR);
            const VkPhysicalDevicePerformanceQueryFeaturesKHR *in_ext = (const VkPhysicalDevicePerformanceQueryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
            out_ext->performanceCounterQueryPools = in_ext->performanceCounterQueryPools;
            out_ext->performanceCounterMultipleQueryPools = in_ext->performanceCounterMultipleQueryPools;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineBinaryFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR);
            const VkPhysicalDevicePipelineBinaryFeaturesKHR *in_ext = (const VkPhysicalDevicePipelineBinaryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR;
            out_ext->pipelineBinaries = in_ext->pipelineBinaries;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC:
        {
            VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC);
            const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC *in_ext = (const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC;
            out_ext->pipelineCacheIncrementalMode = in_ext->pipelineCacheIncrementalMode;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
        {
            VkPhysicalDevicePipelineCreationCacheControlFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES);
            const VkPhysicalDevicePipelineCreationCacheControlFeatures *in_ext = (const VkPhysicalDevicePipelineCreationCacheControlFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR);
            const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *in_ext = (const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
            out_ext->pipelineExecutableInfo = in_ext->pipelineExecutableInfo;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT);
            const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *in_ext = (const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
            out_ext->pipelineLibraryGroupHandles = in_ext->pipelineLibraryGroupHandles;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM:
        {
            VkPhysicalDevicePipelineOpacityMicromapFeaturesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM);
            const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM *in_ext = (const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM;
            out_ext->pipelineOpacityMicromap = in_ext->pipelineOpacityMicromap;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
        {
            VkPhysicalDevicePipelinePropertiesFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT);
            const VkPhysicalDevicePipelinePropertiesFeaturesEXT *in_ext = (const VkPhysicalDevicePipelinePropertiesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
            out_ext->pipelinePropertiesIdentifier = in_ext->pipelinePropertiesIdentifier;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES:
        {
            VkPhysicalDevicePipelineProtectedAccessFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES);
            const VkPhysicalDevicePipelineProtectedAccessFeatures *in_ext = (const VkPhysicalDevicePipelineProtectedAccessFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES:
        {
            VkPhysicalDevicePipelineRobustnessFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES);
            const VkPhysicalDevicePipelineRobustnessFeatures *in_ext = (const VkPhysicalDevicePipelineRobustnessFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
        {
            VkPhysicalDevicePresentBarrierFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV);
            const VkPhysicalDevicePresentBarrierFeaturesNV *in_ext = (const VkPhysicalDevicePresentBarrierFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
            out_ext->presentBarrier = in_ext->presentBarrier;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR:
        {
            VkPhysicalDevicePresentId2FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR);
            const VkPhysicalDevicePresentId2FeaturesKHR *in_ext = (const VkPhysicalDevicePresentId2FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR;
            out_ext->presentId2 = in_ext->presentId2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {
            VkPhysicalDevicePresentIdFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR);
            const VkPhysicalDevicePresentIdFeaturesKHR *in_ext = (const VkPhysicalDevicePresentIdFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
            out_ext->presentId = in_ext->presentId;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR:
        {
            VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR);
            const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR *in_ext = (const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR;
            out_ext->presentModeFifoLatestReady = in_ext->presentModeFifoLatestReady;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWait2FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR);
            const VkPhysicalDevicePresentWait2FeaturesKHR *in_ext = (const VkPhysicalDevicePresentWait2FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR;
            out_ext->presentWait2 = in_ext->presentWait2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {
            VkPhysicalDevicePresentWaitFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR);
            const VkPhysicalDevicePresentWaitFeaturesKHR *in_ext = (const VkPhysicalDevicePresentWaitFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
            out_ext->presentWait = in_ext->presentWait;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT);
            const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *in_ext = (const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
            out_ext->primitiveTopologyListRestart = in_ext->primitiveTopologyListRestart;
            out_ext->primitiveTopologyPatchListRestart = in_ext->primitiveTopologyPatchListRestart;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
        {
            VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT);
            const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *in_ext = (const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
            out_ext->primitivesGeneratedQuery = in_ext->primitivesGeneratedQuery;
            out_ext->primitivesGeneratedQueryWithRasterizerDiscard = in_ext->primitivesGeneratedQueryWithRasterizerDiscard;
            out_ext->primitivesGeneratedQueryWithNonZeroStreams = in_ext->primitivesGeneratedQueryWithNonZeroStreams;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
        {
            VkPhysicalDevicePrivateDataFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES);
            const VkPhysicalDevicePrivateDataFeatures *in_ext = (const VkPhysicalDevicePrivateDataFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
            out_ext->privateData = in_ext->privateData;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {
            VkPhysicalDeviceProtectedMemoryFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES);
            const VkPhysicalDeviceProtectedMemoryFeatures *in_ext = (const VkPhysicalDeviceProtectedMemoryFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {
            VkPhysicalDeviceProvokingVertexFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT);
            const VkPhysicalDeviceProvokingVertexFeaturesEXT *in_ext = (const VkPhysicalDeviceProvokingVertexFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
            out_ext->provokingVertexLast = in_ext->provokingVertexLast;
            out_ext->transformFeedbackPreservesProvokingVertex = in_ext->transformFeedbackPreservesProvokingVertex;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT);
            const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *in_ext = (const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
            out_ext->formatRgba10x6WithoutYCbCrSampler = in_ext->formatRgba10x6WithoutYCbCrSampler;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
        {
            VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT);
            const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *in_ext = (const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
            out_ext->rasterizationOrderColorAttachmentAccess = in_ext->rasterizationOrderColorAttachmentAccess;
            out_ext->rasterizationOrderDepthAttachmentAccess = in_ext->rasterizationOrderDepthAttachmentAccess;
            out_ext->rasterizationOrderStencilAttachmentAccess = in_ext->rasterizationOrderStencilAttachmentAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV:
        {
            VkPhysicalDeviceRawAccessChainsFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV);
            const VkPhysicalDeviceRawAccessChainsFeaturesNV *in_ext = (const VkPhysicalDeviceRawAccessChainsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV;
            out_ext->shaderRawAccessChains = in_ext->shaderRawAccessChains;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {
            VkPhysicalDeviceRayQueryFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR);
            const VkPhysicalDeviceRayQueryFeaturesKHR *in_ext = (const VkPhysicalDeviceRayQueryFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
            out_ext->rayQuery = in_ext->rayQuery;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV);
            const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
            out_ext->rayTracingInvocationReorder = in_ext->rayTracingInvocationReorder;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV);
            const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV;
            out_ext->spheres = in_ext->spheres;
            out_ext->linearSweptSpheres = in_ext->linearSweptSpheres;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR);
            const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
            out_ext->rayTracingMaintenance1 = in_ext->rayTracingMaintenance1;
            out_ext->rayTracingPipelineTraceRaysIndirect2 = in_ext->rayTracingPipelineTraceRaysIndirect2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV);
            const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
            out_ext->rayTracingMotionBlur = in_ext->rayTracingMotionBlur;
            out_ext->rayTracingMotionBlurPipelineTraceRaysIndirect = in_ext->rayTracingMotionBlurPipelineTraceRaysIndirect;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR);
            const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
            out_ext->rayTracingPipeline = in_ext->rayTracingPipeline;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplay = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplay;
            out_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed = in_ext->rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
            out_ext->rayTracingPipelineTraceRaysIndirect = in_ext->rayTracingPipelineTraceRaysIndirect;
            out_ext->rayTraversalPrimitiveCulling = in_ext->rayTraversalPrimitiveCulling;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
        {
            VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR);
            const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *in_ext = (const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
            out_ext->rayTracingPositionFetch = in_ext->rayTracingPositionFetch;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV:
        {
            VkPhysicalDeviceRayTracingValidationFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV);
            const VkPhysicalDeviceRayTracingValidationFeaturesNV *in_ext = (const VkPhysicalDeviceRayTracingValidationFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV;
            out_ext->rayTracingValidation = in_ext->rayTracingValidation;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG:
        {
            VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG);
            const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG *in_ext = (const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG;
            out_ext->relaxedLineRasterization = in_ext->relaxedLineRasterization;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM:
        {
            VkPhysicalDeviceRenderPassStripedFeaturesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM);
            const VkPhysicalDeviceRenderPassStripedFeaturesARM *in_ext = (const VkPhysicalDeviceRenderPassStripedFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM;
            out_ext->renderPassStriped = in_ext->renderPassStriped;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV);
            const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *in_ext = (const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
            out_ext->representativeFragmentTest = in_ext->representativeFragmentTest;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR:
        {
            VkPhysicalDeviceRobustness2FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR);
            const VkPhysicalDeviceRobustness2FeaturesKHR *in_ext = (const VkPhysicalDeviceRobustness2FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR;
            out_ext->robustBufferAccess2 = in_ext->robustBufferAccess2;
            out_ext->robustImageAccess2 = in_ext->robustImageAccess2;
            out_ext->nullDescriptor = in_ext->nullDescriptor;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {
            VkPhysicalDeviceSamplerYcbcrConversionFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES);
            const VkPhysicalDeviceSamplerYcbcrConversionFeatures *in_ext = (const VkPhysicalDeviceSamplerYcbcrConversionFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceScalarBlockLayoutFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES);
            const VkPhysicalDeviceScalarBlockLayoutFeatures *in_ext = (const VkPhysicalDeviceScalarBlockLayoutFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM:
        {
            VkPhysicalDeviceSchedulingControlsFeaturesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM);
            const VkPhysicalDeviceSchedulingControlsFeaturesARM *in_ext = (const VkPhysicalDeviceSchedulingControlsFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM;
            out_ext->schedulingControls = in_ext->schedulingControls;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES);
            const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *in_ext = (const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV:
        {
            VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV);
            const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV *in_ext = (const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV;
            out_ext->shaderFloat16VectorAtomics = in_ext->shaderFloat16VectorAtomics;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT);
            const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *in_ext = (const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
            out_ext->shaderBufferFloat16Atomics = in_ext->shaderBufferFloat16Atomics;
            out_ext->shaderBufferFloat16AtomicAdd = in_ext->shaderBufferFloat16AtomicAdd;
            out_ext->shaderBufferFloat16AtomicMinMax = in_ext->shaderBufferFloat16AtomicMinMax;
            out_ext->shaderBufferFloat32AtomicMinMax = in_ext->shaderBufferFloat32AtomicMinMax;
            out_ext->shaderBufferFloat64AtomicMinMax = in_ext->shaderBufferFloat64AtomicMinMax;
            out_ext->shaderSharedFloat16Atomics = in_ext->shaderSharedFloat16Atomics;
            out_ext->shaderSharedFloat16AtomicAdd = in_ext->shaderSharedFloat16AtomicAdd;
            out_ext->shaderSharedFloat16AtomicMinMax = in_ext->shaderSharedFloat16AtomicMinMax;
            out_ext->shaderSharedFloat32AtomicMinMax = in_ext->shaderSharedFloat32AtomicMinMax;
            out_ext->shaderSharedFloat64AtomicMinMax = in_ext->shaderSharedFloat64AtomicMinMax;
            out_ext->shaderImageFloat32AtomicMinMax = in_ext->shaderImageFloat32AtomicMinMax;
            out_ext->sparseImageFloat32AtomicMinMax = in_ext->sparseImageFloat32AtomicMinMax;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT);
            const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
            out_ext->shaderBufferFloat32Atomics = in_ext->shaderBufferFloat32Atomics;
            out_ext->shaderBufferFloat32AtomicAdd = in_ext->shaderBufferFloat32AtomicAdd;
            out_ext->shaderBufferFloat64Atomics = in_ext->shaderBufferFloat64Atomics;
            out_ext->shaderBufferFloat64AtomicAdd = in_ext->shaderBufferFloat64AtomicAdd;
            out_ext->shaderSharedFloat32Atomics = in_ext->shaderSharedFloat32Atomics;
            out_ext->shaderSharedFloat32AtomicAdd = in_ext->shaderSharedFloat32AtomicAdd;
            out_ext->shaderSharedFloat64Atomics = in_ext->shaderSharedFloat64Atomics;
            out_ext->shaderSharedFloat64AtomicAdd = in_ext->shaderSharedFloat64AtomicAdd;
            out_ext->shaderImageFloat32Atomics = in_ext->shaderImageFloat32Atomics;
            out_ext->shaderImageFloat32AtomicAdd = in_ext->shaderImageFloat32AtomicAdd;
            out_ext->sparseImageFloat32Atomics = in_ext->sparseImageFloat32Atomics;
            out_ext->sparseImageFloat32AtomicAdd = in_ext->sparseImageFloat32AtomicAdd;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {
            VkPhysicalDeviceShaderAtomicInt64Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES);
            const VkPhysicalDeviceShaderAtomicInt64Features *in_ext = (const VkPhysicalDeviceShaderAtomicInt64Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderBfloat16FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR);
            const VkPhysicalDeviceShaderBfloat16FeaturesKHR *in_ext = (const VkPhysicalDeviceShaderBfloat16FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR;
            out_ext->shaderBFloat16Type = in_ext->shaderBFloat16Type;
            out_ext->shaderBFloat16DotProduct = in_ext->shaderBFloat16DotProduct;
            out_ext->shaderBFloat16CooperativeMatrix = in_ext->shaderBFloat16CooperativeMatrix;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderClockFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR);
            const VkPhysicalDeviceShaderClockFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderClockFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
            out_ext->shaderSubgroupClock = in_ext->shaderSubgroupClock;
            out_ext->shaderDeviceClock = in_ext->shaderDeviceClock;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM);
            const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *in_ext = (const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
            out_ext->shaderCoreBuiltins = in_ext->shaderCoreBuiltins;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES);
            const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *in_ext = (const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {
            VkPhysicalDeviceShaderDrawParametersFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES);
            const VkPhysicalDeviceShaderDrawParametersFeatures *in_ext = (const VkPhysicalDeviceShaderDrawParametersFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
        {
            VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD);
            const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *in_ext = (const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
            out_ext->shaderEarlyAndLateFragmentTests = in_ext->shaderEarlyAndLateFragmentTests;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES:
        {
            VkPhysicalDeviceShaderExpectAssumeFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES);
            const VkPhysicalDeviceShaderExpectAssumeFeatures *in_ext = (const VkPhysicalDeviceShaderExpectAssumeFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
            out_ext->shaderExpectAssume = in_ext->shaderExpectAssume;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {
            VkPhysicalDeviceShaderFloat16Int8Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES);
            const VkPhysicalDeviceShaderFloat16Int8Features *in_ext = (const VkPhysicalDeviceShaderFloat16Int8Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderFloat8FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT);
            const VkPhysicalDeviceShaderFloat8FeaturesEXT *in_ext = (const VkPhysicalDeviceShaderFloat8FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT;
            out_ext->shaderFloat8 = in_ext->shaderFloat8;
            out_ext->shaderFloat8CooperativeMatrix = in_ext->shaderFloat8CooperativeMatrix;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES:
        {
            VkPhysicalDeviceShaderFloatControls2Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES);
            const VkPhysicalDeviceShaderFloatControls2Features *in_ext = (const VkPhysicalDeviceShaderFloatControls2Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
            out_ext->shaderFloatControls2 = in_ext->shaderFloatControls2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT);
            const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *in_ext = (const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
            out_ext->shaderImageInt64Atomics = in_ext->shaderImageInt64Atomics;
            out_ext->sparseImageInt64Atomics = in_ext->sparseImageInt64Atomics;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {
            VkPhysicalDeviceShaderImageFootprintFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV);
            const VkPhysicalDeviceShaderImageFootprintFeaturesNV *in_ext = (const VkPhysicalDeviceShaderImageFootprintFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
            out_ext->imageFootprint = in_ext->imageFootprint;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
        {
            VkPhysicalDeviceShaderIntegerDotProductFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES);
            const VkPhysicalDeviceShaderIntegerDotProductFeatures *in_ext = (const VkPhysicalDeviceShaderIntegerDotProductFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL);
            const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *in_ext = (const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
            out_ext->shaderIntegerFunctions2 = in_ext->shaderIntegerFunctions2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR);
            const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR;
            out_ext->shaderMaximalReconvergence = in_ext->shaderMaximalReconvergence;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT);
            const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
            out_ext->shaderModuleIdentifier = in_ext->shaderModuleIdentifier;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderObjectFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT);
            const VkPhysicalDeviceShaderObjectFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderObjectFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
            out_ext->shaderObject = in_ext->shaderObject;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderQuadControlFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR);
            const VkPhysicalDeviceShaderQuadControlFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderQuadControlFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR;
            out_ext->shaderQuadControl = in_ext->shaderQuadControl;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR);
            const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR;
            out_ext->shaderRelaxedExtendedInstruction = in_ext->shaderRelaxedExtendedInstruction;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT);
            const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT;
            out_ext->shaderReplicatedComposites = in_ext->shaderReplicatedComposites;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV);
            const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *in_ext = (const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
            out_ext->shaderSMBuiltins = in_ext->shaderSMBuiltins;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES);
            const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *in_ext = (const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES:
        {
            VkPhysicalDeviceShaderSubgroupRotateFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES);
            const VkPhysicalDeviceShaderSubgroupRotateFeatures *in_ext = (const VkPhysicalDeviceShaderSubgroupRotateFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
            out_ext->shaderSubgroupRotate = in_ext->shaderSubgroupRotate;
            out_ext->shaderSubgroupRotateClustered = in_ext->shaderSubgroupRotateClustered;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR);
            const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
            out_ext->shaderSubgroupUniformControlFlow = in_ext->shaderSubgroupUniformControlFlow;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
        {
            VkPhysicalDeviceShaderTerminateInvocationFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES);
            const VkPhysicalDeviceShaderTerminateInvocationFeatures *in_ext = (const VkPhysicalDeviceShaderTerminateInvocationFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
        {
            VkPhysicalDeviceShaderTileImageFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT);
            const VkPhysicalDeviceShaderTileImageFeaturesEXT *in_ext = (const VkPhysicalDeviceShaderTileImageFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
            out_ext->shaderTileImageColorReadAccess = in_ext->shaderTileImageColorReadAccess;
            out_ext->shaderTileImageDepthReadAccess = in_ext->shaderTileImageDepthReadAccess;
            out_ext->shaderTileImageStencilReadAccess = in_ext->shaderTileImageStencilReadAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR:
        {
            VkPhysicalDeviceShaderUntypedPointersFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR);
            const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR *in_ext = (const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_UNTYPED_POINTERS_FEATURES_KHR;
            out_ext->shaderUntypedPointers = in_ext->shaderUntypedPointers;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {
            VkPhysicalDeviceShadingRateImageFeaturesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV);
            const VkPhysicalDeviceShadingRateImageFeaturesNV *in_ext = (const VkPhysicalDeviceShadingRateImageFeaturesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
            out_ext->shadingRateImage = in_ext->shadingRateImage;
            out_ext->shadingRateCoarseSampleOrder = in_ext->shadingRateCoarseSampleOrder;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
        {
            VkPhysicalDeviceSubgroupSizeControlFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES);
            const VkPhysicalDeviceSubgroupSizeControlFeatures *in_ext = (const VkPhysicalDeviceSubgroupSizeControlFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT);
            const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *in_ext = (const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
            out_ext->subpassMergeFeedback = in_ext->subpassMergeFeedback;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI);
            const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *in_ext = (const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
            out_ext->subpassShading = in_ext->subpassShading;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR);
            const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR *in_ext = (const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR;
            out_ext->swapchainMaintenance1 = in_ext->swapchainMaintenance1;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
        {
            VkPhysicalDeviceSynchronization2Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES);
            const VkPhysicalDeviceSynchronization2Features *in_ext = (const VkPhysicalDeviceSynchronization2Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM:
        {
            VkPhysicalDeviceTensorFeaturesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM);
            const VkPhysicalDeviceTensorFeaturesARM *in_ext = (const VkPhysicalDeviceTensorFeaturesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM;
            out_ext->tensorNonPacked = in_ext->tensorNonPacked;
            out_ext->shaderTensorAccess = in_ext->shaderTensorAccess;
            out_ext->shaderStorageTensorArrayDynamicIndexing = in_ext->shaderStorageTensorArrayDynamicIndexing;
            out_ext->shaderStorageTensorArrayNonUniformIndexing = in_ext->shaderStorageTensorArrayNonUniformIndexing;
            out_ext->descriptorBindingStorageTensorUpdateAfterBind = in_ext->descriptorBindingStorageTensorUpdateAfterBind;
            out_ext->tensors = in_ext->tensors;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT);
            const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *in_ext = (const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
            out_ext->texelBufferAlignment = in_ext->texelBufferAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
        {
            VkPhysicalDeviceTextureCompressionASTCHDRFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES);
            const VkPhysicalDeviceTextureCompressionASTCHDRFeatures *in_ext = (const VkPhysicalDeviceTextureCompressionASTCHDRFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM:
        {
            VkPhysicalDeviceTileMemoryHeapFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM);
            const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM *in_ext = (const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM;
            out_ext->tileMemoryHeap = in_ext->tileMemoryHeap;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
        {
            VkPhysicalDeviceTilePropertiesFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM);
            const VkPhysicalDeviceTilePropertiesFeaturesQCOM *in_ext = (const VkPhysicalDeviceTilePropertiesFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
            out_ext->tileProperties = in_ext->tileProperties;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM:
        {
            VkPhysicalDeviceTileShadingFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM);
            const VkPhysicalDeviceTileShadingFeaturesQCOM *in_ext = (const VkPhysicalDeviceTileShadingFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM;
            out_ext->tileShading = in_ext->tileShading;
            out_ext->tileShadingFragmentStage = in_ext->tileShadingFragmentStage;
            out_ext->tileShadingColorAttachments = in_ext->tileShadingColorAttachments;
            out_ext->tileShadingDepthAttachments = in_ext->tileShadingDepthAttachments;
            out_ext->tileShadingStencilAttachments = in_ext->tileShadingStencilAttachments;
            out_ext->tileShadingInputAttachments = in_ext->tileShadingInputAttachments;
            out_ext->tileShadingSampledAttachments = in_ext->tileShadingSampledAttachments;
            out_ext->tileShadingPerTileDraw = in_ext->tileShadingPerTileDraw;
            out_ext->tileShadingPerTileDispatch = in_ext->tileShadingPerTileDispatch;
            out_ext->tileShadingDispatchTile = in_ext->tileShadingDispatchTile;
            out_ext->tileShadingApron = in_ext->tileShadingApron;
            out_ext->tileShadingAnisotropicApron = in_ext->tileShadingAnisotropicApron;
            out_ext->tileShadingAtomicOps = in_ext->tileShadingAtomicOps;
            out_ext->tileShadingImageProcessing = in_ext->tileShadingImageProcessing;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {
            VkPhysicalDeviceTimelineSemaphoreFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES);
            const VkPhysicalDeviceTimelineSemaphoreFeatures *in_ext = (const VkPhysicalDeviceTimelineSemaphoreFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT);
            const VkPhysicalDeviceTransformFeedbackFeaturesEXT *in_ext = (const VkPhysicalDeviceTransformFeedbackFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
            out_ext->transformFeedback = in_ext->transformFeedback;
            out_ext->geometryStreams = in_ext->geometryStreams;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR:
        {
            VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR);
            const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR *in_ext = (const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR;
            out_ext->unifiedImageLayouts = in_ext->unifiedImageLayouts;
            out_ext->unifiedImageLayoutsVideo = in_ext->unifiedImageLayoutsVideo;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES);
            const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *in_ext = (const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {
            VkPhysicalDeviceVariablePointersFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES);
            const VkPhysicalDeviceVariablePointersFeatures *in_ext = (const VkPhysicalDeviceVariablePointersFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES:
        {
            VkPhysicalDeviceVertexAttributeDivisorFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES);
            const VkPhysicalDeviceVertexAttributeDivisorFeatures *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT);
            const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT *in_ext = (const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT;
            out_ext->vertexAttributeRobustness = in_ext->vertexAttributeRobustness;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT);
            const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *in_ext = (const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
            out_ext->vertexInputDynamicState = in_ext->vertexInputDynamicState;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoDecodeVP9FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR);
            const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR *in_ext = (const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR;
            out_ext->videoDecodeVP9 = in_ext->videoDecodeVP9;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeAV1FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR);
            const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR *in_ext = (const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR;
            out_ext->videoEncodeAV1 = in_ext->videoEncodeAV1;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR);
            const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR *in_ext = (const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR;
            out_ext->videoEncodeIntraRefresh = in_ext->videoEncodeIntraRefresh;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR);
            const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR *in_ext = (const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR;
            out_ext->videoEncodeQuantizationMap = in_ext->videoEncodeQuantizationMap;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR:
        {
            VkPhysicalDeviceVideoMaintenance1FeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR);
            const VkPhysicalDeviceVideoMaintenance1FeaturesKHR *in_ext = (const VkPhysicalDeviceVideoMaintenance1FeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR;
            out_ext->videoMaintenance1 = in_ext->videoMaintenance1;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {
            VkPhysicalDeviceVulkan11Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES);
            const VkPhysicalDeviceVulkan11Features *in_ext = (const VkPhysicalDeviceVulkan11Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
            out_ext->storageBuffer16BitAccess = in_ext->storageBuffer16BitAccess;
            out_ext->uniformAndStorageBuffer16BitAccess = in_ext->uniformAndStorageBuffer16BitAccess;
            out_ext->storagePushConstant16 = in_ext->storagePushConstant16;
            out_ext->storageInputOutput16 = in_ext->storageInputOutput16;
            out_ext->multiview = in_ext->multiview;
            out_ext->multiviewGeometryShader = in_ext->multiviewGeometryShader;
            out_ext->multiviewTessellationShader = in_ext->multiviewTessellationShader;
            out_ext->variablePointersStorageBuffer = in_ext->variablePointersStorageBuffer;
            out_ext->variablePointers = in_ext->variablePointers;
            out_ext->protectedMemory = in_ext->protectedMemory;
            out_ext->samplerYcbcrConversion = in_ext->samplerYcbcrConversion;
            out_ext->shaderDrawParameters = in_ext->shaderDrawParameters;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {
            VkPhysicalDeviceVulkan12Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES);
            const VkPhysicalDeviceVulkan12Features *in_ext = (const VkPhysicalDeviceVulkan12Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
            out_ext->samplerMirrorClampToEdge = in_ext->samplerMirrorClampToEdge;
            out_ext->drawIndirectCount = in_ext->drawIndirectCount;
            out_ext->storageBuffer8BitAccess = in_ext->storageBuffer8BitAccess;
            out_ext->uniformAndStorageBuffer8BitAccess = in_ext->uniformAndStorageBuffer8BitAccess;
            out_ext->storagePushConstant8 = in_ext->storagePushConstant8;
            out_ext->shaderBufferInt64Atomics = in_ext->shaderBufferInt64Atomics;
            out_ext->shaderSharedInt64Atomics = in_ext->shaderSharedInt64Atomics;
            out_ext->shaderFloat16 = in_ext->shaderFloat16;
            out_ext->shaderInt8 = in_ext->shaderInt8;
            out_ext->descriptorIndexing = in_ext->descriptorIndexing;
            out_ext->shaderInputAttachmentArrayDynamicIndexing = in_ext->shaderInputAttachmentArrayDynamicIndexing;
            out_ext->shaderUniformTexelBufferArrayDynamicIndexing = in_ext->shaderUniformTexelBufferArrayDynamicIndexing;
            out_ext->shaderStorageTexelBufferArrayDynamicIndexing = in_ext->shaderStorageTexelBufferArrayDynamicIndexing;
            out_ext->shaderUniformBufferArrayNonUniformIndexing = in_ext->shaderUniformBufferArrayNonUniformIndexing;
            out_ext->shaderSampledImageArrayNonUniformIndexing = in_ext->shaderSampledImageArrayNonUniformIndexing;
            out_ext->shaderStorageBufferArrayNonUniformIndexing = in_ext->shaderStorageBufferArrayNonUniformIndexing;
            out_ext->shaderStorageImageArrayNonUniformIndexing = in_ext->shaderStorageImageArrayNonUniformIndexing;
            out_ext->shaderInputAttachmentArrayNonUniformIndexing = in_ext->shaderInputAttachmentArrayNonUniformIndexing;
            out_ext->shaderUniformTexelBufferArrayNonUniformIndexing = in_ext->shaderUniformTexelBufferArrayNonUniformIndexing;
            out_ext->shaderStorageTexelBufferArrayNonUniformIndexing = in_ext->shaderStorageTexelBufferArrayNonUniformIndexing;
            out_ext->descriptorBindingUniformBufferUpdateAfterBind = in_ext->descriptorBindingUniformBufferUpdateAfterBind;
            out_ext->descriptorBindingSampledImageUpdateAfterBind = in_ext->descriptorBindingSampledImageUpdateAfterBind;
            out_ext->descriptorBindingStorageImageUpdateAfterBind = in_ext->descriptorBindingStorageImageUpdateAfterBind;
            out_ext->descriptorBindingStorageBufferUpdateAfterBind = in_ext->descriptorBindingStorageBufferUpdateAfterBind;
            out_ext->descriptorBindingUniformTexelBufferUpdateAfterBind = in_ext->descriptorBindingUniformTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingStorageTexelBufferUpdateAfterBind = in_ext->descriptorBindingStorageTexelBufferUpdateAfterBind;
            out_ext->descriptorBindingUpdateUnusedWhilePending = in_ext->descriptorBindingUpdateUnusedWhilePending;
            out_ext->descriptorBindingPartiallyBound = in_ext->descriptorBindingPartiallyBound;
            out_ext->descriptorBindingVariableDescriptorCount = in_ext->descriptorBindingVariableDescriptorCount;
            out_ext->runtimeDescriptorArray = in_ext->runtimeDescriptorArray;
            out_ext->samplerFilterMinmax = in_ext->samplerFilterMinmax;
            out_ext->scalarBlockLayout = in_ext->scalarBlockLayout;
            out_ext->imagelessFramebuffer = in_ext->imagelessFramebuffer;
            out_ext->uniformBufferStandardLayout = in_ext->uniformBufferStandardLayout;
            out_ext->shaderSubgroupExtendedTypes = in_ext->shaderSubgroupExtendedTypes;
            out_ext->separateDepthStencilLayouts = in_ext->separateDepthStencilLayouts;
            out_ext->hostQueryReset = in_ext->hostQueryReset;
            out_ext->timelineSemaphore = in_ext->timelineSemaphore;
            out_ext->bufferDeviceAddress = in_ext->bufferDeviceAddress;
            out_ext->bufferDeviceAddressCaptureReplay = in_ext->bufferDeviceAddressCaptureReplay;
            out_ext->bufferDeviceAddressMultiDevice = in_ext->bufferDeviceAddressMultiDevice;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_ext->shaderOutputViewportIndex = in_ext->shaderOutputViewportIndex;
            out_ext->shaderOutputLayer = in_ext->shaderOutputLayer;
            out_ext->subgroupBroadcastDynamicId = in_ext->subgroupBroadcastDynamicId;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
        {
            VkPhysicalDeviceVulkan13Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES);
            const VkPhysicalDeviceVulkan13Features *in_ext = (const VkPhysicalDeviceVulkan13Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
            out_ext->robustImageAccess = in_ext->robustImageAccess;
            out_ext->inlineUniformBlock = in_ext->inlineUniformBlock;
            out_ext->descriptorBindingInlineUniformBlockUpdateAfterBind = in_ext->descriptorBindingInlineUniformBlockUpdateAfterBind;
            out_ext->pipelineCreationCacheControl = in_ext->pipelineCreationCacheControl;
            out_ext->privateData = in_ext->privateData;
            out_ext->shaderDemoteToHelperInvocation = in_ext->shaderDemoteToHelperInvocation;
            out_ext->shaderTerminateInvocation = in_ext->shaderTerminateInvocation;
            out_ext->subgroupSizeControl = in_ext->subgroupSizeControl;
            out_ext->computeFullSubgroups = in_ext->computeFullSubgroups;
            out_ext->synchronization2 = in_ext->synchronization2;
            out_ext->textureCompressionASTC_HDR = in_ext->textureCompressionASTC_HDR;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_ext->dynamicRendering = in_ext->dynamicRendering;
            out_ext->shaderIntegerDotProduct = in_ext->shaderIntegerDotProduct;
            out_ext->maintenance4 = in_ext->maintenance4;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES:
        {
            VkPhysicalDeviceVulkan14Features32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES);
            const VkPhysicalDeviceVulkan14Features *in_ext = (const VkPhysicalDeviceVulkan14Features *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES;
            out_ext->globalPriorityQuery = in_ext->globalPriorityQuery;
            out_ext->shaderSubgroupRotate = in_ext->shaderSubgroupRotate;
            out_ext->shaderSubgroupRotateClustered = in_ext->shaderSubgroupRotateClustered;
            out_ext->shaderFloatControls2 = in_ext->shaderFloatControls2;
            out_ext->shaderExpectAssume = in_ext->shaderExpectAssume;
            out_ext->rectangularLines = in_ext->rectangularLines;
            out_ext->bresenhamLines = in_ext->bresenhamLines;
            out_ext->smoothLines = in_ext->smoothLines;
            out_ext->stippledRectangularLines = in_ext->stippledRectangularLines;
            out_ext->stippledBresenhamLines = in_ext->stippledBresenhamLines;
            out_ext->stippledSmoothLines = in_ext->stippledSmoothLines;
            out_ext->vertexAttributeInstanceRateDivisor = in_ext->vertexAttributeInstanceRateDivisor;
            out_ext->vertexAttributeInstanceRateZeroDivisor = in_ext->vertexAttributeInstanceRateZeroDivisor;
            out_ext->indexTypeUint8 = in_ext->indexTypeUint8;
            out_ext->dynamicRenderingLocalRead = in_ext->dynamicRenderingLocalRead;
            out_ext->maintenance5 = in_ext->maintenance5;
            out_ext->maintenance6 = in_ext->maintenance6;
            out_ext->pipelineProtectedAccess = in_ext->pipelineProtectedAccess;
            out_ext->pipelineRobustness = in_ext->pipelineRobustness;
            out_ext->hostImageCopy = in_ext->hostImageCopy;
            out_ext->pushDescriptor = in_ext->pushDescriptor;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {
            VkPhysicalDeviceVulkanMemoryModelFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES);
            const VkPhysicalDeviceVulkanMemoryModelFeatures *in_ext = (const VkPhysicalDeviceVulkanMemoryModelFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
            out_ext->vulkanMemoryModel = in_ext->vulkanMemoryModel;
            out_ext->vulkanMemoryModelDeviceScope = in_ext->vulkanMemoryModelDeviceScope;
            out_ext->vulkanMemoryModelAvailabilityVisibilityChains = in_ext->vulkanMemoryModelAvailabilityVisibilityChains;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR);
            const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *in_ext = (const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
            out_ext->workgroupMemoryExplicitLayout = in_ext->workgroupMemoryExplicitLayout;
            out_ext->workgroupMemoryExplicitLayoutScalarBlockLayout = in_ext->workgroupMemoryExplicitLayoutScalarBlockLayout;
            out_ext->workgroupMemoryExplicitLayout8BitAccess = in_ext->workgroupMemoryExplicitLayout8BitAccess;
            out_ext->workgroupMemoryExplicitLayout16BitAccess = in_ext->workgroupMemoryExplicitLayout16BitAccess;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT);
            const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *in_ext = (const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
            out_ext->ycbcr2plane444Formats = in_ext->ycbcr2plane444Formats;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
        {
            VkPhysicalDeviceYcbcrDegammaFeaturesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM);
            const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *in_ext = (const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM;
            out_ext->ycbcrDegamma = in_ext->ycbcrDegamma;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT);
            const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *in_ext = (const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
            out_ext->ycbcrImageArrays = in_ext->ycbcrImageArrays;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT:
        {
            VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT);
            const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT *in_ext = (const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT;
            out_ext->zeroInitializeDeviceMemory = in_ext->zeroInitializeDeviceMemory;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
        {
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES);
            const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *in_ext = (const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
            out_ext->shaderZeroInitializeWorkgroupMemory = in_ext->shaderZeroInitializeWorkgroupMemory;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkFormatProperties2_win32_to_host(struct conversion_context *ctx, const VkFormatProperties232 *in, VkFormatProperties2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
        {
            VkFormatProperties3 *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
        {
            VkSubpassResolvePerformanceQueryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM:
        {
            VkTensorFormatPropertiesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkFormatProperties2_host_to_win32(const VkFormatProperties2 *in, VkFormatProperties232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->formatProperties = in->formatProperties;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
        {
            VkFormatProperties332 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3);
            const VkFormatProperties3 *in_ext = (const VkFormatProperties3 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3;
            out_ext->linearTilingFeatures = in_ext->linearTilingFeatures;
            out_ext->optimalTilingFeatures = in_ext->optimalTilingFeatures;
            out_ext->bufferFeatures = in_ext->bufferFeatures;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
        {
            VkSubpassResolvePerformanceQueryEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT);
            const VkSubpassResolvePerformanceQueryEXT *in_ext = (const VkSubpassResolvePerformanceQueryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT;
            out_ext->optimal = in_ext->optimal;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM:
        {
            VkTensorFormatPropertiesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM);
            const VkTensorFormatPropertiesARM *in_ext = (const VkTensorFormatPropertiesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM;
            out_ext->optimalTilingTensorFeatures = in_ext->optimalTilingTensorFeatures;
            out_ext->linearTilingTensorFeatures = in_ext->linearTilingTensorFeatures;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkPhysicalDeviceFragmentShadingRateKHR_win32_to_host(const VkPhysicalDeviceFragmentShadingRateKHR32 *in, VkPhysicalDeviceFragmentShadingRateKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkPhysicalDeviceFragmentShadingRateKHR *convert_VkPhysicalDeviceFragmentShadingRateKHR_array_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceFragmentShadingRateKHR32 *in, uint32_t count)
{
    VkPhysicalDeviceFragmentShadingRateKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceFragmentShadingRateKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPhysicalDeviceFragmentShadingRateKHR_host_to_win32(const VkPhysicalDeviceFragmentShadingRateKHR *in, VkPhysicalDeviceFragmentShadingRateKHR32 *out)
{
    if (!in) return;

    out->sampleCounts = in->sampleCounts;
    out->fragmentSize = in->fragmentSize;
}

static void convert_VkPhysicalDeviceFragmentShadingRateKHR_array_host_to_win32(const VkPhysicalDeviceFragmentShadingRateKHR *in, VkPhysicalDeviceFragmentShadingRateKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceFragmentShadingRateKHR_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkImageFormatProperties_host_to_win32(const VkImageFormatProperties *in, VkImageFormatProperties32 *out)
{
    if (!in) return;

    out->maxExtent = in->maxExtent;
    out->maxMipLevels = in->maxMipLevels;
    out->maxArrayLayers = in->maxArrayLayers;
    out->sampleCounts = in->sampleCounts;
    out->maxResourceSize = in->maxResourceSize;
}

#ifdef _WIN64
static void convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(struct conversion_context *ctx, const VkPhysicalDeviceImageFormatInfo2 *in, VkPhysicalDeviceImageFormatInfo2 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->format = in->format;
    out->type = in->type;
    out->tiling = in->tiling;
    out->usage = in->usage;
    out->flags = in->flags;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageCompressionControlEXT *in_ext = (const VkImageCompressionControlEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
            out_ext->pFixedRateFlags = in_ext->pFixedRateFlags;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageFormatListCreateInfo *in_ext = (const VkImageFormatListCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewFormatCount = in_ext->viewFormatCount;
            out_ext->pViewFormats = in_ext->pViewFormats;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageStencilUsageCreateInfo *in_ext = (const VkImageStencilUsageCreateInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->stencilUsage = in_ext->stencilUsage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
            VkOpticalFlowImageFormatInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpticalFlowImageFormatInfoNV *in_ext = (const VkOpticalFlowImageFormatInfoNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            VkPhysicalDeviceExternalImageFormatInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExternalImageFormatInfo *in_ext = (const VkPhysicalDeviceExternalImageFormatInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            VkPhysicalDeviceImageViewImageFormatInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageViewImageFormatInfoEXT *in_ext = (const VkPhysicalDeviceImageViewImageFormatInfoEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->imageViewType = in_ext->imageViewType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
        {
            VkVideoProfileListInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoProfileListInfoKHR *in_ext = (const VkVideoProfileListInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->profileCount = in_ext->profileCount;
            out_ext->pProfiles = in_ext->pProfiles;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

static void convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceImageFormatInfo232 *in, VkPhysicalDeviceImageFormatInfo2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->format = in->format;
    out->type = in->type;
    out->tiling = in->tiling;
    out->usage = in->usage;
    out->flags = in->flags;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
        {
            VkImageCompressionControlEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageCompressionControlEXT32 *in_ext = (const VkImageCompressionControlEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->compressionControlPlaneCount = in_ext->compressionControlPlaneCount;
            out_ext->pFixedRateFlags = UlongToPtr(in_ext->pFixedRateFlags);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {
            VkImageFormatListCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageFormatListCreateInfo32 *in_ext = (const VkImageFormatListCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->viewFormatCount = in_ext->viewFormatCount;
            out_ext->pViewFormats = UlongToPtr(in_ext->pViewFormats);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {
            VkImageStencilUsageCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkImageStencilUsageCreateInfo32 *in_ext = (const VkImageStencilUsageCreateInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO;
            out_ext->pNext = NULL;
            out_ext->stencilUsage = in_ext->stencilUsage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
        {
            VkOpticalFlowImageFormatInfoNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkOpticalFlowImageFormatInfoNV32 *in_ext = (const VkOpticalFlowImageFormatInfoNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV;
            out_ext->pNext = NULL;
            out_ext->usage = in_ext->usage;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {
            VkPhysicalDeviceExternalImageFormatInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceExternalImageFormatInfo32 *in_ext = (const VkPhysicalDeviceExternalImageFormatInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
            out_ext->pNext = NULL;
            out_ext->handleType = in_ext->handleType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {
            VkPhysicalDeviceImageViewImageFormatInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceImageViewImageFormatInfoEXT32 *in_ext = (const VkPhysicalDeviceImageViewImageFormatInfoEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
            out_ext->pNext = NULL;
            out_ext->imageViewType = in_ext->imageViewType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
        {
            VkVideoProfileListInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoProfileListInfoKHR32 *in_ext = (const VkVideoProfileListInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->profileCount = in_ext->profileCount;
            out_ext->pProfiles = convert_VkVideoProfileInfoKHR_array_win32_to_host(ctx, (const VkVideoProfileInfoKHR32 *)UlongToPtr(in_ext->pProfiles), in_ext->profileCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkImageFormatProperties2_win32_to_host(struct conversion_context *ctx, const VkImageFormatProperties232 *in, VkImageFormatProperties2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            VkExternalImageFormatProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            VkFilterCubicImageViewImageFormatPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY:
        {
            VkHostImageCopyDevicePerformanceQuery *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            VkSamplerYcbcrConversionImageFormatProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            VkTextureLODGatherFormatPropertiesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkImageFormatProperties2_host_to_win32(const VkImageFormatProperties2 *in, VkImageFormatProperties232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    convert_VkImageFormatProperties_host_to_win32(&in->imageFormatProperties, &out->imageFormatProperties);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {
            VkExternalImageFormatProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES);
            const VkExternalImageFormatProperties *in_ext = (const VkExternalImageFormatProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
            out_ext->externalMemoryProperties = in_ext->externalMemoryProperties;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {
            VkFilterCubicImageViewImageFormatPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT);
            const VkFilterCubicImageViewImageFormatPropertiesEXT *in_ext = (const VkFilterCubicImageViewImageFormatPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT;
            out_ext->filterCubic = in_ext->filterCubic;
            out_ext->filterCubicMinmax = in_ext->filterCubicMinmax;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY:
        {
            VkHostImageCopyDevicePerformanceQuery32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY);
            const VkHostImageCopyDevicePerformanceQuery *in_ext = (const VkHostImageCopyDevicePerformanceQuery *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY;
            out_ext->optimalDeviceAccess = in_ext->optimalDeviceAccess;
            out_ext->identicalMemoryLayout = in_ext->identicalMemoryLayout;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT);
            const VkImageCompressionPropertiesEXT *in_ext = (const VkImageCompressionPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->imageCompressionFlags = in_ext->imageCompressionFlags;
            out_ext->imageCompressionFixedRateFlags = in_ext->imageCompressionFixedRateFlags;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {
            VkSamplerYcbcrConversionImageFormatProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES);
            const VkSamplerYcbcrConversionImageFormatProperties *in_ext = (const VkSamplerYcbcrConversionImageFormatProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
            out_ext->combinedImageSamplerDescriptorCount = in_ext->combinedImageSamplerDescriptorCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {
            VkTextureLODGatherFormatPropertiesAMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD);
            const VkTextureLODGatherFormatPropertiesAMD *in_ext = (const VkTextureLODGatherFormatPropertiesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
            out_ext->supportsTextureGatherLODBiasAMD = in_ext->supportsTextureGatherLODBiasAMD;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkMemoryHeap_host_to_win32(const VkMemoryHeap *in, VkMemoryHeap32 *out)
{
    if (!in) return;

    out->size = in->size;
    out->flags = in->flags;
}

static void convert_VkMemoryHeap_array_host_to_win32(const VkMemoryHeap *in, VkMemoryHeap32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkMemoryHeap_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPhysicalDeviceMemoryProperties_host_to_win32(const VkPhysicalDeviceMemoryProperties *in, VkPhysicalDeviceMemoryProperties32 *out)
{
    if (!in) return;

    out->memoryTypeCount = in->memoryTypeCount;
    memcpy(out->memoryTypes, in->memoryTypes, VK_MAX_MEMORY_TYPES * sizeof(VkMemoryType));
    out->memoryHeapCount = in->memoryHeapCount;
    convert_VkMemoryHeap_array_host_to_win32(in->memoryHeaps, out->memoryHeaps, VK_MAX_MEMORY_HEAPS);
}

static void convert_VkPhysicalDeviceMemoryProperties2_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceMemoryProperties232 *in, VkPhysicalDeviceMemoryProperties2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMemoryBudgetPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkPhysicalDeviceMemoryProperties2_host_to_win32(const VkPhysicalDeviceMemoryProperties2 *in, VkPhysicalDeviceMemoryProperties232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    convert_VkPhysicalDeviceMemoryProperties_host_to_win32(&in->memoryProperties, &out->memoryProperties);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMemoryBudgetPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT);
            const VkPhysicalDeviceMemoryBudgetPropertiesEXT *in_ext = (const VkPhysicalDeviceMemoryBudgetPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
            memcpy(out_ext->heapBudget, in_ext->heapBudget, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
            memcpy(out_ext->heapUsage, in_ext->heapUsage, VK_MAX_MEMORY_HEAPS * sizeof(VkDeviceSize));
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkMultisamplePropertiesEXT_win32_to_host(const VkMultisamplePropertiesEXT32 *in, VkMultisamplePropertiesEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMultisamplePropertiesEXT_host_to_win32(const VkMultisamplePropertiesEXT *in, VkMultisamplePropertiesEXT32 *out)
{
    if (!in) return;

    out->maxSampleLocationGridSize = in->maxSampleLocationGridSize;
}

static void convert_VkOpticalFlowImageFormatInfoNV_win32_to_host(const VkOpticalFlowImageFormatInfoNV32 *in, VkOpticalFlowImageFormatInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->usage = in->usage;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkOpticalFlowImageFormatPropertiesNV_win32_to_host(const VkOpticalFlowImageFormatPropertiesNV32 *in, VkOpticalFlowImageFormatPropertiesNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkOpticalFlowImageFormatPropertiesNV *convert_VkOpticalFlowImageFormatPropertiesNV_array_win32_to_host(struct conversion_context *ctx, const VkOpticalFlowImageFormatPropertiesNV32 *in, uint32_t count)
{
    VkOpticalFlowImageFormatPropertiesNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkOpticalFlowImageFormatPropertiesNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkOpticalFlowImageFormatPropertiesNV_host_to_win32(const VkOpticalFlowImageFormatPropertiesNV *in, VkOpticalFlowImageFormatPropertiesNV32 *out)
{
    if (!in) return;

    out->format = in->format;
}

static void convert_VkOpticalFlowImageFormatPropertiesNV_array_host_to_win32(const VkOpticalFlowImageFormatPropertiesNV *in, VkOpticalFlowImageFormatPropertiesNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkOpticalFlowImageFormatPropertiesNV_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPhysicalDeviceLimits_host_to_win32(const VkPhysicalDeviceLimits *in, VkPhysicalDeviceLimits32 *out)
{
    if (!in) return;

    out->maxImageDimension1D = in->maxImageDimension1D;
    out->maxImageDimension2D = in->maxImageDimension2D;
    out->maxImageDimension3D = in->maxImageDimension3D;
    out->maxImageDimensionCube = in->maxImageDimensionCube;
    out->maxImageArrayLayers = in->maxImageArrayLayers;
    out->maxTexelBufferElements = in->maxTexelBufferElements;
    out->maxUniformBufferRange = in->maxUniformBufferRange;
    out->maxStorageBufferRange = in->maxStorageBufferRange;
    out->maxPushConstantsSize = in->maxPushConstantsSize;
    out->maxMemoryAllocationCount = in->maxMemoryAllocationCount;
    out->maxSamplerAllocationCount = in->maxSamplerAllocationCount;
    out->bufferImageGranularity = in->bufferImageGranularity;
    out->sparseAddressSpaceSize = in->sparseAddressSpaceSize;
    out->maxBoundDescriptorSets = in->maxBoundDescriptorSets;
    out->maxPerStageDescriptorSamplers = in->maxPerStageDescriptorSamplers;
    out->maxPerStageDescriptorUniformBuffers = in->maxPerStageDescriptorUniformBuffers;
    out->maxPerStageDescriptorStorageBuffers = in->maxPerStageDescriptorStorageBuffers;
    out->maxPerStageDescriptorSampledImages = in->maxPerStageDescriptorSampledImages;
    out->maxPerStageDescriptorStorageImages = in->maxPerStageDescriptorStorageImages;
    out->maxPerStageDescriptorInputAttachments = in->maxPerStageDescriptorInputAttachments;
    out->maxPerStageResources = in->maxPerStageResources;
    out->maxDescriptorSetSamplers = in->maxDescriptorSetSamplers;
    out->maxDescriptorSetUniformBuffers = in->maxDescriptorSetUniformBuffers;
    out->maxDescriptorSetUniformBuffersDynamic = in->maxDescriptorSetUniformBuffersDynamic;
    out->maxDescriptorSetStorageBuffers = in->maxDescriptorSetStorageBuffers;
    out->maxDescriptorSetStorageBuffersDynamic = in->maxDescriptorSetStorageBuffersDynamic;
    out->maxDescriptorSetSampledImages = in->maxDescriptorSetSampledImages;
    out->maxDescriptorSetStorageImages = in->maxDescriptorSetStorageImages;
    out->maxDescriptorSetInputAttachments = in->maxDescriptorSetInputAttachments;
    out->maxVertexInputAttributes = in->maxVertexInputAttributes;
    out->maxVertexInputBindings = in->maxVertexInputBindings;
    out->maxVertexInputAttributeOffset = in->maxVertexInputAttributeOffset;
    out->maxVertexInputBindingStride = in->maxVertexInputBindingStride;
    out->maxVertexOutputComponents = in->maxVertexOutputComponents;
    out->maxTessellationGenerationLevel = in->maxTessellationGenerationLevel;
    out->maxTessellationPatchSize = in->maxTessellationPatchSize;
    out->maxTessellationControlPerVertexInputComponents = in->maxTessellationControlPerVertexInputComponents;
    out->maxTessellationControlPerVertexOutputComponents = in->maxTessellationControlPerVertexOutputComponents;
    out->maxTessellationControlPerPatchOutputComponents = in->maxTessellationControlPerPatchOutputComponents;
    out->maxTessellationControlTotalOutputComponents = in->maxTessellationControlTotalOutputComponents;
    out->maxTessellationEvaluationInputComponents = in->maxTessellationEvaluationInputComponents;
    out->maxTessellationEvaluationOutputComponents = in->maxTessellationEvaluationOutputComponents;
    out->maxGeometryShaderInvocations = in->maxGeometryShaderInvocations;
    out->maxGeometryInputComponents = in->maxGeometryInputComponents;
    out->maxGeometryOutputComponents = in->maxGeometryOutputComponents;
    out->maxGeometryOutputVertices = in->maxGeometryOutputVertices;
    out->maxGeometryTotalOutputComponents = in->maxGeometryTotalOutputComponents;
    out->maxFragmentInputComponents = in->maxFragmentInputComponents;
    out->maxFragmentOutputAttachments = in->maxFragmentOutputAttachments;
    out->maxFragmentDualSrcAttachments = in->maxFragmentDualSrcAttachments;
    out->maxFragmentCombinedOutputResources = in->maxFragmentCombinedOutputResources;
    out->maxComputeSharedMemorySize = in->maxComputeSharedMemorySize;
    memcpy(out->maxComputeWorkGroupCount, in->maxComputeWorkGroupCount, 3 * sizeof(uint32_t));
    out->maxComputeWorkGroupInvocations = in->maxComputeWorkGroupInvocations;
    memcpy(out->maxComputeWorkGroupSize, in->maxComputeWorkGroupSize, 3 * sizeof(uint32_t));
    out->subPixelPrecisionBits = in->subPixelPrecisionBits;
    out->subTexelPrecisionBits = in->subTexelPrecisionBits;
    out->mipmapPrecisionBits = in->mipmapPrecisionBits;
    out->maxDrawIndexedIndexValue = in->maxDrawIndexedIndexValue;
    out->maxDrawIndirectCount = in->maxDrawIndirectCount;
    out->maxSamplerLodBias = in->maxSamplerLodBias;
    out->maxSamplerAnisotropy = in->maxSamplerAnisotropy;
    out->maxViewports = in->maxViewports;
    memcpy(out->maxViewportDimensions, in->maxViewportDimensions, 2 * sizeof(uint32_t));
    memcpy(out->viewportBoundsRange, in->viewportBoundsRange, 2 * sizeof(float));
    out->viewportSubPixelBits = in->viewportSubPixelBits;
    out->minMemoryMapAlignment = in->minMemoryMapAlignment;
    out->minTexelBufferOffsetAlignment = in->minTexelBufferOffsetAlignment;
    out->minUniformBufferOffsetAlignment = in->minUniformBufferOffsetAlignment;
    out->minStorageBufferOffsetAlignment = in->minStorageBufferOffsetAlignment;
    out->minTexelOffset = in->minTexelOffset;
    out->maxTexelOffset = in->maxTexelOffset;
    out->minTexelGatherOffset = in->minTexelGatherOffset;
    out->maxTexelGatherOffset = in->maxTexelGatherOffset;
    out->minInterpolationOffset = in->minInterpolationOffset;
    out->maxInterpolationOffset = in->maxInterpolationOffset;
    out->subPixelInterpolationOffsetBits = in->subPixelInterpolationOffsetBits;
    out->maxFramebufferWidth = in->maxFramebufferWidth;
    out->maxFramebufferHeight = in->maxFramebufferHeight;
    out->maxFramebufferLayers = in->maxFramebufferLayers;
    out->framebufferColorSampleCounts = in->framebufferColorSampleCounts;
    out->framebufferDepthSampleCounts = in->framebufferDepthSampleCounts;
    out->framebufferStencilSampleCounts = in->framebufferStencilSampleCounts;
    out->framebufferNoAttachmentsSampleCounts = in->framebufferNoAttachmentsSampleCounts;
    out->maxColorAttachments = in->maxColorAttachments;
    out->sampledImageColorSampleCounts = in->sampledImageColorSampleCounts;
    out->sampledImageIntegerSampleCounts = in->sampledImageIntegerSampleCounts;
    out->sampledImageDepthSampleCounts = in->sampledImageDepthSampleCounts;
    out->sampledImageStencilSampleCounts = in->sampledImageStencilSampleCounts;
    out->storageImageSampleCounts = in->storageImageSampleCounts;
    out->maxSampleMaskWords = in->maxSampleMaskWords;
    out->timestampComputeAndGraphics = in->timestampComputeAndGraphics;
    out->timestampPeriod = in->timestampPeriod;
    out->maxClipDistances = in->maxClipDistances;
    out->maxCullDistances = in->maxCullDistances;
    out->maxCombinedClipAndCullDistances = in->maxCombinedClipAndCullDistances;
    out->discreteQueuePriorities = in->discreteQueuePriorities;
    memcpy(out->pointSizeRange, in->pointSizeRange, 2 * sizeof(float));
    memcpy(out->lineWidthRange, in->lineWidthRange, 2 * sizeof(float));
    out->pointSizeGranularity = in->pointSizeGranularity;
    out->lineWidthGranularity = in->lineWidthGranularity;
    out->strictLines = in->strictLines;
    out->standardSampleLocations = in->standardSampleLocations;
    out->optimalBufferCopyOffsetAlignment = in->optimalBufferCopyOffsetAlignment;
    out->optimalBufferCopyRowPitchAlignment = in->optimalBufferCopyRowPitchAlignment;
    out->nonCoherentAtomSize = in->nonCoherentAtomSize;
}

static void convert_VkPhysicalDeviceProperties_host_to_win32(const VkPhysicalDeviceProperties *in, VkPhysicalDeviceProperties32 *out)
{
    if (!in) return;

    out->apiVersion = in->apiVersion;
    out->driverVersion = in->driverVersion;
    out->vendorID = in->vendorID;
    out->deviceID = in->deviceID;
    out->deviceType = in->deviceType;
    memcpy(out->deviceName, in->deviceName, VK_MAX_PHYSICAL_DEVICE_NAME_SIZE * sizeof(char));
    memcpy(out->pipelineCacheUUID, in->pipelineCacheUUID, VK_UUID_SIZE * sizeof(uint8_t));
    convert_VkPhysicalDeviceLimits_host_to_win32(&in->limits, &out->limits);
    out->sparseProperties = in->sparseProperties;
}

static void convert_VkPhysicalDeviceProperties2_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceProperties232 *in, VkPhysicalDeviceProperties2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceAccelerationStructurePropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV:
        {
            VkPhysicalDeviceClusterAccelerationStructurePropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR:
        {
            VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            VkPhysicalDeviceConservativeRasterizationPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV:
        {
            VkPhysicalDeviceCooperativeMatrix2PropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV:
        {
            VkPhysicalDeviceCooperativeVectorPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            VkPhysicalDeviceDepthStencilResolveProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM:
        {
            VkPhysicalDeviceDescriptorBufferTensorPropertiesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceDescriptorBufferTensorPropertiesARM32 *in_ext = (const VkPhysicalDeviceDescriptorBufferTensorPropertiesARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorCaptureReplayDescriptorDataSize = in_ext->tensorCaptureReplayDescriptorDataSize;
            out_ext->tensorViewCaptureReplayDescriptorDataSize = in_ext->tensorViewCaptureReplayDescriptorDataSize;
            out_ext->tensorDescriptorSize = in_ext->tensorDescriptorSize;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            VkPhysicalDeviceDescriptorIndexingProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDiscardRectanglePropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            VkPhysicalDeviceDriverProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3PropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            VkPhysicalDeviceExternalMemoryHostPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            VkPhysicalDeviceFloatControlsProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE:
        {
            VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRatePropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES:
        {
            VkPhysicalDeviceHostImageCopyProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceHostImageCopyProperties32 *in_ext = (const VkPhysicalDeviceHostImageCopyProperties32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES;
            out_ext->pNext = NULL;
            out_ext->copySrcLayoutCount = in_ext->copySrcLayoutCount;
            out_ext->pCopySrcLayouts = UlongToPtr(in_ext->pCopySrcLayouts);
            out_ext->copyDstLayoutCount = in_ext->copyDstLayoutCount;
            out_ext->pCopyDstLayouts = UlongToPtr(in_ext->pCopyDstLayouts);
            memcpy(out_ext->optimalTilingLayoutUUID, in_ext->optimalTilingLayoutUUID, VK_UUID_SIZE * sizeof(uint8_t));
            out_ext->identicalMemoryTypeRequirements = in_ext->identicalMemoryTypeRequirements;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            VkPhysicalDeviceIDProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA:
        {
            VkPhysicalDeviceImageAlignmentControlPropertiesMESA *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2PropertiesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceImageProcessingPropertiesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
        {
            VkPhysicalDeviceInlineUniformBlockProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
        {
            VkPhysicalDeviceLayeredDriverPropertiesMSFT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT:
        {
            VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES:
        {
            VkPhysicalDeviceLineRasterizationProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance3Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance4Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance5Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance6Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR:
        {
            VkPhysicalDeviceMaintenance9PropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMeshShaderPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            VkPhysicalDeviceMeshShaderPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMultiDrawPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            VkPhysicalDeviceMultiviewProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
        {
            VkPhysicalDeviceOpticalFlowPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            VkPhysicalDevicePCIBusInfoPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV:
        {
            VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            VkPhysicalDevicePerformanceQueryPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR:
        {
            VkPhysicalDevicePipelineBinaryPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES:
        {
            VkPhysicalDevicePipelineRobustnessProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            VkPhysicalDevicePointClippingProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            VkPhysicalDeviceProtectedMemoryProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
        {
            VkPhysicalDeviceProvokingVertexPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES:
        {
            VkPhysicalDevicePushDescriptorProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelinePropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            VkPhysicalDeviceRayTracingPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM:
        {
            VkPhysicalDeviceRenderPassStripedPropertiesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR:
        {
            VkPhysicalDeviceRobustness2PropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            VkPhysicalDeviceSampleLocationsPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            VkPhysicalDeviceSamplerFilterMinmaxProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM:
        {
            VkPhysicalDeviceSchedulingControlsPropertiesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            VkPhysicalDeviceShaderCoreProperties2AMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            VkPhysicalDeviceShaderCorePropertiesAMD *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
        {
            VkPhysicalDeviceShaderCorePropertiesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
        {
            VkPhysicalDeviceShaderIntegerDotProductProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderObjectPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderTileImagePropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            VkPhysicalDeviceShadingRateImagePropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            VkPhysicalDeviceSubgroupProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
        {
            VkPhysicalDeviceSubgroupSizeControlProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingPropertiesHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM:
        {
            VkPhysicalDeviceTensorPropertiesARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
        {
            VkPhysicalDeviceTexelBufferAlignmentProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceTileMemoryHeapPropertiesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPhysicalDeviceTileMemoryHeapPropertiesQCOM32 *in_ext = (const VkPhysicalDeviceTileMemoryHeapPropertiesQCOM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM;
            out_ext->pNext = NULL;
            out_ext->queueSubmitBoundary = in_ext->queueSubmitBoundary;
            out_ext->tileBufferTransfers = in_ext->tileBufferTransfers;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceTileShadingPropertiesQCOM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            VkPhysicalDeviceTimelineSemaphoreProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES:
        {
            VkPhysicalDeviceVertexAttributeDivisorProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            VkPhysicalDeviceVulkan11Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            VkPhysicalDeviceVulkan12Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:
        {
            VkPhysicalDeviceVulkan13Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES:
        {
            VkPhysicalDeviceVulkan14Properties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkPhysicalDeviceProperties2_host_to_win32(const VkPhysicalDeviceProperties2 *in, VkPhysicalDeviceProperties232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    convert_VkPhysicalDeviceProperties_host_to_win32(&in->properties, &out->properties);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceAccelerationStructurePropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR);
            const VkPhysicalDeviceAccelerationStructurePropertiesKHR *in_ext = (const VkPhysicalDeviceAccelerationStructurePropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR;
            out_ext->maxGeometryCount = in_ext->maxGeometryCount;
            out_ext->maxInstanceCount = in_ext->maxInstanceCount;
            out_ext->maxPrimitiveCount = in_ext->maxPrimitiveCount;
            out_ext->maxPerStageDescriptorAccelerationStructures = in_ext->maxPerStageDescriptorAccelerationStructures;
            out_ext->maxPerStageDescriptorUpdateAfterBindAccelerationStructures = in_ext->maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
            out_ext->maxDescriptorSetAccelerationStructures = in_ext->maxDescriptorSetAccelerationStructures;
            out_ext->maxDescriptorSetUpdateAfterBindAccelerationStructures = in_ext->maxDescriptorSetUpdateAfterBindAccelerationStructures;
            out_ext->minAccelerationStructureScratchOffsetAlignment = in_ext->minAccelerationStructureScratchOffsetAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {
            VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT);
            const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *in_ext = (const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
            out_ext->advancedBlendMaxColorAttachments = in_ext->advancedBlendMaxColorAttachments;
            out_ext->advancedBlendIndependentBlend = in_ext->advancedBlendIndependentBlend;
            out_ext->advancedBlendNonPremultipliedSrcColor = in_ext->advancedBlendNonPremultipliedSrcColor;
            out_ext->advancedBlendNonPremultipliedDstColor = in_ext->advancedBlendNonPremultipliedDstColor;
            out_ext->advancedBlendCorrelatedOverlap = in_ext->advancedBlendCorrelatedOverlap;
            out_ext->advancedBlendAllOperations = in_ext->advancedBlendAllOperations;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV:
        {
            VkPhysicalDeviceClusterAccelerationStructurePropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV);
            const VkPhysicalDeviceClusterAccelerationStructurePropertiesNV *in_ext = (const VkPhysicalDeviceClusterAccelerationStructurePropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV;
            out_ext->maxVerticesPerCluster = in_ext->maxVerticesPerCluster;
            out_ext->maxTrianglesPerCluster = in_ext->maxTrianglesPerCluster;
            out_ext->clusterScratchByteAlignment = in_ext->clusterScratchByteAlignment;
            out_ext->clusterByteAlignment = in_ext->clusterByteAlignment;
            out_ext->clusterTemplateByteAlignment = in_ext->clusterTemplateByteAlignment;
            out_ext->clusterBottomLevelByteAlignment = in_ext->clusterBottomLevelByteAlignment;
            out_ext->clusterTemplateBoundsByteAlignment = in_ext->clusterTemplateBoundsByteAlignment;
            out_ext->maxClusterGeometryIndex = in_ext->maxClusterGeometryIndex;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
        {
            VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI);
            const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI *in_ext = (const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI;
            memcpy(out_ext->maxWorkGroupCount, in_ext->maxWorkGroupCount, 3 * sizeof(uint32_t));
            memcpy(out_ext->maxWorkGroupSize, in_ext->maxWorkGroupSize, 3 * sizeof(uint32_t));
            out_ext->maxOutputClusterCount = in_ext->maxOutputClusterCount;
            out_ext->indirectBufferOffsetAlignment = in_ext->indirectBufferOffsetAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR:
        {
            VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR);
            const VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR *in_ext = (const VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR;
            out_ext->meshAndTaskShaderDerivatives = in_ext->meshAndTaskShaderDerivatives;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {
            VkPhysicalDeviceConservativeRasterizationPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT);
            const VkPhysicalDeviceConservativeRasterizationPropertiesEXT *in_ext = (const VkPhysicalDeviceConservativeRasterizationPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
            out_ext->primitiveOverestimationSize = in_ext->primitiveOverestimationSize;
            out_ext->maxExtraPrimitiveOverestimationSize = in_ext->maxExtraPrimitiveOverestimationSize;
            out_ext->extraPrimitiveOverestimationSizeGranularity = in_ext->extraPrimitiveOverestimationSizeGranularity;
            out_ext->primitiveUnderestimation = in_ext->primitiveUnderestimation;
            out_ext->conservativePointAndLineRasterization = in_ext->conservativePointAndLineRasterization;
            out_ext->degenerateTrianglesRasterized = in_ext->degenerateTrianglesRasterized;
            out_ext->degenerateLinesRasterized = in_ext->degenerateLinesRasterized;
            out_ext->fullyCoveredFragmentShaderInputVariable = in_ext->fullyCoveredFragmentShaderInputVariable;
            out_ext->conservativeRasterizationPostDepthCoverage = in_ext->conservativeRasterizationPostDepthCoverage;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV:
        {
            VkPhysicalDeviceCooperativeMatrix2PropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV);
            const VkPhysicalDeviceCooperativeMatrix2PropertiesNV *in_ext = (const VkPhysicalDeviceCooperativeMatrix2PropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV;
            out_ext->cooperativeMatrixWorkgroupScopeMaxWorkgroupSize = in_ext->cooperativeMatrixWorkgroupScopeMaxWorkgroupSize;
            out_ext->cooperativeMatrixFlexibleDimensionsMaxDimension = in_ext->cooperativeMatrixFlexibleDimensionsMaxDimension;
            out_ext->cooperativeMatrixWorkgroupScopeReservedSharedMemory = in_ext->cooperativeMatrixWorkgroupScopeReservedSharedMemory;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
        {
            VkPhysicalDeviceCooperativeMatrixPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR);
            const VkPhysicalDeviceCooperativeMatrixPropertiesKHR *in_ext = (const VkPhysicalDeviceCooperativeMatrixPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR;
            out_ext->cooperativeMatrixSupportedStages = in_ext->cooperativeMatrixSupportedStages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {
            VkPhysicalDeviceCooperativeMatrixPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV);
            const VkPhysicalDeviceCooperativeMatrixPropertiesNV *in_ext = (const VkPhysicalDeviceCooperativeMatrixPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
            out_ext->cooperativeMatrixSupportedStages = in_ext->cooperativeMatrixSupportedStages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV:
        {
            VkPhysicalDeviceCooperativeVectorPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV);
            const VkPhysicalDeviceCooperativeVectorPropertiesNV *in_ext = (const VkPhysicalDeviceCooperativeVectorPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV;
            out_ext->cooperativeVectorSupportedStages = in_ext->cooperativeVectorSupportedStages;
            out_ext->cooperativeVectorTrainingFloat16Accumulation = in_ext->cooperativeVectorTrainingFloat16Accumulation;
            out_ext->cooperativeVectorTrainingFloat32Accumulation = in_ext->cooperativeVectorTrainingFloat32Accumulation;
            out_ext->maxCooperativeVectorComponents = in_ext->maxCooperativeVectorComponents;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV:
        {
            VkPhysicalDeviceCopyMemoryIndirectPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV);
            const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV *in_ext = (const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV;
            out_ext->supportedQueues = in_ext->supportedQueues;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {
            VkPhysicalDeviceCustomBorderColorPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT);
            const VkPhysicalDeviceCustomBorderColorPropertiesEXT *in_ext = (const VkPhysicalDeviceCustomBorderColorPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
            out_ext->maxCustomBorderColorSamplers = in_ext->maxCustomBorderColorSamplers;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {
            VkPhysicalDeviceDepthStencilResolveProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES);
            const VkPhysicalDeviceDepthStencilResolveProperties *in_ext = (const VkPhysicalDeviceDepthStencilResolveProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
            out_ext->supportedDepthResolveModes = in_ext->supportedDepthResolveModes;
            out_ext->supportedStencilResolveModes = in_ext->supportedStencilResolveModes;
            out_ext->independentResolveNone = in_ext->independentResolveNone;
            out_ext->independentResolve = in_ext->independentResolve;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT);
            const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT *in_ext = (const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT;
            out_ext->combinedImageSamplerDensityMapDescriptorSize = in_ext->combinedImageSamplerDensityMapDescriptorSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDescriptorBufferPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT);
            const VkPhysicalDeviceDescriptorBufferPropertiesEXT *in_ext = (const VkPhysicalDeviceDescriptorBufferPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT;
            out_ext->combinedImageSamplerDescriptorSingleArray = in_ext->combinedImageSamplerDescriptorSingleArray;
            out_ext->bufferlessPushDescriptors = in_ext->bufferlessPushDescriptors;
            out_ext->allowSamplerImageViewPostSubmitCreation = in_ext->allowSamplerImageViewPostSubmitCreation;
            out_ext->descriptorBufferOffsetAlignment = in_ext->descriptorBufferOffsetAlignment;
            out_ext->maxDescriptorBufferBindings = in_ext->maxDescriptorBufferBindings;
            out_ext->maxResourceDescriptorBufferBindings = in_ext->maxResourceDescriptorBufferBindings;
            out_ext->maxSamplerDescriptorBufferBindings = in_ext->maxSamplerDescriptorBufferBindings;
            out_ext->maxEmbeddedImmutableSamplerBindings = in_ext->maxEmbeddedImmutableSamplerBindings;
            out_ext->maxEmbeddedImmutableSamplers = in_ext->maxEmbeddedImmutableSamplers;
            out_ext->bufferCaptureReplayDescriptorDataSize = in_ext->bufferCaptureReplayDescriptorDataSize;
            out_ext->imageCaptureReplayDescriptorDataSize = in_ext->imageCaptureReplayDescriptorDataSize;
            out_ext->imageViewCaptureReplayDescriptorDataSize = in_ext->imageViewCaptureReplayDescriptorDataSize;
            out_ext->samplerCaptureReplayDescriptorDataSize = in_ext->samplerCaptureReplayDescriptorDataSize;
            out_ext->accelerationStructureCaptureReplayDescriptorDataSize = in_ext->accelerationStructureCaptureReplayDescriptorDataSize;
            out_ext->samplerDescriptorSize = in_ext->samplerDescriptorSize;
            out_ext->combinedImageSamplerDescriptorSize = in_ext->combinedImageSamplerDescriptorSize;
            out_ext->sampledImageDescriptorSize = in_ext->sampledImageDescriptorSize;
            out_ext->storageImageDescriptorSize = in_ext->storageImageDescriptorSize;
            out_ext->uniformTexelBufferDescriptorSize = in_ext->uniformTexelBufferDescriptorSize;
            out_ext->robustUniformTexelBufferDescriptorSize = in_ext->robustUniformTexelBufferDescriptorSize;
            out_ext->storageTexelBufferDescriptorSize = in_ext->storageTexelBufferDescriptorSize;
            out_ext->robustStorageTexelBufferDescriptorSize = in_ext->robustStorageTexelBufferDescriptorSize;
            out_ext->uniformBufferDescriptorSize = in_ext->uniformBufferDescriptorSize;
            out_ext->robustUniformBufferDescriptorSize = in_ext->robustUniformBufferDescriptorSize;
            out_ext->storageBufferDescriptorSize = in_ext->storageBufferDescriptorSize;
            out_ext->robustStorageBufferDescriptorSize = in_ext->robustStorageBufferDescriptorSize;
            out_ext->inputAttachmentDescriptorSize = in_ext->inputAttachmentDescriptorSize;
            out_ext->accelerationStructureDescriptorSize = in_ext->accelerationStructureDescriptorSize;
            out_ext->maxSamplerDescriptorBufferRange = in_ext->maxSamplerDescriptorBufferRange;
            out_ext->maxResourceDescriptorBufferRange = in_ext->maxResourceDescriptorBufferRange;
            out_ext->samplerDescriptorBufferAddressSpaceSize = in_ext->samplerDescriptorBufferAddressSpaceSize;
            out_ext->resourceDescriptorBufferAddressSpaceSize = in_ext->resourceDescriptorBufferAddressSpaceSize;
            out_ext->descriptorBufferAddressSpaceSize = in_ext->descriptorBufferAddressSpaceSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM:
        {
            VkPhysicalDeviceDescriptorBufferTensorPropertiesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM);
            const VkPhysicalDeviceDescriptorBufferTensorPropertiesARM *in_ext = (const VkPhysicalDeviceDescriptorBufferTensorPropertiesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM;
            out_ext->tensorCaptureReplayDescriptorDataSize = in_ext->tensorCaptureReplayDescriptorDataSize;
            out_ext->tensorViewCaptureReplayDescriptorDataSize = in_ext->tensorViewCaptureReplayDescriptorDataSize;
            out_ext->tensorDescriptorSize = in_ext->tensorDescriptorSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {
            VkPhysicalDeviceDescriptorIndexingProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES);
            const VkPhysicalDeviceDescriptorIndexingProperties *in_ext = (const VkPhysicalDeviceDescriptorIndexingProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
            out_ext->maxUpdateAfterBindDescriptorsInAllPools = in_ext->maxUpdateAfterBindDescriptorsInAllPools;
            out_ext->shaderUniformBufferArrayNonUniformIndexingNative = in_ext->shaderUniformBufferArrayNonUniformIndexingNative;
            out_ext->shaderSampledImageArrayNonUniformIndexingNative = in_ext->shaderSampledImageArrayNonUniformIndexingNative;
            out_ext->shaderStorageBufferArrayNonUniformIndexingNative = in_ext->shaderStorageBufferArrayNonUniformIndexingNative;
            out_ext->shaderStorageImageArrayNonUniformIndexingNative = in_ext->shaderStorageImageArrayNonUniformIndexingNative;
            out_ext->shaderInputAttachmentArrayNonUniformIndexingNative = in_ext->shaderInputAttachmentArrayNonUniformIndexingNative;
            out_ext->robustBufferAccessUpdateAfterBind = in_ext->robustBufferAccessUpdateAfterBind;
            out_ext->quadDivergentImplicitLod = in_ext->quadDivergentImplicitLod;
            out_ext->maxPerStageDescriptorUpdateAfterBindSamplers = in_ext->maxPerStageDescriptorUpdateAfterBindSamplers;
            out_ext->maxPerStageDescriptorUpdateAfterBindUniformBuffers = in_ext->maxPerStageDescriptorUpdateAfterBindUniformBuffers;
            out_ext->maxPerStageDescriptorUpdateAfterBindStorageBuffers = in_ext->maxPerStageDescriptorUpdateAfterBindStorageBuffers;
            out_ext->maxPerStageDescriptorUpdateAfterBindSampledImages = in_ext->maxPerStageDescriptorUpdateAfterBindSampledImages;
            out_ext->maxPerStageDescriptorUpdateAfterBindStorageImages = in_ext->maxPerStageDescriptorUpdateAfterBindStorageImages;
            out_ext->maxPerStageDescriptorUpdateAfterBindInputAttachments = in_ext->maxPerStageDescriptorUpdateAfterBindInputAttachments;
            out_ext->maxPerStageUpdateAfterBindResources = in_ext->maxPerStageUpdateAfterBindResources;
            out_ext->maxDescriptorSetUpdateAfterBindSamplers = in_ext->maxDescriptorSetUpdateAfterBindSamplers;
            out_ext->maxDescriptorSetUpdateAfterBindUniformBuffers = in_ext->maxDescriptorSetUpdateAfterBindUniformBuffers;
            out_ext->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = in_ext->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
            out_ext->maxDescriptorSetUpdateAfterBindStorageBuffers = in_ext->maxDescriptorSetUpdateAfterBindStorageBuffers;
            out_ext->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = in_ext->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
            out_ext->maxDescriptorSetUpdateAfterBindSampledImages = in_ext->maxDescriptorSetUpdateAfterBindSampledImages;
            out_ext->maxDescriptorSetUpdateAfterBindStorageImages = in_ext->maxDescriptorSetUpdateAfterBindStorageImages;
            out_ext->maxDescriptorSetUpdateAfterBindInputAttachments = in_ext->maxDescriptorSetUpdateAfterBindInputAttachments;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT);
            const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT;
            out_ext->maxIndirectPipelineCount = in_ext->maxIndirectPipelineCount;
            out_ext->maxIndirectShaderObjectCount = in_ext->maxIndirectShaderObjectCount;
            out_ext->maxIndirectSequenceCount = in_ext->maxIndirectSequenceCount;
            out_ext->maxIndirectCommandsTokenCount = in_ext->maxIndirectCommandsTokenCount;
            out_ext->maxIndirectCommandsTokenOffset = in_ext->maxIndirectCommandsTokenOffset;
            out_ext->maxIndirectCommandsIndirectStride = in_ext->maxIndirectCommandsIndirectStride;
            out_ext->supportedIndirectCommandsInputModes = in_ext->supportedIndirectCommandsInputModes;
            out_ext->supportedIndirectCommandsShaderStages = in_ext->supportedIndirectCommandsShaderStages;
            out_ext->supportedIndirectCommandsShaderStagesPipelineBinding = in_ext->supportedIndirectCommandsShaderStagesPipelineBinding;
            out_ext->supportedIndirectCommandsShaderStagesShaderBinding = in_ext->supportedIndirectCommandsShaderStagesShaderBinding;
            out_ext->deviceGeneratedCommandsTransformFeedback = in_ext->deviceGeneratedCommandsTransformFeedback;
            out_ext->deviceGeneratedCommandsMultiDrawIndirectCount = in_ext->deviceGeneratedCommandsMultiDrawIndirectCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {
            VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV);
            const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV *in_ext = (const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
            out_ext->maxGraphicsShaderGroupCount = in_ext->maxGraphicsShaderGroupCount;
            out_ext->maxIndirectSequenceCount = in_ext->maxIndirectSequenceCount;
            out_ext->maxIndirectCommandsTokenCount = in_ext->maxIndirectCommandsTokenCount;
            out_ext->maxIndirectCommandsStreamCount = in_ext->maxIndirectCommandsStreamCount;
            out_ext->maxIndirectCommandsTokenOffset = in_ext->maxIndirectCommandsTokenOffset;
            out_ext->maxIndirectCommandsStreamStride = in_ext->maxIndirectCommandsStreamStride;
            out_ext->minSequencesCountBufferOffsetAlignment = in_ext->minSequencesCountBufferOffsetAlignment;
            out_ext->minSequencesIndexBufferOffsetAlignment = in_ext->minSequencesIndexBufferOffsetAlignment;
            out_ext->minIndirectCommandsBufferOffsetAlignment = in_ext->minIndirectCommandsBufferOffsetAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {
            VkPhysicalDeviceDiscardRectanglePropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT);
            const VkPhysicalDeviceDiscardRectanglePropertiesEXT *in_ext = (const VkPhysicalDeviceDiscardRectanglePropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
            out_ext->maxDiscardRectangles = in_ext->maxDiscardRectangles;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {
            VkPhysicalDeviceDriverProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES);
            const VkPhysicalDeviceDriverProperties *in_ext = (const VkPhysicalDeviceDriverProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
            out_ext->driverID = in_ext->driverID;
            memcpy(out_ext->driverName, in_ext->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
            memcpy(out_ext->driverInfo, in_ext->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
            out_ext->conformanceVersion = in_ext->conformanceVersion;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
        {
            VkPhysicalDeviceExtendedDynamicState3PropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT);
            const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT *in_ext = (const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT;
            out_ext->dynamicPrimitiveTopologyUnrestricted = in_ext->dynamicPrimitiveTopologyUnrestricted;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV:
        {
            VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV);
            const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV *in_ext = (const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV;
            out_ext->extendedSparseAddressSpaceSize = in_ext->extendedSparseAddressSpaceSize;
            out_ext->extendedSparseImageUsageFlags = in_ext->extendedSparseImageUsageFlags;
            out_ext->extendedSparseBufferUsageFlags = in_ext->extendedSparseBufferUsageFlags;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {
            VkPhysicalDeviceExternalMemoryHostPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT);
            const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *in_ext = (const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
            out_ext->minImportedHostPointerAlignment = in_ext->minImportedHostPointerAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {
            VkPhysicalDeviceFloatControlsProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES);
            const VkPhysicalDeviceFloatControlsProperties *in_ext = (const VkPhysicalDeviceFloatControlsProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
            out_ext->denormBehaviorIndependence = in_ext->denormBehaviorIndependence;
            out_ext->roundingModeIndependence = in_ext->roundingModeIndependence;
            out_ext->shaderSignedZeroInfNanPreserveFloat16 = in_ext->shaderSignedZeroInfNanPreserveFloat16;
            out_ext->shaderSignedZeroInfNanPreserveFloat32 = in_ext->shaderSignedZeroInfNanPreserveFloat32;
            out_ext->shaderSignedZeroInfNanPreserveFloat64 = in_ext->shaderSignedZeroInfNanPreserveFloat64;
            out_ext->shaderDenormPreserveFloat16 = in_ext->shaderDenormPreserveFloat16;
            out_ext->shaderDenormPreserveFloat32 = in_ext->shaderDenormPreserveFloat32;
            out_ext->shaderDenormPreserveFloat64 = in_ext->shaderDenormPreserveFloat64;
            out_ext->shaderDenormFlushToZeroFloat16 = in_ext->shaderDenormFlushToZeroFloat16;
            out_ext->shaderDenormFlushToZeroFloat32 = in_ext->shaderDenormFlushToZeroFloat32;
            out_ext->shaderDenormFlushToZeroFloat64 = in_ext->shaderDenormFlushToZeroFloat64;
            out_ext->shaderRoundingModeRTEFloat16 = in_ext->shaderRoundingModeRTEFloat16;
            out_ext->shaderRoundingModeRTEFloat32 = in_ext->shaderRoundingModeRTEFloat32;
            out_ext->shaderRoundingModeRTEFloat64 = in_ext->shaderRoundingModeRTEFloat64;
            out_ext->shaderRoundingModeRTZFloat16 = in_ext->shaderRoundingModeRTZFloat16;
            out_ext->shaderRoundingModeRTZFloat32 = in_ext->shaderRoundingModeRTZFloat32;
            out_ext->shaderRoundingModeRTZFloat64 = in_ext->shaderRoundingModeRTZFloat64;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMap2PropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT);
            const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT;
            out_ext->subsampledLoads = in_ext->subsampledLoads;
            out_ext->subsampledCoarseReconstructionEarlyAccess = in_ext->subsampledCoarseReconstructionEarlyAccess;
            out_ext->maxSubsampledArrayLayers = in_ext->maxSubsampledArrayLayers;
            out_ext->maxDescriptorSetSubsampledSamplers = in_ext->maxDescriptorSetSubsampledSamplers;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE:
        {
            VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE);
            const VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE *in_ext = (const VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE;
            out_ext->maxFragmentDensityMapLayers = in_ext->maxFragmentDensityMapLayers;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT);
            const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT;
            out_ext->fragmentDensityOffsetGranularity = in_ext->fragmentDensityOffsetGranularity;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceFragmentDensityMapPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT);
            const VkPhysicalDeviceFragmentDensityMapPropertiesEXT *in_ext = (const VkPhysicalDeviceFragmentDensityMapPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
            out_ext->minFragmentDensityTexelSize = in_ext->minFragmentDensityTexelSize;
            out_ext->maxFragmentDensityTexelSize = in_ext->maxFragmentDensityTexelSize;
            out_ext->fragmentDensityInvocations = in_ext->fragmentDensityInvocations;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
        {
            VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR);
            const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR *in_ext = (const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR;
            out_ext->triStripVertexOrderIndependentOfProvokingVertex = in_ext->triStripVertexOrderIndependentOfProvokingVertex;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {
            VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV);
            const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV *in_ext = (const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV;
            out_ext->maxFragmentShadingRateInvocationCount = in_ext->maxFragmentShadingRateInvocationCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceFragmentShadingRatePropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR);
            const VkPhysicalDeviceFragmentShadingRatePropertiesKHR *in_ext = (const VkPhysicalDeviceFragmentShadingRatePropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;
            out_ext->minFragmentShadingRateAttachmentTexelSize = in_ext->minFragmentShadingRateAttachmentTexelSize;
            out_ext->maxFragmentShadingRateAttachmentTexelSize = in_ext->maxFragmentShadingRateAttachmentTexelSize;
            out_ext->maxFragmentShadingRateAttachmentTexelSizeAspectRatio = in_ext->maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
            out_ext->primitiveFragmentShadingRateWithMultipleViewports = in_ext->primitiveFragmentShadingRateWithMultipleViewports;
            out_ext->layeredShadingRateAttachments = in_ext->layeredShadingRateAttachments;
            out_ext->fragmentShadingRateNonTrivialCombinerOps = in_ext->fragmentShadingRateNonTrivialCombinerOps;
            out_ext->maxFragmentSize = in_ext->maxFragmentSize;
            out_ext->maxFragmentSizeAspectRatio = in_ext->maxFragmentSizeAspectRatio;
            out_ext->maxFragmentShadingRateCoverageSamples = in_ext->maxFragmentShadingRateCoverageSamples;
            out_ext->maxFragmentShadingRateRasterizationSamples = in_ext->maxFragmentShadingRateRasterizationSamples;
            out_ext->fragmentShadingRateWithShaderDepthStencilWrites = in_ext->fragmentShadingRateWithShaderDepthStencilWrites;
            out_ext->fragmentShadingRateWithSampleMask = in_ext->fragmentShadingRateWithSampleMask;
            out_ext->fragmentShadingRateWithShaderSampleMask = in_ext->fragmentShadingRateWithShaderSampleMask;
            out_ext->fragmentShadingRateWithConservativeRasterization = in_ext->fragmentShadingRateWithConservativeRasterization;
            out_ext->fragmentShadingRateWithFragmentShaderInterlock = in_ext->fragmentShadingRateWithFragmentShaderInterlock;
            out_ext->fragmentShadingRateWithCustomSampleLocations = in_ext->fragmentShadingRateWithCustomSampleLocations;
            out_ext->fragmentShadingRateStrictMultiplyCombiner = in_ext->fragmentShadingRateStrictMultiplyCombiner;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
        {
            VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT);
            const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT *in_ext = (const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
            out_ext->graphicsPipelineLibraryFastLinking = in_ext->graphicsPipelineLibraryFastLinking;
            out_ext->graphicsPipelineLibraryIndependentInterpolationDecoration = in_ext->graphicsPipelineLibraryIndependentInterpolationDecoration;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES:
        {
            VkPhysicalDeviceHostImageCopyProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES);
            const VkPhysicalDeviceHostImageCopyProperties *in_ext = (const VkPhysicalDeviceHostImageCopyProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES;
            out_ext->copySrcLayoutCount = in_ext->copySrcLayoutCount;
            out_ext->pCopySrcLayouts = PtrToUlong(in_ext->pCopySrcLayouts);
            out_ext->copyDstLayoutCount = in_ext->copyDstLayoutCount;
            out_ext->pCopyDstLayouts = PtrToUlong(in_ext->pCopyDstLayouts);
            memcpy(out_ext->optimalTilingLayoutUUID, in_ext->optimalTilingLayoutUUID, VK_UUID_SIZE * sizeof(uint8_t));
            out_ext->identicalMemoryTypeRequirements = in_ext->identicalMemoryTypeRequirements;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {
            VkPhysicalDeviceIDProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES);
            const VkPhysicalDeviceIDProperties *in_ext = (const VkPhysicalDeviceIDProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
            memcpy(out_ext->deviceUUID, in_ext->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
            memcpy(out_ext->driverUUID, in_ext->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
            memcpy(out_ext->deviceLUID, in_ext->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
            out_ext->deviceNodeMask = in_ext->deviceNodeMask;
            out_ext->deviceLUIDValid = in_ext->deviceLUIDValid;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA:
        {
            VkPhysicalDeviceImageAlignmentControlPropertiesMESA32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA);
            const VkPhysicalDeviceImageAlignmentControlPropertiesMESA *in_ext = (const VkPhysicalDeviceImageAlignmentControlPropertiesMESA *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA;
            out_ext->supportedImageAlignmentMask = in_ext->supportedImageAlignmentMask;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceImageProcessing2PropertiesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM);
            const VkPhysicalDeviceImageProcessing2PropertiesQCOM *in_ext = (const VkPhysicalDeviceImageProcessing2PropertiesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM;
            out_ext->maxBlockMatchWindow = in_ext->maxBlockMatchWindow;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceImageProcessingPropertiesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM);
            const VkPhysicalDeviceImageProcessingPropertiesQCOM *in_ext = (const VkPhysicalDeviceImageProcessingPropertiesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM;
            out_ext->maxWeightFilterPhases = in_ext->maxWeightFilterPhases;
            out_ext->maxWeightFilterDimension = in_ext->maxWeightFilterDimension;
            out_ext->maxBlockMatchRegion = in_ext->maxBlockMatchRegion;
            out_ext->maxBoxFilterBlockSize = in_ext->maxBoxFilterBlockSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
        {
            VkPhysicalDeviceInlineUniformBlockProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES);
            const VkPhysicalDeviceInlineUniformBlockProperties *in_ext = (const VkPhysicalDeviceInlineUniformBlockProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
            out_ext->maxInlineUniformBlockSize = in_ext->maxInlineUniformBlockSize;
            out_ext->maxPerStageDescriptorInlineUniformBlocks = in_ext->maxPerStageDescriptorInlineUniformBlocks;
            out_ext->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = in_ext->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
            out_ext->maxDescriptorSetInlineUniformBlocks = in_ext->maxDescriptorSetInlineUniformBlocks;
            out_ext->maxDescriptorSetUpdateAfterBindInlineUniformBlocks = in_ext->maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
        {
            VkPhysicalDeviceLayeredDriverPropertiesMSFT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT);
            const VkPhysicalDeviceLayeredDriverPropertiesMSFT *in_ext = (const VkPhysicalDeviceLayeredDriverPropertiesMSFT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT;
            out_ext->underlyingAPI = in_ext->underlyingAPI;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT:
        {
            VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT);
            const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT *in_ext = (const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT;
            out_ext->nativeUnalignedPerformance = in_ext->nativeUnalignedPerformance;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES:
        {
            VkPhysicalDeviceLineRasterizationProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES);
            const VkPhysicalDeviceLineRasterizationProperties *in_ext = (const VkPhysicalDeviceLineRasterizationProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES;
            out_ext->lineSubPixelPrecisionBits = in_ext->lineSubPixelPrecisionBits;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance3Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES);
            const VkPhysicalDeviceMaintenance3Properties *in_ext = (const VkPhysicalDeviceMaintenance3Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
            out_ext->maxPerSetDescriptors = in_ext->maxPerSetDescriptors;
            out_ext->maxMemoryAllocationSize = in_ext->maxMemoryAllocationSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance4Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES);
            const VkPhysicalDeviceMaintenance4Properties *in_ext = (const VkPhysicalDeviceMaintenance4Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
            out_ext->maxBufferSize = in_ext->maxBufferSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance5Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES);
            const VkPhysicalDeviceMaintenance5Properties *in_ext = (const VkPhysicalDeviceMaintenance5Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES;
            out_ext->earlyFragmentMultisampleCoverageAfterSampleCounting = in_ext->earlyFragmentMultisampleCoverageAfterSampleCounting;
            out_ext->earlyFragmentSampleMaskTestBeforeSampleCounting = in_ext->earlyFragmentSampleMaskTestBeforeSampleCounting;
            out_ext->depthStencilSwizzleOneSupport = in_ext->depthStencilSwizzleOneSupport;
            out_ext->polygonModePointSize = in_ext->polygonModePointSize;
            out_ext->nonStrictSinglePixelWideLinesUseParallelogram = in_ext->nonStrictSinglePixelWideLinesUseParallelogram;
            out_ext->nonStrictWideLinesUseParallelogram = in_ext->nonStrictWideLinesUseParallelogram;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES:
        {
            VkPhysicalDeviceMaintenance6Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES);
            const VkPhysicalDeviceMaintenance6Properties *in_ext = (const VkPhysicalDeviceMaintenance6Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES;
            out_ext->blockTexelViewCompatibleMultipleLayers = in_ext->blockTexelViewCompatibleMultipleLayers;
            out_ext->maxCombinedImageSamplerDescriptorCount = in_ext->maxCombinedImageSamplerDescriptorCount;
            out_ext->fragmentShadingRateClampCombinerInputs = in_ext->fragmentShadingRateClampCombinerInputs;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR:
        {
            VkPhysicalDeviceMaintenance9PropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR);
            const VkPhysicalDeviceMaintenance9PropertiesKHR *in_ext = (const VkPhysicalDeviceMaintenance9PropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR;
            out_ext->image2DViewOf3DSparse = in_ext->image2DViewOf3DSparse;
            out_ext->defaultVertexAttributeValue = in_ext->defaultVertexAttributeValue;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV:
        {
            VkPhysicalDeviceMemoryDecompressionPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV);
            const VkPhysicalDeviceMemoryDecompressionPropertiesNV *in_ext = (const VkPhysicalDeviceMemoryDecompressionPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV;
            out_ext->decompressionMethods = in_ext->decompressionMethods;
            out_ext->maxDecompressionIndirectCount = in_ext->maxDecompressionIndirectCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMeshShaderPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT);
            const VkPhysicalDeviceMeshShaderPropertiesEXT *in_ext = (const VkPhysicalDeviceMeshShaderPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT;
            out_ext->maxTaskWorkGroupTotalCount = in_ext->maxTaskWorkGroupTotalCount;
            memcpy(out_ext->maxTaskWorkGroupCount, in_ext->maxTaskWorkGroupCount, 3 * sizeof(uint32_t));
            out_ext->maxTaskWorkGroupInvocations = in_ext->maxTaskWorkGroupInvocations;
            memcpy(out_ext->maxTaskWorkGroupSize, in_ext->maxTaskWorkGroupSize, 3 * sizeof(uint32_t));
            out_ext->maxTaskPayloadSize = in_ext->maxTaskPayloadSize;
            out_ext->maxTaskSharedMemorySize = in_ext->maxTaskSharedMemorySize;
            out_ext->maxTaskPayloadAndSharedMemorySize = in_ext->maxTaskPayloadAndSharedMemorySize;
            out_ext->maxMeshWorkGroupTotalCount = in_ext->maxMeshWorkGroupTotalCount;
            memcpy(out_ext->maxMeshWorkGroupCount, in_ext->maxMeshWorkGroupCount, 3 * sizeof(uint32_t));
            out_ext->maxMeshWorkGroupInvocations = in_ext->maxMeshWorkGroupInvocations;
            memcpy(out_ext->maxMeshWorkGroupSize, in_ext->maxMeshWorkGroupSize, 3 * sizeof(uint32_t));
            out_ext->maxMeshSharedMemorySize = in_ext->maxMeshSharedMemorySize;
            out_ext->maxMeshPayloadAndSharedMemorySize = in_ext->maxMeshPayloadAndSharedMemorySize;
            out_ext->maxMeshOutputMemorySize = in_ext->maxMeshOutputMemorySize;
            out_ext->maxMeshPayloadAndOutputMemorySize = in_ext->maxMeshPayloadAndOutputMemorySize;
            out_ext->maxMeshOutputComponents = in_ext->maxMeshOutputComponents;
            out_ext->maxMeshOutputVertices = in_ext->maxMeshOutputVertices;
            out_ext->maxMeshOutputPrimitives = in_ext->maxMeshOutputPrimitives;
            out_ext->maxMeshOutputLayers = in_ext->maxMeshOutputLayers;
            out_ext->maxMeshMultiviewViewCount = in_ext->maxMeshMultiviewViewCount;
            out_ext->meshOutputPerVertexGranularity = in_ext->meshOutputPerVertexGranularity;
            out_ext->meshOutputPerPrimitiveGranularity = in_ext->meshOutputPerPrimitiveGranularity;
            out_ext->maxPreferredTaskWorkGroupInvocations = in_ext->maxPreferredTaskWorkGroupInvocations;
            out_ext->maxPreferredMeshWorkGroupInvocations = in_ext->maxPreferredMeshWorkGroupInvocations;
            out_ext->prefersLocalInvocationVertexOutput = in_ext->prefersLocalInvocationVertexOutput;
            out_ext->prefersLocalInvocationPrimitiveOutput = in_ext->prefersLocalInvocationPrimitiveOutput;
            out_ext->prefersCompactVertexOutput = in_ext->prefersCompactVertexOutput;
            out_ext->prefersCompactPrimitiveOutput = in_ext->prefersCompactPrimitiveOutput;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {
            VkPhysicalDeviceMeshShaderPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV);
            const VkPhysicalDeviceMeshShaderPropertiesNV *in_ext = (const VkPhysicalDeviceMeshShaderPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
            out_ext->maxDrawMeshTasksCount = in_ext->maxDrawMeshTasksCount;
            out_ext->maxTaskWorkGroupInvocations = in_ext->maxTaskWorkGroupInvocations;
            memcpy(out_ext->maxTaskWorkGroupSize, in_ext->maxTaskWorkGroupSize, 3 * sizeof(uint32_t));
            out_ext->maxTaskTotalMemorySize = in_ext->maxTaskTotalMemorySize;
            out_ext->maxTaskOutputCount = in_ext->maxTaskOutputCount;
            out_ext->maxMeshWorkGroupInvocations = in_ext->maxMeshWorkGroupInvocations;
            memcpy(out_ext->maxMeshWorkGroupSize, in_ext->maxMeshWorkGroupSize, 3 * sizeof(uint32_t));
            out_ext->maxMeshTotalMemorySize = in_ext->maxMeshTotalMemorySize;
            out_ext->maxMeshOutputVertices = in_ext->maxMeshOutputVertices;
            out_ext->maxMeshOutputPrimitives = in_ext->maxMeshOutputPrimitives;
            out_ext->maxMeshMultiviewViewCount = in_ext->maxMeshMultiviewViewCount;
            out_ext->meshOutputPerVertexGranularity = in_ext->meshOutputPerVertexGranularity;
            out_ext->meshOutputPerPrimitiveGranularity = in_ext->meshOutputPerPrimitiveGranularity;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
        {
            VkPhysicalDeviceMultiDrawPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT);
            const VkPhysicalDeviceMultiDrawPropertiesEXT *in_ext = (const VkPhysicalDeviceMultiDrawPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT;
            out_ext->maxMultiDrawCount = in_ext->maxMultiDrawCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {
            VkPhysicalDeviceMultiviewProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES);
            const VkPhysicalDeviceMultiviewProperties *in_ext = (const VkPhysicalDeviceMultiviewProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
            out_ext->maxMultiviewViewCount = in_ext->maxMultiviewViewCount;
            out_ext->maxMultiviewInstanceIndex = in_ext->maxMultiviewInstanceIndex;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceNestedCommandBufferPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT);
            const VkPhysicalDeviceNestedCommandBufferPropertiesEXT *in_ext = (const VkPhysicalDeviceNestedCommandBufferPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT;
            out_ext->maxCommandBufferNestingLevel = in_ext->maxCommandBufferNestingLevel;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
        {
            VkPhysicalDeviceOpacityMicromapPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT);
            const VkPhysicalDeviceOpacityMicromapPropertiesEXT *in_ext = (const VkPhysicalDeviceOpacityMicromapPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT;
            out_ext->maxOpacity2StateSubdivisionLevel = in_ext->maxOpacity2StateSubdivisionLevel;
            out_ext->maxOpacity4StateSubdivisionLevel = in_ext->maxOpacity4StateSubdivisionLevel;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
        {
            VkPhysicalDeviceOpticalFlowPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV);
            const VkPhysicalDeviceOpticalFlowPropertiesNV *in_ext = (const VkPhysicalDeviceOpticalFlowPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV;
            out_ext->supportedOutputGridSizes = in_ext->supportedOutputGridSizes;
            out_ext->supportedHintGridSizes = in_ext->supportedHintGridSizes;
            out_ext->hintSupported = in_ext->hintSupported;
            out_ext->costSupported = in_ext->costSupported;
            out_ext->bidirectionalFlowSupported = in_ext->bidirectionalFlowSupported;
            out_ext->globalFlowSupported = in_ext->globalFlowSupported;
            out_ext->minWidth = in_ext->minWidth;
            out_ext->minHeight = in_ext->minHeight;
            out_ext->maxWidth = in_ext->maxWidth;
            out_ext->maxHeight = in_ext->maxHeight;
            out_ext->maxNumRegionsOfInterest = in_ext->maxNumRegionsOfInterest;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {
            VkPhysicalDevicePCIBusInfoPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT);
            const VkPhysicalDevicePCIBusInfoPropertiesEXT *in_ext = (const VkPhysicalDevicePCIBusInfoPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
            out_ext->pciDomain = in_ext->pciDomain;
            out_ext->pciBus = in_ext->pciBus;
            out_ext->pciDevice = in_ext->pciDevice;
            out_ext->pciFunction = in_ext->pciFunction;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV:
        {
            VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV);
            const VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV *in_ext = (const VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV;
            out_ext->maxPartitionCount = in_ext->maxPartitionCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {
            VkPhysicalDevicePerformanceQueryPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR);
            const VkPhysicalDevicePerformanceQueryPropertiesKHR *in_ext = (const VkPhysicalDevicePerformanceQueryPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR;
            out_ext->allowCommandBufferQueryCopies = in_ext->allowCommandBufferQueryCopies;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR:
        {
            VkPhysicalDevicePipelineBinaryPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR);
            const VkPhysicalDevicePipelineBinaryPropertiesKHR *in_ext = (const VkPhysicalDevicePipelineBinaryPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR;
            out_ext->pipelineBinaryInternalCache = in_ext->pipelineBinaryInternalCache;
            out_ext->pipelineBinaryInternalCacheControl = in_ext->pipelineBinaryInternalCacheControl;
            out_ext->pipelineBinaryPrefersInternalCache = in_ext->pipelineBinaryPrefersInternalCache;
            out_ext->pipelineBinaryPrecompiledInternalCache = in_ext->pipelineBinaryPrecompiledInternalCache;
            out_ext->pipelineBinaryCompressedData = in_ext->pipelineBinaryCompressedData;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES:
        {
            VkPhysicalDevicePipelineRobustnessProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES);
            const VkPhysicalDevicePipelineRobustnessProperties *in_ext = (const VkPhysicalDevicePipelineRobustnessProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES;
            out_ext->defaultRobustnessStorageBuffers = in_ext->defaultRobustnessStorageBuffers;
            out_ext->defaultRobustnessUniformBuffers = in_ext->defaultRobustnessUniformBuffers;
            out_ext->defaultRobustnessVertexInputs = in_ext->defaultRobustnessVertexInputs;
            out_ext->defaultRobustnessImages = in_ext->defaultRobustnessImages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {
            VkPhysicalDevicePointClippingProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES);
            const VkPhysicalDevicePointClippingProperties *in_ext = (const VkPhysicalDevicePointClippingProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
            out_ext->pointClippingBehavior = in_ext->pointClippingBehavior;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {
            VkPhysicalDeviceProtectedMemoryProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES);
            const VkPhysicalDeviceProtectedMemoryProperties *in_ext = (const VkPhysicalDeviceProtectedMemoryProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
            out_ext->protectedNoFault = in_ext->protectedNoFault;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
        {
            VkPhysicalDeviceProvokingVertexPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT);
            const VkPhysicalDeviceProvokingVertexPropertiesEXT *in_ext = (const VkPhysicalDeviceProvokingVertexPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT;
            out_ext->provokingVertexModePerPipeline = in_ext->provokingVertexModePerPipeline;
            out_ext->transformFeedbackPreservesTriangleFanProvokingVertex = in_ext->transformFeedbackPreservesTriangleFanProvokingVertex;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES:
        {
            VkPhysicalDevicePushDescriptorProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES);
            const VkPhysicalDevicePushDescriptorProperties *in_ext = (const VkPhysicalDevicePushDescriptorProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES;
            out_ext->maxPushDescriptors = in_ext->maxPushDescriptors;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
        {
            VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV);
            const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV *in_ext = (const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV;
            out_ext->rayTracingInvocationReorderReorderingHint = in_ext->rayTracingInvocationReorderReorderingHint;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {
            VkPhysicalDeviceRayTracingPipelinePropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR);
            const VkPhysicalDeviceRayTracingPipelinePropertiesKHR *in_ext = (const VkPhysicalDeviceRayTracingPipelinePropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
            out_ext->shaderGroupHandleSize = in_ext->shaderGroupHandleSize;
            out_ext->maxRayRecursionDepth = in_ext->maxRayRecursionDepth;
            out_ext->maxShaderGroupStride = in_ext->maxShaderGroupStride;
            out_ext->shaderGroupBaseAlignment = in_ext->shaderGroupBaseAlignment;
            out_ext->shaderGroupHandleCaptureReplaySize = in_ext->shaderGroupHandleCaptureReplaySize;
            out_ext->maxRayDispatchInvocationCount = in_ext->maxRayDispatchInvocationCount;
            out_ext->shaderGroupHandleAlignment = in_ext->shaderGroupHandleAlignment;
            out_ext->maxRayHitAttributeSize = in_ext->maxRayHitAttributeSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {
            VkPhysicalDeviceRayTracingPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV);
            const VkPhysicalDeviceRayTracingPropertiesNV *in_ext = (const VkPhysicalDeviceRayTracingPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
            out_ext->shaderGroupHandleSize = in_ext->shaderGroupHandleSize;
            out_ext->maxRecursionDepth = in_ext->maxRecursionDepth;
            out_ext->maxShaderGroupStride = in_ext->maxShaderGroupStride;
            out_ext->shaderGroupBaseAlignment = in_ext->shaderGroupBaseAlignment;
            out_ext->maxGeometryCount = in_ext->maxGeometryCount;
            out_ext->maxInstanceCount = in_ext->maxInstanceCount;
            out_ext->maxTriangleCount = in_ext->maxTriangleCount;
            out_ext->maxDescriptorSetAccelerationStructures = in_ext->maxDescriptorSetAccelerationStructures;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM:
        {
            VkPhysicalDeviceRenderPassStripedPropertiesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM);
            const VkPhysicalDeviceRenderPassStripedPropertiesARM *in_ext = (const VkPhysicalDeviceRenderPassStripedPropertiesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM;
            out_ext->renderPassStripeGranularity = in_ext->renderPassStripeGranularity;
            out_ext->maxRenderPassStripes = in_ext->maxRenderPassStripes;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR:
        {
            VkPhysicalDeviceRobustness2PropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR);
            const VkPhysicalDeviceRobustness2PropertiesKHR *in_ext = (const VkPhysicalDeviceRobustness2PropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR;
            out_ext->robustStorageBufferAccessSizeAlignment = in_ext->robustStorageBufferAccessSizeAlignment;
            out_ext->robustUniformBufferAccessSizeAlignment = in_ext->robustUniformBufferAccessSizeAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {
            VkPhysicalDeviceSampleLocationsPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT);
            const VkPhysicalDeviceSampleLocationsPropertiesEXT *in_ext = (const VkPhysicalDeviceSampleLocationsPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
            out_ext->sampleLocationSampleCounts = in_ext->sampleLocationSampleCounts;
            out_ext->maxSampleLocationGridSize = in_ext->maxSampleLocationGridSize;
            memcpy(out_ext->sampleLocationCoordinateRange, in_ext->sampleLocationCoordinateRange, 2 * sizeof(float));
            out_ext->sampleLocationSubPixelBits = in_ext->sampleLocationSubPixelBits;
            out_ext->variableSampleLocations = in_ext->variableSampleLocations;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {
            VkPhysicalDeviceSamplerFilterMinmaxProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES);
            const VkPhysicalDeviceSamplerFilterMinmaxProperties *in_ext = (const VkPhysicalDeviceSamplerFilterMinmaxProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
            out_ext->filterMinmaxSingleComponentFormats = in_ext->filterMinmaxSingleComponentFormats;
            out_ext->filterMinmaxImageComponentMapping = in_ext->filterMinmaxImageComponentMapping;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM:
        {
            VkPhysicalDeviceSchedulingControlsPropertiesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM);
            const VkPhysicalDeviceSchedulingControlsPropertiesARM *in_ext = (const VkPhysicalDeviceSchedulingControlsPropertiesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM;
            out_ext->schedulingControlsFlags = in_ext->schedulingControlsFlags;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
        {
            VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM);
            const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM *in_ext = (const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM;
            out_ext->shaderCoreMask = in_ext->shaderCoreMask;
            out_ext->shaderCoreCount = in_ext->shaderCoreCount;
            out_ext->shaderWarpsPerCore = in_ext->shaderWarpsPerCore;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {
            VkPhysicalDeviceShaderCoreProperties2AMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD);
            const VkPhysicalDeviceShaderCoreProperties2AMD *in_ext = (const VkPhysicalDeviceShaderCoreProperties2AMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
            out_ext->shaderCoreFeatures = in_ext->shaderCoreFeatures;
            out_ext->activeComputeUnitCount = in_ext->activeComputeUnitCount;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {
            VkPhysicalDeviceShaderCorePropertiesAMD32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD);
            const VkPhysicalDeviceShaderCorePropertiesAMD *in_ext = (const VkPhysicalDeviceShaderCorePropertiesAMD *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
            out_ext->shaderEngineCount = in_ext->shaderEngineCount;
            out_ext->shaderArraysPerEngineCount = in_ext->shaderArraysPerEngineCount;
            out_ext->computeUnitsPerShaderArray = in_ext->computeUnitsPerShaderArray;
            out_ext->simdPerComputeUnit = in_ext->simdPerComputeUnit;
            out_ext->wavefrontsPerSimd = in_ext->wavefrontsPerSimd;
            out_ext->wavefrontSize = in_ext->wavefrontSize;
            out_ext->sgprsPerSimd = in_ext->sgprsPerSimd;
            out_ext->minSgprAllocation = in_ext->minSgprAllocation;
            out_ext->maxSgprAllocation = in_ext->maxSgprAllocation;
            out_ext->sgprAllocationGranularity = in_ext->sgprAllocationGranularity;
            out_ext->vgprsPerSimd = in_ext->vgprsPerSimd;
            out_ext->minVgprAllocation = in_ext->minVgprAllocation;
            out_ext->maxVgprAllocation = in_ext->maxVgprAllocation;
            out_ext->vgprAllocationGranularity = in_ext->vgprAllocationGranularity;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
        {
            VkPhysicalDeviceShaderCorePropertiesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM);
            const VkPhysicalDeviceShaderCorePropertiesARM *in_ext = (const VkPhysicalDeviceShaderCorePropertiesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM;
            out_ext->pixelRate = in_ext->pixelRate;
            out_ext->texelRate = in_ext->texelRate;
            out_ext->fmaRate = in_ext->fmaRate;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
        {
            VkPhysicalDeviceShaderIntegerDotProductProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES);
            const VkPhysicalDeviceShaderIntegerDotProductProperties *in_ext = (const VkPhysicalDeviceShaderIntegerDotProductProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
            out_ext->integerDotProduct8BitUnsignedAccelerated = in_ext->integerDotProduct8BitUnsignedAccelerated;
            out_ext->integerDotProduct8BitSignedAccelerated = in_ext->integerDotProduct8BitSignedAccelerated;
            out_ext->integerDotProduct8BitMixedSignednessAccelerated = in_ext->integerDotProduct8BitMixedSignednessAccelerated;
            out_ext->integerDotProduct4x8BitPackedUnsignedAccelerated = in_ext->integerDotProduct4x8BitPackedUnsignedAccelerated;
            out_ext->integerDotProduct4x8BitPackedSignedAccelerated = in_ext->integerDotProduct4x8BitPackedSignedAccelerated;
            out_ext->integerDotProduct4x8BitPackedMixedSignednessAccelerated = in_ext->integerDotProduct4x8BitPackedMixedSignednessAccelerated;
            out_ext->integerDotProduct16BitUnsignedAccelerated = in_ext->integerDotProduct16BitUnsignedAccelerated;
            out_ext->integerDotProduct16BitSignedAccelerated = in_ext->integerDotProduct16BitSignedAccelerated;
            out_ext->integerDotProduct16BitMixedSignednessAccelerated = in_ext->integerDotProduct16BitMixedSignednessAccelerated;
            out_ext->integerDotProduct32BitUnsignedAccelerated = in_ext->integerDotProduct32BitUnsignedAccelerated;
            out_ext->integerDotProduct32BitSignedAccelerated = in_ext->integerDotProduct32BitSignedAccelerated;
            out_ext->integerDotProduct32BitMixedSignednessAccelerated = in_ext->integerDotProduct32BitMixedSignednessAccelerated;
            out_ext->integerDotProduct64BitUnsignedAccelerated = in_ext->integerDotProduct64BitUnsignedAccelerated;
            out_ext->integerDotProduct64BitSignedAccelerated = in_ext->integerDotProduct64BitSignedAccelerated;
            out_ext->integerDotProduct64BitMixedSignednessAccelerated = in_ext->integerDotProduct64BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT);
            const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT *in_ext = (const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT;
            memcpy(out_ext->shaderModuleIdentifierAlgorithmUUID, in_ext->shaderModuleIdentifierAlgorithmUUID, VK_UUID_SIZE * sizeof(uint8_t));
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderObjectPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT);
            const VkPhysicalDeviceShaderObjectPropertiesEXT *in_ext = (const VkPhysicalDeviceShaderObjectPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT;
            memcpy(out_ext->shaderBinaryUUID, in_ext->shaderBinaryUUID, VK_UUID_SIZE * sizeof(uint8_t));
            out_ext->shaderBinaryVersion = in_ext->shaderBinaryVersion;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {
            VkPhysicalDeviceShaderSMBuiltinsPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV);
            const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV *in_ext = (const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
            out_ext->shaderSMCount = in_ext->shaderSMCount;
            out_ext->shaderWarpsPerSM = in_ext->shaderWarpsPerSM;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
        {
            VkPhysicalDeviceShaderTileImagePropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT);
            const VkPhysicalDeviceShaderTileImagePropertiesEXT *in_ext = (const VkPhysicalDeviceShaderTileImagePropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT;
            out_ext->shaderTileImageCoherentReadAccelerated = in_ext->shaderTileImageCoherentReadAccelerated;
            out_ext->shaderTileImageReadSampleFromPixelRateInvocation = in_ext->shaderTileImageReadSampleFromPixelRateInvocation;
            out_ext->shaderTileImageReadFromHelperInvocation = in_ext->shaderTileImageReadFromHelperInvocation;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {
            VkPhysicalDeviceShadingRateImagePropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV);
            const VkPhysicalDeviceShadingRateImagePropertiesNV *in_ext = (const VkPhysicalDeviceShadingRateImagePropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
            out_ext->shadingRateTexelSize = in_ext->shadingRateTexelSize;
            out_ext->shadingRatePaletteSize = in_ext->shadingRatePaletteSize;
            out_ext->shadingRateMaxCoarseSamples = in_ext->shadingRateMaxCoarseSamples;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {
            VkPhysicalDeviceSubgroupProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES);
            const VkPhysicalDeviceSubgroupProperties *in_ext = (const VkPhysicalDeviceSubgroupProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
            out_ext->subgroupSize = in_ext->subgroupSize;
            out_ext->supportedStages = in_ext->supportedStages;
            out_ext->supportedOperations = in_ext->supportedOperations;
            out_ext->quadOperationsInAllStages = in_ext->quadOperationsInAllStages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
        {
            VkPhysicalDeviceSubgroupSizeControlProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES);
            const VkPhysicalDeviceSubgroupSizeControlProperties *in_ext = (const VkPhysicalDeviceSubgroupSizeControlProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
            out_ext->minSubgroupSize = in_ext->minSubgroupSize;
            out_ext->maxSubgroupSize = in_ext->maxSubgroupSize;
            out_ext->maxComputeWorkgroupSubgroups = in_ext->maxComputeWorkgroupSubgroups;
            out_ext->requiredSubgroupSizeStages = in_ext->requiredSubgroupSizeStages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
        {
            VkPhysicalDeviceSubpassShadingPropertiesHUAWEI32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI);
            const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI *in_ext = (const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI;
            out_ext->maxSubpassShadingWorkgroupSizeAspectRatio = in_ext->maxSubpassShadingWorkgroupSizeAspectRatio;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM:
        {
            VkPhysicalDeviceTensorPropertiesARM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM);
            const VkPhysicalDeviceTensorPropertiesARM *in_ext = (const VkPhysicalDeviceTensorPropertiesARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM;
            out_ext->maxTensorDimensionCount = in_ext->maxTensorDimensionCount;
            out_ext->maxTensorElements = in_ext->maxTensorElements;
            out_ext->maxPerDimensionTensorElements = in_ext->maxPerDimensionTensorElements;
            out_ext->maxTensorStride = in_ext->maxTensorStride;
            out_ext->maxTensorSize = in_ext->maxTensorSize;
            out_ext->maxTensorShaderAccessArrayLength = in_ext->maxTensorShaderAccessArrayLength;
            out_ext->maxTensorShaderAccessSize = in_ext->maxTensorShaderAccessSize;
            out_ext->maxDescriptorSetStorageTensors = in_ext->maxDescriptorSetStorageTensors;
            out_ext->maxPerStageDescriptorSetStorageTensors = in_ext->maxPerStageDescriptorSetStorageTensors;
            out_ext->maxDescriptorSetUpdateAfterBindStorageTensors = in_ext->maxDescriptorSetUpdateAfterBindStorageTensors;
            out_ext->maxPerStageDescriptorUpdateAfterBindStorageTensors = in_ext->maxPerStageDescriptorUpdateAfterBindStorageTensors;
            out_ext->shaderStorageTensorArrayNonUniformIndexingNative = in_ext->shaderStorageTensorArrayNonUniformIndexingNative;
            out_ext->shaderTensorSupportedStages = in_ext->shaderTensorSupportedStages;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
        {
            VkPhysicalDeviceTexelBufferAlignmentProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES);
            const VkPhysicalDeviceTexelBufferAlignmentProperties *in_ext = (const VkPhysicalDeviceTexelBufferAlignmentProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
            out_ext->storageTexelBufferOffsetAlignmentBytes = in_ext->storageTexelBufferOffsetAlignmentBytes;
            out_ext->storageTexelBufferOffsetSingleTexelAlignment = in_ext->storageTexelBufferOffsetSingleTexelAlignment;
            out_ext->uniformTexelBufferOffsetAlignmentBytes = in_ext->uniformTexelBufferOffsetAlignmentBytes;
            out_ext->uniformTexelBufferOffsetSingleTexelAlignment = in_ext->uniformTexelBufferOffsetSingleTexelAlignment;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceTileMemoryHeapPropertiesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM);
            const VkPhysicalDeviceTileMemoryHeapPropertiesQCOM *in_ext = (const VkPhysicalDeviceTileMemoryHeapPropertiesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM;
            out_ext->queueSubmitBoundary = in_ext->queueSubmitBoundary;
            out_ext->tileBufferTransfers = in_ext->tileBufferTransfers;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM:
        {
            VkPhysicalDeviceTileShadingPropertiesQCOM32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM);
            const VkPhysicalDeviceTileShadingPropertiesQCOM *in_ext = (const VkPhysicalDeviceTileShadingPropertiesQCOM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM;
            out_ext->maxApronSize = in_ext->maxApronSize;
            out_ext->preferNonCoherent = in_ext->preferNonCoherent;
            out_ext->tileGranularity = in_ext->tileGranularity;
            out_ext->maxTileShadingRate = in_ext->maxTileShadingRate;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {
            VkPhysicalDeviceTimelineSemaphoreProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES);
            const VkPhysicalDeviceTimelineSemaphoreProperties *in_ext = (const VkPhysicalDeviceTimelineSemaphoreProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
            out_ext->maxTimelineSemaphoreValueDifference = in_ext->maxTimelineSemaphoreValueDifference;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {
            VkPhysicalDeviceTransformFeedbackPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT);
            const VkPhysicalDeviceTransformFeedbackPropertiesEXT *in_ext = (const VkPhysicalDeviceTransformFeedbackPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
            out_ext->maxTransformFeedbackStreams = in_ext->maxTransformFeedbackStreams;
            out_ext->maxTransformFeedbackBuffers = in_ext->maxTransformFeedbackBuffers;
            out_ext->maxTransformFeedbackBufferSize = in_ext->maxTransformFeedbackBufferSize;
            out_ext->maxTransformFeedbackStreamDataSize = in_ext->maxTransformFeedbackStreamDataSize;
            out_ext->maxTransformFeedbackBufferDataSize = in_ext->maxTransformFeedbackBufferDataSize;
            out_ext->maxTransformFeedbackBufferDataStride = in_ext->maxTransformFeedbackBufferDataStride;
            out_ext->transformFeedbackQueries = in_ext->transformFeedbackQueries;
            out_ext->transformFeedbackStreamsLinesTriangles = in_ext->transformFeedbackStreamsLinesTriangles;
            out_ext->transformFeedbackRasterizationStreamSelect = in_ext->transformFeedbackRasterizationStreamSelect;
            out_ext->transformFeedbackDraw = in_ext->transformFeedbackDraw;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES:
        {
            VkPhysicalDeviceVertexAttributeDivisorProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES);
            const VkPhysicalDeviceVertexAttributeDivisorProperties *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES;
            out_ext->maxVertexAttribDivisor = in_ext->maxVertexAttribDivisor;
            out_ext->supportsNonZeroFirstInstance = in_ext->supportsNonZeroFirstInstance;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {
            VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT);
            const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *in_ext = (const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
            out_ext->maxVertexAttribDivisor = in_ext->maxVertexAttribDivisor;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {
            VkPhysicalDeviceVulkan11Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES);
            const VkPhysicalDeviceVulkan11Properties *in_ext = (const VkPhysicalDeviceVulkan11Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES;
            memcpy(out_ext->deviceUUID, in_ext->deviceUUID, VK_UUID_SIZE * sizeof(uint8_t));
            memcpy(out_ext->driverUUID, in_ext->driverUUID, VK_UUID_SIZE * sizeof(uint8_t));
            memcpy(out_ext->deviceLUID, in_ext->deviceLUID, VK_LUID_SIZE * sizeof(uint8_t));
            out_ext->deviceNodeMask = in_ext->deviceNodeMask;
            out_ext->deviceLUIDValid = in_ext->deviceLUIDValid;
            out_ext->subgroupSize = in_ext->subgroupSize;
            out_ext->subgroupSupportedStages = in_ext->subgroupSupportedStages;
            out_ext->subgroupSupportedOperations = in_ext->subgroupSupportedOperations;
            out_ext->subgroupQuadOperationsInAllStages = in_ext->subgroupQuadOperationsInAllStages;
            out_ext->pointClippingBehavior = in_ext->pointClippingBehavior;
            out_ext->maxMultiviewViewCount = in_ext->maxMultiviewViewCount;
            out_ext->maxMultiviewInstanceIndex = in_ext->maxMultiviewInstanceIndex;
            out_ext->protectedNoFault = in_ext->protectedNoFault;
            out_ext->maxPerSetDescriptors = in_ext->maxPerSetDescriptors;
            out_ext->maxMemoryAllocationSize = in_ext->maxMemoryAllocationSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {
            VkPhysicalDeviceVulkan12Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES);
            const VkPhysicalDeviceVulkan12Properties *in_ext = (const VkPhysicalDeviceVulkan12Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES;
            out_ext->driverID = in_ext->driverID;
            memcpy(out_ext->driverName, in_ext->driverName, VK_MAX_DRIVER_NAME_SIZE * sizeof(char));
            memcpy(out_ext->driverInfo, in_ext->driverInfo, VK_MAX_DRIVER_INFO_SIZE * sizeof(char));
            out_ext->conformanceVersion = in_ext->conformanceVersion;
            out_ext->denormBehaviorIndependence = in_ext->denormBehaviorIndependence;
            out_ext->roundingModeIndependence = in_ext->roundingModeIndependence;
            out_ext->shaderSignedZeroInfNanPreserveFloat16 = in_ext->shaderSignedZeroInfNanPreserveFloat16;
            out_ext->shaderSignedZeroInfNanPreserveFloat32 = in_ext->shaderSignedZeroInfNanPreserveFloat32;
            out_ext->shaderSignedZeroInfNanPreserveFloat64 = in_ext->shaderSignedZeroInfNanPreserveFloat64;
            out_ext->shaderDenormPreserveFloat16 = in_ext->shaderDenormPreserveFloat16;
            out_ext->shaderDenormPreserveFloat32 = in_ext->shaderDenormPreserveFloat32;
            out_ext->shaderDenormPreserveFloat64 = in_ext->shaderDenormPreserveFloat64;
            out_ext->shaderDenormFlushToZeroFloat16 = in_ext->shaderDenormFlushToZeroFloat16;
            out_ext->shaderDenormFlushToZeroFloat32 = in_ext->shaderDenormFlushToZeroFloat32;
            out_ext->shaderDenormFlushToZeroFloat64 = in_ext->shaderDenormFlushToZeroFloat64;
            out_ext->shaderRoundingModeRTEFloat16 = in_ext->shaderRoundingModeRTEFloat16;
            out_ext->shaderRoundingModeRTEFloat32 = in_ext->shaderRoundingModeRTEFloat32;
            out_ext->shaderRoundingModeRTEFloat64 = in_ext->shaderRoundingModeRTEFloat64;
            out_ext->shaderRoundingModeRTZFloat16 = in_ext->shaderRoundingModeRTZFloat16;
            out_ext->shaderRoundingModeRTZFloat32 = in_ext->shaderRoundingModeRTZFloat32;
            out_ext->shaderRoundingModeRTZFloat64 = in_ext->shaderRoundingModeRTZFloat64;
            out_ext->maxUpdateAfterBindDescriptorsInAllPools = in_ext->maxUpdateAfterBindDescriptorsInAllPools;
            out_ext->shaderUniformBufferArrayNonUniformIndexingNative = in_ext->shaderUniformBufferArrayNonUniformIndexingNative;
            out_ext->shaderSampledImageArrayNonUniformIndexingNative = in_ext->shaderSampledImageArrayNonUniformIndexingNative;
            out_ext->shaderStorageBufferArrayNonUniformIndexingNative = in_ext->shaderStorageBufferArrayNonUniformIndexingNative;
            out_ext->shaderStorageImageArrayNonUniformIndexingNative = in_ext->shaderStorageImageArrayNonUniformIndexingNative;
            out_ext->shaderInputAttachmentArrayNonUniformIndexingNative = in_ext->shaderInputAttachmentArrayNonUniformIndexingNative;
            out_ext->robustBufferAccessUpdateAfterBind = in_ext->robustBufferAccessUpdateAfterBind;
            out_ext->quadDivergentImplicitLod = in_ext->quadDivergentImplicitLod;
            out_ext->maxPerStageDescriptorUpdateAfterBindSamplers = in_ext->maxPerStageDescriptorUpdateAfterBindSamplers;
            out_ext->maxPerStageDescriptorUpdateAfterBindUniformBuffers = in_ext->maxPerStageDescriptorUpdateAfterBindUniformBuffers;
            out_ext->maxPerStageDescriptorUpdateAfterBindStorageBuffers = in_ext->maxPerStageDescriptorUpdateAfterBindStorageBuffers;
            out_ext->maxPerStageDescriptorUpdateAfterBindSampledImages = in_ext->maxPerStageDescriptorUpdateAfterBindSampledImages;
            out_ext->maxPerStageDescriptorUpdateAfterBindStorageImages = in_ext->maxPerStageDescriptorUpdateAfterBindStorageImages;
            out_ext->maxPerStageDescriptorUpdateAfterBindInputAttachments = in_ext->maxPerStageDescriptorUpdateAfterBindInputAttachments;
            out_ext->maxPerStageUpdateAfterBindResources = in_ext->maxPerStageUpdateAfterBindResources;
            out_ext->maxDescriptorSetUpdateAfterBindSamplers = in_ext->maxDescriptorSetUpdateAfterBindSamplers;
            out_ext->maxDescriptorSetUpdateAfterBindUniformBuffers = in_ext->maxDescriptorSetUpdateAfterBindUniformBuffers;
            out_ext->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = in_ext->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
            out_ext->maxDescriptorSetUpdateAfterBindStorageBuffers = in_ext->maxDescriptorSetUpdateAfterBindStorageBuffers;
            out_ext->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = in_ext->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
            out_ext->maxDescriptorSetUpdateAfterBindSampledImages = in_ext->maxDescriptorSetUpdateAfterBindSampledImages;
            out_ext->maxDescriptorSetUpdateAfterBindStorageImages = in_ext->maxDescriptorSetUpdateAfterBindStorageImages;
            out_ext->maxDescriptorSetUpdateAfterBindInputAttachments = in_ext->maxDescriptorSetUpdateAfterBindInputAttachments;
            out_ext->supportedDepthResolveModes = in_ext->supportedDepthResolveModes;
            out_ext->supportedStencilResolveModes = in_ext->supportedStencilResolveModes;
            out_ext->independentResolveNone = in_ext->independentResolveNone;
            out_ext->independentResolve = in_ext->independentResolve;
            out_ext->filterMinmaxSingleComponentFormats = in_ext->filterMinmaxSingleComponentFormats;
            out_ext->filterMinmaxImageComponentMapping = in_ext->filterMinmaxImageComponentMapping;
            out_ext->maxTimelineSemaphoreValueDifference = in_ext->maxTimelineSemaphoreValueDifference;
            out_ext->framebufferIntegerColorSampleCounts = in_ext->framebufferIntegerColorSampleCounts;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:
        {
            VkPhysicalDeviceVulkan13Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES);
            const VkPhysicalDeviceVulkan13Properties *in_ext = (const VkPhysicalDeviceVulkan13Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
            out_ext->minSubgroupSize = in_ext->minSubgroupSize;
            out_ext->maxSubgroupSize = in_ext->maxSubgroupSize;
            out_ext->maxComputeWorkgroupSubgroups = in_ext->maxComputeWorkgroupSubgroups;
            out_ext->requiredSubgroupSizeStages = in_ext->requiredSubgroupSizeStages;
            out_ext->maxInlineUniformBlockSize = in_ext->maxInlineUniformBlockSize;
            out_ext->maxPerStageDescriptorInlineUniformBlocks = in_ext->maxPerStageDescriptorInlineUniformBlocks;
            out_ext->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = in_ext->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
            out_ext->maxDescriptorSetInlineUniformBlocks = in_ext->maxDescriptorSetInlineUniformBlocks;
            out_ext->maxDescriptorSetUpdateAfterBindInlineUniformBlocks = in_ext->maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
            out_ext->maxInlineUniformTotalSize = in_ext->maxInlineUniformTotalSize;
            out_ext->integerDotProduct8BitUnsignedAccelerated = in_ext->integerDotProduct8BitUnsignedAccelerated;
            out_ext->integerDotProduct8BitSignedAccelerated = in_ext->integerDotProduct8BitSignedAccelerated;
            out_ext->integerDotProduct8BitMixedSignednessAccelerated = in_ext->integerDotProduct8BitMixedSignednessAccelerated;
            out_ext->integerDotProduct4x8BitPackedUnsignedAccelerated = in_ext->integerDotProduct4x8BitPackedUnsignedAccelerated;
            out_ext->integerDotProduct4x8BitPackedSignedAccelerated = in_ext->integerDotProduct4x8BitPackedSignedAccelerated;
            out_ext->integerDotProduct4x8BitPackedMixedSignednessAccelerated = in_ext->integerDotProduct4x8BitPackedMixedSignednessAccelerated;
            out_ext->integerDotProduct16BitUnsignedAccelerated = in_ext->integerDotProduct16BitUnsignedAccelerated;
            out_ext->integerDotProduct16BitSignedAccelerated = in_ext->integerDotProduct16BitSignedAccelerated;
            out_ext->integerDotProduct16BitMixedSignednessAccelerated = in_ext->integerDotProduct16BitMixedSignednessAccelerated;
            out_ext->integerDotProduct32BitUnsignedAccelerated = in_ext->integerDotProduct32BitUnsignedAccelerated;
            out_ext->integerDotProduct32BitSignedAccelerated = in_ext->integerDotProduct32BitSignedAccelerated;
            out_ext->integerDotProduct32BitMixedSignednessAccelerated = in_ext->integerDotProduct32BitMixedSignednessAccelerated;
            out_ext->integerDotProduct64BitUnsignedAccelerated = in_ext->integerDotProduct64BitUnsignedAccelerated;
            out_ext->integerDotProduct64BitSignedAccelerated = in_ext->integerDotProduct64BitSignedAccelerated;
            out_ext->integerDotProduct64BitMixedSignednessAccelerated = in_ext->integerDotProduct64BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitSignedAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitSignedAccelerated;
            out_ext->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = in_ext->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
            out_ext->storageTexelBufferOffsetAlignmentBytes = in_ext->storageTexelBufferOffsetAlignmentBytes;
            out_ext->storageTexelBufferOffsetSingleTexelAlignment = in_ext->storageTexelBufferOffsetSingleTexelAlignment;
            out_ext->uniformTexelBufferOffsetAlignmentBytes = in_ext->uniformTexelBufferOffsetAlignmentBytes;
            out_ext->uniformTexelBufferOffsetSingleTexelAlignment = in_ext->uniformTexelBufferOffsetSingleTexelAlignment;
            out_ext->maxBufferSize = in_ext->maxBufferSize;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES:
        {
            VkPhysicalDeviceVulkan14Properties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES);
            const VkPhysicalDeviceVulkan14Properties *in_ext = (const VkPhysicalDeviceVulkan14Properties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES;
            out_ext->lineSubPixelPrecisionBits = in_ext->lineSubPixelPrecisionBits;
            out_ext->maxVertexAttribDivisor = in_ext->maxVertexAttribDivisor;
            out_ext->supportsNonZeroFirstInstance = in_ext->supportsNonZeroFirstInstance;
            out_ext->maxPushDescriptors = in_ext->maxPushDescriptors;
            out_ext->dynamicRenderingLocalReadDepthStencilAttachments = in_ext->dynamicRenderingLocalReadDepthStencilAttachments;
            out_ext->dynamicRenderingLocalReadMultisampledAttachments = in_ext->dynamicRenderingLocalReadMultisampledAttachments;
            out_ext->earlyFragmentMultisampleCoverageAfterSampleCounting = in_ext->earlyFragmentMultisampleCoverageAfterSampleCounting;
            out_ext->earlyFragmentSampleMaskTestBeforeSampleCounting = in_ext->earlyFragmentSampleMaskTestBeforeSampleCounting;
            out_ext->depthStencilSwizzleOneSupport = in_ext->depthStencilSwizzleOneSupport;
            out_ext->polygonModePointSize = in_ext->polygonModePointSize;
            out_ext->nonStrictSinglePixelWideLinesUseParallelogram = in_ext->nonStrictSinglePixelWideLinesUseParallelogram;
            out_ext->nonStrictWideLinesUseParallelogram = in_ext->nonStrictWideLinesUseParallelogram;
            out_ext->blockTexelViewCompatibleMultipleLayers = in_ext->blockTexelViewCompatibleMultipleLayers;
            out_ext->maxCombinedImageSamplerDescriptorCount = in_ext->maxCombinedImageSamplerDescriptorCount;
            out_ext->fragmentShadingRateClampCombinerInputs = in_ext->fragmentShadingRateClampCombinerInputs;
            out_ext->defaultRobustnessStorageBuffers = in_ext->defaultRobustnessStorageBuffers;
            out_ext->defaultRobustnessUniformBuffers = in_ext->defaultRobustnessUniformBuffers;
            out_ext->defaultRobustnessVertexInputs = in_ext->defaultRobustnessVertexInputs;
            out_ext->defaultRobustnessImages = in_ext->defaultRobustnessImages;
            out_ext->copySrcLayoutCount = in_ext->copySrcLayoutCount;
            out_ext->pCopySrcLayouts = PtrToUlong(in_ext->pCopySrcLayouts);
            out_ext->copyDstLayoutCount = in_ext->copyDstLayoutCount;
            out_ext->pCopyDstLayouts = PtrToUlong(in_ext->pCopyDstLayouts);
            memcpy(out_ext->optimalTilingLayoutUUID, in_ext->optimalTilingLayoutUUID, VK_UUID_SIZE * sizeof(uint8_t));
            out_ext->identicalMemoryTypeRequirements = in_ext->identicalMemoryTypeRequirements;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM_win32_to_host(const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM32 *in, VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->queueFamilyIndex = in->queueFamilyIndex;
    out->engineType = in->engineType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkQueueFamilyDataGraphProcessingEnginePropertiesARM_win32_to_host(const VkQueueFamilyDataGraphProcessingEnginePropertiesARM32 *in, VkQueueFamilyDataGraphProcessingEnginePropertiesARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->foreignSemaphoreHandleTypes = in->foreignSemaphoreHandleTypes;
    out->foreignMemoryHandleTypes = in->foreignMemoryHandleTypes;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkQueueFamilyDataGraphProcessingEnginePropertiesARM_host_to_win32(const VkQueueFamilyDataGraphProcessingEnginePropertiesARM *in, VkQueueFamilyDataGraphProcessingEnginePropertiesARM32 *out)
{
    if (!in) return;

    out->foreignSemaphoreHandleTypes = in->foreignSemaphoreHandleTypes;
    out->foreignMemoryHandleTypes = in->foreignMemoryHandleTypes;
}

static void convert_VkQueueFamilyDataGraphPropertiesARM_win32_to_host(const VkQueueFamilyDataGraphPropertiesARM32 *in, VkQueueFamilyDataGraphPropertiesARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->engine = in->engine;
    out->operation = in->operation;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkQueueFamilyDataGraphPropertiesARM *convert_VkQueueFamilyDataGraphPropertiesARM_array_win32_to_host(struct conversion_context *ctx, const VkQueueFamilyDataGraphPropertiesARM32 *in, uint32_t count)
{
    VkQueueFamilyDataGraphPropertiesARM *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkQueueFamilyDataGraphPropertiesARM_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkQueueFamilyDataGraphPropertiesARM_host_to_win32(const VkQueueFamilyDataGraphPropertiesARM *in, VkQueueFamilyDataGraphPropertiesARM32 *out)
{
    if (!in) return;

    out->engine = in->engine;
    out->operation = in->operation;
}

static void convert_VkQueueFamilyDataGraphPropertiesARM_array_host_to_win32(const VkQueueFamilyDataGraphPropertiesARM *in, VkQueueFamilyDataGraphPropertiesARM32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkQueueFamilyDataGraphPropertiesARM_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkQueryPoolPerformanceCreateInfoKHR_win32_to_host(const VkQueryPoolPerformanceCreateInfoKHR32 *in, VkQueryPoolPerformanceCreateInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->queueFamilyIndex = in->queueFamilyIndex;
    out->counterIndexCount = in->counterIndexCount;
    out->pCounterIndices = UlongToPtr(in->pCounterIndices);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkQueueFamilyProperties2_win32_to_host(struct conversion_context *ctx, const VkQueueFamilyProperties232 *in, VkQueueFamilyProperties2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
        {
            VkQueueFamilyCheckpointProperties2NV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            VkQueueFamilyCheckpointPropertiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES:
        {
            VkQueueFamilyGlobalPriorityProperties *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR:
        {
            VkQueueFamilyOwnershipTransferPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR:
        {
            VkQueueFamilyQueryResultStatusPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR:
        {
            VkQueueFamilyVideoPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static VkQueueFamilyProperties2 *convert_VkQueueFamilyProperties2_array_win32_to_host(struct conversion_context *ctx, const VkQueueFamilyProperties232 *in, uint32_t count)
{
    VkQueueFamilyProperties2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkQueueFamilyProperties2_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkQueueFamilyProperties2_host_to_win32(const VkQueueFamilyProperties2 *in, VkQueueFamilyProperties232 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->queueFamilyProperties = in->queueFamilyProperties;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
        {
            VkQueueFamilyCheckpointProperties2NV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV);
            const VkQueueFamilyCheckpointProperties2NV *in_ext = (const VkQueueFamilyCheckpointProperties2NV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV;
            out_ext->checkpointExecutionStageMask = in_ext->checkpointExecutionStageMask;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {
            VkQueueFamilyCheckpointPropertiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV);
            const VkQueueFamilyCheckpointPropertiesNV *in_ext = (const VkQueueFamilyCheckpointPropertiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
            out_ext->checkpointExecutionStageMask = in_ext->checkpointExecutionStageMask;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES:
        {
            VkQueueFamilyGlobalPriorityProperties32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES);
            const VkQueueFamilyGlobalPriorityProperties *in_ext = (const VkQueueFamilyGlobalPriorityProperties *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES;
            out_ext->priorityCount = in_ext->priorityCount;
            memcpy(out_ext->priorities, in_ext->priorities, VK_MAX_GLOBAL_PRIORITY_SIZE * sizeof(VkQueueGlobalPriority));
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR:
        {
            VkQueueFamilyOwnershipTransferPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR);
            const VkQueueFamilyOwnershipTransferPropertiesKHR *in_ext = (const VkQueueFamilyOwnershipTransferPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR;
            out_ext->optimalImageTransferToQueueFamilies = in_ext->optimalImageTransferToQueueFamilies;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR:
        {
            VkQueueFamilyQueryResultStatusPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR);
            const VkQueueFamilyQueryResultStatusPropertiesKHR *in_ext = (const VkQueueFamilyQueryResultStatusPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR;
            out_ext->queryResultStatusSupport = in_ext->queryResultStatusSupport;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR:
        {
            VkQueueFamilyVideoPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR);
            const VkQueueFamilyVideoPropertiesKHR *in_ext = (const VkQueueFamilyVideoPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR;
            out_ext->videoCodecOperations = in_ext->videoCodecOperations;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkQueueFamilyProperties2_array_host_to_win32(const VkQueueFamilyProperties2 *in, VkQueueFamilyProperties232 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkQueueFamilyProperties2_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPhysicalDeviceSparseImageFormatInfo2_win32_to_host(const VkPhysicalDeviceSparseImageFormatInfo232 *in, VkPhysicalDeviceSparseImageFormatInfo2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->format = in->format;
    out->type = in->type;
    out->samples = in->samples;
    out->usage = in->usage;
    out->tiling = in->tiling;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkSparseImageFormatProperties2_win32_to_host(const VkSparseImageFormatProperties232 *in, VkSparseImageFormatProperties2 *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkSparseImageFormatProperties2 *convert_VkSparseImageFormatProperties2_array_win32_to_host(struct conversion_context *ctx, const VkSparseImageFormatProperties232 *in, uint32_t count)
{
    VkSparseImageFormatProperties2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageFormatProperties2_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkSparseImageFormatProperties2_host_to_win32(const VkSparseImageFormatProperties2 *in, VkSparseImageFormatProperties232 *out)
{
    if (!in) return;

    out->properties = in->properties;
}

static void convert_VkSparseImageFormatProperties2_array_host_to_win32(const VkSparseImageFormatProperties2 *in, VkSparseImageFormatProperties232 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageFormatProperties2_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkFramebufferMixedSamplesCombinationNV_win32_to_host(const VkFramebufferMixedSamplesCombinationNV32 *in, VkFramebufferMixedSamplesCombinationNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkFramebufferMixedSamplesCombinationNV *convert_VkFramebufferMixedSamplesCombinationNV_array_win32_to_host(struct conversion_context *ctx, const VkFramebufferMixedSamplesCombinationNV32 *in, uint32_t count)
{
    VkFramebufferMixedSamplesCombinationNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkFramebufferMixedSamplesCombinationNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkFramebufferMixedSamplesCombinationNV_host_to_win32(const VkFramebufferMixedSamplesCombinationNV *in, VkFramebufferMixedSamplesCombinationNV32 *out)
{
    if (!in) return;

    out->coverageReductionMode = in->coverageReductionMode;
    out->rasterizationSamples = in->rasterizationSamples;
    out->depthStencilSamples = in->depthStencilSamples;
    out->colorSamples = in->colorSamples;
}

static void convert_VkFramebufferMixedSamplesCombinationNV_array_host_to_win32(const VkFramebufferMixedSamplesCombinationNV *in, VkFramebufferMixedSamplesCombinationNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkFramebufferMixedSamplesCombinationNV_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPhysicalDeviceSurfaceInfo2KHR_win32_to_unwrapped_host(struct conversion_context *ctx, const VkPhysicalDeviceSurfaceInfo2KHR32 *in, VkPhysicalDeviceSurfaceInfo2KHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->surface = in->surface;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR:
        {
            VkSurfacePresentModeKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSurfacePresentModeKHR32 *in_ext = (const VkSurfacePresentModeKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR;
            out_ext->pNext = NULL;
            out_ext->presentMode = in_ext->presentMode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkSurfaceCapabilities2KHR_win32_to_host(struct conversion_context *ctx, const VkSurfaceCapabilities2KHR32 *in, VkSurfaceCapabilities2KHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV:
        {
            VkLatencySurfaceCapabilitiesNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySurfaceCapabilitiesNV32 *in_ext = (const VkLatencySurfaceCapabilitiesNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV;
            out_ext->pNext = NULL;
            out_ext->presentModeCount = in_ext->presentModeCount;
            out_ext->pPresentModes = UlongToPtr(in_ext->pPresentModes);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
        {
            VkSurfaceCapabilitiesPresentBarrierNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR:
        {
            VkSurfaceCapabilitiesPresentId2KHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSurfaceCapabilitiesPresentId2KHR32 *in_ext = (const VkSurfaceCapabilitiesPresentId2KHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR;
            out_ext->pNext = NULL;
            out_ext->presentId2Supported = in_ext->presentId2Supported;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR:
        {
            VkSurfaceCapabilitiesPresentWait2KHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSurfaceCapabilitiesPresentWait2KHR32 *in_ext = (const VkSurfaceCapabilitiesPresentWait2KHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR;
            out_ext->pNext = NULL;
            out_ext->presentWait2Supported = in_ext->presentWait2Supported;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR:
        {
            VkSurfacePresentModeCompatibilityKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSurfacePresentModeCompatibilityKHR32 *in_ext = (const VkSurfacePresentModeCompatibilityKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR;
            out_ext->pNext = NULL;
            out_ext->presentModeCount = in_ext->presentModeCount;
            out_ext->pPresentModes = UlongToPtr(in_ext->pPresentModes);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR:
        {
            VkSurfacePresentScalingCapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSurfacePresentScalingCapabilitiesKHR32 *in_ext = (const VkSurfacePresentScalingCapabilitiesKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_ext->supportedPresentScaling = in_ext->supportedPresentScaling;
            out_ext->supportedPresentGravityX = in_ext->supportedPresentGravityX;
            out_ext->supportedPresentGravityY = in_ext->supportedPresentGravityY;
            out_ext->minScaledImageExtent = in_ext->minScaledImageExtent;
            out_ext->maxScaledImageExtent = in_ext->maxScaledImageExtent;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkSurfaceCapabilities2KHR_host_to_win32(const VkSurfaceCapabilities2KHR *in, VkSurfaceCapabilities2KHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->surfaceCapabilities = in->surfaceCapabilities;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV:
        {
            VkLatencySurfaceCapabilitiesNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV);
            const VkLatencySurfaceCapabilitiesNV *in_ext = (const VkLatencySurfaceCapabilitiesNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV;
            out_ext->presentModeCount = in_ext->presentModeCount;
            out_ext->pPresentModes = PtrToUlong(in_ext->pPresentModes);
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
        {
            VkSurfaceCapabilitiesPresentBarrierNV32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV);
            const VkSurfaceCapabilitiesPresentBarrierNV *in_ext = (const VkSurfaceCapabilitiesPresentBarrierNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV;
            out_ext->presentBarrierSupported = in_ext->presentBarrierSupported;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR:
        {
            VkSurfaceCapabilitiesPresentId2KHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR);
            const VkSurfaceCapabilitiesPresentId2KHR *in_ext = (const VkSurfaceCapabilitiesPresentId2KHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR;
            out_ext->presentId2Supported = in_ext->presentId2Supported;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR:
        {
            VkSurfaceCapabilitiesPresentWait2KHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR);
            const VkSurfaceCapabilitiesPresentWait2KHR *in_ext = (const VkSurfaceCapabilitiesPresentWait2KHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR;
            out_ext->presentWait2Supported = in_ext->presentWait2Supported;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR:
        {
            VkSurfacePresentModeCompatibilityKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR);
            const VkSurfacePresentModeCompatibilityKHR *in_ext = (const VkSurfacePresentModeCompatibilityKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR;
            out_ext->presentModeCount = in_ext->presentModeCount;
            out_ext->pPresentModes = PtrToUlong(in_ext->pPresentModes);
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR:
        {
            VkSurfacePresentScalingCapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR);
            const VkSurfacePresentScalingCapabilitiesKHR *in_ext = (const VkSurfacePresentScalingCapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR;
            out_ext->supportedPresentScaling = in_ext->supportedPresentScaling;
            out_ext->supportedPresentGravityX = in_ext->supportedPresentGravityX;
            out_ext->supportedPresentGravityY = in_ext->supportedPresentGravityY;
            out_ext->minScaledImageExtent = in_ext->minScaledImageExtent;
            out_ext->maxScaledImageExtent = in_ext->maxScaledImageExtent;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkSurfaceFormat2KHR_win32_to_host(struct conversion_context *ctx, const VkSurfaceFormat2KHR32 *in, VkSurfaceFormat2KHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static VkSurfaceFormat2KHR *convert_VkSurfaceFormat2KHR_array_win32_to_host(struct conversion_context *ctx, const VkSurfaceFormat2KHR32 *in, uint32_t count)
{
    VkSurfaceFormat2KHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSurfaceFormat2KHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkSurfaceFormat2KHR_host_to_win32(const VkSurfaceFormat2KHR *in, VkSurfaceFormat2KHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->surfaceFormat = in->surfaceFormat;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
        {
            VkImageCompressionPropertiesEXT32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT);
            const VkImageCompressionPropertiesEXT *in_ext = (const VkImageCompressionPropertiesEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT;
            out_ext->imageCompressionFlags = in_ext->imageCompressionFlags;
            out_ext->imageCompressionFixedRateFlags = in_ext->imageCompressionFixedRateFlags;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkSurfaceFormat2KHR_array_host_to_win32(const VkSurfaceFormat2KHR *in, VkSurfaceFormat2KHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkSurfaceFormat2KHR_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPhysicalDeviceToolProperties_win32_to_host(const VkPhysicalDeviceToolProperties32 *in, VkPhysicalDeviceToolProperties *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkPhysicalDeviceToolProperties *convert_VkPhysicalDeviceToolProperties_array_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceToolProperties32 *in, uint32_t count)
{
    VkPhysicalDeviceToolProperties *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceToolProperties_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPhysicalDeviceToolProperties_host_to_win32(const VkPhysicalDeviceToolProperties *in, VkPhysicalDeviceToolProperties32 *out)
{
    if (!in) return;

    memcpy(out->name, in->name, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    memcpy(out->version, in->version, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
    out->purposes = in->purposes;
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->layer, in->layer, VK_MAX_EXTENSION_NAME_SIZE * sizeof(char));
}

static void convert_VkPhysicalDeviceToolProperties_array_host_to_win32(const VkPhysicalDeviceToolProperties *in, VkPhysicalDeviceToolProperties32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPhysicalDeviceToolProperties_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkVideoCapabilitiesKHR_win32_to_host(struct conversion_context *ctx, const VkVideoCapabilitiesKHR32 *in, VkVideoCapabilitiesKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR:
        {
            VkVideoDecodeAV1CapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR:
        {
            VkVideoDecodeCapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR:
        {
            VkVideoDecodeH264CapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR:
        {
            VkVideoDecodeVP9CapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR:
        {
            VkVideoEncodeAV1CapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR:
        {
            VkVideoEncodeAV1QuantizationMapCapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR:
        {
            VkVideoEncodeCapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR:
        {
            VkVideoEncodeH264CapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR:
        {
            VkVideoEncodeH264QuantizationMapCapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR:
        {
            VkVideoEncodeH265QuantizationMapCapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR:
        {
            VkVideoEncodeIntraRefreshCapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR:
        {
            VkVideoEncodeQuantizationMapCapabilitiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkVideoCapabilitiesKHR_host_to_win32(const VkVideoCapabilitiesKHR *in, VkVideoCapabilitiesKHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->flags = in->flags;
    out->minBitstreamBufferOffsetAlignment = in->minBitstreamBufferOffsetAlignment;
    out->minBitstreamBufferSizeAlignment = in->minBitstreamBufferSizeAlignment;
    out->pictureAccessGranularity = in->pictureAccessGranularity;
    out->minCodedExtent = in->minCodedExtent;
    out->maxCodedExtent = in->maxCodedExtent;
    out->maxDpbSlots = in->maxDpbSlots;
    out->maxActiveReferencePictures = in->maxActiveReferencePictures;
    out->stdHeaderVersion = in->stdHeaderVersion;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR:
        {
            VkVideoDecodeAV1CapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR);
            const VkVideoDecodeAV1CapabilitiesKHR *in_ext = (const VkVideoDecodeAV1CapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR;
            out_ext->maxLevel = in_ext->maxLevel;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR:
        {
            VkVideoDecodeCapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR);
            const VkVideoDecodeCapabilitiesKHR *in_ext = (const VkVideoDecodeCapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR;
            out_ext->flags = in_ext->flags;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR:
        {
            VkVideoDecodeH264CapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR);
            const VkVideoDecodeH264CapabilitiesKHR *in_ext = (const VkVideoDecodeH264CapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR;
            out_ext->maxLevelIdc = in_ext->maxLevelIdc;
            out_ext->fieldOffsetGranularity = in_ext->fieldOffsetGranularity;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR:
        {
            VkVideoDecodeVP9CapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR);
            const VkVideoDecodeVP9CapabilitiesKHR *in_ext = (const VkVideoDecodeVP9CapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR;
            out_ext->maxLevel = in_ext->maxLevel;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR:
        {
            VkVideoEncodeAV1CapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR);
            const VkVideoEncodeAV1CapabilitiesKHR *in_ext = (const VkVideoEncodeAV1CapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR;
            out_ext->flags = in_ext->flags;
            out_ext->maxLevel = in_ext->maxLevel;
            out_ext->codedPictureAlignment = in_ext->codedPictureAlignment;
            out_ext->maxTiles = in_ext->maxTiles;
            out_ext->minTileSize = in_ext->minTileSize;
            out_ext->maxTileSize = in_ext->maxTileSize;
            out_ext->superblockSizes = in_ext->superblockSizes;
            out_ext->maxSingleReferenceCount = in_ext->maxSingleReferenceCount;
            out_ext->singleReferenceNameMask = in_ext->singleReferenceNameMask;
            out_ext->maxUnidirectionalCompoundReferenceCount = in_ext->maxUnidirectionalCompoundReferenceCount;
            out_ext->maxUnidirectionalCompoundGroup1ReferenceCount = in_ext->maxUnidirectionalCompoundGroup1ReferenceCount;
            out_ext->unidirectionalCompoundReferenceNameMask = in_ext->unidirectionalCompoundReferenceNameMask;
            out_ext->maxBidirectionalCompoundReferenceCount = in_ext->maxBidirectionalCompoundReferenceCount;
            out_ext->maxBidirectionalCompoundGroup1ReferenceCount = in_ext->maxBidirectionalCompoundGroup1ReferenceCount;
            out_ext->maxBidirectionalCompoundGroup2ReferenceCount = in_ext->maxBidirectionalCompoundGroup2ReferenceCount;
            out_ext->bidirectionalCompoundReferenceNameMask = in_ext->bidirectionalCompoundReferenceNameMask;
            out_ext->maxTemporalLayerCount = in_ext->maxTemporalLayerCount;
            out_ext->maxSpatialLayerCount = in_ext->maxSpatialLayerCount;
            out_ext->maxOperatingPoints = in_ext->maxOperatingPoints;
            out_ext->minQIndex = in_ext->minQIndex;
            out_ext->maxQIndex = in_ext->maxQIndex;
            out_ext->prefersGopRemainingFrames = in_ext->prefersGopRemainingFrames;
            out_ext->requiresGopRemainingFrames = in_ext->requiresGopRemainingFrames;
            out_ext->stdSyntaxFlags = in_ext->stdSyntaxFlags;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR:
        {
            VkVideoEncodeAV1QuantizationMapCapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR);
            const VkVideoEncodeAV1QuantizationMapCapabilitiesKHR *in_ext = (const VkVideoEncodeAV1QuantizationMapCapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR;
            out_ext->minQIndexDelta = in_ext->minQIndexDelta;
            out_ext->maxQIndexDelta = in_ext->maxQIndexDelta;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR:
        {
            VkVideoEncodeCapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR);
            const VkVideoEncodeCapabilitiesKHR *in_ext = (const VkVideoEncodeCapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR;
            out_ext->flags = in_ext->flags;
            out_ext->rateControlModes = in_ext->rateControlModes;
            out_ext->maxRateControlLayers = in_ext->maxRateControlLayers;
            out_ext->maxBitrate = in_ext->maxBitrate;
            out_ext->maxQualityLevels = in_ext->maxQualityLevels;
            out_ext->encodeInputPictureGranularity = in_ext->encodeInputPictureGranularity;
            out_ext->supportedEncodeFeedbackFlags = in_ext->supportedEncodeFeedbackFlags;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR:
        {
            VkVideoEncodeH264CapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR);
            const VkVideoEncodeH264CapabilitiesKHR *in_ext = (const VkVideoEncodeH264CapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR;
            out_ext->flags = in_ext->flags;
            out_ext->maxLevelIdc = in_ext->maxLevelIdc;
            out_ext->maxSliceCount = in_ext->maxSliceCount;
            out_ext->maxPPictureL0ReferenceCount = in_ext->maxPPictureL0ReferenceCount;
            out_ext->maxBPictureL0ReferenceCount = in_ext->maxBPictureL0ReferenceCount;
            out_ext->maxL1ReferenceCount = in_ext->maxL1ReferenceCount;
            out_ext->maxTemporalLayerCount = in_ext->maxTemporalLayerCount;
            out_ext->expectDyadicTemporalLayerPattern = in_ext->expectDyadicTemporalLayerPattern;
            out_ext->minQp = in_ext->minQp;
            out_ext->maxQp = in_ext->maxQp;
            out_ext->prefersGopRemainingFrames = in_ext->prefersGopRemainingFrames;
            out_ext->requiresGopRemainingFrames = in_ext->requiresGopRemainingFrames;
            out_ext->stdSyntaxFlags = in_ext->stdSyntaxFlags;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR:
        {
            VkVideoEncodeH264QuantizationMapCapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR);
            const VkVideoEncodeH264QuantizationMapCapabilitiesKHR *in_ext = (const VkVideoEncodeH264QuantizationMapCapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR;
            out_ext->minQpDelta = in_ext->minQpDelta;
            out_ext->maxQpDelta = in_ext->maxQpDelta;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR:
        {
            VkVideoEncodeH265QuantizationMapCapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR);
            const VkVideoEncodeH265QuantizationMapCapabilitiesKHR *in_ext = (const VkVideoEncodeH265QuantizationMapCapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR;
            out_ext->minQpDelta = in_ext->minQpDelta;
            out_ext->maxQpDelta = in_ext->maxQpDelta;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR:
        {
            VkVideoEncodeIntraRefreshCapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR);
            const VkVideoEncodeIntraRefreshCapabilitiesKHR *in_ext = (const VkVideoEncodeIntraRefreshCapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR;
            out_ext->intraRefreshModes = in_ext->intraRefreshModes;
            out_ext->maxIntraRefreshCycleDuration = in_ext->maxIntraRefreshCycleDuration;
            out_ext->maxIntraRefreshActiveReferencePictures = in_ext->maxIntraRefreshActiveReferencePictures;
            out_ext->partitionIndependentIntraRefreshRegions = in_ext->partitionIndependentIntraRefreshRegions;
            out_ext->nonRectangularIntraRefreshRegions = in_ext->nonRectangularIntraRefreshRegions;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR:
        {
            VkVideoEncodeQuantizationMapCapabilitiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR);
            const VkVideoEncodeQuantizationMapCapabilitiesKHR *in_ext = (const VkVideoEncodeQuantizationMapCapabilitiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR;
            out_ext->maxQuantizationMapExtent = in_ext->maxQuantizationMapExtent;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR32 *in, VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pVideoProfile = convert_VkVideoProfileInfoKHR_array_win32_to_host(ctx, (const VkVideoProfileInfoKHR32 *)UlongToPtr(in->pVideoProfile), 1);
    out->qualityLevel = in->qualityLevel;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkVideoEncodeQualityLevelPropertiesKHR_win32_to_host(struct conversion_context *ctx, const VkVideoEncodeQualityLevelPropertiesKHR32 *in, VkVideoEncodeQualityLevelPropertiesKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR:
        {
            VkVideoEncodeAV1QualityLevelPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR:
        {
            VkVideoEncodeH264QualityLevelPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkVideoEncodeQualityLevelPropertiesKHR_host_to_win32(const VkVideoEncodeQualityLevelPropertiesKHR *in, VkVideoEncodeQualityLevelPropertiesKHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->preferredRateControlMode = in->preferredRateControlMode;
    out->preferredRateControlLayerCount = in->preferredRateControlLayerCount;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR:
        {
            VkVideoEncodeAV1QualityLevelPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR);
            const VkVideoEncodeAV1QualityLevelPropertiesKHR *in_ext = (const VkVideoEncodeAV1QualityLevelPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR;
            out_ext->preferredRateControlFlags = in_ext->preferredRateControlFlags;
            out_ext->preferredGopFrameCount = in_ext->preferredGopFrameCount;
            out_ext->preferredKeyFramePeriod = in_ext->preferredKeyFramePeriod;
            out_ext->preferredConsecutiveBipredictiveFrameCount = in_ext->preferredConsecutiveBipredictiveFrameCount;
            out_ext->preferredTemporalLayerCount = in_ext->preferredTemporalLayerCount;
            out_ext->preferredConstantQIndex = in_ext->preferredConstantQIndex;
            out_ext->preferredMaxSingleReferenceCount = in_ext->preferredMaxSingleReferenceCount;
            out_ext->preferredSingleReferenceNameMask = in_ext->preferredSingleReferenceNameMask;
            out_ext->preferredMaxUnidirectionalCompoundReferenceCount = in_ext->preferredMaxUnidirectionalCompoundReferenceCount;
            out_ext->preferredMaxUnidirectionalCompoundGroup1ReferenceCount = in_ext->preferredMaxUnidirectionalCompoundGroup1ReferenceCount;
            out_ext->preferredUnidirectionalCompoundReferenceNameMask = in_ext->preferredUnidirectionalCompoundReferenceNameMask;
            out_ext->preferredMaxBidirectionalCompoundReferenceCount = in_ext->preferredMaxBidirectionalCompoundReferenceCount;
            out_ext->preferredMaxBidirectionalCompoundGroup1ReferenceCount = in_ext->preferredMaxBidirectionalCompoundGroup1ReferenceCount;
            out_ext->preferredMaxBidirectionalCompoundGroup2ReferenceCount = in_ext->preferredMaxBidirectionalCompoundGroup2ReferenceCount;
            out_ext->preferredBidirectionalCompoundReferenceNameMask = in_ext->preferredBidirectionalCompoundReferenceNameMask;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR:
        {
            VkVideoEncodeH264QualityLevelPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR);
            const VkVideoEncodeH264QualityLevelPropertiesKHR *in_ext = (const VkVideoEncodeH264QualityLevelPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR;
            out_ext->preferredRateControlFlags = in_ext->preferredRateControlFlags;
            out_ext->preferredGopFrameCount = in_ext->preferredGopFrameCount;
            out_ext->preferredIdrPeriod = in_ext->preferredIdrPeriod;
            out_ext->preferredConsecutiveBFrameCount = in_ext->preferredConsecutiveBFrameCount;
            out_ext->preferredTemporalLayerCount = in_ext->preferredTemporalLayerCount;
            out_ext->preferredConstantQp = in_ext->preferredConstantQp;
            out_ext->preferredMaxL0ReferenceCount = in_ext->preferredMaxL0ReferenceCount;
            out_ext->preferredMaxL1ReferenceCount = in_ext->preferredMaxL1ReferenceCount;
            out_ext->preferredStdEntropyCodingModeFlag = in_ext->preferredStdEntropyCodingModeFlag;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkPhysicalDeviceVideoFormatInfoKHR_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceVideoFormatInfoKHR32 *in, VkPhysicalDeviceVideoFormatInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->imageUsage = in->imageUsage;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
        {
            VkVideoProfileListInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoProfileListInfoKHR32 *in_ext = (const VkVideoProfileListInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->profileCount = in_ext->profileCount;
            out_ext->pProfiles = convert_VkVideoProfileInfoKHR_array_win32_to_host(ctx, (const VkVideoProfileInfoKHR32 *)UlongToPtr(in_ext->pProfiles), in_ext->profileCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkVideoFormatPropertiesKHR_win32_to_host(struct conversion_context *ctx, const VkVideoFormatPropertiesKHR32 *in, VkVideoFormatPropertiesKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR:
        {
            VkVideoFormatAV1QuantizationMapPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR:
        {
            VkVideoFormatH265QuantizationMapPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR:
        {
            VkVideoFormatQuantizationMapPropertiesKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR;
            out_ext->pNext = NULL;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static VkVideoFormatPropertiesKHR *convert_VkVideoFormatPropertiesKHR_array_win32_to_host(struct conversion_context *ctx, const VkVideoFormatPropertiesKHR32 *in, uint32_t count)
{
    VkVideoFormatPropertiesKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVideoFormatPropertiesKHR_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoFormatPropertiesKHR_host_to_win32(const VkVideoFormatPropertiesKHR *in, VkVideoFormatPropertiesKHR32 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure32 *out_header = (void *)out;

    if (!in) return;

    out->format = in->format;
    out->componentMapping = in->componentMapping;
    out->imageCreateFlags = in->imageCreateFlags;
    out->imageType = in->imageType;
    out->imageTiling = in->imageTiling;
    out->imageUsageFlags = in->imageUsageFlags;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR:
        {
            VkVideoFormatAV1QuantizationMapPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR);
            const VkVideoFormatAV1QuantizationMapPropertiesKHR *in_ext = (const VkVideoFormatAV1QuantizationMapPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR;
            out_ext->compatibleSuperblockSizes = in_ext->compatibleSuperblockSizes;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR:
        {
            VkVideoFormatH265QuantizationMapPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR);
            const VkVideoFormatH265QuantizationMapPropertiesKHR *in_ext = (const VkVideoFormatH265QuantizationMapPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR;
            out_ext->compatibleCtbSizes = in_ext->compatibleCtbSizes;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR:
        {
            VkVideoFormatQuantizationMapPropertiesKHR32 *out_ext = find_next_struct32(out_header, VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR);
            const VkVideoFormatQuantizationMapPropertiesKHR *in_ext = (const VkVideoFormatQuantizationMapPropertiesKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR;
            out_ext->quantizationMapTexelSize = in_ext->quantizationMapTexelSize;
            out_header = (void *)out_ext;
            break;
        }
        default:
            break;
        }
    }
}

static void convert_VkVideoFormatPropertiesKHR_array_host_to_win32(const VkVideoFormatPropertiesKHR *in, VkVideoFormatPropertiesKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkVideoFormatPropertiesKHR_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPipelineBinaryDataInfoKHR_win32_to_host(const VkPipelineBinaryDataInfoKHR32 *in, VkPipelineBinaryDataInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipelineBinary = in->pipelineBinary;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPipelineBinaryKeyKHR_host_to_win32(const VkPipelineBinaryKeyKHR *in, VkPipelineBinaryKeyKHR32 *out)
{
    if (!in) return;

    out->keySize = in->keySize;
    memcpy(out->key, in->key, VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR * sizeof(uint8_t));
}

static void convert_VkPipelineExecutableInfoKHR_win32_to_host(const VkPipelineExecutableInfoKHR32 *in, VkPipelineExecutableInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipeline = in->pipeline;
    out->executableIndex = in->executableIndex;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPipelineExecutableInternalRepresentationKHR_win32_to_host(const VkPipelineExecutableInternalRepresentationKHR32 *in, VkPipelineExecutableInternalRepresentationKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkPipelineExecutableInternalRepresentationKHR *convert_VkPipelineExecutableInternalRepresentationKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineExecutableInternalRepresentationKHR32 *in, uint32_t count)
{
    VkPipelineExecutableInternalRepresentationKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutableInternalRepresentationKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineExecutableInternalRepresentationKHR_host_to_win32(const VkPipelineExecutableInternalRepresentationKHR *in, VkPipelineExecutableInternalRepresentationKHR32 *out)
{
    if (!in) return;

    memcpy(out->name, in->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->isText = in->isText;
    out->dataSize = in->dataSize;
    out->pData = PtrToUlong(in->pData);
}

static void convert_VkPipelineExecutableInternalRepresentationKHR_array_host_to_win32(const VkPipelineExecutableInternalRepresentationKHR *in, VkPipelineExecutableInternalRepresentationKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutableInternalRepresentationKHR_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPipelineInfoKHR_win32_to_host(const VkPipelineInfoKHR32 *in, VkPipelineInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipeline = in->pipeline;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPipelineExecutablePropertiesKHR_win32_to_host(const VkPipelineExecutablePropertiesKHR32 *in, VkPipelineExecutablePropertiesKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkPipelineExecutablePropertiesKHR *convert_VkPipelineExecutablePropertiesKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineExecutablePropertiesKHR32 *in, uint32_t count)
{
    VkPipelineExecutablePropertiesKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutablePropertiesKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineExecutablePropertiesKHR_host_to_win32(const VkPipelineExecutablePropertiesKHR *in, VkPipelineExecutablePropertiesKHR32 *out)
{
    if (!in) return;

    out->stages = in->stages;
    memcpy(out->name, in->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->subgroupSize = in->subgroupSize;
}

static void convert_VkPipelineExecutablePropertiesKHR_array_host_to_win32(const VkPipelineExecutablePropertiesKHR *in, VkPipelineExecutablePropertiesKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutablePropertiesKHR_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPipelineExecutableStatisticKHR_win32_to_host(const VkPipelineExecutableStatisticKHR32 *in, VkPipelineExecutableStatisticKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkPipelineExecutableStatisticKHR *convert_VkPipelineExecutableStatisticKHR_array_win32_to_host(struct conversion_context *ctx, const VkPipelineExecutableStatisticKHR32 *in, uint32_t count)
{
    VkPipelineExecutableStatisticKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutableStatisticKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkPipelineExecutableStatisticValueKHR_host_to_win32(const VkPipelineExecutableStatisticValueKHR *in, VkPipelineExecutableStatisticValueKHR32 *out, VkFlags selector)
{
    if (!in) return;

    if (selector == VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR)
        out->b32 = in->b32;
    if (selector == VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR)
        out->i64 = in->i64;
    if (selector == VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR)
        out->u64 = in->u64;
    if (selector == VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR)
        out->f64 = in->f64;
}

static void convert_VkPipelineExecutableStatisticKHR_host_to_win32(const VkPipelineExecutableStatisticKHR *in, VkPipelineExecutableStatisticKHR32 *out)
{
    if (!in) return;

    memcpy(out->name, in->name, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    memcpy(out->description, in->description, VK_MAX_DESCRIPTION_SIZE * sizeof(char));
    out->format = in->format;
    convert_VkPipelineExecutableStatisticValueKHR_host_to_win32(&in->value, &out->value, in->format);
}

static void convert_VkPipelineExecutableStatisticKHR_array_host_to_win32(const VkPipelineExecutableStatisticKHR *in, VkPipelineExecutableStatisticKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkPipelineExecutableStatisticKHR_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkPipelineIndirectDeviceAddressInfoNV_win32_to_host(const VkPipelineIndirectDeviceAddressInfoNV32 *in, VkPipelineIndirectDeviceAddressInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipelineBindPoint = in->pipelineBindPoint;
    out->pipeline = in->pipeline;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkPipelineInfoEXT_win32_to_host(const VkPipelineInfoEXT32 *in, VkPipelineInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipeline = in->pipeline;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCheckpointData2NV_win32_to_host(const VkCheckpointData2NV32 *in, VkCheckpointData2NV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkCheckpointData2NV *convert_VkCheckpointData2NV_array_win32_to_host(struct conversion_context *ctx, const VkCheckpointData2NV32 *in, uint32_t count)
{
    VkCheckpointData2NV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCheckpointData2NV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCheckpointData2NV_host_to_win32(const VkCheckpointData2NV *in, VkCheckpointData2NV32 *out)
{
    if (!in) return;

    out->stage = in->stage;
    out->pCheckpointMarker = PtrToUlong(in->pCheckpointMarker);
}

static void convert_VkCheckpointData2NV_array_host_to_win32(const VkCheckpointData2NV *in, VkCheckpointData2NV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkCheckpointData2NV_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkCheckpointDataNV_win32_to_host(const VkCheckpointDataNV32 *in, VkCheckpointDataNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkCheckpointDataNV *convert_VkCheckpointDataNV_array_win32_to_host(struct conversion_context *ctx, const VkCheckpointDataNV32 *in, uint32_t count)
{
    VkCheckpointDataNV *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCheckpointDataNV_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkCheckpointDataNV_host_to_win32(const VkCheckpointDataNV *in, VkCheckpointDataNV32 *out)
{
    if (!in) return;

    out->stage = in->stage;
    out->pCheckpointMarker = PtrToUlong(in->pCheckpointMarker);
}

static void convert_VkCheckpointDataNV_array_host_to_win32(const VkCheckpointDataNV *in, VkCheckpointDataNV32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkCheckpointDataNV_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkRenderingAreaInfo_win32_to_host(const VkRenderingAreaInfo32 *in, VkRenderingAreaInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->viewMask = in->viewMask;
    out->colorAttachmentCount = in->colorAttachmentCount;
    out->pColorAttachmentFormats = UlongToPtr(in->pColorAttachmentFormats);
    out->depthAttachmentFormat = in->depthAttachmentFormat;
    out->stencilAttachmentFormat = in->stencilAttachmentFormat;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkSamplerCaptureDescriptorDataInfoEXT_win32_to_host(const VkSamplerCaptureDescriptorDataInfoEXT32 *in, VkSamplerCaptureDescriptorDataInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->sampler = in->sampler;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_unwrapped_host(const VkSemaphoreGetWin32HandleInfoKHR32 *in, VkSemaphoreGetWin32HandleInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = in->semaphore;
    out->handleType = in->handleType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkShaderModuleIdentifierEXT_win32_to_host(const VkShaderModuleIdentifierEXT32 *in, VkShaderModuleIdentifierEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkShaderModuleIdentifierEXT_host_to_win32(const VkShaderModuleIdentifierEXT *in, VkShaderModuleIdentifierEXT32 *out)
{
    if (!in) return;

    out->identifierSize = in->identifierSize;
    memcpy(out->identifier, in->identifier, VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT * sizeof(uint8_t));
}

static void convert_VkTensorMemoryRequirementsInfoARM_win32_to_host(const VkTensorMemoryRequirementsInfoARM32 *in, VkTensorMemoryRequirementsInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->tensor = in->tensor;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkTensorCaptureDescriptorDataInfoARM_win32_to_host(const VkTensorCaptureDescriptorDataInfoARM32 *in, VkTensorCaptureDescriptorDataInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->tensor = in->tensor;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkTensorViewCaptureDescriptorDataInfoARM_win32_to_host(const VkTensorViewCaptureDescriptorDataInfoARM32 *in, VkTensorViewCaptureDescriptorDataInfoARM *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->tensorView = in->tensorView;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkVideoSessionMemoryRequirementsKHR_win32_to_host(const VkVideoSessionMemoryRequirementsKHR32 *in, VkVideoSessionMemoryRequirementsKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static VkVideoSessionMemoryRequirementsKHR *convert_VkVideoSessionMemoryRequirementsKHR_array_win32_to_host(struct conversion_context *ctx, const VkVideoSessionMemoryRequirementsKHR32 *in, uint32_t count)
{
    VkVideoSessionMemoryRequirementsKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkVideoSessionMemoryRequirementsKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoSessionMemoryRequirementsKHR_host_to_win32(const VkVideoSessionMemoryRequirementsKHR *in, VkVideoSessionMemoryRequirementsKHR32 *out)
{
    if (!in) return;

    out->memoryBindIndex = in->memoryBindIndex;
    convert_VkMemoryRequirements_host_to_win32(&in->memoryRequirements, &out->memoryRequirements);
}

static void convert_VkVideoSessionMemoryRequirementsKHR_array_host_to_win32(const VkVideoSessionMemoryRequirementsKHR *in, VkVideoSessionMemoryRequirementsKHR32 *out, uint32_t count)
{
    unsigned int i;

    if (!in) return;

    for (i = 0; i < count; i++)
    {
        convert_VkVideoSessionMemoryRequirementsKHR_host_to_win32(&in[i], &out[i]);
    }
}

static void convert_VkImportFenceWin32HandleInfoKHR_win32_to_unwrapped_host(const VkImportFenceWin32HandleInfoKHR32 *in, VkImportFenceWin32HandleInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->fence = in->fence;
    out->flags = in->flags;
    out->handleType = in->handleType;
    out->handle = (HANDLE)UlongToPtr(in->handle);
    out->name = (LPCWSTR)UlongToPtr(in->name);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_unwrapped_host(const VkImportSemaphoreWin32HandleInfoKHR32 *in, VkImportSemaphoreWin32HandleInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = in->semaphore;
    out->flags = in->flags;
    out->handleType = in->handleType;
    out->handle = (HANDLE)UlongToPtr(in->handle);
    out->name = (LPCWSTR)UlongToPtr(in->name);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkInitializePerformanceApiInfoINTEL_win32_to_host(const VkInitializePerformanceApiInfoINTEL32 *in, VkInitializePerformanceApiInfoINTEL *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pUserData = UlongToPtr(in->pUserData);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkLatencySleepInfoNV_win64_to_host(const VkLatencySleepInfoNV *in, VkLatencySleepInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->signalSemaphore = vulkan_semaphore_from_handle(in->signalSemaphore)->host.semaphore;
    out->value = in->value;
}
#endif /* _WIN64 */

static void convert_VkLatencySleepInfoNV_win32_to_host(const VkLatencySleepInfoNV32 *in, VkLatencySleepInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->signalSemaphore = vulkan_semaphore_from_handle(in->signalSemaphore)->host.semaphore;
    out->value = in->value;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkMemoryMapInfo_win64_to_host(const VkMemoryMapInfo *in, VkMemoryMapInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->offset = in->offset;
    out->size = in->size;
}
#endif /* _WIN64 */

static void convert_VkMemoryMapInfo_win32_to_host(const VkMemoryMapInfo32 *in, VkMemoryMapInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    out->offset = in->offset;
    out->size = in->size;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMemoryMapInfo_win32_to_unwrapped_host(const VkMemoryMapInfo32 *in, VkMemoryMapInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->memory = in->memory;
    out->offset = in->offset;
    out->size = in->size;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static const VkSemaphore *convert_VkSemaphore_array_win64_to_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
{
    VkSemaphore *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_semaphore_from_handle(in[i])->host.semaphore;
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkSparseMemoryBind_win64_to_host(const VkSparseMemoryBind *in, VkSparseMemoryBind *out)
{
    if (!in) return;

    out->resourceOffset = in->resourceOffset;
    out->size = in->size;
    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
    out->memoryOffset = in->memoryOffset;
    out->flags = in->flags;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkSparseMemoryBind *convert_VkSparseMemoryBind_array_win64_to_host(struct conversion_context *ctx, const VkSparseMemoryBind *in, uint32_t count)
{
    VkSparseMemoryBind *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseMemoryBind_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkSparseBufferMemoryBindInfo_win64_to_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo *in, VkSparseBufferMemoryBindInfo *out)
{
    if (!in) return;

    out->buffer = in->buffer;
    out->bindCount = in->bindCount;
    out->pBinds = convert_VkSparseMemoryBind_array_win64_to_host(ctx, in->pBinds, in->bindCount);
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkSparseBufferMemoryBindInfo *convert_VkSparseBufferMemoryBindInfo_array_win64_to_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo *in, uint32_t count)
{
    VkSparseBufferMemoryBindInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseBufferMemoryBindInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkSparseImageOpaqueMemoryBindInfo_win64_to_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo *in, VkSparseImageOpaqueMemoryBindInfo *out)
{
    if (!in) return;

    out->image = in->image;
    out->bindCount = in->bindCount;
    out->pBinds = convert_VkSparseMemoryBind_array_win64_to_host(ctx, in->pBinds, in->bindCount);
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkSparseImageOpaqueMemoryBindInfo *convert_VkSparseImageOpaqueMemoryBindInfo_array_win64_to_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo *in, uint32_t count)
{
    VkSparseImageOpaqueMemoryBindInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageOpaqueMemoryBindInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkSparseImageMemoryBind_win64_to_host(const VkSparseImageMemoryBind *in, VkSparseImageMemoryBind *out)
{
    if (!in) return;

    out->subresource = in->subresource;
    out->offset = in->offset;
    out->extent = in->extent;
    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
    out->memoryOffset = in->memoryOffset;
    out->flags = in->flags;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkSparseImageMemoryBind *convert_VkSparseImageMemoryBind_array_win64_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBind *in, uint32_t count)
{
    VkSparseImageMemoryBind *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryBind_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkSparseImageMemoryBindInfo_win64_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo *in, VkSparseImageMemoryBindInfo *out)
{
    if (!in) return;

    out->image = in->image;
    out->bindCount = in->bindCount;
    out->pBinds = convert_VkSparseImageMemoryBind_array_win64_to_host(ctx, in->pBinds, in->bindCount);
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkSparseImageMemoryBindInfo *convert_VkSparseImageMemoryBindInfo_array_win64_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo *in, uint32_t count)
{
    VkSparseImageMemoryBindInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryBindInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkBindSparseInfo_win64_to_host(struct conversion_context *ctx, const VkBindSparseInfo *in, VkBindSparseInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = convert_VkSemaphore_array_win64_to_host(ctx, in->pWaitSemaphores, in->waitSemaphoreCount);
    out->bufferBindCount = in->bufferBindCount;
    out->pBufferBinds = convert_VkSparseBufferMemoryBindInfo_array_win64_to_host(ctx, in->pBufferBinds, in->bufferBindCount);
    out->imageOpaqueBindCount = in->imageOpaqueBindCount;
    out->pImageOpaqueBinds = convert_VkSparseImageOpaqueMemoryBindInfo_array_win64_to_host(ctx, in->pImageOpaqueBinds, in->imageOpaqueBindCount);
    out->imageBindCount = in->imageBindCount;
    out->pImageBinds = convert_VkSparseImageMemoryBindInfo_array_win64_to_host(ctx, in->pImageBinds, in->imageBindCount);
    out->signalSemaphoreCount = in->signalSemaphoreCount;
    out->pSignalSemaphores = convert_VkSemaphore_array_win64_to_host(ctx, in->pSignalSemaphores, in->signalSemaphoreCount);
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkBindSparseInfo *convert_VkBindSparseInfo_array_win64_to_host(struct conversion_context *ctx, const VkBindSparseInfo *in, uint32_t count)
{
    VkBindSparseInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindSparseInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static const VkSemaphore *convert_VkSemaphore_array_win32_to_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
{
    VkSemaphore *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_semaphore_from_handle(in[i])->host.semaphore;
    }

    return out;
}

static void convert_VkSparseMemoryBind_win32_to_host(const VkSparseMemoryBind32 *in, VkSparseMemoryBind *out)
{
    if (!in) return;

    out->resourceOffset = in->resourceOffset;
    out->size = in->size;
    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
    out->memoryOffset = in->memoryOffset;
    out->flags = in->flags;
}

static const VkSparseMemoryBind *convert_VkSparseMemoryBind_array_win32_to_host(struct conversion_context *ctx, const VkSparseMemoryBind32 *in, uint32_t count)
{
    VkSparseMemoryBind *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseMemoryBind_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkSparseBufferMemoryBindInfo_win32_to_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo32 *in, VkSparseBufferMemoryBindInfo *out)
{
    if (!in) return;

    out->buffer = in->buffer;
    out->bindCount = in->bindCount;
    out->pBinds = convert_VkSparseMemoryBind_array_win32_to_host(ctx, (const VkSparseMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
}

static const VkSparseBufferMemoryBindInfo *convert_VkSparseBufferMemoryBindInfo_array_win32_to_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo32 *in, uint32_t count)
{
    VkSparseBufferMemoryBindInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseBufferMemoryBindInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkSparseImageOpaqueMemoryBindInfo_win32_to_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo32 *in, VkSparseImageOpaqueMemoryBindInfo *out)
{
    if (!in) return;

    out->image = in->image;
    out->bindCount = in->bindCount;
    out->pBinds = convert_VkSparseMemoryBind_array_win32_to_host(ctx, (const VkSparseMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
}

static const VkSparseImageOpaqueMemoryBindInfo *convert_VkSparseImageOpaqueMemoryBindInfo_array_win32_to_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo32 *in, uint32_t count)
{
    VkSparseImageOpaqueMemoryBindInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageOpaqueMemoryBindInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkSparseImageMemoryBind_win32_to_host(const VkSparseImageMemoryBind32 *in, VkSparseImageMemoryBind *out)
{
    if (!in) return;

    out->subresource = in->subresource;
    out->offset = in->offset;
    out->extent = in->extent;
    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
    out->memoryOffset = in->memoryOffset;
    out->flags = in->flags;
}

static const VkSparseImageMemoryBind *convert_VkSparseImageMemoryBind_array_win32_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBind32 *in, uint32_t count)
{
    VkSparseImageMemoryBind *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryBind_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkSparseImageMemoryBindInfo_win32_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo32 *in, VkSparseImageMemoryBindInfo *out)
{
    if (!in) return;

    out->image = in->image;
    out->bindCount = in->bindCount;
    out->pBinds = convert_VkSparseImageMemoryBind_array_win32_to_host(ctx, (const VkSparseImageMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
}

static const VkSparseImageMemoryBindInfo *convert_VkSparseImageMemoryBindInfo_array_win32_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo32 *in, uint32_t count)
{
    VkSparseImageMemoryBindInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSparseImageMemoryBindInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkBindSparseInfo_win32_to_host(struct conversion_context *ctx, const VkBindSparseInfo32 *in, VkBindSparseInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = convert_VkSemaphore_array_win32_to_host(ctx, (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores), in->waitSemaphoreCount);
    out->bufferBindCount = in->bufferBindCount;
    out->pBufferBinds = convert_VkSparseBufferMemoryBindInfo_array_win32_to_host(ctx, (const VkSparseBufferMemoryBindInfo32 *)UlongToPtr(in->pBufferBinds), in->bufferBindCount);
    out->imageOpaqueBindCount = in->imageOpaqueBindCount;
    out->pImageOpaqueBinds = convert_VkSparseImageOpaqueMemoryBindInfo_array_win32_to_host(ctx, (const VkSparseImageOpaqueMemoryBindInfo32 *)UlongToPtr(in->pImageOpaqueBinds), in->imageOpaqueBindCount);
    out->imageBindCount = in->imageBindCount;
    out->pImageBinds = convert_VkSparseImageMemoryBindInfo_array_win32_to_host(ctx, (const VkSparseImageMemoryBindInfo32 *)UlongToPtr(in->pImageBinds), in->imageBindCount);
    out->signalSemaphoreCount = in->signalSemaphoreCount;
    out->pSignalSemaphores = convert_VkSemaphore_array_win32_to_host(ctx, (const VkSemaphore *)UlongToPtr(in->pSignalSemaphores), in->signalSemaphoreCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {
            VkDeviceGroupBindSparseInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupBindSparseInfo32 *in_ext = (const VkDeviceGroupBindSparseInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
            out_ext->pNext = NULL;
            out_ext->resourceDeviceIndex = in_ext->resourceDeviceIndex;
            out_ext->memoryDeviceIndex = in_ext->memoryDeviceIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT32 *in_ext = (const VkFrameBoundaryEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = UlongToPtr(in_ext->pImages);
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = UlongToPtr(in_ext->pBuffers);
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = UlongToPtr(in_ext->pTag);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
        {
            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryTensorsARM32 *in_ext = (const VkFrameBoundaryTensorsARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorCount = in_ext->tensorCount;
            out_ext->pTensors = UlongToPtr(in_ext->pTensors);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            VkTimelineSemaphoreSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTimelineSemaphoreSubmitInfo32 *in_ext = (const VkTimelineSemaphoreSubmitInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreValueCount = in_ext->waitSemaphoreValueCount;
            out_ext->pWaitSemaphoreValues = UlongToPtr(in_ext->pWaitSemaphoreValues);
            out_ext->signalSemaphoreValueCount = in_ext->signalSemaphoreValueCount;
            out_ext->pSignalSemaphoreValues = UlongToPtr(in_ext->pSignalSemaphoreValues);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkBindSparseInfo *convert_VkBindSparseInfo_array_win32_to_host(struct conversion_context *ctx, const VkBindSparseInfo32 *in, uint32_t count)
{
    VkBindSparseInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkBindSparseInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkOutOfBandQueueTypeInfoNV_win32_to_host(const VkOutOfBandQueueTypeInfoNV32 *in, VkOutOfBandQueueTypeInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->queueType = in->queueType;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static const VkSemaphore *convert_VkSemaphore_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
{
    VkSemaphore *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = in[i];
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
{
    VkSwapchainKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = in[i];
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkFence *convert_VkFence_array_win64_to_host(struct conversion_context *ctx, const VkFence *in, uint32_t count)
{
    VkFence *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_fence_from_handle(in[i])->host.fence;
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkPresentInfoKHR_win64_to_unwrapped_host(struct conversion_context *ctx, const VkPresentInfoKHR *in, VkPresentInfoKHR *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = convert_VkSemaphore_array_win64_to_unwrapped_host(ctx, in->pWaitSemaphores, in->waitSemaphoreCount);
    out->swapchainCount = in->swapchainCount;
    out->pSwapchains = convert_VkSwapchainKHR_array_win64_to_unwrapped_host(ctx, in->pSwapchains, in->swapchainCount);
    out->pImageIndices = in->pImageIndices;
    out->pResults = in->pResults;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            VkDeviceGroupPresentInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupPresentInfoKHR *in_ext = (const VkDeviceGroupPresentInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pDeviceMasks = in_ext->pDeviceMasks;
            out_ext->mode = in_ext->mode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = in_ext->pImages;
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = in_ext->pBuffers;
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = in_ext->pTag;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
        {
            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryTensorsARM *in_ext = (const VkFrameBoundaryTensorsARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorCount = in_ext->tensorCount;
            out_ext->pTensors = in_ext->pTensors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR:
        {
            VkPresentId2KHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPresentId2KHR *in_ext = (const VkPresentId2KHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pPresentIds = in_ext->pPresentIds;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
        {
            VkPresentIdKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPresentIdKHR *in_ext = (const VkPresentIdKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_ID_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pPresentIds = in_ext->pPresentIds;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            VkPresentRegionsKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPresentRegionsKHR *in_ext = (const VkPresentRegionsKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pRegions = in_ext->pRegions;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR:
        {
            VkSwapchainPresentFenceInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentFenceInfoKHR *in_ext = (const VkSwapchainPresentFenceInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pFences = convert_VkFence_array_win64_to_host(ctx, in_ext->pFences, in_ext->swapchainCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR:
        {
            VkSwapchainPresentModeInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentModeInfoKHR *in_ext = (const VkSwapchainPresentModeInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pPresentModes = in_ext->pPresentModes;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

static const VkSemaphore *convert_VkSemaphore_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
{
    VkSemaphore *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = in[i];
    }

    return out;
}

static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
{
    VkSwapchainKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = in[i];
    }

    return out;
}

static void convert_VkPresentRegionKHR_win32_to_host(const VkPresentRegionKHR32 *in, VkPresentRegionKHR *out)
{
    if (!in) return;

    out->rectangleCount = in->rectangleCount;
    out->pRectangles = UlongToPtr(in->pRectangles);
}

static const VkPresentRegionKHR *convert_VkPresentRegionKHR_array_win32_to_host(struct conversion_context *ctx, const VkPresentRegionKHR32 *in, uint32_t count)
{
    VkPresentRegionKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkPresentRegionKHR_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static const VkFence *convert_VkFence_array_win32_to_host(struct conversion_context *ctx, const VkFence *in, uint32_t count)
{
    VkFence *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_fence_from_handle(in[i])->host.fence;
    }

    return out;
}

static void convert_VkPresentInfoKHR_win32_to_unwrapped_host(struct conversion_context *ctx, const VkPresentInfoKHR32 *in, VkPresentInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = convert_VkSemaphore_array_win32_to_unwrapped_host(ctx, (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores), in->waitSemaphoreCount);
    out->swapchainCount = in->swapchainCount;
    out->pSwapchains = convert_VkSwapchainKHR_array_win32_to_unwrapped_host(ctx, (const VkSwapchainKHR *)UlongToPtr(in->pSwapchains), in->swapchainCount);
    out->pImageIndices = UlongToPtr(in->pImageIndices);
    out->pResults = UlongToPtr(in->pResults);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {
            VkDeviceGroupPresentInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupPresentInfoKHR32 *in_ext = (const VkDeviceGroupPresentInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pDeviceMasks = UlongToPtr(in_ext->pDeviceMasks);
            out_ext->mode = in_ext->mode;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT32 *in_ext = (const VkFrameBoundaryEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = UlongToPtr(in_ext->pImages);
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = UlongToPtr(in_ext->pBuffers);
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = UlongToPtr(in_ext->pTag);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
        {
            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryTensorsARM32 *in_ext = (const VkFrameBoundaryTensorsARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorCount = in_ext->tensorCount;
            out_ext->pTensors = UlongToPtr(in_ext->pTensors);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR:
        {
            VkPresentId2KHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPresentId2KHR32 *in_ext = (const VkPresentId2KHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pPresentIds = UlongToPtr(in_ext->pPresentIds);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
        {
            VkPresentIdKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPresentIdKHR32 *in_ext = (const VkPresentIdKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_ID_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pPresentIds = UlongToPtr(in_ext->pPresentIds);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {
            VkPresentRegionsKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPresentRegionsKHR32 *in_ext = (const VkPresentRegionsKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pRegions = convert_VkPresentRegionKHR_array_win32_to_host(ctx, (const VkPresentRegionKHR32 *)UlongToPtr(in_ext->pRegions), in_ext->swapchainCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR:
        {
            VkSwapchainPresentFenceInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentFenceInfoKHR32 *in_ext = (const VkSwapchainPresentFenceInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pFences = convert_VkFence_array_win32_to_host(ctx, (const VkFence *)UlongToPtr(in_ext->pFences), in_ext->swapchainCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR:
        {
            VkSwapchainPresentModeInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkSwapchainPresentModeInfoKHR32 *in_ext = (const VkSwapchainPresentModeInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->swapchainCount = in_ext->swapchainCount;
            out_ext->pPresentModes = UlongToPtr(in_ext->pPresentModes);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

#ifdef _WIN64
static const VkCommandBuffer *convert_VkCommandBuffer_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBuffer *in, uint32_t count)
{
    VkCommandBuffer *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = in[i];
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkDeviceMemory *convert_VkDeviceMemory_array_win64_to_host(struct conversion_context *ctx, const VkDeviceMemory *in, uint32_t count)
{
    VkDeviceMemory *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_device_memory_from_handle(in[i])->host.device_memory;
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkSubmitInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo *in, VkSubmitInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = convert_VkSemaphore_array_win64_to_unwrapped_host(ctx, in->pWaitSemaphores, in->waitSemaphoreCount);
    out->pWaitDstStageMask = in->pWaitDstStageMask;
    out->commandBufferCount = in->commandBufferCount;
    out->pCommandBuffers = convert_VkCommandBuffer_array_win64_to_unwrapped_host(ctx, in->pCommandBuffers, in->commandBufferCount);
    out->signalSemaphoreCount = in->signalSemaphoreCount;
    out->pSignalSemaphores = convert_VkSemaphore_array_win64_to_unwrapped_host(ctx, in->pSignalSemaphores, in->signalSemaphoreCount);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            VkD3D12FenceSubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkD3D12FenceSubmitInfoKHR *in_ext = (const VkD3D12FenceSubmitInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreValuesCount = in_ext->waitSemaphoreValuesCount;
            out_ext->pWaitSemaphoreValues = in_ext->pWaitSemaphoreValues;
            out_ext->signalSemaphoreValuesCount = in_ext->signalSemaphoreValuesCount;
            out_ext->pSignalSemaphoreValues = in_ext->pSignalSemaphoreValues;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            VkDeviceGroupSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupSubmitInfo *in_ext = (const VkDeviceGroupSubmitInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreCount = in_ext->waitSemaphoreCount;
            out_ext->pWaitSemaphoreDeviceIndices = in_ext->pWaitSemaphoreDeviceIndices;
            out_ext->commandBufferCount = in_ext->commandBufferCount;
            out_ext->pCommandBufferDeviceMasks = in_ext->pCommandBufferDeviceMasks;
            out_ext->signalSemaphoreCount = in_ext->signalSemaphoreCount;
            out_ext->pSignalSemaphoreDeviceIndices = in_ext->pSignalSemaphoreDeviceIndices;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = in_ext->pImages;
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = in_ext->pBuffers;
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = in_ext->pTag;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
        {
            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryTensorsARM *in_ext = (const VkFrameBoundaryTensorsARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorCount = in_ext->tensorCount;
            out_ext->pTensors = in_ext->pTensors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
        {
            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySubmissionPresentIdNV *in_ext = (const VkLatencySubmissionPresentIdNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
            out_ext->pNext = NULL;
            out_ext->presentID = in_ext->presentID;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQuerySubmitInfoKHR *in_ext = (const VkPerformanceQuerySubmitInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->counterPassIndex = in_ext->counterPassIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            VkProtectedSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkProtectedSubmitInfo *in_ext = (const VkProtectedSubmitInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->protectedSubmit = in_ext->protectedSubmit;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            VkTimelineSemaphoreSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTimelineSemaphoreSubmitInfo *in_ext = (const VkTimelineSemaphoreSubmitInfo *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreValueCount = in_ext->waitSemaphoreValueCount;
            out_ext->pWaitSemaphoreValues = in_ext->pWaitSemaphoreValues;
            out_ext->signalSemaphoreValueCount = in_ext->signalSemaphoreValueCount;
            out_ext->pSignalSemaphoreValues = in_ext->pSignalSemaphoreValues;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            VkWin32KeyedMutexAcquireReleaseInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWin32KeyedMutexAcquireReleaseInfoKHR *in_ext = (const VkWin32KeyedMutexAcquireReleaseInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->acquireCount = in_ext->acquireCount;
            out_ext->pAcquireSyncs = convert_VkDeviceMemory_array_win64_to_host(ctx, in_ext->pAcquireSyncs, in_ext->acquireCount);
            out_ext->pAcquireKeys = in_ext->pAcquireKeys;
            out_ext->pAcquireTimeouts = in_ext->pAcquireTimeouts;
            out_ext->releaseCount = in_ext->releaseCount;
            out_ext->pReleaseSyncs = convert_VkDeviceMemory_array_win64_to_host(ctx, in_ext->pReleaseSyncs, in_ext->releaseCount);
            out_ext->pReleaseKeys = in_ext->pReleaseKeys;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkSubmitInfo *convert_VkSubmitInfo_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo *in, uint32_t count)
{
    VkSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubmitInfo_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static const VkDeviceMemory *convert_VkDeviceMemory_array_win32_to_host(struct conversion_context *ctx, const VkDeviceMemory *in, uint32_t count)
{
    VkDeviceMemory *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_device_memory_from_handle(in[i])->host.device_memory;
    }

    return out;
}

static void convert_VkSubmitInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo32 *in, VkSubmitInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->waitSemaphoreCount = in->waitSemaphoreCount;
    out->pWaitSemaphores = convert_VkSemaphore_array_win32_to_unwrapped_host(ctx, (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores), in->waitSemaphoreCount);
    out->pWaitDstStageMask = UlongToPtr(in->pWaitDstStageMask);
    out->commandBufferCount = in->commandBufferCount;
    out->pCommandBuffers = convert_VkCommandBuffer_array_win32_to_unwrapped_host(ctx, (const PTR32 *)UlongToPtr(in->pCommandBuffers), in->commandBufferCount);
    out->signalSemaphoreCount = in->signalSemaphoreCount;
    out->pSignalSemaphores = convert_VkSemaphore_array_win32_to_unwrapped_host(ctx, (const VkSemaphore *)UlongToPtr(in->pSignalSemaphores), in->signalSemaphoreCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {
            VkD3D12FenceSubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkD3D12FenceSubmitInfoKHR32 *in_ext = (const VkD3D12FenceSubmitInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreValuesCount = in_ext->waitSemaphoreValuesCount;
            out_ext->pWaitSemaphoreValues = UlongToPtr(in_ext->pWaitSemaphoreValues);
            out_ext->signalSemaphoreValuesCount = in_ext->signalSemaphoreValuesCount;
            out_ext->pSignalSemaphoreValues = UlongToPtr(in_ext->pSignalSemaphoreValues);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {
            VkDeviceGroupSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceGroupSubmitInfo32 *in_ext = (const VkDeviceGroupSubmitInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreCount = in_ext->waitSemaphoreCount;
            out_ext->pWaitSemaphoreDeviceIndices = UlongToPtr(in_ext->pWaitSemaphoreDeviceIndices);
            out_ext->commandBufferCount = in_ext->commandBufferCount;
            out_ext->pCommandBufferDeviceMasks = UlongToPtr(in_ext->pCommandBufferDeviceMasks);
            out_ext->signalSemaphoreCount = in_ext->signalSemaphoreCount;
            out_ext->pSignalSemaphoreDeviceIndices = UlongToPtr(in_ext->pSignalSemaphoreDeviceIndices);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT32 *in_ext = (const VkFrameBoundaryEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = UlongToPtr(in_ext->pImages);
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = UlongToPtr(in_ext->pBuffers);
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = UlongToPtr(in_ext->pTag);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
        {
            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryTensorsARM32 *in_ext = (const VkFrameBoundaryTensorsARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorCount = in_ext->tensorCount;
            out_ext->pTensors = UlongToPtr(in_ext->pTensors);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
        {
            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySubmissionPresentIdNV32 *in_ext = (const VkLatencySubmissionPresentIdNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
            out_ext->pNext = NULL;
            out_ext->presentID = in_ext->presentID;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQuerySubmitInfoKHR32 *in_ext = (const VkPerformanceQuerySubmitInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->counterPassIndex = in_ext->counterPassIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {
            VkProtectedSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkProtectedSubmitInfo32 *in_ext = (const VkProtectedSubmitInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->protectedSubmit = in_ext->protectedSubmit;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {
            VkTimelineSemaphoreSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkTimelineSemaphoreSubmitInfo32 *in_ext = (const VkTimelineSemaphoreSubmitInfo32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
            out_ext->pNext = NULL;
            out_ext->waitSemaphoreValueCount = in_ext->waitSemaphoreValueCount;
            out_ext->pWaitSemaphoreValues = UlongToPtr(in_ext->pWaitSemaphoreValues);
            out_ext->signalSemaphoreValueCount = in_ext->signalSemaphoreValueCount;
            out_ext->pSignalSemaphoreValues = UlongToPtr(in_ext->pSignalSemaphoreValues);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            VkWin32KeyedMutexAcquireReleaseInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWin32KeyedMutexAcquireReleaseInfoKHR32 *in_ext = (const VkWin32KeyedMutexAcquireReleaseInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->acquireCount = in_ext->acquireCount;
            out_ext->pAcquireSyncs = convert_VkDeviceMemory_array_win32_to_host(ctx, (const VkDeviceMemory *)UlongToPtr(in_ext->pAcquireSyncs), in_ext->acquireCount);
            out_ext->pAcquireKeys = UlongToPtr(in_ext->pAcquireKeys);
            out_ext->pAcquireTimeouts = UlongToPtr(in_ext->pAcquireTimeouts);
            out_ext->releaseCount = in_ext->releaseCount;
            out_ext->pReleaseSyncs = convert_VkDeviceMemory_array_win32_to_host(ctx, (const VkDeviceMemory *)UlongToPtr(in_ext->pReleaseSyncs), in_ext->releaseCount);
            out_ext->pReleaseKeys = UlongToPtr(in_ext->pReleaseKeys);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkSubmitInfo *convert_VkSubmitInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo32 *in, uint32_t count)
{
    VkSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubmitInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static void convert_VkSemaphoreSubmitInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, VkSemaphoreSubmitInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->semaphore = in->semaphore;
    out->value = in->value;
    out->stageMask = in->stageMask;
    out->deviceIndex = in->deviceIndex;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, uint32_t count)
{
    VkSemaphoreSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSemaphoreSubmitInfo_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkSemaphoreSubmitInfo_win64_to_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, VkSemaphoreSubmitInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
    out->value = in->value;
    out->stageMask = in->stageMask;
    out->deviceIndex = in->deviceIndex;
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win64_to_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, uint32_t count)
{
    VkSemaphoreSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSemaphoreSubmitInfo_win64_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkCommandBufferSubmitInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo *in, VkCommandBufferSubmitInfo *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->commandBuffer = in->commandBuffer;
    out->deviceMask = in->deviceMask;

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM:
        {
            VkRenderPassStripeSubmitInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassStripeSubmitInfoARM *in_ext = (const VkRenderPassStripeSubmitInfoARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->stripeSemaphoreInfoCount = in_ext->stripeSemaphoreInfoCount;
            out_ext->pStripeSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win64_to_host(ctx, in_ext->pStripeSemaphoreInfos, in_ext->stripeSemaphoreInfoCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkCommandBufferSubmitInfo *convert_VkCommandBufferSubmitInfo_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo *in, uint32_t count)
{
    VkCommandBufferSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCommandBufferSubmitInfo_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkSubmitInfo2_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo2 *in, VkSubmitInfo2 *out)
{
    const VkBaseInStructure *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->waitSemaphoreInfoCount = in->waitSemaphoreInfoCount;
    out->pWaitSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win64_to_unwrapped_host(ctx, in->pWaitSemaphoreInfos, in->waitSemaphoreInfoCount);
    out->commandBufferInfoCount = in->commandBufferInfoCount;
    out->pCommandBufferInfos = convert_VkCommandBufferSubmitInfo_array_win64_to_unwrapped_host(ctx, in->pCommandBufferInfos, in->commandBufferInfoCount);
    out->signalSemaphoreInfoCount = in->signalSemaphoreInfoCount;
    out->pSignalSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win64_to_unwrapped_host(ctx, in->pSignalSemaphoreInfos, in->signalSemaphoreInfoCount);

    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = in_ext->pImages;
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = in_ext->pBuffers;
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = in_ext->pTag;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
        {
            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryTensorsARM *in_ext = (const VkFrameBoundaryTensorsARM *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorCount = in_ext->tensorCount;
            out_ext->pTensors = in_ext->pTensors;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
        {
            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySubmissionPresentIdNV *in_ext = (const VkLatencySubmissionPresentIdNV *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
            out_ext->pNext = NULL;
            out_ext->presentID = in_ext->presentID;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQuerySubmitInfoKHR *in_ext = (const VkPerformanceQuerySubmitInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->counterPassIndex = in_ext->counterPassIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            VkWin32KeyedMutexAcquireReleaseInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWin32KeyedMutexAcquireReleaseInfoKHR *in_ext = (const VkWin32KeyedMutexAcquireReleaseInfoKHR *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->acquireCount = in_ext->acquireCount;
            out_ext->pAcquireSyncs = convert_VkDeviceMemory_array_win64_to_host(ctx, in_ext->pAcquireSyncs, in_ext->acquireCount);
            out_ext->pAcquireKeys = in_ext->pAcquireKeys;
            out_ext->pAcquireTimeouts = in_ext->pAcquireTimeouts;
            out_ext->releaseCount = in_ext->releaseCount;
            out_ext->pReleaseSyncs = convert_VkDeviceMemory_array_win64_to_host(ctx, in_ext->pReleaseSyncs, in_ext->releaseCount);
            out_ext->pReleaseKeys = in_ext->pReleaseKeys;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}
#endif /* _WIN64 */

#ifdef _WIN64
static const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo2 *in, uint32_t count)
{
    VkSubmitInfo2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubmitInfo2_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

static void convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, VkSemaphoreSubmitInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = in->semaphore;
    out->value = in->value;
    out->stageMask = in->stageMask;
    out->deviceIndex = in->deviceIndex;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, uint32_t count)
{
    VkSemaphoreSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkSemaphoreSubmitInfo_win32_to_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, VkSemaphoreSubmitInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
    out->value = in->value;
    out->stageMask = in->stageMask;
    out->deviceIndex = in->deviceIndex;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win32_to_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, uint32_t count)
{
    VkSemaphoreSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSemaphoreSubmitInfo_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkCommandBufferSubmitInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo32 *in, VkCommandBufferSubmitInfo *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->commandBuffer = (VkCommandBuffer)UlongToPtr(in->commandBuffer);
    out->deviceMask = in->deviceMask;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM:
        {
            VkRenderPassStripeSubmitInfoARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkRenderPassStripeSubmitInfoARM32 *in_ext = (const VkRenderPassStripeSubmitInfoARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM;
            out_ext->pNext = NULL;
            out_ext->stripeSemaphoreInfoCount = in_ext->stripeSemaphoreInfoCount;
            out_ext->pStripeSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in_ext->pStripeSemaphoreInfos), in_ext->stripeSemaphoreInfoCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkCommandBufferSubmitInfo *convert_VkCommandBufferSubmitInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBufferSubmitInfo32 *in, uint32_t count)
{
    VkCommandBufferSubmitInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCommandBufferSubmitInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkSubmitInfo2_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo232 *in, VkSubmitInfo2 *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->waitSemaphoreInfoCount = in->waitSemaphoreInfoCount;
    out->pWaitSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in->pWaitSemaphoreInfos), in->waitSemaphoreInfoCount);
    out->commandBufferInfoCount = in->commandBufferInfoCount;
    out->pCommandBufferInfos = convert_VkCommandBufferSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkCommandBufferSubmitInfo32 *)UlongToPtr(in->pCommandBufferInfos), in->commandBufferInfoCount);
    out->signalSemaphoreInfoCount = in->signalSemaphoreInfoCount;
    out->pSignalSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkSemaphoreSubmitInfo32 *)UlongToPtr(in->pSignalSemaphoreInfos), in->signalSemaphoreInfoCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
        {
            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryEXT32 *in_ext = (const VkFrameBoundaryEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->frameID = in_ext->frameID;
            out_ext->imageCount = in_ext->imageCount;
            out_ext->pImages = UlongToPtr(in_ext->pImages);
            out_ext->bufferCount = in_ext->bufferCount;
            out_ext->pBuffers = UlongToPtr(in_ext->pBuffers);
            out_ext->tagName = in_ext->tagName;
            out_ext->tagSize = in_ext->tagSize;
            out_ext->pTag = UlongToPtr(in_ext->pTag);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
        {
            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkFrameBoundaryTensorsARM32 *in_ext = (const VkFrameBoundaryTensorsARM32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
            out_ext->pNext = NULL;
            out_ext->tensorCount = in_ext->tensorCount;
            out_ext->pTensors = UlongToPtr(in_ext->pTensors);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
        {
            VkLatencySubmissionPresentIdNV *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkLatencySubmissionPresentIdNV32 *in_ext = (const VkLatencySubmissionPresentIdNV32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV;
            out_ext->pNext = NULL;
            out_ext->presentID = in_ext->presentID;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {
            VkPerformanceQuerySubmitInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkPerformanceQuerySubmitInfoKHR32 *in_ext = (const VkPerformanceQuerySubmitInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->counterPassIndex = in_ext->counterPassIndex;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {
            VkWin32KeyedMutexAcquireReleaseInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkWin32KeyedMutexAcquireReleaseInfoKHR32 *in_ext = (const VkWin32KeyedMutexAcquireReleaseInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->acquireCount = in_ext->acquireCount;
            out_ext->pAcquireSyncs = convert_VkDeviceMemory_array_win32_to_host(ctx, (const VkDeviceMemory *)UlongToPtr(in_ext->pAcquireSyncs), in_ext->acquireCount);
            out_ext->pAcquireKeys = UlongToPtr(in_ext->pAcquireKeys);
            out_ext->pAcquireTimeouts = UlongToPtr(in_ext->pAcquireTimeouts);
            out_ext->releaseCount = in_ext->releaseCount;
            out_ext->pReleaseSyncs = convert_VkDeviceMemory_array_win32_to_host(ctx, (const VkDeviceMemory *)UlongToPtr(in_ext->pReleaseSyncs), in_ext->releaseCount);
            out_ext->pReleaseKeys = UlongToPtr(in_ext->pReleaseKeys);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkSubmitInfo2 *convert_VkSubmitInfo2_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSubmitInfo232 *in, uint32_t count)
{
    VkSubmitInfo2 *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkSubmitInfo2_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkReleaseCapturedPipelineDataInfoKHR_win32_to_host(const VkReleaseCapturedPipelineDataInfoKHR32 *in, VkReleaseCapturedPipelineDataInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->pipeline = in->pipeline;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkReleaseSwapchainImagesInfoKHR_win64_to_host(const VkReleaseSwapchainImagesInfoKHR *in, VkReleaseSwapchainImagesInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->swapchain = vulkan_swapchain_from_handle(in->swapchain)->host.swapchain;
    out->imageIndexCount = in->imageIndexCount;
    out->pImageIndices = in->pImageIndices;
}
#endif /* _WIN64 */

static void convert_VkReleaseSwapchainImagesInfoKHR_win32_to_host(const VkReleaseSwapchainImagesInfoKHR32 *in, VkReleaseSwapchainImagesInfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->swapchain = vulkan_swapchain_from_handle(in->swapchain)->host.swapchain;
    out->imageIndexCount = in->imageIndexCount;
    out->pImageIndices = UlongToPtr(in->pImageIndices);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkDebugUtilsObjectNameInfoEXT_win64_to_host(const VkDebugUtilsObjectNameInfoEXT *in, VkDebugUtilsObjectNameInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->objectType = in->objectType;
    out->objectHandle = wine_vk_unwrap_handle(in->objectType, in->objectHandle);
    out->pObjectName = in->pObjectName;
}
#endif /* _WIN64 */

static void convert_VkDebugUtilsObjectNameInfoEXT_win32_to_host(const VkDebugUtilsObjectNameInfoEXT32 *in, VkDebugUtilsObjectNameInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->objectType = in->objectType;
    out->objectHandle = wine_vk_unwrap_handle(in->objectType, in->objectHandle);
    out->pObjectName = UlongToPtr(in->pObjectName);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkDebugUtilsObjectTagInfoEXT_win64_to_host(const VkDebugUtilsObjectTagInfoEXT *in, VkDebugUtilsObjectTagInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->objectType = in->objectType;
    out->objectHandle = wine_vk_unwrap_handle(in->objectType, in->objectHandle);
    out->tagName = in->tagName;
    out->tagSize = in->tagSize;
    out->pTag = in->pTag;
}
#endif /* _WIN64 */

static void convert_VkDebugUtilsObjectTagInfoEXT_win32_to_host(const VkDebugUtilsObjectTagInfoEXT32 *in, VkDebugUtilsObjectTagInfoEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->objectType = in->objectType;
    out->objectHandle = wine_vk_unwrap_handle(in->objectType, in->objectHandle);
    out->tagName = in->tagName;
    out->tagSize = in->tagSize;
    out->pTag = UlongToPtr(in->pTag);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win64_to_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
{
    VkSwapchainKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_swapchain_from_handle(in[i])->host.swapchain;
    }

    return out;
}
#endif /* _WIN64 */

static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win32_to_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
{
    VkSwapchainKHR *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        out[i] = vulkan_swapchain_from_handle(in[i])->host.swapchain;
    }

    return out;
}

static void convert_VkHdrMetadataEXT_win32_to_host(struct conversion_context *ctx, const VkHdrMetadataEXT32 *in, VkHdrMetadataEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->displayPrimaryRed = in->displayPrimaryRed;
    out->displayPrimaryGreen = in->displayPrimaryGreen;
    out->displayPrimaryBlue = in->displayPrimaryBlue;
    out->whitePoint = in->whitePoint;
    out->maxLuminance = in->maxLuminance;
    out->minLuminance = in->minLuminance;
    out->maxContentLightLevel = in->maxContentLightLevel;
    out->maxFrameAverageLightLevel = in->maxFrameAverageLightLevel;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI:
        {
            VkHdrVividDynamicMetadataHUAWEI *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkHdrVividDynamicMetadataHUAWEI32 *in_ext = (const VkHdrVividDynamicMetadataHUAWEI32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI;
            out_ext->pNext = NULL;
            out_ext->dynamicMetadataSize = in_ext->dynamicMetadataSize;
            out_ext->pDynamicMetadata = UlongToPtr(in_ext->pDynamicMetadata);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static const VkHdrMetadataEXT *convert_VkHdrMetadataEXT_array_win32_to_host(struct conversion_context *ctx, const VkHdrMetadataEXT32 *in, uint32_t count)
{
    VkHdrMetadataEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkHdrMetadataEXT_win32_to_host(ctx, &in[i], &out[i]);
    }

    return out;
}

static void convert_VkSetLatencyMarkerInfoNV_win32_to_host(const VkSetLatencyMarkerInfoNV32 *in, VkSetLatencyMarkerInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->presentID = in->presentID;
    out->marker = in->marker;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkLatencySleepModeInfoNV_win32_to_host(const VkLatencySleepModeInfoNV32 *in, VkLatencySleepModeInfoNV *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->lowLatencyMode = in->lowLatencyMode;
    out->lowLatencyBoost = in->lowLatencyBoost;
    out->minimumIntervalUs = in->minimumIntervalUs;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkSemaphoreSignalInfo_win64_to_host(const VkSemaphoreSignalInfo *in, VkSemaphoreSignalInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
    out->value = in->value;
}
#endif /* _WIN64 */

static void convert_VkSemaphoreSignalInfo_win32_to_host(const VkSemaphoreSignalInfo32 *in, VkSemaphoreSignalInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
    out->value = in->value;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static const VkDebugUtilsObjectNameInfoEXT *convert_VkDebugUtilsObjectNameInfoEXT_array_win64_to_host(struct conversion_context *ctx, const VkDebugUtilsObjectNameInfoEXT *in, uint32_t count)
{
    VkDebugUtilsObjectNameInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDebugUtilsObjectNameInfoEXT_win64_to_host(&in[i], &out[i]);
    }

    return out;
}
#endif /* _WIN64 */

#ifdef _WIN64
static void convert_VkDebugUtilsMessengerCallbackDataEXT_win64_to_host(struct conversion_context *ctx, const VkDebugUtilsMessengerCallbackDataEXT *in, VkDebugUtilsMessengerCallbackDataEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    out->pMessageIdName = in->pMessageIdName;
    out->messageIdNumber = in->messageIdNumber;
    out->pMessage = in->pMessage;
    out->queueLabelCount = in->queueLabelCount;
    out->pQueueLabels = in->pQueueLabels;
    out->cmdBufLabelCount = in->cmdBufLabelCount;
    out->pCmdBufLabels = in->pCmdBufLabels;
    out->objectCount = in->objectCount;
    out->pObjects = convert_VkDebugUtilsObjectNameInfoEXT_array_win64_to_host(ctx, in->pObjects, in->objectCount);
}
#endif /* _WIN64 */

static const VkDebugUtilsLabelEXT *convert_VkDebugUtilsLabelEXT_array_win32_to_host(struct conversion_context *ctx, const VkDebugUtilsLabelEXT32 *in, uint32_t count)
{
    VkDebugUtilsLabelEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDebugUtilsLabelEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static const VkDebugUtilsObjectNameInfoEXT *convert_VkDebugUtilsObjectNameInfoEXT_array_win32_to_host(struct conversion_context *ctx, const VkDebugUtilsObjectNameInfoEXT32 *in, uint32_t count)
{
    VkDebugUtilsObjectNameInfoEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkDebugUtilsObjectNameInfoEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkDebugUtilsMessengerCallbackDataEXT_win32_to_host(struct conversion_context *ctx, const VkDebugUtilsMessengerCallbackDataEXT32 *in, VkDebugUtilsMessengerCallbackDataEXT *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->pMessageIdName = UlongToPtr(in->pMessageIdName);
    out->messageIdNumber = in->messageIdNumber;
    out->pMessage = UlongToPtr(in->pMessage);
    out->queueLabelCount = in->queueLabelCount;
    out->pQueueLabels = convert_VkDebugUtilsLabelEXT_array_win32_to_host(ctx, (const VkDebugUtilsLabelEXT32 *)UlongToPtr(in->pQueueLabels), in->queueLabelCount);
    out->cmdBufLabelCount = in->cmdBufLabelCount;
    out->pCmdBufLabels = convert_VkDebugUtilsLabelEXT_array_win32_to_host(ctx, (const VkDebugUtilsLabelEXT32 *)UlongToPtr(in->pCmdBufLabels), in->cmdBufLabelCount);
    out->objectCount = in->objectCount;
    out->pObjects = convert_VkDebugUtilsObjectNameInfoEXT_array_win32_to_host(ctx, (const VkDebugUtilsObjectNameInfoEXT32 *)UlongToPtr(in->pObjects), in->objectCount);

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT:
        {
            VkDeviceAddressBindingCallbackDataEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkDeviceAddressBindingCallbackDataEXT32 *in_ext = (const VkDeviceAddressBindingCallbackDataEXT32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT;
            out_ext->pNext = NULL;
            out_ext->flags = in_ext->flags;
            out_ext->baseAddress = in_ext->baseAddress;
            out_ext->size = in_ext->size;
            out_ext->bindingType = in_ext->bindingType;
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkHostImageLayoutTransitionInfo_win32_to_host(const VkHostImageLayoutTransitionInfo32 *in, VkHostImageLayoutTransitionInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->image = in->image;
    out->oldLayout = in->oldLayout;
    out->newLayout = in->newLayout;
    out->subresourceRange = in->subresourceRange;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkHostImageLayoutTransitionInfo *convert_VkHostImageLayoutTransitionInfo_array_win32_to_host(struct conversion_context *ctx, const VkHostImageLayoutTransitionInfo32 *in, uint32_t count)
{
    VkHostImageLayoutTransitionInfo *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkHostImageLayoutTransitionInfo_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

#ifdef _WIN64
static void convert_VkMemoryUnmapInfo_win64_to_host(const VkMemoryUnmapInfo *in, VkMemoryUnmapInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
}
#endif /* _WIN64 */

static void convert_VkMemoryUnmapInfo_win32_to_host(const VkMemoryUnmapInfo32 *in, VkMemoryUnmapInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkMemoryUnmapInfo_win32_to_unwrapped_host(const VkMemoryUnmapInfo32 *in, VkMemoryUnmapInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->memory = in->memory;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static void convert_VkCopyDescriptorSet_win32_to_host(const VkCopyDescriptorSet32 *in, VkCopyDescriptorSet *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->srcSet = in->srcSet;
    out->srcBinding = in->srcBinding;
    out->srcArrayElement = in->srcArrayElement;
    out->dstSet = in->dstSet;
    out->dstBinding = in->dstBinding;
    out->dstArrayElement = in->dstArrayElement;
    out->descriptorCount = in->descriptorCount;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkCopyDescriptorSet *convert_VkCopyDescriptorSet_array_win32_to_host(struct conversion_context *ctx, const VkCopyDescriptorSet32 *in, uint32_t count)
{
    VkCopyDescriptorSet *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkCopyDescriptorSet_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkWriteIndirectExecutionSetPipelineEXT_win32_to_host(const VkWriteIndirectExecutionSetPipelineEXT32 *in, VkWriteIndirectExecutionSetPipelineEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->index = in->index;
    out->pipeline = in->pipeline;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkWriteIndirectExecutionSetPipelineEXT *convert_VkWriteIndirectExecutionSetPipelineEXT_array_win32_to_host(struct conversion_context *ctx, const VkWriteIndirectExecutionSetPipelineEXT32 *in, uint32_t count)
{
    VkWriteIndirectExecutionSetPipelineEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkWriteIndirectExecutionSetPipelineEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkWriteIndirectExecutionSetShaderEXT_win32_to_host(const VkWriteIndirectExecutionSetShaderEXT32 *in, VkWriteIndirectExecutionSetShaderEXT *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->index = in->index;
    out->shader = in->shader;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

static const VkWriteIndirectExecutionSetShaderEXT *convert_VkWriteIndirectExecutionSetShaderEXT_array_win32_to_host(struct conversion_context *ctx, const VkWriteIndirectExecutionSetShaderEXT32 *in, uint32_t count)
{
    VkWriteIndirectExecutionSetShaderEXT *out;
    unsigned int i;

    if (!in || !count) return NULL;

    out = conversion_context_alloc(ctx, count * sizeof(*out));
    for (i = 0; i < count; i++)
    {
        convert_VkWriteIndirectExecutionSetShaderEXT_win32_to_host(&in[i], &out[i]);
    }

    return out;
}

static void convert_VkVideoSessionParametersUpdateInfoKHR_win32_to_host(struct conversion_context *ctx, const VkVideoSessionParametersUpdateInfoKHR32 *in, VkVideoSessionParametersUpdateInfoKHR *out)
{
    const VkBaseInStructure32 *in_header;
    VkBaseOutStructure *out_header = (void *)out;

    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->updateSequenceCount = in->updateSequenceCount;

    for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
    {
        switch (in_header->sType)
        {
        case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
        {
            VkVideoDecodeH264SessionParametersAddInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoDecodeH264SessionParametersAddInfoKHR32 *in_ext = (const VkVideoDecodeH264SessionParametersAddInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdSPSCount = in_ext->stdSPSCount;
            out_ext->pStdSPSs = convert_StdVideoH264SequenceParameterSet_array_win32_to_host(ctx, (const StdVideoH264SequenceParameterSet32 *)UlongToPtr(in_ext->pStdSPSs), in_ext->stdSPSCount);
            out_ext->stdPPSCount = in_ext->stdPPSCount;
            out_ext->pStdPPSs = convert_StdVideoH264PictureParameterSet_array_win32_to_host(ctx, (const StdVideoH264PictureParameterSet32 *)UlongToPtr(in_ext->pStdPPSs), in_ext->stdPPSCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
        {
            VkVideoEncodeH264SessionParametersAddInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
            const VkVideoEncodeH264SessionParametersAddInfoKHR32 *in_ext = (const VkVideoEncodeH264SessionParametersAddInfoKHR32 *)in_header;
            out_ext->sType = VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR;
            out_ext->pNext = NULL;
            out_ext->stdSPSCount = in_ext->stdSPSCount;
            out_ext->pStdSPSs = convert_StdVideoH264SequenceParameterSet_array_win32_to_host(ctx, (const StdVideoH264SequenceParameterSet32 *)UlongToPtr(in_ext->pStdSPSs), in_ext->stdSPSCount);
            out_ext->stdPPSCount = in_ext->stdPPSCount;
            out_ext->pStdPPSs = convert_StdVideoH264PictureParameterSet_array_win32_to_host(ctx, (const StdVideoH264PictureParameterSet32 *)UlongToPtr(in_ext->pStdPPSs), in_ext->stdPPSCount);
            out_header->pNext = (void *)out_ext;
            out_header = (void *)out_ext;
            break;
        }
        default:
            FIXME("Unhandled sType %u.\n", in_header->sType);
            break;
        }
    }
}

static void convert_VkPresentWait2InfoKHR_win32_to_host(const VkPresentWait2InfoKHR32 *in, VkPresentWait2InfoKHR *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->presentId = in->presentId;
    out->timeout = in->timeout;
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static void convert_VkSemaphoreWaitInfo_win64_to_host(struct conversion_context *ctx, const VkSemaphoreWaitInfo *in, VkSemaphoreWaitInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->flags = in->flags;
    out->semaphoreCount = in->semaphoreCount;
    out->pSemaphores = convert_VkSemaphore_array_win64_to_host(ctx, in->pSemaphores, in->semaphoreCount);
    out->pValues = in->pValues;
}
#endif /* _WIN64 */

static void convert_VkSemaphoreWaitInfo_win32_to_host(struct conversion_context *ctx, const VkSemaphoreWaitInfo32 *in, VkSemaphoreWaitInfo *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = NULL;
    out->flags = in->flags;
    out->semaphoreCount = in->semaphoreCount;
    out->pSemaphores = convert_VkSemaphore_array_win32_to_host(ctx, (const VkSemaphore *)UlongToPtr(in->pSemaphores), in->semaphoreCount);
    out->pValues = UlongToPtr(in->pValues);
    if (in->pNext)
        FIXME("Unexpected pNext\n");
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAcquireNextImage2KHR(void *args)
{
    struct vkAcquireNextImage2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pAcquireInfo, params->pImageIndex);

    params->result = vk_funcs->p_vkAcquireNextImage2KHR(params->device, params->pAcquireInfo, params->pImageIndex);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAcquireNextImage2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAcquireInfo;
        PTR32 pImageIndex;
        VkResult result;
    } *params = args;
    VkAcquireNextImageInfoKHR pAcquireInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pAcquireInfo, params->pImageIndex);

    convert_VkAcquireNextImageInfoKHR_win32_to_unwrapped_host((const VkAcquireNextImageInfoKHR32 *)UlongToPtr(params->pAcquireInfo), &pAcquireInfo_host);
    params->result = vk_funcs->p_vkAcquireNextImage2KHR((VkDevice)UlongToPtr(params->device), &pAcquireInfo_host, (uint32_t *)UlongToPtr(params->pImageIndex));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAcquireNextImageKHR(void *args)
{
    struct vkAcquireNextImageKHR_params *params = args;

    TRACE("%p, 0x%s, 0x%s, 0x%s, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), wine_dbgstr_longlong(params->timeout), wine_dbgstr_longlong(params->semaphore), wine_dbgstr_longlong(params->fence), params->pImageIndex);

    params->result = vk_funcs->p_vkAcquireNextImageKHR(params->device, params->swapchain, params->timeout, params->semaphore, params->fence, params->pImageIndex);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAcquireNextImageKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        uint64_t DECLSPEC_ALIGN(8) timeout;
        VkSemaphore DECLSPEC_ALIGN(8) semaphore;
        VkFence DECLSPEC_ALIGN(8) fence;
        PTR32 pImageIndex;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, 0x%s, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), wine_dbgstr_longlong(params->timeout), wine_dbgstr_longlong(params->semaphore), wine_dbgstr_longlong(params->fence), params->pImageIndex);

    params->result = vk_funcs->p_vkAcquireNextImageKHR((VkDevice)UlongToPtr(params->device), params->swapchain, params->timeout, params->semaphore, params->fence, (uint32_t *)UlongToPtr(params->pImageIndex));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAcquirePerformanceConfigurationINTEL(void *args)
{
    struct vkAcquirePerformanceConfigurationINTEL_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pAcquireInfo, params->pConfiguration);

    params->result = vulkan_device_from_handle(params->device)->p_vkAcquirePerformanceConfigurationINTEL(vulkan_device_from_handle(params->device)->host.device, params->pAcquireInfo, params->pConfiguration);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAcquirePerformanceConfigurationINTEL(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAcquireInfo;
        PTR32 pConfiguration;
        VkResult result;
    } *params = args;
    VkPerformanceConfigurationAcquireInfoINTEL pAcquireInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pAcquireInfo, params->pConfiguration);

    convert_VkPerformanceConfigurationAcquireInfoINTEL_win32_to_host((const VkPerformanceConfigurationAcquireInfoINTEL32 *)UlongToPtr(params->pAcquireInfo), &pAcquireInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkAcquirePerformanceConfigurationINTEL(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pAcquireInfo_host, (VkPerformanceConfigurationINTEL *)UlongToPtr(params->pConfiguration));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAcquireProfilingLockKHR(void *args)
{
    struct vkAcquireProfilingLockKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkAcquireProfilingLockKHR(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAcquireProfilingLockKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkAcquireProfilingLockInfoKHR pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkAcquireProfilingLockInfoKHR_win32_to_host((const VkAcquireProfilingLockInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkAcquireProfilingLockKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAllocateCommandBuffers(void *args)
{
    struct vkAllocateCommandBuffers_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pAllocateInfo, params->pCommandBuffers);

    params->result = wine_vkAllocateCommandBuffers(params->device, params->pAllocateInfo, params->pCommandBuffers);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAllocateCommandBuffers(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAllocateInfo;
        PTR32 pCommandBuffers;
        VkResult result;
    } *params = args;
    VkCommandBufferAllocateInfo pAllocateInfo_host;
    VkCommandBuffer *pCommandBuffers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pAllocateInfo, params->pCommandBuffers);

    init_conversion_context(ctx);
    convert_VkCommandBufferAllocateInfo_win32_to_unwrapped_host((const VkCommandBufferAllocateInfo32 *)UlongToPtr(params->pAllocateInfo), &pAllocateInfo_host);
    pCommandBuffers_host = convert_VkCommandBuffer_array_win32_to_unwrapped_host(ctx, (PTR32 *)UlongToPtr(params->pCommandBuffers), ((const VkCommandBufferAllocateInfo32 *)UlongToPtr(params->pAllocateInfo))->commandBufferCount);
    params->result = wine_vkAllocateCommandBuffers((VkDevice)UlongToPtr(params->device), &pAllocateInfo_host, pCommandBuffers_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAllocateDescriptorSets(void *args)
{
    struct vkAllocateDescriptorSets_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pAllocateInfo, params->pDescriptorSets);

    params->result = vulkan_device_from_handle(params->device)->p_vkAllocateDescriptorSets(vulkan_device_from_handle(params->device)->host.device, params->pAllocateInfo, params->pDescriptorSets);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAllocateDescriptorSets(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAllocateInfo;
        PTR32 pDescriptorSets;
        VkResult result;
    } *params = args;
    VkDescriptorSetAllocateInfo pAllocateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pAllocateInfo, params->pDescriptorSets);

    init_conversion_context(ctx);
    convert_VkDescriptorSetAllocateInfo_win32_to_host(ctx, (const VkDescriptorSetAllocateInfo32 *)UlongToPtr(params->pAllocateInfo), &pAllocateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkAllocateDescriptorSets(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pAllocateInfo_host, (VkDescriptorSet *)UlongToPtr(params->pDescriptorSets));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAllocateMemory(void *args)
{
    struct vkAllocateMemory_params *params = args;
    VkMemoryAllocateInfo pAllocateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pAllocateInfo, params->pAllocator, params->pMemory);

    init_conversion_context(ctx);
    convert_VkMemoryAllocateInfo_win64_to_host(ctx, params->pAllocateInfo, &pAllocateInfo_host);
    params->result = vk_funcs->p_vkAllocateMemory(params->device, &pAllocateInfo_host, params->pAllocator, params->pMemory);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAllocateMemory(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAllocateInfo;
        PTR32 pAllocator;
        PTR32 pMemory;
        VkResult result;
    } *params = args;
    VkMemoryAllocateInfo pAllocateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pAllocateInfo, params->pAllocator, params->pMemory);

    init_conversion_context(ctx);
    convert_VkMemoryAllocateInfo_win32_to_host(ctx, (const VkMemoryAllocateInfo32 *)UlongToPtr(params->pAllocateInfo), &pAllocateInfo_host);
    params->result = vk_funcs->p_vkAllocateMemory((VkDevice)UlongToPtr(params->device), &pAllocateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDeviceMemory *)UlongToPtr(params->pMemory));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkAntiLagUpdateAMD(void *args)
{
    struct vkAntiLagUpdateAMD_params *params = args;

    TRACE("%p, %p\n", params->device, params->pData);

    vulkan_device_from_handle(params->device)->p_vkAntiLagUpdateAMD(vulkan_device_from_handle(params->device)->host.device, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkAntiLagUpdateAMD(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pData;
    } *params = args;
    VkAntiLagDataAMD pData_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->device, params->pData);

    init_conversion_context(ctx);
    convert_VkAntiLagDataAMD_win32_to_host(ctx, (const VkAntiLagDataAMD32 *)UlongToPtr(params->pData), &pData_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkAntiLagUpdateAMD(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pData_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBeginCommandBuffer(void *args)
{
    struct vkBeginCommandBuffer_params *params = args;
    VkCommandBufferBeginInfo pBeginInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p\n", params->commandBuffer, params->pBeginInfo);

    init_conversion_context(ctx);
    convert_VkCommandBufferBeginInfo_win64_to_host(ctx, params->pBeginInfo, &pBeginInfo_host);
    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkBeginCommandBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, &pBeginInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBeginCommandBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBeginInfo;
        VkResult result;
    } *params = args;
    VkCommandBufferBeginInfo pBeginInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->commandBuffer, params->pBeginInfo);

    init_conversion_context(ctx);
    convert_VkCommandBufferBeginInfo_win32_to_host(ctx, (const VkCommandBufferBeginInfo32 *)UlongToPtr(params->pBeginInfo), &pBeginInfo_host);
    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkBeginCommandBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBeginInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindAccelerationStructureMemoryNV(void *args)
{
    struct vkBindAccelerationStructureMemoryNV_params *params = args;
    const VkBindAccelerationStructureMemoryInfoNV *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindAccelerationStructureMemoryInfoNV_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkBindAccelerationStructureMemoryNV(vulkan_device_from_handle(params->device)->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindAccelerationStructureMemoryNV(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindAccelerationStructureMemoryInfoNV *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindAccelerationStructureMemoryInfoNV_array_win32_to_host(ctx, (const VkBindAccelerationStructureMemoryInfoNV32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindAccelerationStructureMemoryNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindBufferMemory(void *args)
{
    struct vkBindBufferMemory_params *params = args;

    TRACE("%p, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->buffer), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));

    params->result = vulkan_device_from_handle(params->device)->p_vkBindBufferMemory(vulkan_device_from_handle(params->device)->host.device, params->buffer, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindBufferMemory(void *args)
{
    struct
    {
        PTR32 device;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->buffer), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindBufferMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->buffer, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindBufferMemory2(void *args)
{
    struct vkBindBufferMemory2_params *params = args;
    const VkBindBufferMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindBufferMemoryInfo_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkBindBufferMemory2(vulkan_device_from_handle(params->device)->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindBufferMemory2(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindBufferMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindBufferMemoryInfo_array_win32_to_host(ctx, (const VkBindBufferMemoryInfo32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindBufferMemory2(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindBufferMemory2KHR(void *args)
{
    struct vkBindBufferMemory2KHR_params *params = args;
    const VkBindBufferMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindBufferMemoryInfo_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkBindBufferMemory2KHR(vulkan_device_from_handle(params->device)->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindBufferMemory2KHR(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindBufferMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindBufferMemoryInfo_array_win32_to_host(ctx, (const VkBindBufferMemoryInfo32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindBufferMemory2KHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindDataGraphPipelineSessionMemoryARM(void *args)
{
    struct vkBindDataGraphPipelineSessionMemoryARM_params *params = args;
    const VkBindDataGraphPipelineSessionMemoryInfoARM *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindDataGraphPipelineSessionMemoryInfoARM_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkBindDataGraphPipelineSessionMemoryARM(vulkan_device_from_handle(params->device)->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindDataGraphPipelineSessionMemoryARM(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindDataGraphPipelineSessionMemoryInfoARM *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindDataGraphPipelineSessionMemoryInfoARM_array_win32_to_host(ctx, (const VkBindDataGraphPipelineSessionMemoryInfoARM32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindDataGraphPipelineSessionMemoryARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindImageMemory(void *args)
{
    struct vkBindImageMemory_params *params = args;

    TRACE("%p, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->image), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));

    params->result = vulkan_device_from_handle(params->device)->p_vkBindImageMemory(vulkan_device_from_handle(params->device)->host.device, params->image, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindImageMemory(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        VkDeviceSize DECLSPEC_ALIGN(8) memoryOffset;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->image), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindImageMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindImageMemory2(void *args)
{
    struct vkBindImageMemory2_params *params = args;
    const VkBindImageMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindImageMemoryInfo_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkBindImageMemory2(vulkan_device_from_handle(params->device)->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindImageMemory2(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindImageMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindImageMemoryInfo_array_win32_to_host(ctx, (const VkBindImageMemoryInfo32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindImageMemory2(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindImageMemory2KHR(void *args)
{
    struct vkBindImageMemory2KHR_params *params = args;
    const VkBindImageMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindImageMemoryInfo_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkBindImageMemory2KHR(vulkan_device_from_handle(params->device)->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindImageMemory2KHR(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindImageMemoryInfo *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindImageMemoryInfo_array_win32_to_host(ctx, (const VkBindImageMemoryInfo32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindImageMemory2KHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindOpticalFlowSessionImageNV(void *args)
{
    struct vkBindOpticalFlowSessionImageNV_params *params = args;

    TRACE("%p, 0x%s, %#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->session), params->bindingPoint, wine_dbgstr_longlong(params->view), params->layout);

    params->result = vulkan_device_from_handle(params->device)->p_vkBindOpticalFlowSessionImageNV(vulkan_device_from_handle(params->device)->host.device, params->session, params->bindingPoint, params->view, params->layout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindOpticalFlowSessionImageNV(void *args)
{
    struct
    {
        PTR32 device;
        VkOpticalFlowSessionNV DECLSPEC_ALIGN(8) session;
        VkOpticalFlowSessionBindingPointNV bindingPoint;
        VkImageView DECLSPEC_ALIGN(8) view;
        VkImageLayout layout;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->session), params->bindingPoint, wine_dbgstr_longlong(params->view), params->layout);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindOpticalFlowSessionImageNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->session, params->bindingPoint, params->view, params->layout);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindTensorMemoryARM(void *args)
{
    struct vkBindTensorMemoryARM_params *params = args;
    const VkBindTensorMemoryInfoARM *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindTensorMemoryInfoARM_array_win64_to_host(ctx, params->pBindInfos, params->bindInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkBindTensorMemoryARM(vulkan_device_from_handle(params->device)->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindTensorMemoryARM(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t bindInfoCount;
        PTR32 pBindInfos;
        VkResult result;
    } *params = args;
    const VkBindTensorMemoryInfoARM *pBindInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->bindInfoCount, params->pBindInfos);

    init_conversion_context(ctx);
    pBindInfos_host = convert_VkBindTensorMemoryInfoARM_array_win32_to_host(ctx, (const VkBindTensorMemoryInfoARM32 *)UlongToPtr(params->pBindInfos), params->bindInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindTensorMemoryARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->bindInfoCount, pBindInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBindVideoSessionMemoryKHR(void *args)
{
    struct vkBindVideoSessionMemoryKHR_params *params = args;
    const VkBindVideoSessionMemoryInfoKHR *pBindSessionMemoryInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->videoSession), params->bindSessionMemoryInfoCount, params->pBindSessionMemoryInfos);

    init_conversion_context(ctx);
    pBindSessionMemoryInfos_host = convert_VkBindVideoSessionMemoryInfoKHR_array_win64_to_host(ctx, params->pBindSessionMemoryInfos, params->bindSessionMemoryInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkBindVideoSessionMemoryKHR(vulkan_device_from_handle(params->device)->host.device, params->videoSession, params->bindSessionMemoryInfoCount, pBindSessionMemoryInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBindVideoSessionMemoryKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkVideoSessionKHR DECLSPEC_ALIGN(8) videoSession;
        uint32_t bindSessionMemoryInfoCount;
        PTR32 pBindSessionMemoryInfos;
        VkResult result;
    } *params = args;
    const VkBindVideoSessionMemoryInfoKHR *pBindSessionMemoryInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->videoSession), params->bindSessionMemoryInfoCount, params->pBindSessionMemoryInfos);

    init_conversion_context(ctx);
    pBindSessionMemoryInfos_host = convert_VkBindVideoSessionMemoryInfoKHR_array_win32_to_host(ctx, (const VkBindVideoSessionMemoryInfoKHR32 *)UlongToPtr(params->pBindSessionMemoryInfos), params->bindSessionMemoryInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindVideoSessionMemoryKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->videoSession, params->bindSessionMemoryInfoCount, pBindSessionMemoryInfos_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBuildAccelerationStructuresKHR(void *args)
{
    struct vkBuildAccelerationStructuresKHR_params *params = args;

    TRACE("%p, 0x%s, %u, %p, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->infoCount, params->pInfos, params->ppBuildRangeInfos);

    params->result = vulkan_device_from_handle(params->device)->p_vkBuildAccelerationStructuresKHR(vulkan_device_from_handle(params->device)->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->infoCount, params->pInfos, params->ppBuildRangeInfos);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBuildAccelerationStructuresKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        uint32_t infoCount;
        PTR32 pInfos;
        PTR32 ppBuildRangeInfos;
        VkResult result;
    } *params = args;
    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos_host;
    const VkAccelerationStructureBuildRangeInfoKHR* const *ppBuildRangeInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->infoCount, params->pInfos, params->ppBuildRangeInfos);

    if (params->deferredOperation == VK_NULL_HANDLE)
        init_conversion_context(ctx);
    else
        ctx = &wine_deferred_operation_from_handle(params->deferredOperation)->ctx;
    pInfos_host = convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pInfos), params->infoCount);
    ppBuildRangeInfos_host = convert_VkAccelerationStructureBuildRangeInfoKHR_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->ppBuildRangeInfos), params->infoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBuildAccelerationStructuresKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->infoCount, pInfos_host, ppBuildRangeInfos_host);
    if (params->deferredOperation == VK_NULL_HANDLE)
        free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkBuildMicromapsEXT(void *args)
{
    struct vkBuildMicromapsEXT_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->infoCount, params->pInfos);

    params->result = vulkan_device_from_handle(params->device)->p_vkBuildMicromapsEXT(vulkan_device_from_handle(params->device)->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->infoCount, params->pInfos);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkBuildMicromapsEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        uint32_t infoCount;
        PTR32 pInfos;
        VkResult result;
    } *params = args;
    const VkMicromapBuildInfoEXT *pInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->infoCount, params->pInfos);

    if (params->deferredOperation == VK_NULL_HANDLE)
        init_conversion_context(ctx);
    else
        ctx = &wine_deferred_operation_from_handle(params->deferredOperation)->ctx;
    pInfos_host = convert_VkMicromapBuildInfoEXT_array_win32_to_host(ctx, (const VkMicromapBuildInfoEXT32 *)UlongToPtr(params->pInfos), params->infoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBuildMicromapsEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->infoCount, pInfos_host);
    if (params->deferredOperation == VK_NULL_HANDLE)
        free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static void thunk64_vkCmdBeginConditionalRenderingEXT(void *args)
{
    struct vkCmdBeginConditionalRenderingEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginConditionalRenderingEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pConditionalRenderingBegin);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginConditionalRenderingEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pConditionalRenderingBegin;
    } *params = args;
    VkConditionalRenderingBeginInfoEXT pConditionalRenderingBegin_host;

    convert_VkConditionalRenderingBeginInfoEXT_win32_to_host((const VkConditionalRenderingBeginInfoEXT32 *)UlongToPtr(params->pConditionalRenderingBegin), &pConditionalRenderingBegin_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginConditionalRenderingEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pConditionalRenderingBegin_host);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginDebugUtilsLabelEXT(void *args)
{
    struct vkCmdBeginDebugUtilsLabelEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginDebugUtilsLabelEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLabelInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pLabelInfo;
    } *params = args;
    VkDebugUtilsLabelEXT pLabelInfo_host;

    convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginDebugUtilsLabelEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLabelInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginPerTileExecutionQCOM(void *args)
{
    struct vkCmdBeginPerTileExecutionQCOM_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginPerTileExecutionQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPerTileBeginInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginPerTileExecutionQCOM(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pPerTileBeginInfo;
    } *params = args;
    VkPerTileBeginInfoQCOM pPerTileBeginInfo_host;

    convert_VkPerTileBeginInfoQCOM_win32_to_host((const VkPerTileBeginInfoQCOM32 *)UlongToPtr(params->pPerTileBeginInfo), &pPerTileBeginInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginPerTileExecutionQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPerTileBeginInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginQuery(void *args)
{
    struct vkCmdBeginQuery_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginQuery(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->flags);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginQuery(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
        VkQueryControlFlags flags;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginQuery(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->flags);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginQueryIndexedEXT(void *args)
{
    struct vkCmdBeginQueryIndexedEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginQueryIndexedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->flags, params->index);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginQueryIndexedEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
        VkQueryControlFlags flags;
        uint32_t index;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginQueryIndexedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->flags, params->index);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginRenderPass(void *args)
{
    struct vkCmdBeginRenderPass_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->contents);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginRenderPass(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderPassBegin;
        VkSubpassContents contents;
    } *params = args;
    VkRenderPassBeginInfo pRenderPassBegin_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, params->contents);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginRenderPass2(void *args)
{
    struct vkCmdBeginRenderPass2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginRenderPass2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderPassBegin;
        PTR32 pSubpassBeginInfo;
    } *params = args;
    VkRenderPassBeginInfo pRenderPassBegin_host;
    VkSubpassBeginInfo pSubpassBeginInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
    convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginRenderPass2KHR(void *args)
{
    struct vkCmdBeginRenderPass2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginRenderPass2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderPassBegin;
        PTR32 pSubpassBeginInfo;
    } *params = args;
    VkRenderPassBeginInfo pRenderPassBegin_host;
    VkSubpassBeginInfo pSubpassBeginInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
    convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginRendering(void *args)
{
    struct vkCmdBeginRendering_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRendering(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginRendering(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderingInfo;
    } *params = args;
    VkRenderingInfo pRenderingInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkRenderingInfo_win32_to_host(ctx, (const VkRenderingInfo32 *)UlongToPtr(params->pRenderingInfo), &pRenderingInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRendering(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderingInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginRenderingKHR(void *args)
{
    struct vkCmdBeginRenderingKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginRenderingKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderingInfo;
    } *params = args;
    VkRenderingInfo pRenderingInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkRenderingInfo_win32_to_host(ctx, (const VkRenderingInfo32 *)UlongToPtr(params->pRenderingInfo), &pRenderingInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderingInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBeginTransformFeedbackEXT(void *args)
{
    struct vkCmdBeginTransformFeedbackEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginTransformFeedbackEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginTransformFeedbackEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstCounterBuffer;
        uint32_t counterBufferCount;
        PTR32 pCounterBuffers;
        PTR32 pCounterBufferOffsets;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginTransformFeedbackEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
}

#ifdef _WIN64
static void thunk64_vkCmdBeginVideoCodingKHR(void *args)
{
    struct vkCmdBeginVideoCodingKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginVideoCodingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBeginInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBeginVideoCodingKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBeginInfo;
    } *params = args;
    VkVideoBeginCodingInfoKHR pBeginInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkVideoBeginCodingInfoKHR_win32_to_host(ctx, (const VkVideoBeginCodingInfoKHR32 *)UlongToPtr(params->pBeginInfo), &pBeginInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginVideoCodingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBeginInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(void *args)
{
    struct vkCmdBindDescriptorBufferEmbeddedSamplers2EXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorBufferEmbeddedSamplersInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBindDescriptorBufferEmbeddedSamplersInfo;
    } *params = args;
    VkBindDescriptorBufferEmbeddedSamplersInfoEXT pBindDescriptorBufferEmbeddedSamplersInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkBindDescriptorBufferEmbeddedSamplersInfoEXT_win32_to_host(ctx, (const VkBindDescriptorBufferEmbeddedSamplersInfoEXT32 *)UlongToPtr(params->pBindDescriptorBufferEmbeddedSamplersInfo), &pBindDescriptorBufferEmbeddedSamplersInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorBufferEmbeddedSamplersInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(void *args)
{
    struct vkCmdBindDescriptorBufferEmbeddedSamplersEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t set;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set);
}

#ifdef _WIN64
static void thunk64_vkCmdBindDescriptorBuffersEXT(void *args)
{
    struct vkCmdBindDescriptorBuffersEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBuffersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->bufferCount, params->pBindingInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindDescriptorBuffersEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t bufferCount;
        PTR32 pBindingInfos;
    } *params = args;
    const VkDescriptorBufferBindingInfoEXT *pBindingInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pBindingInfos_host = convert_VkDescriptorBufferBindingInfoEXT_array_win32_to_host(ctx, (const VkDescriptorBufferBindingInfoEXT32 *)UlongToPtr(params->pBindingInfos), params->bufferCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBuffersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->bufferCount, pBindingInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBindDescriptorSets(void *args)
{
    struct vkCmdBindDescriptorSets_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, params->pDescriptorSets, params->dynamicOffsetCount, params->pDynamicOffsets);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindDescriptorSets(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t firstSet;
        uint32_t descriptorSetCount;
        PTR32 pDescriptorSets;
        uint32_t dynamicOffsetCount;
        PTR32 pDynamicOffsets;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, (const VkDescriptorSet *)UlongToPtr(params->pDescriptorSets), params->dynamicOffsetCount, (const uint32_t *)UlongToPtr(params->pDynamicOffsets));
}

#ifdef _WIN64
static void thunk64_vkCmdBindDescriptorSets2(void *args)
{
    struct vkCmdBindDescriptorSets2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorSetsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindDescriptorSets2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBindDescriptorSetsInfo;
    } *params = args;
    VkBindDescriptorSetsInfo pBindDescriptorSetsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkBindDescriptorSetsInfo_win32_to_host(ctx, (const VkBindDescriptorSetsInfo32 *)UlongToPtr(params->pBindDescriptorSetsInfo), &pBindDescriptorSetsInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorSetsInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBindDescriptorSets2KHR(void *args)
{
    struct vkCmdBindDescriptorSets2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorSetsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindDescriptorSets2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBindDescriptorSetsInfo;
    } *params = args;
    VkBindDescriptorSetsInfo pBindDescriptorSetsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkBindDescriptorSetsInfo_win32_to_host(ctx, (const VkBindDescriptorSetsInfo32 *)UlongToPtr(params->pBindDescriptorSetsInfo), &pBindDescriptorSetsInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorSetsInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBindIndexBuffer(void *args)
{
    struct vkCmdBindIndexBuffer_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->indexType);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindIndexBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkIndexType indexType;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->indexType);
}

#ifdef _WIN64
static void thunk64_vkCmdBindIndexBuffer2(void *args)
{
    struct vkCmdBindIndexBuffer2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindIndexBuffer2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkDeviceSize DECLSPEC_ALIGN(8) size;
        VkIndexType indexType;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
}

#ifdef _WIN64
static void thunk64_vkCmdBindIndexBuffer2KHR(void *args)
{
    struct vkCmdBindIndexBuffer2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindIndexBuffer2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkDeviceSize DECLSPEC_ALIGN(8) size;
        VkIndexType indexType;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
}

#ifdef _WIN64
static void thunk64_vkCmdBindInvocationMaskHUAWEI(void *args)
{
    struct vkCmdBindInvocationMaskHUAWEI_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindInvocationMaskHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->imageView, params->imageLayout);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindInvocationMaskHUAWEI(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImageView DECLSPEC_ALIGN(8) imageView;
        VkImageLayout imageLayout;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindInvocationMaskHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->imageView, params->imageLayout);
}

#ifdef _WIN64
static void thunk64_vkCmdBindPipeline(void *args)
{
    struct vkCmdBindPipeline_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindPipeline(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindPipeline(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipeline(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline);
}

#ifdef _WIN64
static void thunk64_vkCmdBindPipelineShaderGroupNV(void *args)
{
    struct vkCmdBindPipelineShaderGroupNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindPipelineShaderGroupNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindPipelineShaderGroupNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t groupIndex;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipelineShaderGroupNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
}

#ifdef _WIN64
static void thunk64_vkCmdBindShadersEXT(void *args)
{
    struct vkCmdBindShadersEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindShadersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stageCount, params->pStages, params->pShaders);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindShadersEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t stageCount;
        PTR32 pStages;
        PTR32 pShaders;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindShadersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stageCount, (const VkShaderStageFlagBits *)UlongToPtr(params->pStages), (const VkShaderEXT *)UlongToPtr(params->pShaders));
}

#ifdef _WIN64
static void thunk64_vkCmdBindShadingRateImageNV(void *args)
{
    struct vkCmdBindShadingRateImageNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindShadingRateImageNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->imageView, params->imageLayout);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindShadingRateImageNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImageView DECLSPEC_ALIGN(8) imageView;
        VkImageLayout imageLayout;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindShadingRateImageNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->imageView, params->imageLayout);
}

#ifdef _WIN64
static void thunk64_vkCmdBindTileMemoryQCOM(void *args)
{
    struct vkCmdBindTileMemoryQCOM_params *params = args;
    VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo_host = NULL;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    if (params->pTileMemoryBindInfo)
    {
        pTileMemoryBindInfo_host = conversion_context_alloc(ctx, sizeof(*pTileMemoryBindInfo_host));
        convert_VkTileMemoryBindInfoQCOM_win64_to_host(params->pTileMemoryBindInfo, pTileMemoryBindInfo_host);
    }
    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindTileMemoryQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, pTileMemoryBindInfo_host);
    free_conversion_context(ctx);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindTileMemoryQCOM(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pTileMemoryBindInfo;
    } *params = args;
    VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo_host = NULL;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    if (params->pTileMemoryBindInfo)
    {
        pTileMemoryBindInfo_host = conversion_context_alloc(ctx, sizeof(*pTileMemoryBindInfo_host));
        convert_VkTileMemoryBindInfoQCOM_win32_to_host((const VkTileMemoryBindInfoQCOM32 *)UlongToPtr(params->pTileMemoryBindInfo), pTileMemoryBindInfo_host);
    }
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindTileMemoryQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, pTileMemoryBindInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBindTransformFeedbackBuffersEXT(void *args)
{
    struct vkCmdBindTransformFeedbackBuffersEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindTransformFeedbackBuffersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindTransformFeedbackBuffersEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstBinding;
        uint32_t bindingCount;
        PTR32 pBuffers;
        PTR32 pOffsets;
        PTR32 pSizes;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindTransformFeedbackBuffersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes));
}

#ifdef _WIN64
static void thunk64_vkCmdBindVertexBuffers(void *args)
{
    struct vkCmdBindVertexBuffers_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindVertexBuffers(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstBinding;
        uint32_t bindingCount;
        PTR32 pBuffers;
        PTR32 pOffsets;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
}

#ifdef _WIN64
static void thunk64_vkCmdBindVertexBuffers2(void *args)
{
    struct vkCmdBindVertexBuffers2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindVertexBuffers2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstBinding;
        uint32_t bindingCount;
        PTR32 pBuffers;
        PTR32 pOffsets;
        PTR32 pSizes;
        PTR32 pStrides;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
}

#ifdef _WIN64
static void thunk64_vkCmdBindVertexBuffers2EXT(void *args)
{
    struct vkCmdBindVertexBuffers2EXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBindVertexBuffers2EXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstBinding;
        uint32_t bindingCount;
        PTR32 pBuffers;
        PTR32 pOffsets;
        PTR32 pSizes;
        PTR32 pStrides;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
}

#ifdef _WIN64
static void thunk64_vkCmdBlitImage(void *args)
{
    struct vkCmdBlitImage_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions, params->filter);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBlitImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) srcImage;
        VkImageLayout srcImageLayout;
        VkImage DECLSPEC_ALIGN(8) dstImage;
        VkImageLayout dstImageLayout;
        uint32_t regionCount;
        PTR32 pRegions;
        VkFilter filter;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageBlit *)UlongToPtr(params->pRegions), params->filter);
}

#ifdef _WIN64
static void thunk64_vkCmdBlitImage2(void *args)
{
    struct vkCmdBlitImage2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBlitImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBlitImage2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBlitImageInfo;
    } *params = args;
    VkBlitImageInfo2 pBlitImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkBlitImageInfo2_win32_to_host(ctx, (const VkBlitImageInfo232 *)UlongToPtr(params->pBlitImageInfo), &pBlitImageInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBlitImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBlitImage2KHR(void *args)
{
    struct vkCmdBlitImage2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBlitImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBlitImage2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBlitImageInfo;
    } *params = args;
    VkBlitImageInfo2 pBlitImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkBlitImageInfo2_win32_to_host(ctx, (const VkBlitImageInfo232 *)UlongToPtr(params->pBlitImageInfo), &pBlitImageInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBlitImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBuildAccelerationStructureNV(void *args)
{
    struct vkCmdBuildAccelerationStructureNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructureNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBuildAccelerationStructureNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
        VkBuffer DECLSPEC_ALIGN(8) instanceData;
        VkDeviceSize DECLSPEC_ALIGN(8) instanceOffset;
        VkBool32 update;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) dst;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) src;
        VkBuffer DECLSPEC_ALIGN(8) scratch;
        VkDeviceSize DECLSPEC_ALIGN(8) scratchOffset;
    } *params = args;
    VkAccelerationStructureInfoNV pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkAccelerationStructureInfoNV_win32_to_host(ctx, (const VkAccelerationStructureInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructureNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBuildAccelerationStructuresIndirectKHR(void *args)
{
    struct vkCmdBuildAccelerationStructuresIndirectKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructuresIndirectKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos, params->pIndirectDeviceAddresses, params->pIndirectStrides, params->ppMaxPrimitiveCounts);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBuildAccelerationStructuresIndirectKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t infoCount;
        PTR32 pInfos;
        PTR32 pIndirectDeviceAddresses;
        PTR32 pIndirectStrides;
        PTR32 ppMaxPrimitiveCounts;
    } *params = args;
    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos_host;
    const uint32_t* const *ppMaxPrimitiveCounts_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pInfos_host = convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pInfos), params->infoCount);
    ppMaxPrimitiveCounts_host = convert_uint32_t_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->ppMaxPrimitiveCounts), params->infoCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructuresIndirectKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host, (const VkDeviceAddress *)UlongToPtr(params->pIndirectDeviceAddresses), (const uint32_t *)UlongToPtr(params->pIndirectStrides), ppMaxPrimitiveCounts_host);
    convert_uint32_t_array_host_to_win32(ppMaxPrimitiveCounts_host, (PTR32 *)UlongToPtr(params->ppMaxPrimitiveCounts), params->infoCount);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBuildAccelerationStructuresKHR(void *args)
{
    struct vkCmdBuildAccelerationStructuresKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructuresKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos, params->ppBuildRangeInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBuildAccelerationStructuresKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t infoCount;
        PTR32 pInfos;
        PTR32 ppBuildRangeInfos;
    } *params = args;
    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos_host;
    const VkAccelerationStructureBuildRangeInfoKHR* const *ppBuildRangeInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pInfos_host = convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pInfos), params->infoCount);
    ppBuildRangeInfos_host = convert_VkAccelerationStructureBuildRangeInfoKHR_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->ppBuildRangeInfos), params->infoCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructuresKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host, ppBuildRangeInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBuildClusterAccelerationStructureIndirectNV(void *args)
{
    struct vkCmdBuildClusterAccelerationStructureIndirectNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildClusterAccelerationStructureIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCommandInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBuildClusterAccelerationStructureIndirectNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCommandInfos;
    } *params = args;
    VkClusterAccelerationStructureCommandsInfoNV pCommandInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkClusterAccelerationStructureCommandsInfoNV_win32_to_host(ctx, (const VkClusterAccelerationStructureCommandsInfoNV32 *)UlongToPtr(params->pCommandInfos), &pCommandInfos_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildClusterAccelerationStructureIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCommandInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBuildMicromapsEXT(void *args)
{
    struct vkCmdBuildMicromapsEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildMicromapsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBuildMicromapsEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t infoCount;
        PTR32 pInfos;
    } *params = args;
    const VkMicromapBuildInfoEXT *pInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pInfos_host = convert_VkMicromapBuildInfoEXT_array_win32_to_host(ctx, (const VkMicromapBuildInfoEXT32 *)UlongToPtr(params->pInfos), params->infoCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildMicromapsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdBuildPartitionedAccelerationStructuresNV(void *args)
{
    struct vkCmdBuildPartitionedAccelerationStructuresNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildPartitionedAccelerationStructuresNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBuildInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdBuildPartitionedAccelerationStructuresNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pBuildInfo;
    } *params = args;
    VkBuildPartitionedAccelerationStructureInfoNV pBuildInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkBuildPartitionedAccelerationStructureInfoNV_win32_to_host(ctx, (const VkBuildPartitionedAccelerationStructureInfoNV32 *)UlongToPtr(params->pBuildInfo), &pBuildInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildPartitionedAccelerationStructuresNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBuildInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdClearAttachments(void *args)
{
    struct vkCmdClearAttachments_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearAttachments(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->attachmentCount, params->pAttachments, params->rectCount, params->pRects);
}
#endif /* _WIN64 */

static void thunk32_vkCmdClearAttachments(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t attachmentCount;
        PTR32 pAttachments;
        uint32_t rectCount;
        PTR32 pRects;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearAttachments(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->attachmentCount, (const VkClearAttachment *)UlongToPtr(params->pAttachments), params->rectCount, (const VkClearRect *)UlongToPtr(params->pRects));
}

#ifdef _WIN64
static void thunk64_vkCmdClearColorImage(void *args)
{
    struct vkCmdClearColorImage_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearColorImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->image, params->imageLayout, params->pColor, params->rangeCount, params->pRanges);
}
#endif /* _WIN64 */

static void thunk32_vkCmdClearColorImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) image;
        VkImageLayout imageLayout;
        PTR32 pColor;
        uint32_t rangeCount;
        PTR32 pRanges;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearColorImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->image, params->imageLayout, (const VkClearColorValue *)UlongToPtr(params->pColor), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
}

#ifdef _WIN64
static void thunk64_vkCmdClearDepthStencilImage(void *args)
{
    struct vkCmdClearDepthStencilImage_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearDepthStencilImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->image, params->imageLayout, params->pDepthStencil, params->rangeCount, params->pRanges);
}
#endif /* _WIN64 */

static void thunk32_vkCmdClearDepthStencilImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) image;
        VkImageLayout imageLayout;
        PTR32 pDepthStencil;
        uint32_t rangeCount;
        PTR32 pRanges;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearDepthStencilImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->image, params->imageLayout, (const VkClearDepthStencilValue *)UlongToPtr(params->pDepthStencil), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
}

#ifdef _WIN64
static void thunk64_vkCmdControlVideoCodingKHR(void *args)
{
    struct vkCmdControlVideoCodingKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdControlVideoCodingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCodingControlInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdControlVideoCodingKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCodingControlInfo;
    } *params = args;
    VkVideoCodingControlInfoKHR pCodingControlInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkVideoCodingControlInfoKHR_win32_to_host(ctx, (const VkVideoCodingControlInfoKHR32 *)UlongToPtr(params->pCodingControlInfo), &pCodingControlInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdControlVideoCodingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCodingControlInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdConvertCooperativeVectorMatrixNV(void *args)
{
    struct vkCmdConvertCooperativeVectorMatrixNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdConvertCooperativeVectorMatrixNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdConvertCooperativeVectorMatrixNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t infoCount;
        PTR32 pInfos;
    } *params = args;
    const VkConvertCooperativeVectorMatrixInfoNV *pInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pInfos_host = convert_VkConvertCooperativeVectorMatrixInfoNV_array_win32_to_host(ctx, (const VkConvertCooperativeVectorMatrixInfoNV32 *)UlongToPtr(params->pInfos), params->infoCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdConvertCooperativeVectorMatrixNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyAccelerationStructureKHR(void *args)
{
    struct vkCmdCopyAccelerationStructureKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyAccelerationStructureInfoKHR pInfo_host;

    convert_VkCopyAccelerationStructureInfoKHR_win32_to_host((const VkCopyAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyAccelerationStructureNV(void *args)
{
    struct vkCmdCopyAccelerationStructureNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dst, params->src, params->mode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyAccelerationStructureNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) dst;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) src;
        VkCopyAccelerationStructureModeKHR mode;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dst, params->src, params->mode);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyAccelerationStructureToMemoryKHR(void *args)
{
    struct vkCmdCopyAccelerationStructureToMemoryKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureToMemoryKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyAccelerationStructureToMemoryKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyAccelerationStructureToMemoryInfoKHR pInfo_host;

    convert_VkCopyAccelerationStructureToMemoryInfoKHR_win32_to_host((const VkCopyAccelerationStructureToMemoryInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureToMemoryKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBuffer(void *args)
{
    struct vkCmdCopyBuffer_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, params->pRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) srcBuffer;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        uint32_t regionCount;
        PTR32 pRegions;
    } *params = args;
    const VkBufferCopy *pRegions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pRegions_host = convert_VkBufferCopy_array_win32_to_host(ctx, (const VkBufferCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, pRegions_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBuffer2(void *args)
{
    struct vkCmdCopyBuffer2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBuffer2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyBufferInfo;
    } *params = args;
    VkCopyBufferInfo2 pCopyBufferInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyBufferInfo2_win32_to_host(ctx, (const VkCopyBufferInfo232 *)UlongToPtr(params->pCopyBufferInfo), &pCopyBufferInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBuffer2KHR(void *args)
{
    struct vkCmdCopyBuffer2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBuffer2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyBufferInfo;
    } *params = args;
    VkCopyBufferInfo2 pCopyBufferInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyBufferInfo2_win32_to_host(ctx, (const VkCopyBufferInfo232 *)UlongToPtr(params->pCopyBufferInfo), &pCopyBufferInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBufferToImage(void *args)
{
    struct vkCmdCopyBufferToImage_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBufferToImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) srcBuffer;
        VkImage DECLSPEC_ALIGN(8) dstImage;
        VkImageLayout dstImageLayout;
        uint32_t regionCount;
        PTR32 pRegions;
    } *params = args;
    const VkBufferImageCopy *pRegions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pRegions_host = convert_VkBufferImageCopy_array_win32_to_host(ctx, (const VkBufferImageCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, pRegions_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBufferToImage2(void *args)
{
    struct vkCmdCopyBufferToImage2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferToImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBufferToImage2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyBufferToImageInfo;
    } *params = args;
    VkCopyBufferToImageInfo2 pCopyBufferToImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyBufferToImageInfo2_win32_to_host(ctx, (const VkCopyBufferToImageInfo232 *)UlongToPtr(params->pCopyBufferToImageInfo), &pCopyBufferToImageInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferToImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyBufferToImage2KHR(void *args)
{
    struct vkCmdCopyBufferToImage2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferToImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyBufferToImage2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyBufferToImageInfo;
    } *params = args;
    VkCopyBufferToImageInfo2 pCopyBufferToImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyBufferToImageInfo2_win32_to_host(ctx, (const VkCopyBufferToImageInfo232 *)UlongToPtr(params->pCopyBufferToImageInfo), &pCopyBufferToImageInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferToImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImage(void *args)
{
    struct vkCmdCopyImage_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) srcImage;
        VkImageLayout srcImageLayout;
        VkImage DECLSPEC_ALIGN(8) dstImage;
        VkImageLayout dstImageLayout;
        uint32_t regionCount;
        PTR32 pRegions;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageCopy *)UlongToPtr(params->pRegions));
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImage2(void *args)
{
    struct vkCmdCopyImage2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImage2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyImageInfo;
    } *params = args;
    VkCopyImageInfo2 pCopyImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyImageInfo2_win32_to_host(ctx, (const VkCopyImageInfo232 *)UlongToPtr(params->pCopyImageInfo), &pCopyImageInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImage2KHR(void *args)
{
    struct vkCmdCopyImage2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImage2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyImageInfo;
    } *params = args;
    VkCopyImageInfo2 pCopyImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyImageInfo2_win32_to_host(ctx, (const VkCopyImageInfo232 *)UlongToPtr(params->pCopyImageInfo), &pCopyImageInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImageToBuffer(void *args)
{
    struct vkCmdCopyImageToBuffer_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, params->pRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImageToBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) srcImage;
        VkImageLayout srcImageLayout;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        uint32_t regionCount;
        PTR32 pRegions;
    } *params = args;
    const VkBufferImageCopy *pRegions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pRegions_host = convert_VkBufferImageCopy_array_win32_to_host(ctx, (const VkBufferImageCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, pRegions_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImageToBuffer2(void *args)
{
    struct vkCmdCopyImageToBuffer2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageToBufferInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImageToBuffer2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyImageToBufferInfo;
    } *params = args;
    VkCopyImageToBufferInfo2 pCopyImageToBufferInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyImageToBufferInfo2_win32_to_host(ctx, (const VkCopyImageToBufferInfo232 *)UlongToPtr(params->pCopyImageToBufferInfo), &pCopyImageToBufferInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageToBufferInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyImageToBuffer2KHR(void *args)
{
    struct vkCmdCopyImageToBuffer2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageToBufferInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyImageToBuffer2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyImageToBufferInfo;
    } *params = args;
    VkCopyImageToBufferInfo2 pCopyImageToBufferInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyImageToBufferInfo2_win32_to_host(ctx, (const VkCopyImageToBufferInfo232 *)UlongToPtr(params->pCopyImageToBufferInfo), &pCopyImageToBufferInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageToBufferInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMemoryIndirectNV(void *args)
{
    struct vkCmdCopyMemoryIndirectNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMemoryIndirectNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDeviceAddress DECLSPEC_ALIGN(8) copyBufferAddress;
        uint32_t copyCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMemoryToAccelerationStructureKHR(void *args)
{
    struct vkCmdCopyMemoryToAccelerationStructureKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToAccelerationStructureKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMemoryToAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyMemoryToAccelerationStructureInfoKHR pInfo_host;

    convert_VkCopyMemoryToAccelerationStructureInfoKHR_win32_to_host((const VkCopyMemoryToAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToAccelerationStructureKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMemoryToImageIndirectNV(void *args)
{
    struct vkCmdCopyMemoryToImageIndirectNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToImageIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, params->pImageSubresources);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMemoryToImageIndirectNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDeviceAddress DECLSPEC_ALIGN(8) copyBufferAddress;
        uint32_t copyCount;
        uint32_t stride;
        VkImage DECLSPEC_ALIGN(8) dstImage;
        VkImageLayout dstImageLayout;
        PTR32 pImageSubresources;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToImageIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, (const VkImageSubresourceLayers *)UlongToPtr(params->pImageSubresources));
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMemoryToMicromapEXT(void *args)
{
    struct vkCmdCopyMemoryToMicromapEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToMicromapEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMemoryToMicromapEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyMemoryToMicromapInfoEXT pInfo_host;

    convert_VkCopyMemoryToMicromapInfoEXT_win32_to_host((const VkCopyMemoryToMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToMicromapEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMicromapEXT(void *args)
{
    struct vkCmdCopyMicromapEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMicromapEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMicromapEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyMicromapInfoEXT pInfo_host;

    convert_VkCopyMicromapInfoEXT_win32_to_host((const VkCopyMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMicromapEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyMicromapToMemoryEXT(void *args)
{
    struct vkCmdCopyMicromapToMemoryEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMicromapToMemoryEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyMicromapToMemoryEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInfo;
    } *params = args;
    VkCopyMicromapToMemoryInfoEXT pInfo_host;

    convert_VkCopyMicromapToMemoryInfoEXT_win32_to_host((const VkCopyMicromapToMemoryInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMicromapToMemoryEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyQueryPoolResults(void *args)
{
    struct vkCmdCopyQueryPoolResults_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyQueryPoolResults(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyQueryPoolResults(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
        uint32_t queryCount;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) stride;
        VkQueryResultFlags flags;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyQueryPoolResults(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
}

#ifdef _WIN64
static void thunk64_vkCmdCopyTensorARM(void *args)
{
    struct vkCmdCopyTensorARM_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyTensorARM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyTensorInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCopyTensorARM(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCopyTensorInfo;
    } *params = args;
    VkCopyTensorInfoARM pCopyTensorInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkCopyTensorInfoARM_win32_to_host(ctx, (const VkCopyTensorInfoARM32 *)UlongToPtr(params->pCopyTensorInfo), &pCopyTensorInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyTensorARM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyTensorInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdCuLaunchKernelNVX(void *args)
{
    struct vkCmdCuLaunchKernelNVX_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCuLaunchKernelNVX(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLaunchInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdCuLaunchKernelNVX(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pLaunchInfo;
    } *params = args;
    VkCuLaunchInfoNVX pLaunchInfo_host;

    convert_VkCuLaunchInfoNVX_win32_to_host((const VkCuLaunchInfoNVX32 *)UlongToPtr(params->pLaunchInfo), &pLaunchInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCuLaunchKernelNVX(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLaunchInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdDebugMarkerBeginEXT(void *args)
{
    struct vkCmdDebugMarkerBeginEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerBeginEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDebugMarkerBeginEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pMarkerInfo;
    } *params = args;
    VkDebugMarkerMarkerInfoEXT pMarkerInfo_host;

    convert_VkDebugMarkerMarkerInfoEXT_win32_to_host((const VkDebugMarkerMarkerInfoEXT32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerBeginEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdDebugMarkerEndEXT(void *args)
{
    struct vkCmdDebugMarkerEndEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerEndEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDebugMarkerEndEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerEndEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdDebugMarkerInsertEXT(void *args)
{
    struct vkCmdDebugMarkerInsertEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerInsertEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDebugMarkerInsertEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pMarkerInfo;
    } *params = args;
    VkDebugMarkerMarkerInfoEXT pMarkerInfo_host;

    convert_VkDebugMarkerMarkerInfoEXT_win32_to_host((const VkDebugMarkerMarkerInfoEXT32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerInsertEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdDecodeVideoKHR(void *args)
{
    struct vkCmdDecodeVideoKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecodeVideoKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDecodeInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDecodeVideoKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pDecodeInfo;
    } *params = args;
    VkVideoDecodeInfoKHR pDecodeInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkVideoDecodeInfoKHR_win32_to_host(ctx, (const VkVideoDecodeInfoKHR32 *)UlongToPtr(params->pDecodeInfo), &pDecodeInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecodeVideoKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDecodeInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdDecompressMemoryIndirectCountNV(void *args)
{
    struct vkCmdDecompressMemoryIndirectCountNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecompressMemoryIndirectCountNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDecompressMemoryIndirectCountNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDeviceAddress DECLSPEC_ALIGN(8) indirectCommandsAddress;
        VkDeviceAddress DECLSPEC_ALIGN(8) indirectCommandsCountAddress;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecompressMemoryIndirectCountNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDecompressMemoryNV(void *args)
{
    struct vkCmdDecompressMemoryNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecompressMemoryNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->decompressRegionCount, params->pDecompressMemoryRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDecompressMemoryNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t decompressRegionCount;
        PTR32 pDecompressMemoryRegions;
    } *params = args;
    const VkDecompressMemoryRegionNV *pDecompressMemoryRegions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDecompressMemoryRegions_host = convert_VkDecompressMemoryRegionNV_array_win32_to_host(ctx, (const VkDecompressMemoryRegionNV32 *)UlongToPtr(params->pDecompressMemoryRegions), params->decompressRegionCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecompressMemoryNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->decompressRegionCount, pDecompressMemoryRegions_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdDispatch(void *args)
{
    struct vkCmdDispatch_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatch(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDispatch(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t groupCountX;
        uint32_t groupCountY;
        uint32_t groupCountZ;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatch(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}

#ifdef _WIN64
static void thunk64_vkCmdDispatchBase(void *args)
{
    struct vkCmdDispatchBase_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchBase(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDispatchBase(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t baseGroupX;
        uint32_t baseGroupY;
        uint32_t baseGroupZ;
        uint32_t groupCountX;
        uint32_t groupCountY;
        uint32_t groupCountZ;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchBase(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
}

#ifdef _WIN64
static void thunk64_vkCmdDispatchBaseKHR(void *args)
{
    struct vkCmdDispatchBaseKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchBaseKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDispatchBaseKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t baseGroupX;
        uint32_t baseGroupY;
        uint32_t baseGroupZ;
        uint32_t groupCountX;
        uint32_t groupCountY;
        uint32_t groupCountZ;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchBaseKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
}

#ifdef _WIN64
static void thunk64_vkCmdDispatchDataGraphARM(void *args)
{
    struct vkCmdDispatchDataGraphARM_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchDataGraphARM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->session, params->pInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDispatchDataGraphARM(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDataGraphPipelineSessionARM DECLSPEC_ALIGN(8) session;
        PTR32 pInfo;
    } *params = args;
    VkDataGraphPipelineDispatchInfoARM *pInfo_host = NULL;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    if (params->pInfo)
    {
        pInfo_host = conversion_context_alloc(ctx, sizeof(*pInfo_host));
        convert_VkDataGraphPipelineDispatchInfoARM_win32_to_host((const VkDataGraphPipelineDispatchInfoARM32 *)UlongToPtr(params->pInfo), pInfo_host);
    }
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchDataGraphARM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->session, pInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdDispatchIndirect(void *args)
{
    struct vkCmdDispatchIndirect_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchIndirect(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDispatchIndirect(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchIndirect(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset);
}

#ifdef _WIN64
static void thunk64_vkCmdDispatchTileQCOM(void *args)
{
    struct vkCmdDispatchTileQCOM_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchTileQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDispatchTileInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDispatchTileQCOM(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pDispatchTileInfo;
    } *params = args;
    VkDispatchTileInfoQCOM pDispatchTileInfo_host;

    convert_VkDispatchTileInfoQCOM_win32_to_host((const VkDispatchTileInfoQCOM32 *)UlongToPtr(params->pDispatchTileInfo), &pDispatchTileInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchTileQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDispatchTileInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdDraw(void *args)
{
    struct vkCmdDraw_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDraw(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDraw(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t vertexCount;
        uint32_t instanceCount;
        uint32_t firstVertex;
        uint32_t firstInstance;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDraw(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawClusterHUAWEI(void *args)
{
    struct vkCmdDrawClusterHUAWEI_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawClusterHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawClusterHUAWEI(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t groupCountX;
        uint32_t groupCountY;
        uint32_t groupCountZ;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawClusterHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawClusterIndirectHUAWEI(void *args)
{
    struct vkCmdDrawClusterIndirectHUAWEI_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawClusterIndirectHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawClusterIndirectHUAWEI(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawClusterIndirectHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndexed(void *args)
{
    struct vkCmdDrawIndexed_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexed(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndexed(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t indexCount;
        uint32_t instanceCount;
        uint32_t firstIndex;
        int32_t vertexOffset;
        uint32_t firstInstance;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexed(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndexedIndirect(void *args)
{
    struct vkCmdDrawIndexedIndirect_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirect(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndexedIndirect(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        uint32_t drawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirect(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndexedIndirectCount(void *args)
{
    struct vkCmdDrawIndexedIndirectCount_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndexedIndirectCount(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndexedIndirectCountAMD(void *args)
{
    struct vkCmdDrawIndexedIndirectCountAMD_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCountAMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndexedIndirectCountAMD(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCountAMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndexedIndirectCountKHR(void *args)
{
    struct vkCmdDrawIndexedIndirectCountKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCountKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndexedIndirectCountKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCountKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndirect(void *args)
{
    struct vkCmdDrawIndirect_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirect(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndirect(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        uint32_t drawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirect(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndirectByteCountEXT(void *args)
{
    struct vkCmdDrawIndirectByteCountEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectByteCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndirectByteCountEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t instanceCount;
        uint32_t firstInstance;
        VkBuffer DECLSPEC_ALIGN(8) counterBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) counterBufferOffset;
        uint32_t counterOffset;
        uint32_t vertexStride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectByteCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndirectCount(void *args)
{
    struct vkCmdDrawIndirectCount_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndirectCount(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndirectCountAMD(void *args)
{
    struct vkCmdDrawIndirectCountAMD_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCountAMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndirectCountAMD(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCountAMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawIndirectCountKHR(void *args)
{
    struct vkCmdDrawIndirectCountKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCountKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawIndirectCountKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCountKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksEXT(void *args)
{
    struct vkCmdDrawMeshTasksEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t groupCountX;
        uint32_t groupCountY;
        uint32_t groupCountZ;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksIndirectCountEXT(void *args)
{
    struct vkCmdDrawMeshTasksIndirectCountEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksIndirectCountEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksIndirectCountNV(void *args)
{
    struct vkCmdDrawMeshTasksIndirectCountNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectCountNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksIndirectCountNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkBuffer DECLSPEC_ALIGN(8) countBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) countBufferOffset;
        uint32_t maxDrawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectCountNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksIndirectEXT(void *args)
{
    struct vkCmdDrawMeshTasksIndirectEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksIndirectEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        uint32_t drawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksIndirectNV(void *args)
{
    struct vkCmdDrawMeshTasksIndirectNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksIndirectNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        uint32_t drawCount;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMeshTasksNV(void *args)
{
    struct vkCmdDrawMeshTasksNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->taskCount, params->firstTask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMeshTasksNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t taskCount;
        uint32_t firstTask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->taskCount, params->firstTask);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMultiEXT(void *args)
{
    struct vkCmdDrawMultiEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMultiEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->drawCount, params->pVertexInfo, params->instanceCount, params->firstInstance, params->stride);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMultiEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t drawCount;
        PTR32 pVertexInfo;
        uint32_t instanceCount;
        uint32_t firstInstance;
        uint32_t stride;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMultiEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->drawCount, (const VkMultiDrawInfoEXT *)UlongToPtr(params->pVertexInfo), params->instanceCount, params->firstInstance, params->stride);
}

#ifdef _WIN64
static void thunk64_vkCmdDrawMultiIndexedEXT(void *args)
{
    struct vkCmdDrawMultiIndexedEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMultiIndexedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->drawCount, params->pIndexInfo, params->instanceCount, params->firstInstance, params->stride, params->pVertexOffset);
}
#endif /* _WIN64 */

static void thunk32_vkCmdDrawMultiIndexedEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t drawCount;
        PTR32 pIndexInfo;
        uint32_t instanceCount;
        uint32_t firstInstance;
        uint32_t stride;
        PTR32 pVertexOffset;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMultiIndexedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->drawCount, (const VkMultiDrawIndexedInfoEXT *)UlongToPtr(params->pIndexInfo), params->instanceCount, params->firstInstance, params->stride, (const int32_t *)UlongToPtr(params->pVertexOffset));
}

#ifdef _WIN64
static void thunk64_vkCmdEncodeVideoKHR(void *args)
{
    struct vkCmdEncodeVideoKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEncodeVideoKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pEncodeInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEncodeVideoKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pEncodeInfo;
    } *params = args;
    VkVideoEncodeInfoKHR pEncodeInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkVideoEncodeInfoKHR_win32_to_host(ctx, (const VkVideoEncodeInfoKHR32 *)UlongToPtr(params->pEncodeInfo), &pEncodeInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEncodeVideoKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pEncodeInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdEndConditionalRenderingEXT(void *args)
{
    struct vkCmdEndConditionalRenderingEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndConditionalRenderingEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndConditionalRenderingEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndConditionalRenderingEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdEndDebugUtilsLabelEXT(void *args)
{
    struct vkCmdEndDebugUtilsLabelEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndDebugUtilsLabelEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndDebugUtilsLabelEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdEndPerTileExecutionQCOM(void *args)
{
    struct vkCmdEndPerTileExecutionQCOM_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndPerTileExecutionQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPerTileEndInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndPerTileExecutionQCOM(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pPerTileEndInfo;
    } *params = args;
    VkPerTileEndInfoQCOM pPerTileEndInfo_host;

    convert_VkPerTileEndInfoQCOM_win32_to_host((const VkPerTileEndInfoQCOM32 *)UlongToPtr(params->pPerTileEndInfo), &pPerTileEndInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndPerTileExecutionQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPerTileEndInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdEndQuery(void *args)
{
    struct vkCmdEndQuery_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndQuery(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndQuery(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndQuery(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query);
}

#ifdef _WIN64
static void thunk64_vkCmdEndQueryIndexedEXT(void *args)
{
    struct vkCmdEndQueryIndexedEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndQueryIndexedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->index);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndQueryIndexedEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
        uint32_t index;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndQueryIndexedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->index);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRenderPass(void *args)
{
    struct vkCmdEndRenderPass_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRenderPass(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRenderPass2(void *args)
{
    struct vkCmdEndRenderPass2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassEndInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRenderPass2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSubpassEndInfo;
    } *params = args;
    VkSubpassEndInfo pSubpassEndInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassEndInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRenderPass2KHR(void *args)
{
    struct vkCmdEndRenderPass2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassEndInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRenderPass2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSubpassEndInfo;
    } *params = args;
    VkSubpassEndInfo pSubpassEndInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassEndInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRendering(void *args)
{
    struct vkCmdEndRendering_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRendering(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRendering(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRendering(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRendering2EXT(void *args)
{
    struct vkCmdEndRendering2EXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRendering2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingEndInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRendering2EXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRenderingEndInfo;
    } *params = args;
    VkRenderingEndInfoEXT *pRenderingEndInfo_host = NULL;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    if (params->pRenderingEndInfo)
    {
        pRenderingEndInfo_host = conversion_context_alloc(ctx, sizeof(*pRenderingEndInfo_host));
        convert_VkRenderingEndInfoEXT_win32_to_host(ctx, (const VkRenderingEndInfoEXT32 *)UlongToPtr(params->pRenderingEndInfo), pRenderingEndInfo_host);
    }
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRendering2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, pRenderingEndInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdEndRenderingKHR(void *args)
{
    struct vkCmdEndRenderingKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndRenderingKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdEndTransformFeedbackEXT(void *args)
{
    struct vkCmdEndTransformFeedbackEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndTransformFeedbackEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndTransformFeedbackEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstCounterBuffer;
        uint32_t counterBufferCount;
        PTR32 pCounterBuffers;
        PTR32 pCounterBufferOffsets;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndTransformFeedbackEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
}

#ifdef _WIN64
static void thunk64_vkCmdEndVideoCodingKHR(void *args)
{
    struct vkCmdEndVideoCodingKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndVideoCodingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pEndCodingInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdEndVideoCodingKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pEndCodingInfo;
    } *params = args;
    VkVideoEndCodingInfoKHR pEndCodingInfo_host;

    convert_VkVideoEndCodingInfoKHR_win32_to_host((const VkVideoEndCodingInfoKHR32 *)UlongToPtr(params->pEndCodingInfo), &pEndCodingInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndVideoCodingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pEndCodingInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdExecuteCommands(void *args)
{
    struct vkCmdExecuteCommands_params *params = args;
    const VkCommandBuffer *pCommandBuffers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pCommandBuffers_host = convert_VkCommandBuffer_array_win64_to_host(ctx, params->pCommandBuffers, params->commandBufferCount);
    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteCommands(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->commandBufferCount, pCommandBuffers_host);
    free_conversion_context(ctx);
}
#endif /* _WIN64 */

static void thunk32_vkCmdExecuteCommands(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t commandBufferCount;
        PTR32 pCommandBuffers;
    } *params = args;
    const VkCommandBuffer *pCommandBuffers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pCommandBuffers_host = convert_VkCommandBuffer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->pCommandBuffers), params->commandBufferCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteCommands(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->commandBufferCount, pCommandBuffers_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdExecuteGeneratedCommandsEXT(void *args)
{
    struct vkCmdExecuteGeneratedCommandsEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteGeneratedCommandsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdExecuteGeneratedCommandsEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 isPreprocessed;
        PTR32 pGeneratedCommandsInfo;
    } *params = args;
    VkGeneratedCommandsInfoEXT pGeneratedCommandsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkGeneratedCommandsInfoEXT_win32_to_host(ctx, (const VkGeneratedCommandsInfoEXT32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteGeneratedCommandsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdExecuteGeneratedCommandsNV(void *args)
{
    struct vkCmdExecuteGeneratedCommandsNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteGeneratedCommandsNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdExecuteGeneratedCommandsNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 isPreprocessed;
        PTR32 pGeneratedCommandsInfo;
    } *params = args;
    VkGeneratedCommandsInfoNV pGeneratedCommandsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkGeneratedCommandsInfoNV_win32_to_host(ctx, (const VkGeneratedCommandsInfoNV32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteGeneratedCommandsNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdFillBuffer(void *args)
{
    struct vkCmdFillBuffer_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdFillBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
}
#endif /* _WIN64 */

static void thunk32_vkCmdFillBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) size;
        uint32_t data;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdFillBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
}

#ifdef _WIN64
static void thunk64_vkCmdInsertDebugUtilsLabelEXT(void *args)
{
    struct vkCmdInsertDebugUtilsLabelEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdInsertDebugUtilsLabelEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLabelInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdInsertDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pLabelInfo;
    } *params = args;
    VkDebugUtilsLabelEXT pLabelInfo_host;

    convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdInsertDebugUtilsLabelEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLabelInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdNextSubpass(void *args)
{
    struct vkCmdNextSubpass_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->contents);
}
#endif /* _WIN64 */

static void thunk32_vkCmdNextSubpass(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkSubpassContents contents;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->contents);
}

#ifdef _WIN64
static void thunk64_vkCmdNextSubpass2(void *args)
{
    struct vkCmdNextSubpass2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdNextSubpass2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSubpassBeginInfo;
        PTR32 pSubpassEndInfo;
    } *params = args;
    VkSubpassBeginInfo pSubpassBeginInfo_host;
    VkSubpassEndInfo pSubpassEndInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
    convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdNextSubpass2KHR(void *args)
{
    struct vkCmdNextSubpass2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdNextSubpass2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSubpassBeginInfo;
        PTR32 pSubpassEndInfo;
    } *params = args;
    VkSubpassBeginInfo pSubpassBeginInfo_host;
    VkSubpassEndInfo pSubpassEndInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
    convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdOpticalFlowExecuteNV(void *args)
{
    struct vkCmdOpticalFlowExecuteNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdOpticalFlowExecuteNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->session, params->pExecuteInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdOpticalFlowExecuteNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkOpticalFlowSessionNV DECLSPEC_ALIGN(8) session;
        PTR32 pExecuteInfo;
    } *params = args;
    VkOpticalFlowExecuteInfoNV pExecuteInfo_host;

    convert_VkOpticalFlowExecuteInfoNV_win32_to_host((const VkOpticalFlowExecuteInfoNV32 *)UlongToPtr(params->pExecuteInfo), &pExecuteInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdOpticalFlowExecuteNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->session, &pExecuteInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdPipelineBarrier(void *args)
{
    struct vkCmdPipelineBarrier_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPipelineBarrier(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlags srcStageMask;
        VkPipelineStageFlags dstStageMask;
        VkDependencyFlags dependencyFlags;
        uint32_t memoryBarrierCount;
        PTR32 pMemoryBarriers;
        uint32_t bufferMemoryBarrierCount;
        PTR32 pBufferMemoryBarriers;
        uint32_t imageMemoryBarrierCount;
        PTR32 pImageMemoryBarriers;
    } *params = args;
    const VkMemoryBarrier *pMemoryBarriers_host;
    const VkBufferMemoryBarrier *pBufferMemoryBarriers_host;
    const VkImageMemoryBarrier *pImageMemoryBarriers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pMemoryBarriers_host = convert_VkMemoryBarrier_array_win32_to_host(ctx, (const VkMemoryBarrier32 *)UlongToPtr(params->pMemoryBarriers), params->memoryBarrierCount);
    pBufferMemoryBarriers_host = convert_VkBufferMemoryBarrier_array_win32_to_host(ctx, (const VkBufferMemoryBarrier32 *)UlongToPtr(params->pBufferMemoryBarriers), params->bufferMemoryBarrierCount);
    pImageMemoryBarriers_host = convert_VkImageMemoryBarrier_array_win32_to_host(ctx, (const VkImageMemoryBarrier32 *)UlongToPtr(params->pImageMemoryBarriers), params->imageMemoryBarrierCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPipelineBarrier2(void *args)
{
    struct vkCmdPipelineBarrier2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDependencyInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPipelineBarrier2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pDependencyInfo;
    } *params = args;
    VkDependencyInfo pDependencyInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDependencyInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPipelineBarrier2KHR(void *args)
{
    struct vkCmdPipelineBarrier2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDependencyInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPipelineBarrier2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pDependencyInfo;
    } *params = args;
    VkDependencyInfo pDependencyInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDependencyInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPreprocessGeneratedCommandsEXT(void *args)
{
    struct vkCmdPreprocessGeneratedCommandsEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPreprocessGeneratedCommandsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pGeneratedCommandsInfo, vulkan_command_buffer_from_handle(params->stateCommandBuffer)->host.command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPreprocessGeneratedCommandsEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pGeneratedCommandsInfo;
        PTR32 stateCommandBuffer;
    } *params = args;
    VkGeneratedCommandsInfoEXT pGeneratedCommandsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkGeneratedCommandsInfoEXT_win32_to_host(ctx, (const VkGeneratedCommandsInfoEXT32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPreprocessGeneratedCommandsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pGeneratedCommandsInfo_host, vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->stateCommandBuffer))->host.command_buffer);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPreprocessGeneratedCommandsNV(void *args)
{
    struct vkCmdPreprocessGeneratedCommandsNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPreprocessGeneratedCommandsNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pGeneratedCommandsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPreprocessGeneratedCommandsNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pGeneratedCommandsInfo;
    } *params = args;
    VkGeneratedCommandsInfoNV pGeneratedCommandsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkGeneratedCommandsInfoNV_win32_to_host(ctx, (const VkGeneratedCommandsInfoNV32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPreprocessGeneratedCommandsNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pGeneratedCommandsInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushConstants(void *args)
{
    struct vkCmdPushConstants_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->layout, params->stageFlags, params->offset, params->size, params->pValues);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushConstants(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        VkShaderStageFlags stageFlags;
        uint32_t offset;
        uint32_t size;
        PTR32 pValues;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->layout, params->stageFlags, params->offset, params->size, (const void *)UlongToPtr(params->pValues));
}

#ifdef _WIN64
static void thunk64_vkCmdPushConstants2(void *args)
{
    struct vkCmdPushConstants2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushConstantsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushConstants2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pPushConstantsInfo;
    } *params = args;
    VkPushConstantsInfo pPushConstantsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkPushConstantsInfo_win32_to_host(ctx, (const VkPushConstantsInfo32 *)UlongToPtr(params->pPushConstantsInfo), &pPushConstantsInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushConstantsInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushConstants2KHR(void *args)
{
    struct vkCmdPushConstants2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushConstantsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushConstants2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pPushConstantsInfo;
    } *params = args;
    VkPushConstantsInfo pPushConstantsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkPushConstantsInfo_win32_to_host(ctx, (const VkPushConstantsInfo32 *)UlongToPtr(params->pPushConstantsInfo), &pPushConstantsInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushConstantsInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushDescriptorSet(void *args)
{
    struct vkCmdPushDescriptorSet_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushDescriptorSet(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t set;
        uint32_t descriptorWriteCount;
        PTR32 pDescriptorWrites;
    } *params = args;
    const VkWriteDescriptorSet *pDescriptorWrites_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDescriptorWrites_host = convert_VkWriteDescriptorSet_array_win32_to_host(ctx, (const VkWriteDescriptorSet32 *)UlongToPtr(params->pDescriptorWrites), params->descriptorWriteCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushDescriptorSet2(void *args)
{
    struct vkCmdPushDescriptorSet2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushDescriptorSet2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pPushDescriptorSetInfo;
    } *params = args;
    VkPushDescriptorSetInfo pPushDescriptorSetInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkPushDescriptorSetInfo_win32_to_host(ctx, (const VkPushDescriptorSetInfo32 *)UlongToPtr(params->pPushDescriptorSetInfo), &pPushDescriptorSetInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushDescriptorSet2KHR(void *args)
{
    struct vkCmdPushDescriptorSet2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushDescriptorSet2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pPushDescriptorSetInfo;
    } *params = args;
    VkPushDescriptorSetInfo pPushDescriptorSetInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkPushDescriptorSetInfo_win32_to_host(ctx, (const VkPushDescriptorSetInfo32 *)UlongToPtr(params->pPushDescriptorSetInfo), &pPushDescriptorSetInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushDescriptorSetKHR(void *args)
{
    struct vkCmdPushDescriptorSetKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushDescriptorSetKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t set;
        uint32_t descriptorWriteCount;
        PTR32 pDescriptorWrites;
    } *params = args;
    const VkWriteDescriptorSet *pDescriptorWrites_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDescriptorWrites_host = convert_VkWriteDescriptorSet_array_win32_to_host(ctx, (const VkWriteDescriptorSet32 *)UlongToPtr(params->pDescriptorWrites), params->descriptorWriteCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushDescriptorSetWithTemplate(void *args)
{
    struct vkCmdPushDescriptorSetWithTemplate_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushDescriptorSetWithTemplate(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t set;
        PTR32 pData;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
}

#ifdef _WIN64
static void thunk64_vkCmdPushDescriptorSetWithTemplate2(void *args)
{
    struct vkCmdPushDescriptorSetWithTemplate2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetWithTemplateInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushDescriptorSetWithTemplate2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pPushDescriptorSetWithTemplateInfo;
    } *params = args;
    VkPushDescriptorSetWithTemplateInfo pPushDescriptorSetWithTemplateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkPushDescriptorSetWithTemplateInfo_win32_to_host(ctx, (const VkPushDescriptorSetWithTemplateInfo32 *)UlongToPtr(params->pPushDescriptorSetWithTemplateInfo), &pPushDescriptorSetWithTemplateInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetWithTemplateInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushDescriptorSetWithTemplate2KHR(void *args)
{
    struct vkCmdPushDescriptorSetWithTemplate2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetWithTemplateInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushDescriptorSetWithTemplate2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pPushDescriptorSetWithTemplateInfo;
    } *params = args;
    VkPushDescriptorSetWithTemplateInfo pPushDescriptorSetWithTemplateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkPushDescriptorSetWithTemplateInfo_win32_to_host(ctx, (const VkPushDescriptorSetWithTemplateInfo32 *)UlongToPtr(params->pPushDescriptorSetWithTemplateInfo), &pPushDescriptorSetWithTemplateInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetWithTemplateInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdPushDescriptorSetWithTemplateKHR(void *args)
{
    struct vkCmdPushDescriptorSetWithTemplateKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplateKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
}
#endif /* _WIN64 */

static void thunk32_vkCmdPushDescriptorSetWithTemplateKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t set;
        PTR32 pData;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplateKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
}

#ifdef _WIN64
static void thunk64_vkCmdResetEvent(void *args)
{
    struct vkCmdResetEvent_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResetEvent(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkPipelineStageFlags stageMask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
}

#ifdef _WIN64
static void thunk64_vkCmdResetEvent2(void *args)
{
    struct vkCmdResetEvent2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResetEvent2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stageMask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
}

#ifdef _WIN64
static void thunk64_vkCmdResetEvent2KHR(void *args)
{
    struct vkCmdResetEvent2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResetEvent2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stageMask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
}

#ifdef _WIN64
static void thunk64_vkCmdResetQueryPool(void *args)
{
    struct vkCmdResetQueryPool_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetQueryPool(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResetQueryPool(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
        uint32_t queryCount;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetQueryPool(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount);
}

#ifdef _WIN64
static void thunk64_vkCmdResolveImage(void *args)
{
    struct vkCmdResolveImage_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResolveImage(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImage DECLSPEC_ALIGN(8) srcImage;
        VkImageLayout srcImageLayout;
        VkImage DECLSPEC_ALIGN(8) dstImage;
        VkImageLayout dstImageLayout;
        uint32_t regionCount;
        PTR32 pRegions;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageResolve *)UlongToPtr(params->pRegions));
}

#ifdef _WIN64
static void thunk64_vkCmdResolveImage2(void *args)
{
    struct vkCmdResolveImage2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pResolveImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResolveImage2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pResolveImageInfo;
    } *params = args;
    VkResolveImageInfo2 pResolveImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkResolveImageInfo2_win32_to_host(ctx, (const VkResolveImageInfo232 *)UlongToPtr(params->pResolveImageInfo), &pResolveImageInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pResolveImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdResolveImage2KHR(void *args)
{
    struct vkCmdResolveImage2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pResolveImageInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdResolveImage2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pResolveImageInfo;
    } *params = args;
    VkResolveImageInfo2 pResolveImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkResolveImageInfo2_win32_to_host(ctx, (const VkResolveImageInfo232 *)UlongToPtr(params->pResolveImageInfo), &pResolveImageInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pResolveImageInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetAlphaToCoverageEnableEXT(void *args)
{
    struct vkCmdSetAlphaToCoverageEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAlphaToCoverageEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->alphaToCoverageEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetAlphaToCoverageEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 alphaToCoverageEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAlphaToCoverageEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->alphaToCoverageEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetAlphaToOneEnableEXT(void *args)
{
    struct vkCmdSetAlphaToOneEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAlphaToOneEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->alphaToOneEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetAlphaToOneEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 alphaToOneEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAlphaToOneEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->alphaToOneEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetAttachmentFeedbackLoopEnableEXT(void *args)
{
    struct vkCmdSetAttachmentFeedbackLoopEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAttachmentFeedbackLoopEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->aspectMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetAttachmentFeedbackLoopEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkImageAspectFlags aspectMask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAttachmentFeedbackLoopEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->aspectMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetBlendConstants(void *args)
{
    struct vkCmdSetBlendConstants_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetBlendConstants(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->blendConstants);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetBlendConstants(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 blendConstants;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetBlendConstants(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const float *)UlongToPtr(params->blendConstants));
}

#ifdef _WIN64
static void thunk64_vkCmdSetCheckpointNV(void *args)
{
    struct vkCmdSetCheckpointNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCheckpointNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCheckpointMarker);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCheckpointNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pCheckpointMarker;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCheckpointNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const void *)UlongToPtr(params->pCheckpointMarker));
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoarseSampleOrderNV(void *args)
{
    struct vkCmdSetCoarseSampleOrderNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoarseSampleOrderNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->sampleOrderType, params->customSampleOrderCount, params->pCustomSampleOrders);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoarseSampleOrderNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCoarseSampleOrderTypeNV sampleOrderType;
        uint32_t customSampleOrderCount;
        PTR32 pCustomSampleOrders;
    } *params = args;
    const VkCoarseSampleOrderCustomNV *pCustomSampleOrders_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pCustomSampleOrders_host = convert_VkCoarseSampleOrderCustomNV_array_win32_to_host(ctx, (const VkCoarseSampleOrderCustomNV32 *)UlongToPtr(params->pCustomSampleOrders), params->customSampleOrderCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoarseSampleOrderNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->sampleOrderType, params->customSampleOrderCount, pCustomSampleOrders_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetColorBlendAdvancedEXT(void *args)
{
    struct vkCmdSetColorBlendAdvancedEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendAdvancedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendAdvanced);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetColorBlendAdvancedEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstAttachment;
        uint32_t attachmentCount;
        PTR32 pColorBlendAdvanced;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendAdvancedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendAdvancedEXT *)UlongToPtr(params->pColorBlendAdvanced));
}

#ifdef _WIN64
static void thunk64_vkCmdSetColorBlendEnableEXT(void *args)
{
    struct vkCmdSetColorBlendEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEnables);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetColorBlendEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstAttachment;
        uint32_t attachmentCount;
        PTR32 pColorBlendEnables;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorBlendEnables));
}

#ifdef _WIN64
static void thunk64_vkCmdSetColorBlendEquationEXT(void *args)
{
    struct vkCmdSetColorBlendEquationEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendEquationEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEquations);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetColorBlendEquationEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstAttachment;
        uint32_t attachmentCount;
        PTR32 pColorBlendEquations;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendEquationEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendEquationEXT *)UlongToPtr(params->pColorBlendEquations));
}

#ifdef _WIN64
static void thunk64_vkCmdSetColorWriteEnableEXT(void *args)
{
    struct vkCmdSetColorWriteEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorWriteEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->attachmentCount, params->pColorWriteEnables);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetColorWriteEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t attachmentCount;
        PTR32 pColorWriteEnables;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorWriteEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorWriteEnables));
}

#ifdef _WIN64
static void thunk64_vkCmdSetColorWriteMaskEXT(void *args)
{
    struct vkCmdSetColorWriteMaskEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorWriteMaskEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorWriteMasks);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetColorWriteMaskEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstAttachment;
        uint32_t attachmentCount;
        PTR32 pColorWriteMasks;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorWriteMaskEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorComponentFlags *)UlongToPtr(params->pColorWriteMasks));
}

#ifdef _WIN64
static void thunk64_vkCmdSetConservativeRasterizationModeEXT(void *args)
{
    struct vkCmdSetConservativeRasterizationModeEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetConservativeRasterizationModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->conservativeRasterizationMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetConservativeRasterizationModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkConservativeRasterizationModeEXT conservativeRasterizationMode;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetConservativeRasterizationModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->conservativeRasterizationMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageModulationModeNV(void *args)
{
    struct vkCmdSetCoverageModulationModeNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationModeNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageModulationModeNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCoverageModulationModeNV coverageModulationMode;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationModeNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageModulationTableEnableNV(void *args)
{
    struct vkCmdSetCoverageModulationTableEnableNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationTableEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationTableEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageModulationTableEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 coverageModulationTableEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationTableEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationTableEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageModulationTableNV(void *args)
{
    struct vkCmdSetCoverageModulationTableNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationTableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationTableCount, params->pCoverageModulationTable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageModulationTableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t coverageModulationTableCount;
        PTR32 pCoverageModulationTable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationTableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationTableCount, (const float *)UlongToPtr(params->pCoverageModulationTable));
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageReductionModeNV(void *args)
{
    struct vkCmdSetCoverageReductionModeNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageReductionModeNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageReductionMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageReductionModeNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCoverageReductionModeNV coverageReductionMode;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageReductionModeNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageReductionMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageToColorEnableNV(void *args)
{
    struct vkCmdSetCoverageToColorEnableNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageToColorEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageToColorEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageToColorEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 coverageToColorEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageToColorEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageToColorEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCoverageToColorLocationNV(void *args)
{
    struct vkCmdSetCoverageToColorLocationNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageToColorLocationNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageToColorLocation);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCoverageToColorLocationNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t coverageToColorLocation;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageToColorLocationNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageToColorLocation);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCullMode(void *args)
{
    struct vkCmdSetCullMode_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCullMode(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->cullMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCullMode(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCullModeFlags cullMode;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCullMode(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->cullMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetCullModeEXT(void *args)
{
    struct vkCmdSetCullModeEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCullModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->cullMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetCullModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCullModeFlags cullMode;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCullModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->cullMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBias(void *args)
{
    struct vkCmdSetDepthBias_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBias(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBias(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        float depthBiasConstantFactor;
        float depthBiasClamp;
        float depthBiasSlopeFactor;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBias(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBias2EXT(void *args)
{
    struct vkCmdSetDepthBias2EXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBias2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDepthBiasInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBias2EXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pDepthBiasInfo;
    } *params = args;
    VkDepthBiasInfoEXT pDepthBiasInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDepthBiasInfoEXT_win32_to_host(ctx, (const VkDepthBiasInfoEXT32 *)UlongToPtr(params->pDepthBiasInfo), &pDepthBiasInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBias2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDepthBiasInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBiasEnable(void *args)
{
    struct vkCmdSetDepthBiasEnable_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBiasEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBiasEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthBiasEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBiasEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBiasEnableEXT(void *args)
{
    struct vkCmdSetDepthBiasEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBiasEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBiasEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthBiasEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBiasEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBounds(void *args)
{
    struct vkCmdSetDepthBounds_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBounds(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->minDepthBounds, params->maxDepthBounds);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBounds(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        float minDepthBounds;
        float maxDepthBounds;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBounds(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->minDepthBounds, params->maxDepthBounds);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBoundsTestEnable(void *args)
{
    struct vkCmdSetDepthBoundsTestEnable_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBoundsTestEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBoundsTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBoundsTestEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthBoundsTestEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBoundsTestEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBoundsTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthBoundsTestEnableEXT(void *args)
{
    struct vkCmdSetDepthBoundsTestEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBoundsTestEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBoundsTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthBoundsTestEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthBoundsTestEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBoundsTestEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBoundsTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthClampEnableEXT(void *args)
{
    struct vkCmdSetDepthClampEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClampEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClampEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthClampEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthClampEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClampEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClampEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthClampRangeEXT(void *args)
{
    struct vkCmdSetDepthClampRangeEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClampRangeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClampMode, params->pDepthClampRange);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthClampRangeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDepthClampModeEXT depthClampMode;
        PTR32 pDepthClampRange;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClampRangeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClampMode, (const VkDepthClampRangeEXT *)UlongToPtr(params->pDepthClampRange));
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthClipEnableEXT(void *args)
{
    struct vkCmdSetDepthClipEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClipEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClipEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthClipEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthClipEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClipEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClipEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthClipNegativeOneToOneEXT(void *args)
{
    struct vkCmdSetDepthClipNegativeOneToOneEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClipNegativeOneToOneEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->negativeOneToOne);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthClipNegativeOneToOneEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 negativeOneToOne;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClipNegativeOneToOneEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->negativeOneToOne);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthCompareOp(void *args)
{
    struct vkCmdSetDepthCompareOp_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthCompareOp(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthCompareOp);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthCompareOp(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCompareOp depthCompareOp;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthCompareOp(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthCompareOp);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthCompareOpEXT(void *args)
{
    struct vkCmdSetDepthCompareOpEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthCompareOpEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthCompareOp);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthCompareOpEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCompareOp depthCompareOp;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthCompareOpEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthCompareOp);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthTestEnable(void *args)
{
    struct vkCmdSetDepthTestEnable_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthTestEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthTestEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthTestEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthTestEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthTestEnableEXT(void *args)
{
    struct vkCmdSetDepthTestEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthTestEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthTestEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthTestEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthTestEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthWriteEnable(void *args)
{
    struct vkCmdSetDepthWriteEnable_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthWriteEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthWriteEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthWriteEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthWriteEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthWriteEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthWriteEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDepthWriteEnableEXT(void *args)
{
    struct vkCmdSetDepthWriteEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthWriteEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthWriteEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDepthWriteEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 depthWriteEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthWriteEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthWriteEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDescriptorBufferOffsets2EXT(void *args)
{
    struct vkCmdSetDescriptorBufferOffsets2EXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDescriptorBufferOffsets2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSetDescriptorBufferOffsetsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDescriptorBufferOffsets2EXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSetDescriptorBufferOffsetsInfo;
    } *params = args;
    VkSetDescriptorBufferOffsetsInfoEXT pSetDescriptorBufferOffsetsInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkSetDescriptorBufferOffsetsInfoEXT_win32_to_host(ctx, (const VkSetDescriptorBufferOffsetsInfoEXT32 *)UlongToPtr(params->pSetDescriptorBufferOffsetsInfo), &pSetDescriptorBufferOffsetsInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDescriptorBufferOffsets2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSetDescriptorBufferOffsetsInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDescriptorBufferOffsetsEXT(void *args)
{
    struct vkCmdSetDescriptorBufferOffsetsEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDescriptorBufferOffsetsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, params->pBufferIndices, params->pOffsets);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDescriptorBufferOffsetsEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipelineLayout DECLSPEC_ALIGN(8) layout;
        uint32_t firstSet;
        uint32_t setCount;
        PTR32 pBufferIndices;
        PTR32 pOffsets;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDescriptorBufferOffsetsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, (const uint32_t *)UlongToPtr(params->pBufferIndices), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
}

#ifdef _WIN64
static void thunk64_vkCmdSetDeviceMask(void *args)
{
    struct vkCmdSetDeviceMask_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDeviceMask(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->deviceMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDeviceMask(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t deviceMask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDeviceMask(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->deviceMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDeviceMaskKHR(void *args)
{
    struct vkCmdSetDeviceMaskKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDeviceMaskKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->deviceMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDeviceMaskKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t deviceMask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDeviceMaskKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->deviceMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDiscardRectangleEXT(void *args)
{
    struct vkCmdSetDiscardRectangleEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, params->pDiscardRectangles);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDiscardRectangleEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstDiscardRectangle;
        uint32_t discardRectangleCount;
        PTR32 pDiscardRectangles;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, (const VkRect2D *)UlongToPtr(params->pDiscardRectangles));
}

#ifdef _WIN64
static void thunk64_vkCmdSetDiscardRectangleEnableEXT(void *args)
{
    struct vkCmdSetDiscardRectangleEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->discardRectangleEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDiscardRectangleEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 discardRectangleEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->discardRectangleEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetDiscardRectangleModeEXT(void *args)
{
    struct vkCmdSetDiscardRectangleModeEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->discardRectangleMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetDiscardRectangleModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDiscardRectangleModeEXT discardRectangleMode;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->discardRectangleMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetEvent(void *args)
{
    struct vkCmdSetEvent_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetEvent(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkPipelineStageFlags stageMask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetEvent2(void *args)
{
    struct vkCmdSetEvent2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->pDependencyInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetEvent2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        PTR32 pDependencyInfo;
    } *params = args;
    VkDependencyInfo pDependencyInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, &pDependencyInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetEvent2KHR(void *args)
{
    struct vkCmdSetEvent2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->pDependencyInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetEvent2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkEvent DECLSPEC_ALIGN(8) event;
        PTR32 pDependencyInfo;
    } *params = args;
    VkDependencyInfo pDependencyInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, &pDependencyInfo_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetExclusiveScissorEnableNV(void *args)
{
    struct vkCmdSetExclusiveScissorEnableNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExclusiveScissorEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissorEnables);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetExclusiveScissorEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstExclusiveScissor;
        uint32_t exclusiveScissorCount;
        PTR32 pExclusiveScissorEnables;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExclusiveScissorEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkBool32 *)UlongToPtr(params->pExclusiveScissorEnables));
}

#ifdef _WIN64
static void thunk64_vkCmdSetExclusiveScissorNV(void *args)
{
    struct vkCmdSetExclusiveScissorNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExclusiveScissorNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissors);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetExclusiveScissorNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstExclusiveScissor;
        uint32_t exclusiveScissorCount;
        PTR32 pExclusiveScissors;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExclusiveScissorNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkRect2D *)UlongToPtr(params->pExclusiveScissors));
}

#ifdef _WIN64
static void thunk64_vkCmdSetExtraPrimitiveOverestimationSizeEXT(void *args)
{
    struct vkCmdSetExtraPrimitiveOverestimationSizeEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->extraPrimitiveOverestimationSize);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetExtraPrimitiveOverestimationSizeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        float extraPrimitiveOverestimationSize;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->extraPrimitiveOverestimationSize);
}

#ifdef _WIN64
static void thunk64_vkCmdSetFragmentShadingRateEnumNV(void *args)
{
    struct vkCmdSetFragmentShadingRateEnumNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFragmentShadingRateEnumNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->shadingRate, params->combinerOps);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetFragmentShadingRateEnumNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkFragmentShadingRateNV shadingRate;
        PTR32 combinerOps;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFragmentShadingRateEnumNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->shadingRate, (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
}

#ifdef _WIN64
static void thunk64_vkCmdSetFragmentShadingRateKHR(void *args)
{
    struct vkCmdSetFragmentShadingRateKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFragmentShadingRateKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pFragmentSize, params->combinerOps);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetFragmentShadingRateKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pFragmentSize;
        PTR32 combinerOps;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFragmentShadingRateKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const VkExtent2D *)UlongToPtr(params->pFragmentSize), (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
}

#ifdef _WIN64
static void thunk64_vkCmdSetFrontFace(void *args)
{
    struct vkCmdSetFrontFace_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFrontFace(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->frontFace);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetFrontFace(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkFrontFace frontFace;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFrontFace(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->frontFace);
}

#ifdef _WIN64
static void thunk64_vkCmdSetFrontFaceEXT(void *args)
{
    struct vkCmdSetFrontFaceEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFrontFaceEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->frontFace);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetFrontFaceEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkFrontFace frontFace;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFrontFaceEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->frontFace);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLineRasterizationModeEXT(void *args)
{
    struct vkCmdSetLineRasterizationModeEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineRasterizationModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineRasterizationMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLineRasterizationModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkLineRasterizationModeEXT lineRasterizationMode;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineRasterizationModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineRasterizationMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLineStipple(void *args)
{
    struct vkCmdSetLineStipple_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStipple(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLineStipple(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t lineStippleFactor;
        uint16_t lineStipplePattern;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStipple(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLineStippleEXT(void *args)
{
    struct vkCmdSetLineStippleEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLineStippleEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t lineStippleFactor;
        uint16_t lineStipplePattern;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLineStippleEnableEXT(void *args)
{
    struct vkCmdSetLineStippleEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stippledLineEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLineStippleEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 stippledLineEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stippledLineEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLineStippleKHR(void *args)
{
    struct vkCmdSetLineStippleKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLineStippleKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t lineStippleFactor;
        uint16_t lineStipplePattern;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLineWidth(void *args)
{
    struct vkCmdSetLineWidth_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineWidth(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineWidth);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLineWidth(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        float lineWidth;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineWidth(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineWidth);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLogicOpEXT(void *args)
{
    struct vkCmdSetLogicOpEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLogicOpEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->logicOp);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLogicOpEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkLogicOp logicOp;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLogicOpEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->logicOp);
}

#ifdef _WIN64
static void thunk64_vkCmdSetLogicOpEnableEXT(void *args)
{
    struct vkCmdSetLogicOpEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLogicOpEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->logicOpEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetLogicOpEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 logicOpEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLogicOpEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->logicOpEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetPatchControlPointsEXT(void *args)
{
    struct vkCmdSetPatchControlPointsEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPatchControlPointsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->patchControlPoints);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPatchControlPointsEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t patchControlPoints;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPatchControlPointsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->patchControlPoints);
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCmdSetPerformanceMarkerINTEL(void *args)
{
    struct vkCmdSetPerformanceMarkerINTEL_params *params = args;

    TRACE("%p, %p\n", params->commandBuffer, params->pMarkerInfo);

    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceMarkerINTEL(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCmdSetPerformanceMarkerINTEL(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pMarkerInfo;
        VkResult result;
    } *params = args;
    VkPerformanceMarkerInfoINTEL pMarkerInfo_host;

    TRACE("%#x, %#x\n", params->commandBuffer, params->pMarkerInfo);

    convert_VkPerformanceMarkerInfoINTEL_win32_to_host((const VkPerformanceMarkerInfoINTEL32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceMarkerINTEL(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCmdSetPerformanceOverrideINTEL(void *args)
{
    struct vkCmdSetPerformanceOverrideINTEL_params *params = args;

    TRACE("%p, %p\n", params->commandBuffer, params->pOverrideInfo);

    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceOverrideINTEL(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pOverrideInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCmdSetPerformanceOverrideINTEL(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pOverrideInfo;
        VkResult result;
    } *params = args;
    VkPerformanceOverrideInfoINTEL pOverrideInfo_host;

    TRACE("%#x, %#x\n", params->commandBuffer, params->pOverrideInfo);

    convert_VkPerformanceOverrideInfoINTEL_win32_to_host((const VkPerformanceOverrideInfoINTEL32 *)UlongToPtr(params->pOverrideInfo), &pOverrideInfo_host);
    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceOverrideINTEL(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pOverrideInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCmdSetPerformanceStreamMarkerINTEL(void *args)
{
    struct vkCmdSetPerformanceStreamMarkerINTEL_params *params = args;

    TRACE("%p, %p\n", params->commandBuffer, params->pMarkerInfo);

    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceStreamMarkerINTEL(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCmdSetPerformanceStreamMarkerINTEL(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pMarkerInfo;
        VkResult result;
    } *params = args;
    VkPerformanceStreamMarkerInfoINTEL pMarkerInfo_host;

    TRACE("%#x, %#x\n", params->commandBuffer, params->pMarkerInfo);

    convert_VkPerformanceStreamMarkerInfoINTEL_win32_to_host((const VkPerformanceStreamMarkerInfoINTEL32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceStreamMarkerINTEL(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static void thunk64_vkCmdSetPolygonModeEXT(void *args)
{
    struct vkCmdSetPolygonModeEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPolygonModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->polygonMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPolygonModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPolygonMode polygonMode;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPolygonModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->polygonMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetPrimitiveRestartEnable(void *args)
{
    struct vkCmdSetPrimitiveRestartEnable_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveRestartEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveRestartEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPrimitiveRestartEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 primitiveRestartEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveRestartEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveRestartEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetPrimitiveRestartEnableEXT(void *args)
{
    struct vkCmdSetPrimitiveRestartEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveRestartEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveRestartEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPrimitiveRestartEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 primitiveRestartEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveRestartEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveRestartEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetPrimitiveTopology(void *args)
{
    struct vkCmdSetPrimitiveTopology_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveTopology(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveTopology);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPrimitiveTopology(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPrimitiveTopology primitiveTopology;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveTopology(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveTopology);
}

#ifdef _WIN64
static void thunk64_vkCmdSetPrimitiveTopologyEXT(void *args)
{
    struct vkCmdSetPrimitiveTopologyEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveTopologyEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveTopology);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetPrimitiveTopologyEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPrimitiveTopology primitiveTopology;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveTopologyEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveTopology);
}

#ifdef _WIN64
static void thunk64_vkCmdSetProvokingVertexModeEXT(void *args)
{
    struct vkCmdSetProvokingVertexModeEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetProvokingVertexModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->provokingVertexMode);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetProvokingVertexModeEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkProvokingVertexModeEXT provokingVertexMode;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetProvokingVertexModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->provokingVertexMode);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRasterizationSamplesEXT(void *args)
{
    struct vkCmdSetRasterizationSamplesEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizationSamplesEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizationSamples);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRasterizationSamplesEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkSampleCountFlagBits rasterizationSamples;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizationSamplesEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizationSamples);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRasterizationStreamEXT(void *args)
{
    struct vkCmdSetRasterizationStreamEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizationStreamEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizationStream);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRasterizationStreamEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t rasterizationStream;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizationStreamEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizationStream);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRasterizerDiscardEnable(void *args)
{
    struct vkCmdSetRasterizerDiscardEnable_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizerDiscardEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizerDiscardEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRasterizerDiscardEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 rasterizerDiscardEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizerDiscardEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizerDiscardEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRasterizerDiscardEnableEXT(void *args)
{
    struct vkCmdSetRasterizerDiscardEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizerDiscardEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizerDiscardEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRasterizerDiscardEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 rasterizerDiscardEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizerDiscardEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizerDiscardEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRayTracingPipelineStackSizeKHR(void *args)
{
    struct vkCmdSetRayTracingPipelineStackSizeKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRayTracingPipelineStackSizeKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStackSize);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRayTracingPipelineStackSizeKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t pipelineStackSize;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRayTracingPipelineStackSizeKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStackSize);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRenderingAttachmentLocations(void *args)
{
    struct vkCmdSetRenderingAttachmentLocations_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingAttachmentLocations(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLocationInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRenderingAttachmentLocations(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pLocationInfo;
    } *params = args;
    VkRenderingAttachmentLocationInfo pLocationInfo_host;

    convert_VkRenderingAttachmentLocationInfo_win32_to_host((const VkRenderingAttachmentLocationInfo32 *)UlongToPtr(params->pLocationInfo), &pLocationInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingAttachmentLocations(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLocationInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRenderingAttachmentLocationsKHR(void *args)
{
    struct vkCmdSetRenderingAttachmentLocationsKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingAttachmentLocationsKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLocationInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRenderingAttachmentLocationsKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pLocationInfo;
    } *params = args;
    VkRenderingAttachmentLocationInfo pLocationInfo_host;

    convert_VkRenderingAttachmentLocationInfo_win32_to_host((const VkRenderingAttachmentLocationInfo32 *)UlongToPtr(params->pLocationInfo), &pLocationInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingAttachmentLocationsKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLocationInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRenderingInputAttachmentIndices(void *args)
{
    struct vkCmdSetRenderingInputAttachmentIndices_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingInputAttachmentIndices(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInputAttachmentIndexInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRenderingInputAttachmentIndices(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInputAttachmentIndexInfo;
    } *params = args;
    VkRenderingInputAttachmentIndexInfo pInputAttachmentIndexInfo_host;

    convert_VkRenderingInputAttachmentIndexInfo_win32_to_host((const VkRenderingInputAttachmentIndexInfo32 *)UlongToPtr(params->pInputAttachmentIndexInfo), &pInputAttachmentIndexInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingInputAttachmentIndices(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInputAttachmentIndexInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRenderingInputAttachmentIndicesKHR(void *args)
{
    struct vkCmdSetRenderingInputAttachmentIndicesKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingInputAttachmentIndicesKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInputAttachmentIndexInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRenderingInputAttachmentIndicesKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pInputAttachmentIndexInfo;
    } *params = args;
    VkRenderingInputAttachmentIndexInfo pInputAttachmentIndexInfo_host;

    convert_VkRenderingInputAttachmentIndexInfo_win32_to_host((const VkRenderingInputAttachmentIndexInfo32 *)UlongToPtr(params->pInputAttachmentIndexInfo), &pInputAttachmentIndexInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingInputAttachmentIndicesKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInputAttachmentIndexInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdSetRepresentativeFragmentTestEnableNV(void *args)
{
    struct vkCmdSetRepresentativeFragmentTestEnableNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRepresentativeFragmentTestEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->representativeFragmentTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetRepresentativeFragmentTestEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 representativeFragmentTestEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRepresentativeFragmentTestEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->representativeFragmentTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetSampleLocationsEXT(void *args)
{
    struct vkCmdSetSampleLocationsEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleLocationsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSampleLocationsInfo);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetSampleLocationsEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pSampleLocationsInfo;
    } *params = args;
    VkSampleLocationsInfoEXT pSampleLocationsInfo_host;

    convert_VkSampleLocationsInfoEXT_win32_to_host((const VkSampleLocationsInfoEXT32 *)UlongToPtr(params->pSampleLocationsInfo), &pSampleLocationsInfo_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleLocationsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSampleLocationsInfo_host);
}

#ifdef _WIN64
static void thunk64_vkCmdSetSampleLocationsEnableEXT(void *args)
{
    struct vkCmdSetSampleLocationsEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleLocationsEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->sampleLocationsEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetSampleLocationsEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 sampleLocationsEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleLocationsEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->sampleLocationsEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetSampleMaskEXT(void *args)
{
    struct vkCmdSetSampleMaskEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleMaskEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->samples, params->pSampleMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetSampleMaskEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkSampleCountFlagBits samples;
        PTR32 pSampleMask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleMaskEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->samples, (const VkSampleMask *)UlongToPtr(params->pSampleMask));
}

#ifdef _WIN64
static void thunk64_vkCmdSetScissor(void *args)
{
    struct vkCmdSetScissor_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissor(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstScissor, params->scissorCount, params->pScissors);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetScissor(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstScissor;
        uint32_t scissorCount;
        PTR32 pScissors;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissor(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstScissor, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
}

#ifdef _WIN64
static void thunk64_vkCmdSetScissorWithCount(void *args)
{
    struct vkCmdSetScissorWithCount_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissorWithCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->scissorCount, params->pScissors);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetScissorWithCount(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t scissorCount;
        PTR32 pScissors;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissorWithCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
}

#ifdef _WIN64
static void thunk64_vkCmdSetScissorWithCountEXT(void *args)
{
    struct vkCmdSetScissorWithCountEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissorWithCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->scissorCount, params->pScissors);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetScissorWithCountEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t scissorCount;
        PTR32 pScissors;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissorWithCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
}

#ifdef _WIN64
static void thunk64_vkCmdSetShadingRateImageEnableNV(void *args)
{
    struct vkCmdSetShadingRateImageEnableNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetShadingRateImageEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->shadingRateImageEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetShadingRateImageEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 shadingRateImageEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetShadingRateImageEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->shadingRateImageEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilCompareMask(void *args)
{
    struct vkCmdSetStencilCompareMask_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilCompareMask(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->compareMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilCompareMask(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkStencilFaceFlags faceMask;
        uint32_t compareMask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilCompareMask(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->compareMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilOp(void *args)
{
    struct vkCmdSetStencilOp_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilOp(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilOp(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkStencilFaceFlags faceMask;
        VkStencilOp failOp;
        VkStencilOp passOp;
        VkStencilOp depthFailOp;
        VkCompareOp compareOp;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilOp(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilOpEXT(void *args)
{
    struct vkCmdSetStencilOpEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilOpEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilOpEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkStencilFaceFlags faceMask;
        VkStencilOp failOp;
        VkStencilOp passOp;
        VkStencilOp depthFailOp;
        VkCompareOp compareOp;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilOpEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilReference(void *args)
{
    struct vkCmdSetStencilReference_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilReference(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->reference);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilReference(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkStencilFaceFlags faceMask;
        uint32_t reference;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilReference(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->reference);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilTestEnable(void *args)
{
    struct vkCmdSetStencilTestEnable_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilTestEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stencilTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilTestEnable(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 stencilTestEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilTestEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stencilTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilTestEnableEXT(void *args)
{
    struct vkCmdSetStencilTestEnableEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilTestEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stencilTestEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilTestEnableEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 stencilTestEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilTestEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stencilTestEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetStencilWriteMask(void *args)
{
    struct vkCmdSetStencilWriteMask_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilWriteMask(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->writeMask);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetStencilWriteMask(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkStencilFaceFlags faceMask;
        uint32_t writeMask;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilWriteMask(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->writeMask);
}

#ifdef _WIN64
static void thunk64_vkCmdSetTessellationDomainOriginEXT(void *args)
{
    struct vkCmdSetTessellationDomainOriginEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetTessellationDomainOriginEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->domainOrigin);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetTessellationDomainOriginEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkTessellationDomainOrigin domainOrigin;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetTessellationDomainOriginEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->domainOrigin);
}

#ifdef _WIN64
static void thunk64_vkCmdSetVertexInputEXT(void *args)
{
    struct vkCmdSetVertexInputEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetVertexInputEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->vertexBindingDescriptionCount, params->pVertexBindingDescriptions, params->vertexAttributeDescriptionCount, params->pVertexAttributeDescriptions);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetVertexInputEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t vertexBindingDescriptionCount;
        PTR32 pVertexBindingDescriptions;
        uint32_t vertexAttributeDescriptionCount;
        PTR32 pVertexAttributeDescriptions;
    } *params = args;
    const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions_host;
    const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pVertexBindingDescriptions_host = convert_VkVertexInputBindingDescription2EXT_array_win32_to_host(ctx, (const VkVertexInputBindingDescription2EXT32 *)UlongToPtr(params->pVertexBindingDescriptions), params->vertexBindingDescriptionCount);
    pVertexAttributeDescriptions_host = convert_VkVertexInputAttributeDescription2EXT_array_win32_to_host(ctx, (const VkVertexInputAttributeDescription2EXT32 *)UlongToPtr(params->pVertexAttributeDescriptions), params->vertexAttributeDescriptionCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetVertexInputEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->vertexBindingDescriptionCount, pVertexBindingDescriptions_host, params->vertexAttributeDescriptionCount, pVertexAttributeDescriptions_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewport(void *args)
{
    struct vkCmdSetViewport_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewport(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewports);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewport(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstViewport;
        uint32_t viewportCount;
        PTR32 pViewports;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewport(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportShadingRatePaletteNV(void *args)
{
    struct vkCmdSetViewportShadingRatePaletteNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportShadingRatePaletteNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pShadingRatePalettes);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportShadingRatePaletteNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstViewport;
        uint32_t viewportCount;
        PTR32 pShadingRatePalettes;
    } *params = args;
    const VkShadingRatePaletteNV *pShadingRatePalettes_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pShadingRatePalettes_host = convert_VkShadingRatePaletteNV_array_win32_to_host(ctx, (const VkShadingRatePaletteNV32 *)UlongToPtr(params->pShadingRatePalettes), params->viewportCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportShadingRatePaletteNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, pShadingRatePalettes_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportSwizzleNV(void *args)
{
    struct vkCmdSetViewportSwizzleNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportSwizzleNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewportSwizzles);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportSwizzleNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstViewport;
        uint32_t viewportCount;
        PTR32 pViewportSwizzles;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportSwizzleNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewportSwizzleNV *)UlongToPtr(params->pViewportSwizzles));
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportWScalingEnableNV(void *args)
{
    struct vkCmdSetViewportWScalingEnableNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWScalingEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportWScalingEnable);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportWScalingEnableNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBool32 viewportWScalingEnable;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWScalingEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportWScalingEnable);
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportWScalingNV(void *args)
{
    struct vkCmdSetViewportWScalingNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWScalingNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewportWScalings);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportWScalingNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t firstViewport;
        uint32_t viewportCount;
        PTR32 pViewportWScalings;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWScalingNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewportWScalingNV *)UlongToPtr(params->pViewportWScalings));
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportWithCount(void *args)
{
    struct vkCmdSetViewportWithCount_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWithCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportCount, params->pViewports);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportWithCount(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t viewportCount;
        PTR32 pViewports;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWithCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
}

#ifdef _WIN64
static void thunk64_vkCmdSetViewportWithCountEXT(void *args)
{
    struct vkCmdSetViewportWithCountEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWithCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportCount, params->pViewports);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSetViewportWithCountEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t viewportCount;
        PTR32 pViewports;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWithCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
}

#ifdef _WIN64
static void thunk64_vkCmdSubpassShadingHUAWEI(void *args)
{
    struct vkCmdSubpassShadingHUAWEI_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSubpassShadingHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
}
#endif /* _WIN64 */

static void thunk32_vkCmdSubpassShadingHUAWEI(void *args)
{
    struct
    {
        PTR32 commandBuffer;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSubpassShadingHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
}

#ifdef _WIN64
static void thunk64_vkCmdTraceRaysIndirect2KHR(void *args)
{
    struct vkCmdTraceRaysIndirect2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysIndirect2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indirectDeviceAddress);
}
#endif /* _WIN64 */

static void thunk32_vkCmdTraceRaysIndirect2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkDeviceAddress DECLSPEC_ALIGN(8) indirectDeviceAddress;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysIndirect2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indirectDeviceAddress);
}

#ifdef _WIN64
static void thunk64_vkCmdTraceRaysIndirectKHR(void *args)
{
    struct vkCmdTraceRaysIndirectKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysIndirectKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->indirectDeviceAddress);
}
#endif /* _WIN64 */

static void thunk32_vkCmdTraceRaysIndirectKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRaygenShaderBindingTable;
        PTR32 pMissShaderBindingTable;
        PTR32 pHitShaderBindingTable;
        PTR32 pCallableShaderBindingTable;
        VkDeviceAddress DECLSPEC_ALIGN(8) indirectDeviceAddress;
    } *params = args;
    VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pMissShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pHitShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable_host;

    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pRaygenShaderBindingTable), &pRaygenShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pMissShaderBindingTable), &pMissShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pHitShaderBindingTable), &pHitShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pCallableShaderBindingTable), &pCallableShaderBindingTable_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysIndirectKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->indirectDeviceAddress);
}

#ifdef _WIN64
static void thunk64_vkCmdTraceRaysKHR(void *args)
{
    struct vkCmdTraceRaysKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->width, params->height, params->depth);
}
#endif /* _WIN64 */

static void thunk32_vkCmdTraceRaysKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        PTR32 pRaygenShaderBindingTable;
        PTR32 pMissShaderBindingTable;
        PTR32 pHitShaderBindingTable;
        PTR32 pCallableShaderBindingTable;
        uint32_t width;
        uint32_t height;
        uint32_t depth;
    } *params = args;
    VkStridedDeviceAddressRegionKHR pRaygenShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pMissShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pHitShaderBindingTable_host;
    VkStridedDeviceAddressRegionKHR pCallableShaderBindingTable_host;

    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pRaygenShaderBindingTable), &pRaygenShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pMissShaderBindingTable), &pMissShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pHitShaderBindingTable), &pHitShaderBindingTable_host);
    convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pCallableShaderBindingTable), &pCallableShaderBindingTable_host);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->width, params->height, params->depth);
}

#ifdef _WIN64
static void thunk64_vkCmdTraceRaysNV(void *args)
{
    struct vkCmdTraceRaysNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
}
#endif /* _WIN64 */

static void thunk32_vkCmdTraceRaysNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) raygenShaderBindingTableBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) raygenShaderBindingOffset;
        VkBuffer DECLSPEC_ALIGN(8) missShaderBindingTableBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) missShaderBindingOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) missShaderBindingStride;
        VkBuffer DECLSPEC_ALIGN(8) hitShaderBindingTableBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) hitShaderBindingOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) hitShaderBindingStride;
        VkBuffer DECLSPEC_ALIGN(8) callableShaderBindingTableBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) callableShaderBindingOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) callableShaderBindingStride;
        uint32_t width;
        uint32_t height;
        uint32_t depth;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
}

#ifdef _WIN64
static void thunk64_vkCmdUpdateBuffer(void *args)
{
    struct vkCmdUpdateBuffer_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdUpdateBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, params->pData);
}
#endif /* _WIN64 */

static void thunk32_vkCmdUpdateBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
        VkDeviceSize DECLSPEC_ALIGN(8) dataSize;
        PTR32 pData;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdUpdateBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, (const void *)UlongToPtr(params->pData));
}

#ifdef _WIN64
static void thunk64_vkCmdUpdatePipelineIndirectBufferNV(void *args)
{
    struct vkCmdUpdatePipelineIndirectBufferNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdUpdatePipelineIndirectBufferNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline);
}
#endif /* _WIN64 */

static void thunk32_vkCmdUpdatePipelineIndirectBufferNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineBindPoint pipelineBindPoint;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdUpdatePipelineIndirectBufferNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline);
}

#ifdef _WIN64
static void thunk64_vkCmdWaitEvents(void *args)
{
    struct vkCmdWaitEvents_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWaitEvents(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t eventCount;
        PTR32 pEvents;
        VkPipelineStageFlags srcStageMask;
        VkPipelineStageFlags dstStageMask;
        uint32_t memoryBarrierCount;
        PTR32 pMemoryBarriers;
        uint32_t bufferMemoryBarrierCount;
        PTR32 pBufferMemoryBarriers;
        uint32_t imageMemoryBarrierCount;
        PTR32 pImageMemoryBarriers;
    } *params = args;
    const VkMemoryBarrier *pMemoryBarriers_host;
    const VkBufferMemoryBarrier *pBufferMemoryBarriers_host;
    const VkImageMemoryBarrier *pImageMemoryBarriers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pMemoryBarriers_host = convert_VkMemoryBarrier_array_win32_to_host(ctx, (const VkMemoryBarrier32 *)UlongToPtr(params->pMemoryBarriers), params->memoryBarrierCount);
    pBufferMemoryBarriers_host = convert_VkBufferMemoryBarrier_array_win32_to_host(ctx, (const VkBufferMemoryBarrier32 *)UlongToPtr(params->pBufferMemoryBarriers), params->bufferMemoryBarrierCount);
    pImageMemoryBarriers_host = convert_VkImageMemoryBarrier_array_win32_to_host(ctx, (const VkImageMemoryBarrier32 *)UlongToPtr(params->pImageMemoryBarriers), params->imageMemoryBarrierCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdWaitEvents2(void *args)
{
    struct vkCmdWaitEvents2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWaitEvents2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t eventCount;
        PTR32 pEvents;
        PTR32 pDependencyInfos;
    } *params = args;
    const VkDependencyInfo *pDependencyInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDependencyInfos_host = convert_VkDependencyInfo_array_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfos), params->eventCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdWaitEvents2KHR(void *args)
{
    struct vkCmdWaitEvents2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWaitEvents2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t eventCount;
        PTR32 pEvents;
        PTR32 pDependencyInfos;
    } *params = args;
    const VkDependencyInfo *pDependencyInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDependencyInfos_host = convert_VkDependencyInfo_array_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfos), params->eventCount);
    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteAccelerationStructuresPropertiesKHR(void *args)
{
    struct vkCmdWriteAccelerationStructuresPropertiesKHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteAccelerationStructuresPropertiesKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteAccelerationStructuresPropertiesKHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t accelerationStructureCount;
        PTR32 pAccelerationStructures;
        VkQueryType queryType;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteAccelerationStructuresPropertiesKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureKHR *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteAccelerationStructuresPropertiesNV(void *args)
{
    struct vkCmdWriteAccelerationStructuresPropertiesNV_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteAccelerationStructuresPropertiesNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteAccelerationStructuresPropertiesNV(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t accelerationStructureCount;
        PTR32 pAccelerationStructures;
        VkQueryType queryType;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteAccelerationStructuresPropertiesNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureNV *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteBufferMarker2AMD(void *args)
{
    struct vkCmdWriteBufferMarker2AMD_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteBufferMarker2AMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteBufferMarker2AMD(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stage;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
        uint32_t marker;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteBufferMarker2AMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteBufferMarkerAMD(void *args)
{
    struct vkCmdWriteBufferMarkerAMD_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteBufferMarkerAMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteBufferMarkerAMD(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlagBits pipelineStage;
        VkBuffer DECLSPEC_ALIGN(8) dstBuffer;
        VkDeviceSize DECLSPEC_ALIGN(8) dstOffset;
        uint32_t marker;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteBufferMarkerAMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteMicromapsPropertiesEXT(void *args)
{
    struct vkCmdWriteMicromapsPropertiesEXT_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteMicromapsPropertiesEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->micromapCount, params->pMicromaps, params->queryType, params->queryPool, params->firstQuery);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteMicromapsPropertiesEXT(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        uint32_t micromapCount;
        PTR32 pMicromaps;
        VkQueryType queryType;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteMicromapsPropertiesEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->micromapCount, (const VkMicromapEXT *)UlongToPtr(params->pMicromaps), params->queryType, params->queryPool, params->firstQuery);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteTimestamp(void *args)
{
    struct vkCmdWriteTimestamp_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStage, params->queryPool, params->query);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteTimestamp(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlagBits pipelineStage;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStage, params->queryPool, params->query);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteTimestamp2(void *args)
{
    struct vkCmdWriteTimestamp2_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->queryPool, params->query);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteTimestamp2(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stage;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->queryPool, params->query);
}

#ifdef _WIN64
static void thunk64_vkCmdWriteTimestamp2KHR(void *args)
{
    struct vkCmdWriteTimestamp2KHR_params *params = args;

    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->queryPool, params->query);
}
#endif /* _WIN64 */

static void thunk32_vkCmdWriteTimestamp2KHR(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stage;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t query;
    } *params = args;

    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->queryPool, params->query);
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCompileDeferredNV(void *args)
{
    struct vkCompileDeferredNV_params *params = args;

    TRACE("%p, 0x%s, %u\n", params->device, wine_dbgstr_longlong(params->pipeline), params->shader);

    params->result = vulkan_device_from_handle(params->device)->p_vkCompileDeferredNV(vulkan_device_from_handle(params->device)->host.device, params->pipeline, params->shader);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCompileDeferredNV(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t shader;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u\n", params->device, wine_dbgstr_longlong(params->pipeline), params->shader);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCompileDeferredNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipeline, params->shader);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkConvertCooperativeVectorMatrixNV(void *args)
{
    struct vkConvertCooperativeVectorMatrixNV_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkConvertCooperativeVectorMatrixNV(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkConvertCooperativeVectorMatrixNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkConvertCooperativeVectorMatrixInfoNV pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkConvertCooperativeVectorMatrixInfoNV_win32_to_host((const VkConvertCooperativeVectorMatrixInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkConvertCooperativeVectorMatrixNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyAccelerationStructureKHR(void *args)
{
    struct vkCopyAccelerationStructureKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyAccelerationStructureKHR(vulkan_device_from_handle(params->device)->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyAccelerationStructureInfoKHR pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyAccelerationStructureInfoKHR_win32_to_host((const VkCopyAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyAccelerationStructureKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyAccelerationStructureToMemoryKHR(void *args)
{
    struct vkCopyAccelerationStructureToMemoryKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyAccelerationStructureToMemoryKHR(vulkan_device_from_handle(params->device)->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyAccelerationStructureToMemoryKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyAccelerationStructureToMemoryInfoKHR pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyAccelerationStructureToMemoryInfoKHR_win32_to_host((const VkCopyAccelerationStructureToMemoryInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyAccelerationStructureToMemoryKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyImageToImage(void *args)
{
    struct vkCopyImageToImage_params *params = args;

    TRACE("%p, %p\n", params->device, params->pCopyImageToImageInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyImageToImage(vulkan_device_from_handle(params->device)->host.device, params->pCopyImageToImageInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyImageToImage(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCopyImageToImageInfo;
        VkResult result;
    } *params = args;
    VkCopyImageToImageInfo pCopyImageToImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->device, params->pCopyImageToImageInfo);

    init_conversion_context(ctx);
    convert_VkCopyImageToImageInfo_win32_to_host(ctx, (const VkCopyImageToImageInfo32 *)UlongToPtr(params->pCopyImageToImageInfo), &pCopyImageToImageInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyImageToImage(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCopyImageToImageInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyImageToImageEXT(void *args)
{
    struct vkCopyImageToImageEXT_params *params = args;

    TRACE("%p, %p\n", params->device, params->pCopyImageToImageInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyImageToImageEXT(vulkan_device_from_handle(params->device)->host.device, params->pCopyImageToImageInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyImageToImageEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCopyImageToImageInfo;
        VkResult result;
    } *params = args;
    VkCopyImageToImageInfo pCopyImageToImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->device, params->pCopyImageToImageInfo);

    init_conversion_context(ctx);
    convert_VkCopyImageToImageInfo_win32_to_host(ctx, (const VkCopyImageToImageInfo32 *)UlongToPtr(params->pCopyImageToImageInfo), &pCopyImageToImageInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyImageToImageEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCopyImageToImageInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyImageToMemory(void *args)
{
    struct vkCopyImageToMemory_params *params = args;

    TRACE("%p, %p\n", params->device, params->pCopyImageToMemoryInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyImageToMemory(vulkan_device_from_handle(params->device)->host.device, params->pCopyImageToMemoryInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyImageToMemory(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCopyImageToMemoryInfo;
        VkResult result;
    } *params = args;
    VkCopyImageToMemoryInfo pCopyImageToMemoryInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->device, params->pCopyImageToMemoryInfo);

    init_conversion_context(ctx);
    convert_VkCopyImageToMemoryInfo_win32_to_host(ctx, (const VkCopyImageToMemoryInfo32 *)UlongToPtr(params->pCopyImageToMemoryInfo), &pCopyImageToMemoryInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyImageToMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCopyImageToMemoryInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyImageToMemoryEXT(void *args)
{
    struct vkCopyImageToMemoryEXT_params *params = args;

    TRACE("%p, %p\n", params->device, params->pCopyImageToMemoryInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyImageToMemoryEXT(vulkan_device_from_handle(params->device)->host.device, params->pCopyImageToMemoryInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyImageToMemoryEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCopyImageToMemoryInfo;
        VkResult result;
    } *params = args;
    VkCopyImageToMemoryInfo pCopyImageToMemoryInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->device, params->pCopyImageToMemoryInfo);

    init_conversion_context(ctx);
    convert_VkCopyImageToMemoryInfo_win32_to_host(ctx, (const VkCopyImageToMemoryInfo32 *)UlongToPtr(params->pCopyImageToMemoryInfo), &pCopyImageToMemoryInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyImageToMemoryEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCopyImageToMemoryInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMemoryToAccelerationStructureKHR(void *args)
{
    struct vkCopyMemoryToAccelerationStructureKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyMemoryToAccelerationStructureKHR(vulkan_device_from_handle(params->device)->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMemoryToAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyMemoryToAccelerationStructureInfoKHR pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyMemoryToAccelerationStructureInfoKHR_win32_to_host((const VkCopyMemoryToAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyMemoryToAccelerationStructureKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMemoryToImage(void *args)
{
    struct vkCopyMemoryToImage_params *params = args;

    TRACE("%p, %p\n", params->device, params->pCopyMemoryToImageInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyMemoryToImage(vulkan_device_from_handle(params->device)->host.device, params->pCopyMemoryToImageInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMemoryToImage(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCopyMemoryToImageInfo;
        VkResult result;
    } *params = args;
    VkCopyMemoryToImageInfo pCopyMemoryToImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->device, params->pCopyMemoryToImageInfo);

    init_conversion_context(ctx);
    convert_VkCopyMemoryToImageInfo_win32_to_host(ctx, (const VkCopyMemoryToImageInfo32 *)UlongToPtr(params->pCopyMemoryToImageInfo), &pCopyMemoryToImageInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyMemoryToImage(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCopyMemoryToImageInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMemoryToImageEXT(void *args)
{
    struct vkCopyMemoryToImageEXT_params *params = args;

    TRACE("%p, %p\n", params->device, params->pCopyMemoryToImageInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyMemoryToImageEXT(vulkan_device_from_handle(params->device)->host.device, params->pCopyMemoryToImageInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMemoryToImageEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCopyMemoryToImageInfo;
        VkResult result;
    } *params = args;
    VkCopyMemoryToImageInfo pCopyMemoryToImageInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->device, params->pCopyMemoryToImageInfo);

    init_conversion_context(ctx);
    convert_VkCopyMemoryToImageInfo_win32_to_host(ctx, (const VkCopyMemoryToImageInfo32 *)UlongToPtr(params->pCopyMemoryToImageInfo), &pCopyMemoryToImageInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyMemoryToImageEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCopyMemoryToImageInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMemoryToMicromapEXT(void *args)
{
    struct vkCopyMemoryToMicromapEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyMemoryToMicromapEXT(vulkan_device_from_handle(params->device)->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMemoryToMicromapEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyMemoryToMicromapInfoEXT pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyMemoryToMicromapInfoEXT_win32_to_host((const VkCopyMemoryToMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyMemoryToMicromapEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMicromapEXT(void *args)
{
    struct vkCopyMicromapEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyMicromapEXT(vulkan_device_from_handle(params->device)->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMicromapEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyMicromapInfoEXT pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyMicromapInfoEXT_win32_to_host((const VkCopyMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyMicromapEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCopyMicromapToMemoryEXT(void *args)
{
    struct vkCopyMicromapToMemoryEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkCopyMicromapToMemoryEXT(vulkan_device_from_handle(params->device)->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCopyMicromapToMemoryEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    VkCopyMicromapToMemoryInfoEXT pInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), params->pInfo);

    convert_VkCopyMicromapToMemoryInfoEXT_win32_to_host((const VkCopyMicromapToMemoryInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCopyMicromapToMemoryEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateAccelerationStructureKHR(void *args)
{
    struct vkCreateAccelerationStructureKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pAccelerationStructure);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateAccelerationStructureKHR(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pAccelerationStructure);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pAccelerationStructure;
        VkResult result;
    } *params = args;
    VkAccelerationStructureCreateInfoKHR pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pAccelerationStructure);

    init_conversion_context(ctx);
    convert_VkAccelerationStructureCreateInfoKHR_win32_to_host(ctx, (const VkAccelerationStructureCreateInfoKHR32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateAccelerationStructureKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkAccelerationStructureKHR *)UlongToPtr(params->pAccelerationStructure));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateAccelerationStructureNV(void *args)
{
    struct vkCreateAccelerationStructureNV_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pAccelerationStructure);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateAccelerationStructureNV(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pAccelerationStructure);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateAccelerationStructureNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pAccelerationStructure;
        VkResult result;
    } *params = args;
    VkAccelerationStructureCreateInfoNV pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pAccelerationStructure);

    init_conversion_context(ctx);
    convert_VkAccelerationStructureCreateInfoNV_win32_to_host(ctx, (const VkAccelerationStructureCreateInfoNV32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateAccelerationStructureNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkAccelerationStructureNV *)UlongToPtr(params->pAccelerationStructure));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateBuffer(void *args)
{
    struct vkCreateBuffer_params *params = args;
    VkBufferCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pBuffer);

    init_conversion_context(ctx);
    convert_VkBufferCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = vk_funcs->p_vkCreateBuffer(params->device, &pCreateInfo_host, params->pAllocator, params->pBuffer);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateBuffer(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pBuffer;
        VkResult result;
    } *params = args;
    VkBufferCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pBuffer);

    init_conversion_context(ctx);
    convert_VkBufferCreateInfo_win32_to_host(ctx, (const VkBufferCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vk_funcs->p_vkCreateBuffer((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkBuffer *)UlongToPtr(params->pBuffer));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateBufferView(void *args)
{
    struct vkCreateBufferView_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pView);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateBufferView(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pView);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateBufferView(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pView;
        VkResult result;
    } *params = args;
    VkBufferViewCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pView);

    init_conversion_context(ctx);
    convert_VkBufferViewCreateInfo_win32_to_host(ctx, (const VkBufferViewCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateBufferView(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkBufferView *)UlongToPtr(params->pView));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateCommandPool(void *args)
{
    struct vkCreateCommandPool_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pCommandPool);

    params->result = wine_vkCreateCommandPool(params->device, params->pCreateInfo, params->pAllocator, params->pCommandPool, params->client_ptr);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateCommandPool(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pCommandPool;
        PTR32 client_ptr;
        VkResult result;
    } *params = args;
    VkCommandPoolCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pCommandPool);

    init_conversion_context(ctx);
    convert_VkCommandPoolCreateInfo_win32_to_host(ctx, (const VkCommandPoolCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateCommandPool((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkCommandPool *)UlongToPtr(params->pCommandPool), UlongToPtr(params->client_ptr));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateComputePipelines(void *args)
{
    struct vkCreateComputePipelines_params *params = args;
    const VkComputePipelineCreateInfo *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, 0x%s, %u, %p, %p, %p\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkComputePipelineCreateInfo_array_win64_to_host(ctx, params->pCreateInfos, params->createInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkCreateComputePipelines(vulkan_device_from_handle(params->device)->host.device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, params->pPipelines);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateComputePipelines(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pPipelines;
        VkResult result;
    } *params = args;
    const VkComputePipelineCreateInfo *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkComputePipelineCreateInfo_array_win32_to_host(ctx, (const VkComputePipelineCreateInfo32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateComputePipelines(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, (VkPipeline *)UlongToPtr(params->pPipelines));
    convert_VkComputePipelineCreateInfo_array_host_to_win32(pCreateInfos_host, (VkComputePipelineCreateInfo32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateCuFunctionNVX(void *args)
{
    struct vkCreateCuFunctionNVX_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pFunction);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateCuFunctionNVX(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pFunction);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateCuFunctionNVX(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pFunction;
        VkResult result;
    } *params = args;
    VkCuFunctionCreateInfoNVX pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pFunction);

    convert_VkCuFunctionCreateInfoNVX_win32_to_host((const VkCuFunctionCreateInfoNVX32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateCuFunctionNVX(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkCuFunctionNVX *)UlongToPtr(params->pFunction));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateCuModuleNVX(void *args)
{
    struct vkCreateCuModuleNVX_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pModule);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateCuModuleNVX(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pModule);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateCuModuleNVX(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pModule;
        VkResult result;
    } *params = args;
    VkCuModuleCreateInfoNVX pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pModule);

    init_conversion_context(ctx);
    convert_VkCuModuleCreateInfoNVX_win32_to_host(ctx, (const VkCuModuleCreateInfoNVX32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateCuModuleNVX(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkCuModuleNVX *)UlongToPtr(params->pModule));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDataGraphPipelineSessionARM(void *args)
{
    struct vkCreateDataGraphPipelineSessionARM_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSession);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateDataGraphPipelineSessionARM(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pSession);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDataGraphPipelineSessionARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSession;
        VkResult result;
    } *params = args;
    VkDataGraphPipelineSessionCreateInfoARM pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSession);

    convert_VkDataGraphPipelineSessionCreateInfoARM_win32_to_host((const VkDataGraphPipelineSessionCreateInfoARM32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateDataGraphPipelineSessionARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkDataGraphPipelineSessionARM *)UlongToPtr(params->pSession));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDataGraphPipelinesARM(void *args)
{
    struct vkCreateDataGraphPipelinesARM_params *params = args;

    TRACE("%p, 0x%s, 0x%s, %u, %p, %p, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateDataGraphPipelinesARM(vulkan_device_from_handle(params->device)->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->pipelineCache, params->createInfoCount, params->pCreateInfos, NULL, params->pPipelines);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDataGraphPipelinesARM(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pPipelines;
        VkResult result;
    } *params = args;
    const VkDataGraphPipelineCreateInfoARM *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, 0x%s, %u, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    if (params->deferredOperation == VK_NULL_HANDLE)
        init_conversion_context(ctx);
    else
        ctx = &wine_deferred_operation_from_handle(params->deferredOperation)->ctx;
    pCreateInfos_host = convert_VkDataGraphPipelineCreateInfoARM_array_win32_to_host(ctx, (const VkDataGraphPipelineCreateInfoARM32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateDataGraphPipelinesARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, (VkPipeline *)UlongToPtr(params->pPipelines));
    convert_VkDataGraphPipelineCreateInfoARM_array_host_to_win32(pCreateInfos_host, (VkDataGraphPipelineCreateInfoARM32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    if (params->deferredOperation == VK_NULL_HANDLE)
        free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDebugReportCallbackEXT(void *args)
{
    struct vkCreateDebugReportCallbackEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->instance, params->pCreateInfo, params->pAllocator, params->pCallback);

    params->result = wine_vkCreateDebugReportCallbackEXT(params->instance, params->pCreateInfo, params->pAllocator, params->pCallback);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDebugReportCallbackEXT(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pCallback;
        VkResult result;
    } *params = args;
    VkDebugReportCallbackCreateInfoEXT pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->instance, params->pCreateInfo, params->pAllocator, params->pCallback);

    convert_VkDebugReportCallbackCreateInfoEXT_win32_to_host((const VkDebugReportCallbackCreateInfoEXT32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateDebugReportCallbackEXT((VkInstance)UlongToPtr(params->instance), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDebugReportCallbackEXT *)UlongToPtr(params->pCallback));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDebugUtilsMessengerEXT(void *args)
{
    struct vkCreateDebugUtilsMessengerEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->instance, params->pCreateInfo, params->pAllocator, params->pMessenger);

    params->result = wine_vkCreateDebugUtilsMessengerEXT(params->instance, params->pCreateInfo, params->pAllocator, params->pMessenger);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDebugUtilsMessengerEXT(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pMessenger;
        VkResult result;
    } *params = args;
    VkDebugUtilsMessengerCreateInfoEXT pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->instance, params->pCreateInfo, params->pAllocator, params->pMessenger);

    convert_VkDebugUtilsMessengerCreateInfoEXT_win32_to_host((const VkDebugUtilsMessengerCreateInfoEXT32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = wine_vkCreateDebugUtilsMessengerEXT((VkInstance)UlongToPtr(params->instance), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDebugUtilsMessengerEXT *)UlongToPtr(params->pMessenger));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDeferredOperationKHR(void *args)
{
    struct vkCreateDeferredOperationKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pAllocator, params->pDeferredOperation);

    params->result = wine_vkCreateDeferredOperationKHR(params->device, params->pAllocator, params->pDeferredOperation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDeferredOperationKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAllocator;
        PTR32 pDeferredOperation;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->device, params->pAllocator, params->pDeferredOperation);

    params->result = wine_vkCreateDeferredOperationKHR((VkDevice)UlongToPtr(params->device), (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDeferredOperationKHR *)UlongToPtr(params->pDeferredOperation));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDescriptorPool(void *args)
{
    struct vkCreateDescriptorPool_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorPool);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateDescriptorPool(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pDescriptorPool);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDescriptorPool(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pDescriptorPool;
        VkResult result;
    } *params = args;
    VkDescriptorPoolCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorPool);

    init_conversion_context(ctx);
    convert_VkDescriptorPoolCreateInfo_win32_to_host(ctx, (const VkDescriptorPoolCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateDescriptorPool(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkDescriptorPool *)UlongToPtr(params->pDescriptorPool));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDescriptorSetLayout(void *args)
{
    struct vkCreateDescriptorSetLayout_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSetLayout);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateDescriptorSetLayout(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pSetLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDescriptorSetLayout(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSetLayout;
        VkResult result;
    } *params = args;
    VkDescriptorSetLayoutCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSetLayout);

    init_conversion_context(ctx);
    convert_VkDescriptorSetLayoutCreateInfo_win32_to_host(ctx, (const VkDescriptorSetLayoutCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateDescriptorSetLayout(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkDescriptorSetLayout *)UlongToPtr(params->pSetLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDescriptorUpdateTemplate(void *args)
{
    struct vkCreateDescriptorUpdateTemplate_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorUpdateTemplate);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateDescriptorUpdateTemplate(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pDescriptorUpdateTemplate);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDescriptorUpdateTemplate(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pDescriptorUpdateTemplate;
        VkResult result;
    } *params = args;
    VkDescriptorUpdateTemplateCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorUpdateTemplate);

    init_conversion_context(ctx);
    convert_VkDescriptorUpdateTemplateCreateInfo_win32_to_host(ctx, (const VkDescriptorUpdateTemplateCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateDescriptorUpdateTemplate(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkDescriptorUpdateTemplate *)UlongToPtr(params->pDescriptorUpdateTemplate));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDescriptorUpdateTemplateKHR(void *args)
{
    struct vkCreateDescriptorUpdateTemplateKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorUpdateTemplate);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateDescriptorUpdateTemplateKHR(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pDescriptorUpdateTemplate);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDescriptorUpdateTemplateKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pDescriptorUpdateTemplate;
        VkResult result;
    } *params = args;
    VkDescriptorUpdateTemplateCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pDescriptorUpdateTemplate);

    init_conversion_context(ctx);
    convert_VkDescriptorUpdateTemplateCreateInfo_win32_to_host(ctx, (const VkDescriptorUpdateTemplateCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateDescriptorUpdateTemplateKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkDescriptorUpdateTemplate *)UlongToPtr(params->pDescriptorUpdateTemplate));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateDevice(void *args)
{
    struct vkCreateDevice_params *params = args;
    VkDeviceCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pCreateInfo, params->pAllocator, params->pDevice);

    init_conversion_context(ctx);
    convert_VkDeviceCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = wine_vkCreateDevice(params->physicalDevice, &pCreateInfo_host, params->pAllocator, params->pDevice, params->client_ptr);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateDevice(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pDevice;
        PTR32 client_ptr;
        VkResult result;
    } *params = args;
    VkDeviceCreateInfo pCreateInfo_host;
    VkDevice pDevice_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pCreateInfo, params->pAllocator, params->pDevice);

    init_conversion_context(ctx);
    convert_VkDeviceCreateInfo_win32_to_host(ctx, (const VkDeviceCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    pDevice_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pDevice));
    params->result = wine_vkCreateDevice((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), &pDevice_host, UlongToPtr(params->client_ptr));
    *(PTR32 *)UlongToPtr(params->pDevice) = PtrToUlong(pDevice_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateEvent(void *args)
{
    struct vkCreateEvent_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pEvent);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateEvent(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pEvent);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateEvent(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pEvent;
        VkResult result;
    } *params = args;
    VkEventCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pEvent);

    convert_VkEventCreateInfo_win32_to_host((const VkEventCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateEvent(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkEvent *)UlongToPtr(params->pEvent));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateFence(void *args)
{
    struct vkCreateFence_params *params = args;
    VkFenceCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pFence);

    init_conversion_context(ctx);
    convert_VkFenceCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = vk_funcs->p_vkCreateFence(params->device, &pCreateInfo_host, params->pAllocator, params->pFence);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateFence(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pFence;
        VkResult result;
    } *params = args;
    VkFenceCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pFence);

    init_conversion_context(ctx);
    convert_VkFenceCreateInfo_win32_to_host(ctx, (const VkFenceCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vk_funcs->p_vkCreateFence((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkFence *)UlongToPtr(params->pFence));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateFramebuffer(void *args)
{
    struct vkCreateFramebuffer_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pFramebuffer);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateFramebuffer(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pFramebuffer);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateFramebuffer(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pFramebuffer;
        VkResult result;
    } *params = args;
    VkFramebufferCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pFramebuffer);

    init_conversion_context(ctx);
    convert_VkFramebufferCreateInfo_win32_to_host(ctx, (const VkFramebufferCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateFramebuffer(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkFramebuffer *)UlongToPtr(params->pFramebuffer));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateGraphicsPipelines(void *args)
{
    struct vkCreateGraphicsPipelines_params *params = args;
    const VkGraphicsPipelineCreateInfo *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, 0x%s, %u, %p, %p, %p\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkGraphicsPipelineCreateInfo_array_win64_to_host(ctx, params->pCreateInfos, params->createInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkCreateGraphicsPipelines(vulkan_device_from_handle(params->device)->host.device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, params->pPipelines);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateGraphicsPipelines(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pPipelines;
        VkResult result;
    } *params = args;
    const VkGraphicsPipelineCreateInfo *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkGraphicsPipelineCreateInfo_array_win32_to_host(ctx, (const VkGraphicsPipelineCreateInfo32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateGraphicsPipelines(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, (VkPipeline *)UlongToPtr(params->pPipelines));
    convert_VkGraphicsPipelineCreateInfo_array_host_to_win32(pCreateInfos_host, (VkGraphicsPipelineCreateInfo32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateImage(void *args)
{
    struct vkCreateImage_params *params = args;
    VkImageCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pImage);

    init_conversion_context(ctx);
    convert_VkImageCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = vk_funcs->p_vkCreateImage(params->device, &pCreateInfo_host, params->pAllocator, params->pImage);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateImage(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pImage;
        VkResult result;
    } *params = args;
    VkImageCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pImage);

    init_conversion_context(ctx);
    convert_VkImageCreateInfo_win32_to_host(ctx, (const VkImageCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vk_funcs->p_vkCreateImage((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkImage *)UlongToPtr(params->pImage));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateImageView(void *args)
{
    struct vkCreateImageView_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pView);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateImageView(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pView);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateImageView(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pView;
        VkResult result;
    } *params = args;
    VkImageViewCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pView);

    init_conversion_context(ctx);
    convert_VkImageViewCreateInfo_win32_to_host(ctx, (const VkImageViewCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateImageView(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkImageView *)UlongToPtr(params->pView));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateIndirectCommandsLayoutEXT(void *args)
{
    struct vkCreateIndirectCommandsLayoutEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pIndirectCommandsLayout);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateIndirectCommandsLayoutEXT(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pIndirectCommandsLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateIndirectCommandsLayoutEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pIndirectCommandsLayout;
        VkResult result;
    } *params = args;
    VkIndirectCommandsLayoutCreateInfoEXT pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pIndirectCommandsLayout);

    init_conversion_context(ctx);
    convert_VkIndirectCommandsLayoutCreateInfoEXT_win32_to_host(ctx, (const VkIndirectCommandsLayoutCreateInfoEXT32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateIndirectCommandsLayoutEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkIndirectCommandsLayoutEXT *)UlongToPtr(params->pIndirectCommandsLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateIndirectCommandsLayoutNV(void *args)
{
    struct vkCreateIndirectCommandsLayoutNV_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pIndirectCommandsLayout);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateIndirectCommandsLayoutNV(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pIndirectCommandsLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateIndirectCommandsLayoutNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pIndirectCommandsLayout;
        VkResult result;
    } *params = args;
    VkIndirectCommandsLayoutCreateInfoNV pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pIndirectCommandsLayout);

    init_conversion_context(ctx);
    convert_VkIndirectCommandsLayoutCreateInfoNV_win32_to_host(ctx, (const VkIndirectCommandsLayoutCreateInfoNV32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateIndirectCommandsLayoutNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkIndirectCommandsLayoutNV *)UlongToPtr(params->pIndirectCommandsLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateIndirectExecutionSetEXT(void *args)
{
    struct vkCreateIndirectExecutionSetEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pIndirectExecutionSet);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateIndirectExecutionSetEXT(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pIndirectExecutionSet);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateIndirectExecutionSetEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pIndirectExecutionSet;
        VkResult result;
    } *params = args;
    VkIndirectExecutionSetCreateInfoEXT pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pIndirectExecutionSet);

    init_conversion_context(ctx);
    convert_VkIndirectExecutionSetCreateInfoEXT_win32_to_host(ctx, (const VkIndirectExecutionSetCreateInfoEXT32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateIndirectExecutionSetEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkIndirectExecutionSetEXT *)UlongToPtr(params->pIndirectExecutionSet));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateInstance(void *args)
{
    struct vkCreateInstance_params *params = args;
    VkInstanceCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->pCreateInfo, params->pAllocator, params->pInstance);

    init_conversion_context(ctx);
    convert_VkInstanceCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = wine_vkCreateInstance(&pCreateInfo_host, params->pAllocator, params->pInstance, params->client_ptr);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateInstance(void *args)
{
    struct
    {
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pInstance;
        PTR32 client_ptr;
        VkResult result;
    } *params = args;
    VkInstanceCreateInfo pCreateInfo_host;
    VkInstance pInstance_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->pCreateInfo, params->pAllocator, params->pInstance);

    init_conversion_context(ctx);
    convert_VkInstanceCreateInfo_win32_to_host(ctx, (const VkInstanceCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    pInstance_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pInstance));
    params->result = wine_vkCreateInstance(&pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), &pInstance_host, UlongToPtr(params->client_ptr));
    *(PTR32 *)UlongToPtr(params->pInstance) = PtrToUlong(pInstance_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateMicromapEXT(void *args)
{
    struct vkCreateMicromapEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pMicromap);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateMicromapEXT(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pMicromap);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateMicromapEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pMicromap;
        VkResult result;
    } *params = args;
    VkMicromapCreateInfoEXT pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pMicromap);

    convert_VkMicromapCreateInfoEXT_win32_to_host((const VkMicromapCreateInfoEXT32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateMicromapEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkMicromapEXT *)UlongToPtr(params->pMicromap));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateOpticalFlowSessionNV(void *args)
{
    struct vkCreateOpticalFlowSessionNV_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSession);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateOpticalFlowSessionNV(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pSession);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateOpticalFlowSessionNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSession;
        VkResult result;
    } *params = args;
    VkOpticalFlowSessionCreateInfoNV pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSession);

    init_conversion_context(ctx);
    convert_VkOpticalFlowSessionCreateInfoNV_win32_to_host(ctx, (const VkOpticalFlowSessionCreateInfoNV32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateOpticalFlowSessionNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkOpticalFlowSessionNV *)UlongToPtr(params->pSession));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreatePipelineBinariesKHR(void *args)
{
    struct vkCreatePipelineBinariesKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pBinaries);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreatePipelineBinariesKHR(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pBinaries);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreatePipelineBinariesKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pBinaries;
        VkResult result;
    } *params = args;
    VkPipelineBinaryCreateInfoKHR pCreateInfo_host;
    VkPipelineBinaryHandlesInfoKHR pBinaries_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pBinaries);

    init_conversion_context(ctx);
    convert_VkPipelineBinaryCreateInfoKHR_win32_to_host(ctx, (const VkPipelineBinaryCreateInfoKHR32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    convert_VkPipelineBinaryHandlesInfoKHR_win32_to_host((VkPipelineBinaryHandlesInfoKHR32 *)UlongToPtr(params->pBinaries), &pBinaries_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreatePipelineBinariesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, &pBinaries_host);
    convert_VkPipelineBinaryHandlesInfoKHR_host_to_win32(&pBinaries_host, (VkPipelineBinaryHandlesInfoKHR32 *)UlongToPtr(params->pBinaries));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreatePipelineCache(void *args)
{
    struct vkCreatePipelineCache_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pPipelineCache);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreatePipelineCache(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pPipelineCache);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreatePipelineCache(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pPipelineCache;
        VkResult result;
    } *params = args;
    VkPipelineCacheCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pPipelineCache);

    convert_VkPipelineCacheCreateInfo_win32_to_host((const VkPipelineCacheCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreatePipelineCache(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkPipelineCache *)UlongToPtr(params->pPipelineCache));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreatePipelineLayout(void *args)
{
    struct vkCreatePipelineLayout_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pPipelineLayout);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreatePipelineLayout(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pPipelineLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreatePipelineLayout(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pPipelineLayout;
        VkResult result;
    } *params = args;
    VkPipelineLayoutCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pPipelineLayout);

    convert_VkPipelineLayoutCreateInfo_win32_to_host((const VkPipelineLayoutCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreatePipelineLayout(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkPipelineLayout *)UlongToPtr(params->pPipelineLayout));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreatePrivateDataSlot(void *args)
{
    struct vkCreatePrivateDataSlot_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pPrivateDataSlot);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreatePrivateDataSlot(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pPrivateDataSlot);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreatePrivateDataSlot(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pPrivateDataSlot;
        VkResult result;
    } *params = args;
    VkPrivateDataSlotCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pPrivateDataSlot);

    convert_VkPrivateDataSlotCreateInfo_win32_to_host((const VkPrivateDataSlotCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreatePrivateDataSlot(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkPrivateDataSlot *)UlongToPtr(params->pPrivateDataSlot));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreatePrivateDataSlotEXT(void *args)
{
    struct vkCreatePrivateDataSlotEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pPrivateDataSlot);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreatePrivateDataSlotEXT(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pPrivateDataSlot);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreatePrivateDataSlotEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pPrivateDataSlot;
        VkResult result;
    } *params = args;
    VkPrivateDataSlotCreateInfo pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pPrivateDataSlot);

    convert_VkPrivateDataSlotCreateInfo_win32_to_host((const VkPrivateDataSlotCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreatePrivateDataSlotEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkPrivateDataSlot *)UlongToPtr(params->pPrivateDataSlot));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateQueryPool(void *args)
{
    struct vkCreateQueryPool_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pQueryPool);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateQueryPool(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pQueryPool);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateQueryPool(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pQueryPool;
        VkResult result;
    } *params = args;
    VkQueryPoolCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pQueryPool);

    init_conversion_context(ctx);
    convert_VkQueryPoolCreateInfo_win32_to_host(ctx, (const VkQueryPoolCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateQueryPool(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkQueryPool *)UlongToPtr(params->pQueryPool));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateRayTracingPipelinesKHR(void *args)
{
    struct vkCreateRayTracingPipelinesKHR_params *params = args;
    const VkRayTracingPipelineCreateInfoKHR *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, 0x%s, 0x%s, %u, %p, %p, %p\n", params->device, wine_dbgstr_longlong(params->deferredOperation), wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    if (params->deferredOperation == VK_NULL_HANDLE)
        init_conversion_context(ctx);
    else
        ctx = &wine_deferred_operation_from_handle(params->deferredOperation)->ctx;
    pCreateInfos_host = convert_VkRayTracingPipelineCreateInfoKHR_array_win64_to_host(ctx, params->pCreateInfos, params->createInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkCreateRayTracingPipelinesKHR(vulkan_device_from_handle(params->device)->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, params->pPipelines);
    if (params->deferredOperation == VK_NULL_HANDLE)
        free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateRayTracingPipelinesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) deferredOperation;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pPipelines;
        VkResult result;
    } *params = args;
    const VkRayTracingPipelineCreateInfoKHR *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, 0x%s, %u, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->deferredOperation), wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    if (params->deferredOperation == VK_NULL_HANDLE)
        init_conversion_context(ctx);
    else
        ctx = &wine_deferred_operation_from_handle(params->deferredOperation)->ctx;
    pCreateInfos_host = convert_VkRayTracingPipelineCreateInfoKHR_array_win32_to_host(ctx, (const VkRayTracingPipelineCreateInfoKHR32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateRayTracingPipelinesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->deferredOperation ? wine_deferred_operation_from_handle(params->deferredOperation)->host.deferred_operation : 0, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, (VkPipeline *)UlongToPtr(params->pPipelines));
    convert_VkRayTracingPipelineCreateInfoKHR_array_host_to_win32(pCreateInfos_host, (VkRayTracingPipelineCreateInfoKHR32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    if (params->deferredOperation == VK_NULL_HANDLE)
        free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateRayTracingPipelinesNV(void *args)
{
    struct vkCreateRayTracingPipelinesNV_params *params = args;
    const VkRayTracingPipelineCreateInfoNV *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, 0x%s, %u, %p, %p, %p\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkRayTracingPipelineCreateInfoNV_array_win64_to_host(ctx, params->pCreateInfos, params->createInfoCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkCreateRayTracingPipelinesNV(vulkan_device_from_handle(params->device)->host.device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, params->pPipelines);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateRayTracingPipelinesNV(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pPipelines;
        VkResult result;
    } *params = args;
    const VkRayTracingPipelineCreateInfoNV *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pPipelines);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkRayTracingPipelineCreateInfoNV_array_win32_to_host(ctx, (const VkRayTracingPipelineCreateInfoNV32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateRayTracingPipelinesNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipelineCache, params->createInfoCount, pCreateInfos_host, NULL, (VkPipeline *)UlongToPtr(params->pPipelines));
    convert_VkRayTracingPipelineCreateInfoNV_array_host_to_win32(pCreateInfos_host, (VkRayTracingPipelineCreateInfoNV32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateRenderPass(void *args)
{
    struct vkCreateRenderPass_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateRenderPass(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pRenderPass);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateRenderPass(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pRenderPass;
        VkResult result;
    } *params = args;
    VkRenderPassCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    init_conversion_context(ctx);
    convert_VkRenderPassCreateInfo_win32_to_host(ctx, (const VkRenderPassCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateRenderPass(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkRenderPass *)UlongToPtr(params->pRenderPass));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateRenderPass2(void *args)
{
    struct vkCreateRenderPass2_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateRenderPass2(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pRenderPass);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateRenderPass2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pRenderPass;
        VkResult result;
    } *params = args;
    VkRenderPassCreateInfo2 pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    init_conversion_context(ctx);
    convert_VkRenderPassCreateInfo2_win32_to_host(ctx, (const VkRenderPassCreateInfo232 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateRenderPass2(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkRenderPass *)UlongToPtr(params->pRenderPass));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateRenderPass2KHR(void *args)
{
    struct vkCreateRenderPass2KHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateRenderPass2KHR(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pRenderPass);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateRenderPass2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pRenderPass;
        VkResult result;
    } *params = args;
    VkRenderPassCreateInfo2 pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pRenderPass);

    init_conversion_context(ctx);
    convert_VkRenderPassCreateInfo2_win32_to_host(ctx, (const VkRenderPassCreateInfo232 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateRenderPass2KHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkRenderPass *)UlongToPtr(params->pRenderPass));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateSampler(void *args)
{
    struct vkCreateSampler_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSampler);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateSampler(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pSampler);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateSampler(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSampler;
        VkResult result;
    } *params = args;
    VkSamplerCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSampler);

    init_conversion_context(ctx);
    convert_VkSamplerCreateInfo_win32_to_host(ctx, (const VkSamplerCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateSampler(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkSampler *)UlongToPtr(params->pSampler));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateSamplerYcbcrConversion(void *args)
{
    struct vkCreateSamplerYcbcrConversion_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pYcbcrConversion);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateSamplerYcbcrConversion(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pYcbcrConversion);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateSamplerYcbcrConversion(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pYcbcrConversion;
        VkResult result;
    } *params = args;
    VkSamplerYcbcrConversionCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pYcbcrConversion);

    init_conversion_context(ctx);
    convert_VkSamplerYcbcrConversionCreateInfo_win32_to_host(ctx, (const VkSamplerYcbcrConversionCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateSamplerYcbcrConversion(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkSamplerYcbcrConversion *)UlongToPtr(params->pYcbcrConversion));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateSamplerYcbcrConversionKHR(void *args)
{
    struct vkCreateSamplerYcbcrConversionKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pYcbcrConversion);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateSamplerYcbcrConversionKHR(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pYcbcrConversion);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateSamplerYcbcrConversionKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pYcbcrConversion;
        VkResult result;
    } *params = args;
    VkSamplerYcbcrConversionCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pYcbcrConversion);

    init_conversion_context(ctx);
    convert_VkSamplerYcbcrConversionCreateInfo_win32_to_host(ctx, (const VkSamplerYcbcrConversionCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateSamplerYcbcrConversionKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkSamplerYcbcrConversion *)UlongToPtr(params->pYcbcrConversion));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateSemaphore(void *args)
{
    struct vkCreateSemaphore_params *params = args;
    VkSemaphoreCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSemaphore);

    init_conversion_context(ctx);
    convert_VkSemaphoreCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    params->result = vk_funcs->p_vkCreateSemaphore(params->device, &pCreateInfo_host, params->pAllocator, params->pSemaphore);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateSemaphore(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSemaphore;
        VkResult result;
    } *params = args;
    VkSemaphoreCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSemaphore);

    init_conversion_context(ctx);
    convert_VkSemaphoreCreateInfo_win32_to_host(ctx, (const VkSemaphoreCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vk_funcs->p_vkCreateSemaphore((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkSemaphore *)UlongToPtr(params->pSemaphore));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateShaderModule(void *args)
{
    struct vkCreateShaderModule_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pShaderModule);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateShaderModule(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pShaderModule);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateShaderModule(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pShaderModule;
        VkResult result;
    } *params = args;
    VkShaderModuleCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pShaderModule);

    init_conversion_context(ctx);
    convert_VkShaderModuleCreateInfo_win32_to_host(ctx, (const VkShaderModuleCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateShaderModule(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkShaderModule *)UlongToPtr(params->pShaderModule));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateShadersEXT(void *args)
{
    struct vkCreateShadersEXT_params *params = args;

    TRACE("%p, %u, %p, %p, %p\n", params->device, params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pShaders);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateShadersEXT(vulkan_device_from_handle(params->device)->host.device, params->createInfoCount, params->pCreateInfos, NULL, params->pShaders);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateShadersEXT(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t createInfoCount;
        PTR32 pCreateInfos;
        PTR32 pAllocator;
        PTR32 pShaders;
        VkResult result;
    } *params = args;
    const VkShaderCreateInfoEXT *pCreateInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %#x, %#x\n", params->device, params->createInfoCount, params->pCreateInfos, params->pAllocator, params->pShaders);

    init_conversion_context(ctx);
    pCreateInfos_host = convert_VkShaderCreateInfoEXT_array_win32_to_host(ctx, (const VkShaderCreateInfoEXT32 *)UlongToPtr(params->pCreateInfos), params->createInfoCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateShadersEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->createInfoCount, pCreateInfos_host, NULL, (VkShaderEXT *)UlongToPtr(params->pShaders));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateSwapchainKHR(void *args)
{
    struct vkCreateSwapchainKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pSwapchain);

    params->result = vk_funcs->p_vkCreateSwapchainKHR(params->device, params->pCreateInfo, params->pAllocator, params->pSwapchain);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateSwapchainKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSwapchain;
        VkResult result;
    } *params = args;
    VkSwapchainCreateInfoKHR pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pSwapchain);

    init_conversion_context(ctx);
    convert_VkSwapchainCreateInfoKHR_win32_to_unwrapped_host(ctx, (const VkSwapchainCreateInfoKHR32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vk_funcs->p_vkCreateSwapchainKHR((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkSwapchainKHR *)UlongToPtr(params->pSwapchain));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateTensorARM(void *args)
{
    struct vkCreateTensorARM_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pTensor);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateTensorARM(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pTensor);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateTensorARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pTensor;
        VkResult result;
    } *params = args;
    VkTensorCreateInfoARM pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pTensor);

    init_conversion_context(ctx);
    convert_VkTensorCreateInfoARM_win32_to_host(ctx, (const VkTensorCreateInfoARM32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateTensorARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkTensorARM *)UlongToPtr(params->pTensor));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateTensorViewARM(void *args)
{
    struct vkCreateTensorViewARM_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pView);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateTensorViewARM(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pView);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateTensorViewARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pView;
        VkResult result;
    } *params = args;
    VkTensorViewCreateInfoARM pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pView);

    init_conversion_context(ctx);
    convert_VkTensorViewCreateInfoARM_win32_to_host(ctx, (const VkTensorViewCreateInfoARM32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateTensorViewARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkTensorViewARM *)UlongToPtr(params->pView));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateValidationCacheEXT(void *args)
{
    struct vkCreateValidationCacheEXT_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pValidationCache);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateValidationCacheEXT(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pValidationCache);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateValidationCacheEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pValidationCache;
        VkResult result;
    } *params = args;
    VkValidationCacheCreateInfoEXT pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pValidationCache);

    convert_VkValidationCacheCreateInfoEXT_win32_to_host((const VkValidationCacheCreateInfoEXT32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateValidationCacheEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkValidationCacheEXT *)UlongToPtr(params->pValidationCache));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateVideoSessionKHR(void *args)
{
    struct vkCreateVideoSessionKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pVideoSession);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateVideoSessionKHR(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pVideoSession);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateVideoSessionKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pVideoSession;
        VkResult result;
    } *params = args;
    VkVideoSessionCreateInfoKHR pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pVideoSession);

    init_conversion_context(ctx);
    convert_VkVideoSessionCreateInfoKHR_win32_to_host(ctx, (const VkVideoSessionCreateInfoKHR32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateVideoSessionKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkVideoSessionKHR *)UlongToPtr(params->pVideoSession));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateVideoSessionParametersKHR(void *args)
{
    struct vkCreateVideoSessionParametersKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pVideoSessionParameters);

    params->result = vulkan_device_from_handle(params->device)->p_vkCreateVideoSessionParametersKHR(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pVideoSessionParameters);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateVideoSessionParametersKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pVideoSessionParameters;
        VkResult result;
    } *params = args;
    VkVideoSessionParametersCreateInfoKHR pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pAllocator, params->pVideoSessionParameters);

    init_conversion_context(ctx);
    convert_VkVideoSessionParametersCreateInfoKHR_win32_to_host(ctx, (const VkVideoSessionParametersCreateInfoKHR32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateVideoSessionParametersKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkVideoSessionParametersKHR *)UlongToPtr(params->pVideoSessionParameters));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkCreateWin32SurfaceKHR(void *args)
{
    struct vkCreateWin32SurfaceKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->instance, params->pCreateInfo, params->pAllocator, params->pSurface);

    params->result = vk_funcs->p_vkCreateWin32SurfaceKHR(params->instance, params->pCreateInfo, params->pAllocator, params->pSurface);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkCreateWin32SurfaceKHR(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pCreateInfo;
        PTR32 pAllocator;
        PTR32 pSurface;
        VkResult result;
    } *params = args;
    VkWin32SurfaceCreateInfoKHR pCreateInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->instance, params->pCreateInfo, params->pAllocator, params->pSurface);

    convert_VkWin32SurfaceCreateInfoKHR_win32_to_host((const VkWin32SurfaceCreateInfoKHR32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    params->result = vk_funcs->p_vkCreateWin32SurfaceKHR((VkInstance)UlongToPtr(params->instance), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkSurfaceKHR *)UlongToPtr(params->pSurface));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDebugMarkerSetObjectNameEXT(void *args)
{
    struct vkDebugMarkerSetObjectNameEXT_params *params = args;
    VkDebugMarkerObjectNameInfoEXT pNameInfo_host;

    TRACE("%p, %p\n", params->device, params->pNameInfo);

    convert_VkDebugMarkerObjectNameInfoEXT_win64_to_host(params->pNameInfo, &pNameInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkDebugMarkerSetObjectNameEXT(vulkan_device_from_handle(params->device)->host.device, &pNameInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDebugMarkerSetObjectNameEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pNameInfo;
        VkResult result;
    } *params = args;
    VkDebugMarkerObjectNameInfoEXT pNameInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pNameInfo);

    convert_VkDebugMarkerObjectNameInfoEXT_win32_to_host((const VkDebugMarkerObjectNameInfoEXT32 *)UlongToPtr(params->pNameInfo), &pNameInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDebugMarkerSetObjectNameEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pNameInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDebugMarkerSetObjectTagEXT(void *args)
{
    struct vkDebugMarkerSetObjectTagEXT_params *params = args;
    VkDebugMarkerObjectTagInfoEXT pTagInfo_host;

    TRACE("%p, %p\n", params->device, params->pTagInfo);

    convert_VkDebugMarkerObjectTagInfoEXT_win64_to_host(params->pTagInfo, &pTagInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkDebugMarkerSetObjectTagEXT(vulkan_device_from_handle(params->device)->host.device, &pTagInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDebugMarkerSetObjectTagEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pTagInfo;
        VkResult result;
    } *params = args;
    VkDebugMarkerObjectTagInfoEXT pTagInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pTagInfo);

    convert_VkDebugMarkerObjectTagInfoEXT_win32_to_host((const VkDebugMarkerObjectTagInfoEXT32 *)UlongToPtr(params->pTagInfo), &pTagInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDebugMarkerSetObjectTagEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pTagInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDebugReportMessageEXT(void *args)
{
    struct vkDebugReportMessageEXT_params *params = args;

    TRACE("%p, %#x, %#x, 0x%s, 0x%s, %d, %p, %p\n", params->instance, params->flags, params->objectType, wine_dbgstr_longlong(params->object), wine_dbgstr_longlong(params->location), params->messageCode, params->pLayerPrefix, params->pMessage);

    vulkan_instance_from_handle(params->instance)->p_vkDebugReportMessageEXT(vulkan_instance_from_handle(params->instance)->host.instance, params->flags, params->objectType, wine_vk_unwrap_handle(params->objectType, params->object), params->location, params->messageCode, params->pLayerPrefix, params->pMessage);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDebugReportMessageEXT(void *args)
{
    struct
    {
        PTR32 instance;
        VkDebugReportFlagsEXT flags;
        VkDebugReportObjectTypeEXT objectType;
        uint64_t DECLSPEC_ALIGN(8) object;
        PTR32 location;
        int32_t messageCode;
        PTR32 pLayerPrefix;
        PTR32 pMessage;
    } *params = args;

    TRACE("%#x, %#x, %#x, 0x%s, 0x%s, %d, %#x, %#x\n", params->instance, params->flags, params->objectType, wine_dbgstr_longlong(params->object), wine_dbgstr_longlong(params->location), params->messageCode, params->pLayerPrefix, params->pMessage);

    vulkan_instance_from_handle((VkInstance)UlongToPtr(params->instance))->p_vkDebugReportMessageEXT(vulkan_instance_from_handle((VkInstance)UlongToPtr(params->instance))->host.instance, params->flags, params->objectType, wine_vk_unwrap_handle(params->objectType, params->object), params->location, params->messageCode, (const char *)UlongToPtr(params->pLayerPrefix), (const char *)UlongToPtr(params->pMessage));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDeferredOperationJoinKHR(void *args)
{
    struct vkDeferredOperationJoinKHR_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = vulkan_device_from_handle(params->device)->p_vkDeferredOperationJoinKHR(vulkan_device_from_handle(params->device)->host.device, wine_deferred_operation_from_handle(params->operation)->host.deferred_operation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDeferredOperationJoinKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) operation;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDeferredOperationJoinKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, wine_deferred_operation_from_handle(params->operation)->host.deferred_operation);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyAccelerationStructureKHR(void *args)
{
    struct vkDestroyAccelerationStructureKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyAccelerationStructureKHR(vulkan_device_from_handle(params->device)->host.device, params->accelerationStructure, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyAccelerationStructureKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkAccelerationStructureKHR DECLSPEC_ALIGN(8) accelerationStructure;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyAccelerationStructureKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->accelerationStructure, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyAccelerationStructureNV(void *args)
{
    struct vkDestroyAccelerationStructureNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyAccelerationStructureNV(vulkan_device_from_handle(params->device)->host.device, params->accelerationStructure, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyAccelerationStructureNV(void *args)
{
    struct
    {
        PTR32 device;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) accelerationStructure;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyAccelerationStructureNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->accelerationStructure, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyBuffer(void *args)
{
    struct vkDestroyBuffer_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->buffer), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyBuffer(vulkan_device_from_handle(params->device)->host.device, params->buffer, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyBuffer(void *args)
{
    struct
    {
        PTR32 device;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->buffer), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyBuffer(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->buffer, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyBufferView(void *args)
{
    struct vkDestroyBufferView_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->bufferView), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyBufferView(vulkan_device_from_handle(params->device)->host.device, params->bufferView, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyBufferView(void *args)
{
    struct
    {
        PTR32 device;
        VkBufferView DECLSPEC_ALIGN(8) bufferView;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->bufferView), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyBufferView(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->bufferView, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyCommandPool(void *args)
{
    struct vkDestroyCommandPool_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->commandPool), params->pAllocator);

    wine_vkDestroyCommandPool(params->device, params->commandPool, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyCommandPool(void *args)
{
    struct
    {
        PTR32 device;
        VkCommandPool DECLSPEC_ALIGN(8) commandPool;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->pAllocator);

    wine_vkDestroyCommandPool((VkDevice)UlongToPtr(params->device), params->commandPool, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyCuFunctionNVX(void *args)
{
    struct vkDestroyCuFunctionNVX_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->function), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyCuFunctionNVX(vulkan_device_from_handle(params->device)->host.device, params->function, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyCuFunctionNVX(void *args)
{
    struct
    {
        PTR32 device;
        VkCuFunctionNVX DECLSPEC_ALIGN(8) function;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->function), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyCuFunctionNVX(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->function, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyCuModuleNVX(void *args)
{
    struct vkDestroyCuModuleNVX_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->module), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyCuModuleNVX(vulkan_device_from_handle(params->device)->host.device, params->module, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyCuModuleNVX(void *args)
{
    struct
    {
        PTR32 device;
        VkCuModuleNVX DECLSPEC_ALIGN(8) module;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->module), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyCuModuleNVX(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->module, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDataGraphPipelineSessionARM(void *args)
{
    struct vkDestroyDataGraphPipelineSessionARM_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->session), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyDataGraphPipelineSessionARM(vulkan_device_from_handle(params->device)->host.device, params->session, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDataGraphPipelineSessionARM(void *args)
{
    struct
    {
        PTR32 device;
        VkDataGraphPipelineSessionARM DECLSPEC_ALIGN(8) session;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->session), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyDataGraphPipelineSessionARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->session, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDebugReportCallbackEXT(void *args)
{
    struct vkDestroyDebugReportCallbackEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->instance, wine_dbgstr_longlong(params->callback), params->pAllocator);

    wine_vkDestroyDebugReportCallbackEXT(params->instance, params->callback, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDebugReportCallbackEXT(void *args)
{
    struct
    {
        PTR32 instance;
        VkDebugReportCallbackEXT DECLSPEC_ALIGN(8) callback;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->instance, wine_dbgstr_longlong(params->callback), params->pAllocator);

    wine_vkDestroyDebugReportCallbackEXT((VkInstance)UlongToPtr(params->instance), params->callback, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDebugUtilsMessengerEXT(void *args)
{
    struct vkDestroyDebugUtilsMessengerEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->instance, wine_dbgstr_longlong(params->messenger), params->pAllocator);

    wine_vkDestroyDebugUtilsMessengerEXT(params->instance, params->messenger, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDebugUtilsMessengerEXT(void *args)
{
    struct
    {
        PTR32 instance;
        VkDebugUtilsMessengerEXT DECLSPEC_ALIGN(8) messenger;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->instance, wine_dbgstr_longlong(params->messenger), params->pAllocator);

    wine_vkDestroyDebugUtilsMessengerEXT((VkInstance)UlongToPtr(params->instance), params->messenger, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDeferredOperationKHR(void *args)
{
    struct vkDestroyDeferredOperationKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->operation), params->pAllocator);

    wine_vkDestroyDeferredOperationKHR(params->device, params->operation, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDeferredOperationKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) operation;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->operation), params->pAllocator);

    wine_vkDestroyDeferredOperationKHR((VkDevice)UlongToPtr(params->device), params->operation, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDescriptorPool(void *args)
{
    struct vkDestroyDescriptorPool_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyDescriptorPool(vulkan_device_from_handle(params->device)->host.device, params->descriptorPool, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDescriptorPool(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorPool DECLSPEC_ALIGN(8) descriptorPool;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyDescriptorPool(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->descriptorPool, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDescriptorSetLayout(void *args)
{
    struct vkDestroyDescriptorSetLayout_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorSetLayout), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyDescriptorSetLayout(vulkan_device_from_handle(params->device)->host.device, params->descriptorSetLayout, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDescriptorSetLayout(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSetLayout DECLSPEC_ALIGN(8) descriptorSetLayout;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorSetLayout), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyDescriptorSetLayout(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->descriptorSetLayout, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDescriptorUpdateTemplate(void *args)
{
    struct vkDestroyDescriptorUpdateTemplate_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyDescriptorUpdateTemplate(vulkan_device_from_handle(params->device)->host.device, params->descriptorUpdateTemplate, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDescriptorUpdateTemplate(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyDescriptorUpdateTemplate(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->descriptorUpdateTemplate, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDescriptorUpdateTemplateKHR(void *args)
{
    struct vkDestroyDescriptorUpdateTemplateKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyDescriptorUpdateTemplateKHR(vulkan_device_from_handle(params->device)->host.device, params->descriptorUpdateTemplate, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDescriptorUpdateTemplateKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyDescriptorUpdateTemplateKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->descriptorUpdateTemplate, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyDevice(void *args)
{
    struct vkDestroyDevice_params *params = args;

    TRACE("%p, %p\n", params->device, params->pAllocator);

    if (!params->device)
        return STATUS_SUCCESS;

    wine_vkDestroyDevice(params->device, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyDevice(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, %#x\n", params->device, params->pAllocator);

    if (!params->device)
        return STATUS_SUCCESS;

    wine_vkDestroyDevice((VkDevice)UlongToPtr(params->device), (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyEvent(void *args)
{
    struct vkDestroyEvent_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->event), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyEvent(vulkan_device_from_handle(params->device)->host.device, params->event, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyEvent(void *args)
{
    struct
    {
        PTR32 device;
        VkEvent DECLSPEC_ALIGN(8) event;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->event), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyEvent(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->event, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyFence(void *args)
{
    struct vkDestroyFence_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->fence), params->pAllocator);

    vk_funcs->p_vkDestroyFence(params->device, params->fence, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyFence(void *args)
{
    struct
    {
        PTR32 device;
        VkFence DECLSPEC_ALIGN(8) fence;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->fence), params->pAllocator);

    vk_funcs->p_vkDestroyFence((VkDevice)UlongToPtr(params->device), params->fence, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyFramebuffer(void *args)
{
    struct vkDestroyFramebuffer_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->framebuffer), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyFramebuffer(vulkan_device_from_handle(params->device)->host.device, params->framebuffer, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyFramebuffer(void *args)
{
    struct
    {
        PTR32 device;
        VkFramebuffer DECLSPEC_ALIGN(8) framebuffer;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->framebuffer), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyFramebuffer(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->framebuffer, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyImage(void *args)
{
    struct vkDestroyImage_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyImage(vulkan_device_from_handle(params->device)->host.device, params->image, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyImage(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyImage(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyImageView(void *args)
{
    struct vkDestroyImageView_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->imageView), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyImageView(vulkan_device_from_handle(params->device)->host.device, params->imageView, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyImageView(void *args)
{
    struct
    {
        PTR32 device;
        VkImageView DECLSPEC_ALIGN(8) imageView;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->imageView), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyImageView(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->imageView, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyIndirectCommandsLayoutEXT(void *args)
{
    struct vkDestroyIndirectCommandsLayoutEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->indirectCommandsLayout), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyIndirectCommandsLayoutEXT(vulkan_device_from_handle(params->device)->host.device, params->indirectCommandsLayout, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyIndirectCommandsLayoutEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkIndirectCommandsLayoutEXT DECLSPEC_ALIGN(8) indirectCommandsLayout;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->indirectCommandsLayout), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyIndirectCommandsLayoutEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->indirectCommandsLayout, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyIndirectCommandsLayoutNV(void *args)
{
    struct vkDestroyIndirectCommandsLayoutNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->indirectCommandsLayout), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyIndirectCommandsLayoutNV(vulkan_device_from_handle(params->device)->host.device, params->indirectCommandsLayout, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyIndirectCommandsLayoutNV(void *args)
{
    struct
    {
        PTR32 device;
        VkIndirectCommandsLayoutNV DECLSPEC_ALIGN(8) indirectCommandsLayout;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->indirectCommandsLayout), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyIndirectCommandsLayoutNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->indirectCommandsLayout, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyIndirectExecutionSetEXT(void *args)
{
    struct vkDestroyIndirectExecutionSetEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->indirectExecutionSet), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyIndirectExecutionSetEXT(vulkan_device_from_handle(params->device)->host.device, params->indirectExecutionSet, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyIndirectExecutionSetEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkIndirectExecutionSetEXT DECLSPEC_ALIGN(8) indirectExecutionSet;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->indirectExecutionSet), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyIndirectExecutionSetEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->indirectExecutionSet, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyInstance(void *args)
{
    struct vkDestroyInstance_params *params = args;

    TRACE("%p, %p\n", params->instance, params->pAllocator);

    if (!params->instance)
        return STATUS_SUCCESS;

    wine_vkDestroyInstance(params->instance, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyInstance(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, %#x\n", params->instance, params->pAllocator);

    if (!params->instance)
        return STATUS_SUCCESS;

    wine_vkDestroyInstance((VkInstance)UlongToPtr(params->instance), (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyMicromapEXT(void *args)
{
    struct vkDestroyMicromapEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->micromap), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyMicromapEXT(vulkan_device_from_handle(params->device)->host.device, params->micromap, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyMicromapEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkMicromapEXT DECLSPEC_ALIGN(8) micromap;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->micromap), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyMicromapEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->micromap, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyOpticalFlowSessionNV(void *args)
{
    struct vkDestroyOpticalFlowSessionNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->session), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyOpticalFlowSessionNV(vulkan_device_from_handle(params->device)->host.device, params->session, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyOpticalFlowSessionNV(void *args)
{
    struct
    {
        PTR32 device;
        VkOpticalFlowSessionNV DECLSPEC_ALIGN(8) session;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->session), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyOpticalFlowSessionNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->session, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPipeline(void *args)
{
    struct vkDestroyPipeline_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipeline), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyPipeline(vulkan_device_from_handle(params->device)->host.device, params->pipeline, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPipeline(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyPipeline(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipeline, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPipelineBinaryKHR(void *args)
{
    struct vkDestroyPipelineBinaryKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipelineBinary), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyPipelineBinaryKHR(vulkan_device_from_handle(params->device)->host.device, params->pipelineBinary, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPipelineBinaryKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineBinaryKHR DECLSPEC_ALIGN(8) pipelineBinary;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineBinary), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyPipelineBinaryKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipelineBinary, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPipelineCache(void *args)
{
    struct vkDestroyPipelineCache_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyPipelineCache(vulkan_device_from_handle(params->device)->host.device, params->pipelineCache, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPipelineCache(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyPipelineCache(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipelineCache, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPipelineLayout(void *args)
{
    struct vkDestroyPipelineLayout_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipelineLayout), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyPipelineLayout(vulkan_device_from_handle(params->device)->host.device, params->pipelineLayout, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPipelineLayout(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineLayout DECLSPEC_ALIGN(8) pipelineLayout;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineLayout), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyPipelineLayout(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipelineLayout, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPrivateDataSlot(void *args)
{
    struct vkDestroyPrivateDataSlot_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->privateDataSlot), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyPrivateDataSlot(vulkan_device_from_handle(params->device)->host.device, params->privateDataSlot, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPrivateDataSlot(void *args)
{
    struct
    {
        PTR32 device;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->privateDataSlot), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyPrivateDataSlot(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->privateDataSlot, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyPrivateDataSlotEXT(void *args)
{
    struct vkDestroyPrivateDataSlotEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->privateDataSlot), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyPrivateDataSlotEXT(vulkan_device_from_handle(params->device)->host.device, params->privateDataSlot, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyPrivateDataSlotEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->privateDataSlot), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyPrivateDataSlotEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->privateDataSlot, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyQueryPool(void *args)
{
    struct vkDestroyQueryPool_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->queryPool), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyQueryPool(vulkan_device_from_handle(params->device)->host.device, params->queryPool, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyQueryPool(void *args)
{
    struct
    {
        PTR32 device;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->queryPool), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyQueryPool(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->queryPool, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyRenderPass(void *args)
{
    struct vkDestroyRenderPass_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->renderPass), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyRenderPass(vulkan_device_from_handle(params->device)->host.device, params->renderPass, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyRenderPass(void *args)
{
    struct
    {
        PTR32 device;
        VkRenderPass DECLSPEC_ALIGN(8) renderPass;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->renderPass), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyRenderPass(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->renderPass, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySampler(void *args)
{
    struct vkDestroySampler_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->sampler), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroySampler(vulkan_device_from_handle(params->device)->host.device, params->sampler, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySampler(void *args)
{
    struct
    {
        PTR32 device;
        VkSampler DECLSPEC_ALIGN(8) sampler;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->sampler), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroySampler(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->sampler, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySamplerYcbcrConversion(void *args)
{
    struct vkDestroySamplerYcbcrConversion_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->ycbcrConversion), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroySamplerYcbcrConversion(vulkan_device_from_handle(params->device)->host.device, params->ycbcrConversion, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySamplerYcbcrConversion(void *args)
{
    struct
    {
        PTR32 device;
        VkSamplerYcbcrConversion DECLSPEC_ALIGN(8) ycbcrConversion;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->ycbcrConversion), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroySamplerYcbcrConversion(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->ycbcrConversion, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySamplerYcbcrConversionKHR(void *args)
{
    struct vkDestroySamplerYcbcrConversionKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->ycbcrConversion), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroySamplerYcbcrConversionKHR(vulkan_device_from_handle(params->device)->host.device, params->ycbcrConversion, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySamplerYcbcrConversionKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSamplerYcbcrConversion DECLSPEC_ALIGN(8) ycbcrConversion;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->ycbcrConversion), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroySamplerYcbcrConversionKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->ycbcrConversion, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySemaphore(void *args)
{
    struct vkDestroySemaphore_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pAllocator);

    vk_funcs->p_vkDestroySemaphore(params->device, params->semaphore, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySemaphore(void *args)
{
    struct
    {
        PTR32 device;
        VkSemaphore DECLSPEC_ALIGN(8) semaphore;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pAllocator);

    vk_funcs->p_vkDestroySemaphore((VkDevice)UlongToPtr(params->device), params->semaphore, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyShaderEXT(void *args)
{
    struct vkDestroyShaderEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->shader), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyShaderEXT(vulkan_device_from_handle(params->device)->host.device, params->shader, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyShaderEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkShaderEXT DECLSPEC_ALIGN(8) shader;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->shader), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyShaderEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->shader, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyShaderModule(void *args)
{
    struct vkDestroyShaderModule_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->shaderModule), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyShaderModule(vulkan_device_from_handle(params->device)->host.device, params->shaderModule, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyShaderModule(void *args)
{
    struct
    {
        PTR32 device;
        VkShaderModule DECLSPEC_ALIGN(8) shaderModule;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->shaderModule), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyShaderModule(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->shaderModule, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySurfaceKHR(void *args)
{
    struct vkDestroySurfaceKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->instance, wine_dbgstr_longlong(params->surface), params->pAllocator);

    vk_funcs->p_vkDestroySurfaceKHR(params->instance, params->surface, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySurfaceKHR(void *args)
{
    struct
    {
        PTR32 instance;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->instance, wine_dbgstr_longlong(params->surface), params->pAllocator);

    vk_funcs->p_vkDestroySurfaceKHR((VkInstance)UlongToPtr(params->instance), params->surface, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroySwapchainKHR(void *args)
{
    struct vkDestroySwapchainKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pAllocator);

    vk_funcs->p_vkDestroySwapchainKHR(params->device, params->swapchain, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroySwapchainKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pAllocator);

    vk_funcs->p_vkDestroySwapchainKHR((VkDevice)UlongToPtr(params->device), params->swapchain, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyTensorARM(void *args)
{
    struct vkDestroyTensorARM_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->tensor), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyTensorARM(vulkan_device_from_handle(params->device)->host.device, params->tensor, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyTensorARM(void *args)
{
    struct
    {
        PTR32 device;
        VkTensorARM DECLSPEC_ALIGN(8) tensor;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->tensor), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyTensorARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->tensor, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyTensorViewARM(void *args)
{
    struct vkDestroyTensorViewARM_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->tensorView), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyTensorViewARM(vulkan_device_from_handle(params->device)->host.device, params->tensorView, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyTensorViewARM(void *args)
{
    struct
    {
        PTR32 device;
        VkTensorViewARM DECLSPEC_ALIGN(8) tensorView;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->tensorView), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyTensorViewARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->tensorView, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyValidationCacheEXT(void *args)
{
    struct vkDestroyValidationCacheEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->validationCache), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyValidationCacheEXT(vulkan_device_from_handle(params->device)->host.device, params->validationCache, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyValidationCacheEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkValidationCacheEXT DECLSPEC_ALIGN(8) validationCache;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->validationCache), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyValidationCacheEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->validationCache, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyVideoSessionKHR(void *args)
{
    struct vkDestroyVideoSessionKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->videoSession), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyVideoSessionKHR(vulkan_device_from_handle(params->device)->host.device, params->videoSession, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyVideoSessionKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkVideoSessionKHR DECLSPEC_ALIGN(8) videoSession;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->videoSession), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyVideoSessionKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->videoSession, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDestroyVideoSessionParametersKHR(void *args)
{
    struct vkDestroyVideoSessionParametersKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->videoSessionParameters), params->pAllocator);

    vulkan_device_from_handle(params->device)->p_vkDestroyVideoSessionParametersKHR(vulkan_device_from_handle(params->device)->host.device, params->videoSessionParameters, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDestroyVideoSessionParametersKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkVideoSessionParametersKHR DECLSPEC_ALIGN(8) videoSessionParameters;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->videoSessionParameters), params->pAllocator);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyVideoSessionParametersKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->videoSessionParameters, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkDeviceWaitIdle(void *args)
{
    struct vkDeviceWaitIdle_params *params = args;

    TRACE("%p\n", params->device);

    params->result = vulkan_device_from_handle(params->device)->p_vkDeviceWaitIdle(vulkan_device_from_handle(params->device)->host.device);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkDeviceWaitIdle(void *args)
{
    struct
    {
        PTR32 device;
        VkResult result;
    } *params = args;

    TRACE("%#x\n", params->device);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDeviceWaitIdle(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEndCommandBuffer(void *args)
{
    struct vkEndCommandBuffer_params *params = args;

    TRACE("%p\n", params->commandBuffer);

    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkEndCommandBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEndCommandBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkResult result;
    } *params = args;

    TRACE("%#x\n", params->commandBuffer);

    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkEndCommandBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumerateDeviceExtensionProperties(void *args)
{
    struct vkEnumerateDeviceExtensionProperties_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pLayerName, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateDeviceExtensionProperties(params->physicalDevice, params->pLayerName, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumerateDeviceExtensionProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pLayerName;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pLayerName, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateDeviceExtensionProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), (const char *)UlongToPtr(params->pLayerName), (uint32_t *)UlongToPtr(params->pPropertyCount), (VkExtensionProperties *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumerateDeviceLayerProperties(void *args)
{
    struct vkEnumerateDeviceLayerProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateDeviceLayerProperties(params->physicalDevice, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumerateDeviceLayerProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateDeviceLayerProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), (uint32_t *)UlongToPtr(params->pPropertyCount), (VkLayerProperties *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumerateInstanceExtensionProperties(void *args)
{
    struct vkEnumerateInstanceExtensionProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->pLayerName, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateInstanceExtensionProperties(params->pLayerName, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumerateInstanceExtensionProperties(void *args)
{
    struct
    {
        PTR32 pLayerName;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->pLayerName, params->pPropertyCount, params->pProperties);

    params->result = wine_vkEnumerateInstanceExtensionProperties((const char *)UlongToPtr(params->pLayerName), (uint32_t *)UlongToPtr(params->pPropertyCount), (VkExtensionProperties *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumerateInstanceVersion(void *args)
{
    struct vkEnumerateInstanceVersion_params *params = args;

    TRACE("%p\n", params->pApiVersion);

    params->result = wine_vkEnumerateInstanceVersion(params->pApiVersion);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumerateInstanceVersion(void *args)
{
    struct
    {
        PTR32 pApiVersion;
        VkResult result;
    } *params = args;

    TRACE("%#x\n", params->pApiVersion);

    params->result = wine_vkEnumerateInstanceVersion((uint32_t *)UlongToPtr(params->pApiVersion));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumeratePhysicalDeviceGroups(void *args)
{
    struct vkEnumeratePhysicalDeviceGroups_params *params = args;

    TRACE("%p, %p, %p\n", params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);

    params->result = wine_vkEnumeratePhysicalDeviceGroups(params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumeratePhysicalDeviceGroups(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pPhysicalDeviceGroupCount;
        PTR32 pPhysicalDeviceGroupProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);

    init_conversion_context(ctx);
    pPhysicalDeviceGroupProperties_host = convert_VkPhysicalDeviceGroupProperties_array_win32_to_unwrapped_host(ctx, (VkPhysicalDeviceGroupProperties32 *)UlongToPtr(params->pPhysicalDeviceGroupProperties), *(uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount));
    params->result = wine_vkEnumeratePhysicalDeviceGroups((VkInstance)UlongToPtr(params->instance), (uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount), pPhysicalDeviceGroupProperties_host);
    convert_VkPhysicalDeviceGroupProperties_array_unwrapped_host_to_win32(pPhysicalDeviceGroupProperties_host, (VkPhysicalDeviceGroupProperties32 *)UlongToPtr(params->pPhysicalDeviceGroupProperties), *(uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumeratePhysicalDeviceGroupsKHR(void *args)
{
    struct vkEnumeratePhysicalDeviceGroupsKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);

    params->result = wine_vkEnumeratePhysicalDeviceGroupsKHR(params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumeratePhysicalDeviceGroupsKHR(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pPhysicalDeviceGroupCount;
        PTR32 pPhysicalDeviceGroupProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->instance, params->pPhysicalDeviceGroupCount, params->pPhysicalDeviceGroupProperties);

    init_conversion_context(ctx);
    pPhysicalDeviceGroupProperties_host = convert_VkPhysicalDeviceGroupProperties_array_win32_to_unwrapped_host(ctx, (VkPhysicalDeviceGroupProperties32 *)UlongToPtr(params->pPhysicalDeviceGroupProperties), *(uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount));
    params->result = wine_vkEnumeratePhysicalDeviceGroupsKHR((VkInstance)UlongToPtr(params->instance), (uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount), pPhysicalDeviceGroupProperties_host);
    convert_VkPhysicalDeviceGroupProperties_array_unwrapped_host_to_win32(pPhysicalDeviceGroupProperties_host, (VkPhysicalDeviceGroupProperties32 *)UlongToPtr(params->pPhysicalDeviceGroupProperties), *(uint32_t *)UlongToPtr(params->pPhysicalDeviceGroupCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(void *args)
{
    struct vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_params *params = args;

    TRACE("%p, %u, %p, %p, %p\n", params->physicalDevice, params->queueFamilyIndex, params->pCounterCount, params->pCounters, params->pCounterDescriptions);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->queueFamilyIndex, params->pCounterCount, params->pCounters, params->pCounterDescriptions);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        uint32_t queueFamilyIndex;
        PTR32 pCounterCount;
        PTR32 pCounters;
        PTR32 pCounterDescriptions;
        VkResult result;
    } *params = args;
    VkPerformanceCounterKHR *pCounters_host;
    VkPerformanceCounterDescriptionKHR *pCounterDescriptions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %#x, %#x\n", params->physicalDevice, params->queueFamilyIndex, params->pCounterCount, params->pCounters, params->pCounterDescriptions);

    init_conversion_context(ctx);
    pCounters_host = convert_VkPerformanceCounterKHR_array_win32_to_host(ctx, (VkPerformanceCounterKHR32 *)UlongToPtr(params->pCounters), *(uint32_t *)UlongToPtr(params->pCounterCount));
    pCounterDescriptions_host = convert_VkPerformanceCounterDescriptionKHR_array_win32_to_host(ctx, (VkPerformanceCounterDescriptionKHR32 *)UlongToPtr(params->pCounterDescriptions), *(uint32_t *)UlongToPtr(params->pCounterCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->queueFamilyIndex, (uint32_t *)UlongToPtr(params->pCounterCount), pCounters_host, pCounterDescriptions_host);
    convert_VkPerformanceCounterKHR_array_host_to_win32(pCounters_host, (VkPerformanceCounterKHR32 *)UlongToPtr(params->pCounters), *(uint32_t *)UlongToPtr(params->pCounterCount));
    convert_VkPerformanceCounterDescriptionKHR_array_host_to_win32(pCounterDescriptions_host, (VkPerformanceCounterDescriptionKHR32 *)UlongToPtr(params->pCounterDescriptions), *(uint32_t *)UlongToPtr(params->pCounterCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkEnumeratePhysicalDevices(void *args)
{
    struct vkEnumeratePhysicalDevices_params *params = args;

    TRACE("%p, %p, %p\n", params->instance, params->pPhysicalDeviceCount, params->pPhysicalDevices);

    params->result = wine_vkEnumeratePhysicalDevices(params->instance, params->pPhysicalDeviceCount, params->pPhysicalDevices);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkEnumeratePhysicalDevices(void *args)
{
    struct
    {
        PTR32 instance;
        PTR32 pPhysicalDeviceCount;
        PTR32 pPhysicalDevices;
        VkResult result;
    } *params = args;
    VkPhysicalDevice *pPhysicalDevices_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->instance, params->pPhysicalDeviceCount, params->pPhysicalDevices);

    init_conversion_context(ctx);
    pPhysicalDevices_host = (params->pPhysicalDevices && *(uint32_t *)UlongToPtr(params->pPhysicalDeviceCount)) ? conversion_context_alloc(ctx, sizeof(*pPhysicalDevices_host) * *(uint32_t *)UlongToPtr(params->pPhysicalDeviceCount)) : NULL;
    params->result = wine_vkEnumeratePhysicalDevices((VkInstance)UlongToPtr(params->instance), (uint32_t *)UlongToPtr(params->pPhysicalDeviceCount), pPhysicalDevices_host);
    convert_VkPhysicalDevice_array_unwrapped_host_to_win32(pPhysicalDevices_host, (PTR32 *)UlongToPtr(params->pPhysicalDevices), *(uint32_t *)UlongToPtr(params->pPhysicalDeviceCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkFlushMappedMemoryRanges(void *args)
{
    struct vkFlushMappedMemoryRanges_params *params = args;
    const VkMappedMemoryRange *pMemoryRanges_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->memoryRangeCount, params->pMemoryRanges);

    init_conversion_context(ctx);
    pMemoryRanges_host = convert_VkMappedMemoryRange_array_win64_to_host(ctx, params->pMemoryRanges, params->memoryRangeCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkFlushMappedMemoryRanges(vulkan_device_from_handle(params->device)->host.device, params->memoryRangeCount, pMemoryRanges_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkFlushMappedMemoryRanges(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t memoryRangeCount;
        PTR32 pMemoryRanges;
        VkResult result;
    } *params = args;
    const VkMappedMemoryRange *pMemoryRanges_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->memoryRangeCount, params->pMemoryRanges);

    init_conversion_context(ctx);
    pMemoryRanges_host = convert_VkMappedMemoryRange_array_win32_to_host(ctx, (const VkMappedMemoryRange32 *)UlongToPtr(params->pMemoryRanges), params->memoryRangeCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkFlushMappedMemoryRanges(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->memoryRangeCount, pMemoryRanges_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkFreeCommandBuffers(void *args)
{
    struct vkFreeCommandBuffers_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->commandPool), params->commandBufferCount, params->pCommandBuffers);

    wine_vkFreeCommandBuffers(params->device, params->commandPool, params->commandBufferCount, params->pCommandBuffers);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkFreeCommandBuffers(void *args)
{
    struct
    {
        PTR32 device;
        VkCommandPool DECLSPEC_ALIGN(8) commandPool;
        uint32_t commandBufferCount;
        PTR32 pCommandBuffers;
    } *params = args;
    const VkCommandBuffer *pCommandBuffers_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->commandBufferCount, params->pCommandBuffers);

    init_conversion_context(ctx);
    pCommandBuffers_host = convert_VkCommandBuffer_array_win32_to_unwrapped_host(ctx, (const PTR32 *)UlongToPtr(params->pCommandBuffers), params->commandBufferCount);
    wine_vkFreeCommandBuffers((VkDevice)UlongToPtr(params->device), params->commandPool, params->commandBufferCount, pCommandBuffers_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkFreeDescriptorSets(void *args)
{
    struct vkFreeDescriptorSets_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->descriptorSetCount, params->pDescriptorSets);

    params->result = vulkan_device_from_handle(params->device)->p_vkFreeDescriptorSets(vulkan_device_from_handle(params->device)->host.device, params->descriptorPool, params->descriptorSetCount, params->pDescriptorSets);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkFreeDescriptorSets(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorPool DECLSPEC_ALIGN(8) descriptorPool;
        uint32_t descriptorSetCount;
        PTR32 pDescriptorSets;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->descriptorSetCount, params->pDescriptorSets);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkFreeDescriptorSets(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->descriptorPool, params->descriptorSetCount, (const VkDescriptorSet *)UlongToPtr(params->pDescriptorSets));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkFreeMemory(void *args)
{
    struct vkFreeMemory_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->memory), params->pAllocator);

    vk_funcs->p_vkFreeMemory(params->device, params->memory, params->pAllocator);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkFreeMemory(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        PTR32 pAllocator;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->memory), params->pAllocator);

    vk_funcs->p_vkFreeMemory((VkDevice)UlongToPtr(params->device), params->memory, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetAccelerationStructureBuildSizesKHR(void *args)
{
    struct vkGetAccelerationStructureBuildSizesKHR_params *params = args;

    TRACE("%p, %#x, %p, %p, %p\n", params->device, params->buildType, params->pBuildInfo, params->pMaxPrimitiveCounts, params->pSizeInfo);

    vulkan_device_from_handle(params->device)->p_vkGetAccelerationStructureBuildSizesKHR(vulkan_device_from_handle(params->device)->host.device, params->buildType, params->pBuildInfo, params->pMaxPrimitiveCounts, params->pSizeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetAccelerationStructureBuildSizesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkAccelerationStructureBuildTypeKHR buildType;
        PTR32 pBuildInfo;
        PTR32 pMaxPrimitiveCounts;
        PTR32 pSizeInfo;
    } *params = args;
    VkAccelerationStructureBuildGeometryInfoKHR pBuildInfo_host;
    VkAccelerationStructureBuildSizesInfoKHR pSizeInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x, %#x\n", params->device, params->buildType, params->pBuildInfo, params->pMaxPrimitiveCounts, params->pSizeInfo);

    init_conversion_context(ctx);
    convert_VkAccelerationStructureBuildGeometryInfoKHR_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pBuildInfo), &pBuildInfo_host);
    convert_VkAccelerationStructureBuildSizesInfoKHR_win32_to_host((VkAccelerationStructureBuildSizesInfoKHR32 *)UlongToPtr(params->pSizeInfo), &pSizeInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetAccelerationStructureBuildSizesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->buildType, &pBuildInfo_host, (const uint32_t *)UlongToPtr(params->pMaxPrimitiveCounts), &pSizeInfo_host);
    convert_VkAccelerationStructureBuildSizesInfoKHR_host_to_win32(&pSizeInfo_host, (VkAccelerationStructureBuildSizesInfoKHR32 *)UlongToPtr(params->pSizeInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetAccelerationStructureDeviceAddressKHR(void *args)
{
    struct vkGetAccelerationStructureDeviceAddressKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetAccelerationStructureDeviceAddressKHR(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetAccelerationStructureDeviceAddressKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkDeviceAddress result;
    } *params = args;
    VkAccelerationStructureDeviceAddressInfoKHR pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkAccelerationStructureDeviceAddressInfoKHR_win32_to_host((const VkAccelerationStructureDeviceAddressInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetAccelerationStructureDeviceAddressKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetAccelerationStructureHandleNV(void *args)
{
    struct vkGetAccelerationStructureHandleNV_params *params = args;

    TRACE("%p, 0x%s, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetAccelerationStructureHandleNV(vulkan_device_from_handle(params->device)->host.device, params->accelerationStructure, params->dataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetAccelerationStructureHandleNV(void *args)
{
    struct
    {
        PTR32 device;
        VkAccelerationStructureNV DECLSPEC_ALIGN(8) accelerationStructure;
        PTR32 dataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->accelerationStructure), wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetAccelerationStructureHandleNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->accelerationStructure, params->dataSize, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetAccelerationStructureMemoryRequirementsNV(void *args)
{
    struct vkGetAccelerationStructureMemoryRequirementsNV_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetAccelerationStructureMemoryRequirementsNV(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetAccelerationStructureMemoryRequirementsNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkAccelerationStructureMemoryRequirementsInfoNV pInfo_host;
    VkMemoryRequirements2KHR pMemoryRequirements_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    convert_VkAccelerationStructureMemoryRequirementsInfoNV_win32_to_host((const VkAccelerationStructureMemoryRequirementsInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2KHR_win32_to_host((VkMemoryRequirements2KHR32 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetAccelerationStructureMemoryRequirementsNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2KHR_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements2KHR32 *)UlongToPtr(params->pMemoryRequirements));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkAccelerationStructureCaptureDescriptorDataInfoEXT pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkAccelerationStructureCaptureDescriptorDataInfoEXT_win32_to_host((const VkAccelerationStructureCaptureDescriptorDataInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferDeviceAddress(void *args)
{
    struct vkGetBufferDeviceAddress_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetBufferDeviceAddress(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferDeviceAddress(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkDeviceAddress result;
    } *params = args;
    VkBufferDeviceAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkBufferDeviceAddressInfo_win32_to_host((const VkBufferDeviceAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetBufferDeviceAddress(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferDeviceAddressEXT(void *args)
{
    struct vkGetBufferDeviceAddressEXT_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetBufferDeviceAddressEXT(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferDeviceAddressEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkDeviceAddress result;
    } *params = args;
    VkBufferDeviceAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkBufferDeviceAddressInfo_win32_to_host((const VkBufferDeviceAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetBufferDeviceAddressEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferDeviceAddressKHR(void *args)
{
    struct vkGetBufferDeviceAddressKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetBufferDeviceAddressKHR(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferDeviceAddressKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkDeviceAddress result;
    } *params = args;
    VkBufferDeviceAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkBufferDeviceAddressInfo_win32_to_host((const VkBufferDeviceAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetBufferDeviceAddressKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferMemoryRequirements(void *args)
{
    struct vkGetBufferMemoryRequirements_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->buffer), params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetBufferMemoryRequirements(vulkan_device_from_handle(params->device)->host.device, params->buffer, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        VkBuffer DECLSPEC_ALIGN(8) buffer;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkMemoryRequirements pMemoryRequirements_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->buffer), params->pMemoryRequirements);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetBufferMemoryRequirements(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->buffer, &pMemoryRequirements_host);
    convert_VkMemoryRequirements_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements32 *)UlongToPtr(params->pMemoryRequirements));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferMemoryRequirements2(void *args)
{
    struct vkGetBufferMemoryRequirements2_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetBufferMemoryRequirements2(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferMemoryRequirements2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkBufferMemoryRequirementsInfo2 pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkBufferMemoryRequirementsInfo2_win32_to_host((const VkBufferMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetBufferMemoryRequirements2(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferMemoryRequirements2KHR(void *args)
{
    struct vkGetBufferMemoryRequirements2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetBufferMemoryRequirements2KHR(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferMemoryRequirements2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkBufferMemoryRequirementsInfo2 pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkBufferMemoryRequirementsInfo2_win32_to_host((const VkBufferMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetBufferMemoryRequirements2KHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferOpaqueCaptureAddress(void *args)
{
    struct vkGetBufferOpaqueCaptureAddress_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetBufferOpaqueCaptureAddress(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferOpaqueCaptureAddress(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint64_t result;
    } *params = args;
    VkBufferDeviceAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkBufferDeviceAddressInfo_win32_to_host((const VkBufferDeviceAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetBufferOpaqueCaptureAddress(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferOpaqueCaptureAddressKHR(void *args)
{
    struct vkGetBufferOpaqueCaptureAddressKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetBufferOpaqueCaptureAddressKHR(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferOpaqueCaptureAddressKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint64_t result;
    } *params = args;
    VkBufferDeviceAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkBufferDeviceAddressInfo_win32_to_host((const VkBufferDeviceAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetBufferOpaqueCaptureAddressKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetBufferOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct vkGetBufferOpaqueCaptureDescriptorDataEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetBufferOpaqueCaptureDescriptorDataEXT(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetBufferOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkBufferCaptureDescriptorDataInfoEXT pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkBufferCaptureDescriptorDataInfoEXT_win32_to_host((const VkBufferCaptureDescriptorDataInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetBufferOpaqueCaptureDescriptorDataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetCalibratedTimestampsEXT(void *args)
{
    struct vkGetCalibratedTimestampsEXT_params *params = args;

    TRACE("%p, %u, %p, %p, %p\n", params->device, params->timestampCount, params->pTimestampInfos, params->pTimestamps, params->pMaxDeviation);

    params->result = wine_vkGetCalibratedTimestampsEXT(params->device, params->timestampCount, params->pTimestampInfos, params->pTimestamps, params->pMaxDeviation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetCalibratedTimestampsEXT(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t timestampCount;
        PTR32 pTimestampInfos;
        PTR32 pTimestamps;
        PTR32 pMaxDeviation;
        VkResult result;
    } *params = args;
    const VkCalibratedTimestampInfoKHR *pTimestampInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %#x, %#x\n", params->device, params->timestampCount, params->pTimestampInfos, params->pTimestamps, params->pMaxDeviation);

    init_conversion_context(ctx);
    pTimestampInfos_host = convert_VkCalibratedTimestampInfoKHR_array_win32_to_host(ctx, (const VkCalibratedTimestampInfoKHR32 *)UlongToPtr(params->pTimestampInfos), params->timestampCount);
    params->result = wine_vkGetCalibratedTimestampsEXT((VkDevice)UlongToPtr(params->device), params->timestampCount, pTimestampInfos_host, (uint64_t *)UlongToPtr(params->pTimestamps), (uint64_t *)UlongToPtr(params->pMaxDeviation));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetCalibratedTimestampsKHR(void *args)
{
    struct vkGetCalibratedTimestampsKHR_params *params = args;

    TRACE("%p, %u, %p, %p, %p\n", params->device, params->timestampCount, params->pTimestampInfos, params->pTimestamps, params->pMaxDeviation);

    params->result = wine_vkGetCalibratedTimestampsKHR(params->device, params->timestampCount, params->pTimestampInfos, params->pTimestamps, params->pMaxDeviation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetCalibratedTimestampsKHR(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t timestampCount;
        PTR32 pTimestampInfos;
        PTR32 pTimestamps;
        PTR32 pMaxDeviation;
        VkResult result;
    } *params = args;
    const VkCalibratedTimestampInfoKHR *pTimestampInfos_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %#x, %#x\n", params->device, params->timestampCount, params->pTimestampInfos, params->pTimestamps, params->pMaxDeviation);

    init_conversion_context(ctx);
    pTimestampInfos_host = convert_VkCalibratedTimestampInfoKHR_array_win32_to_host(ctx, (const VkCalibratedTimestampInfoKHR32 *)UlongToPtr(params->pTimestampInfos), params->timestampCount);
    params->result = wine_vkGetCalibratedTimestampsKHR((VkDevice)UlongToPtr(params->device), params->timestampCount, pTimestampInfos_host, (uint64_t *)UlongToPtr(params->pTimestamps), (uint64_t *)UlongToPtr(params->pMaxDeviation));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetClusterAccelerationStructureBuildSizesNV(void *args)
{
    struct vkGetClusterAccelerationStructureBuildSizesNV_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pSizeInfo);

    vulkan_device_from_handle(params->device)->p_vkGetClusterAccelerationStructureBuildSizesNV(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pSizeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetClusterAccelerationStructureBuildSizesNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pSizeInfo;
    } *params = args;
    VkClusterAccelerationStructureInputInfoNV pInfo_host;
    VkAccelerationStructureBuildSizesInfoKHR pSizeInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pSizeInfo);

    init_conversion_context(ctx);
    convert_VkClusterAccelerationStructureInputInfoNV_win32_to_host(ctx, (const VkClusterAccelerationStructureInputInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkAccelerationStructureBuildSizesInfoKHR_win32_to_host((VkAccelerationStructureBuildSizesInfoKHR32 *)UlongToPtr(params->pSizeInfo), &pSizeInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetClusterAccelerationStructureBuildSizesNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pSizeInfo_host);
    convert_VkAccelerationStructureBuildSizesInfoKHR_host_to_win32(&pSizeInfo_host, (VkAccelerationStructureBuildSizesInfoKHR32 *)UlongToPtr(params->pSizeInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDataGraphPipelineAvailablePropertiesARM(void *args)
{
    struct vkGetDataGraphPipelineAvailablePropertiesARM_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pPipelineInfo, params->pPropertiesCount, params->pProperties);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetDataGraphPipelineAvailablePropertiesARM(vulkan_device_from_handle(params->device)->host.device, params->pPipelineInfo, params->pPropertiesCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDataGraphPipelineAvailablePropertiesARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pPipelineInfo;
        PTR32 pPropertiesCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkDataGraphPipelineInfoARM pPipelineInfo_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pPipelineInfo, params->pPropertiesCount, params->pProperties);

    convert_VkDataGraphPipelineInfoARM_win32_to_host((const VkDataGraphPipelineInfoARM32 *)UlongToPtr(params->pPipelineInfo), &pPipelineInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDataGraphPipelineAvailablePropertiesARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pPipelineInfo_host, (uint32_t *)UlongToPtr(params->pPropertiesCount), (VkDataGraphPipelinePropertyARM *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDataGraphPipelinePropertiesARM(void *args)
{
    struct vkGetDataGraphPipelinePropertiesARM_params *params = args;

    TRACE("%p, %p, %u, %p\n", params->device, params->pPipelineInfo, params->propertiesCount, params->pProperties);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetDataGraphPipelinePropertiesARM(vulkan_device_from_handle(params->device)->host.device, params->pPipelineInfo, params->propertiesCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDataGraphPipelinePropertiesARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pPipelineInfo;
        uint32_t propertiesCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkDataGraphPipelineInfoARM pPipelineInfo_host;
    VkDataGraphPipelinePropertyQueryResultARM *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %u, %#x\n", params->device, params->pPipelineInfo, params->propertiesCount, params->pProperties);

    init_conversion_context(ctx);
    convert_VkDataGraphPipelineInfoARM_win32_to_host((const VkDataGraphPipelineInfoARM32 *)UlongToPtr(params->pPipelineInfo), &pPipelineInfo_host);
    pProperties_host = convert_VkDataGraphPipelinePropertyQueryResultARM_array_win32_to_host(ctx, (VkDataGraphPipelinePropertyQueryResultARM32 *)UlongToPtr(params->pProperties), params->propertiesCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDataGraphPipelinePropertiesARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pPipelineInfo_host, params->propertiesCount, pProperties_host);
    convert_VkDataGraphPipelinePropertyQueryResultARM_array_host_to_win32(pProperties_host, (VkDataGraphPipelinePropertyQueryResultARM32 *)UlongToPtr(params->pProperties), params->propertiesCount);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDataGraphPipelineSessionBindPointRequirementsARM(void *args)
{
    struct vkGetDataGraphPipelineSessionBindPointRequirementsARM_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pInfo, params->pBindPointRequirementCount, params->pBindPointRequirements);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetDataGraphPipelineSessionBindPointRequirementsARM(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pBindPointRequirementCount, params->pBindPointRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDataGraphPipelineSessionBindPointRequirementsARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pBindPointRequirementCount;
        PTR32 pBindPointRequirements;
        VkResult result;
    } *params = args;
    VkDataGraphPipelineSessionBindPointRequirementsInfoARM pInfo_host;
    VkDataGraphPipelineSessionBindPointRequirementARM *pBindPointRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pInfo, params->pBindPointRequirementCount, params->pBindPointRequirements);

    init_conversion_context(ctx);
    convert_VkDataGraphPipelineSessionBindPointRequirementsInfoARM_win32_to_host((const VkDataGraphPipelineSessionBindPointRequirementsInfoARM32 *)UlongToPtr(params->pInfo), &pInfo_host);
    pBindPointRequirements_host = convert_VkDataGraphPipelineSessionBindPointRequirementARM_array_win32_to_host(ctx, (VkDataGraphPipelineSessionBindPointRequirementARM32 *)UlongToPtr(params->pBindPointRequirements), *(uint32_t *)UlongToPtr(params->pBindPointRequirementCount));
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDataGraphPipelineSessionBindPointRequirementsARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (uint32_t *)UlongToPtr(params->pBindPointRequirementCount), pBindPointRequirements_host);
    convert_VkDataGraphPipelineSessionBindPointRequirementARM_array_host_to_win32(pBindPointRequirements_host, (VkDataGraphPipelineSessionBindPointRequirementARM32 *)UlongToPtr(params->pBindPointRequirements), *(uint32_t *)UlongToPtr(params->pBindPointRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDataGraphPipelineSessionMemoryRequirementsARM(void *args)
{
    struct vkGetDataGraphPipelineSessionMemoryRequirementsARM_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetDataGraphPipelineSessionMemoryRequirementsARM(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDataGraphPipelineSessionMemoryRequirementsARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkDataGraphPipelineSessionMemoryRequirementsInfoARM pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDataGraphPipelineSessionMemoryRequirementsInfoARM_win32_to_host((const VkDataGraphPipelineSessionMemoryRequirementsInfoARM32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDataGraphPipelineSessionMemoryRequirementsARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeferredOperationMaxConcurrencyKHR(void *args)
{
    struct vkGetDeferredOperationMaxConcurrencyKHR_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = vulkan_device_from_handle(params->device)->p_vkGetDeferredOperationMaxConcurrencyKHR(vulkan_device_from_handle(params->device)->host.device, wine_deferred_operation_from_handle(params->operation)->host.deferred_operation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeferredOperationMaxConcurrencyKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) operation;
        uint32_t result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeferredOperationMaxConcurrencyKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, wine_deferred_operation_from_handle(params->operation)->host.deferred_operation);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeferredOperationResultKHR(void *args)
{
    struct vkGetDeferredOperationResultKHR_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = vulkan_device_from_handle(params->device)->p_vkGetDeferredOperationResultKHR(vulkan_device_from_handle(params->device)->host.device, wine_deferred_operation_from_handle(params->operation)->host.deferred_operation);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeferredOperationResultKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDeferredOperationKHR DECLSPEC_ALIGN(8) operation;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->operation));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeferredOperationResultKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, wine_deferred_operation_from_handle(params->operation)->host.deferred_operation);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static void thunk64_vkGetDescriptorEXT(void *args)
{
    struct vkGetDescriptorEXT_params *params = args;

    vulkan_device_from_handle(params->device)->p_vkGetDescriptorEXT(vulkan_device_from_handle(params->device)->host.device, params->pDescriptorInfo, params->dataSize, params->pDescriptor);
}
#endif /* _WIN64 */

static void thunk32_vkGetDescriptorEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pDescriptorInfo;
        PTR32 dataSize;
        PTR32 pDescriptor;
    } *params = args;
    VkDescriptorGetInfoEXT pDescriptorInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    convert_VkDescriptorGetInfoEXT_win32_to_host(ctx, (const VkDescriptorGetInfoEXT32 *)UlongToPtr(params->pDescriptorInfo), &pDescriptorInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDescriptorEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pDescriptorInfo_host, params->dataSize, (void *)UlongToPtr(params->pDescriptor));
    free_conversion_context(ctx);
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetHostMappingVALVE(void *args)
{
    struct vkGetDescriptorSetHostMappingVALVE_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorSet), params->ppData);

    vulkan_device_from_handle(params->device)->p_vkGetDescriptorSetHostMappingVALVE(vulkan_device_from_handle(params->device)->host.device, params->descriptorSet, params->ppData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetHostMappingVALVE(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSet DECLSPEC_ALIGN(8) descriptorSet;
        PTR32 ppData;
    } *params = args;
    void *ppData_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorSet), params->ppData);

    ppData_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->ppData));
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDescriptorSetHostMappingVALVE(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->descriptorSet, &ppData_host);
    *(PTR32 *)UlongToPtr(params->ppData) = PtrToUlong(ppData_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetLayoutBindingOffsetEXT(void *args)
{
    struct vkGetDescriptorSetLayoutBindingOffsetEXT_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->layout), params->binding, params->pOffset);

    vulkan_device_from_handle(params->device)->p_vkGetDescriptorSetLayoutBindingOffsetEXT(vulkan_device_from_handle(params->device)->host.device, params->layout, params->binding, params->pOffset);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetLayoutBindingOffsetEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSetLayout DECLSPEC_ALIGN(8) layout;
        uint32_t binding;
        PTR32 pOffset;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->layout), params->binding, params->pOffset);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDescriptorSetLayoutBindingOffsetEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->layout, params->binding, (VkDeviceSize *)UlongToPtr(params->pOffset));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetLayoutHostMappingInfoVALVE(void *args)
{
    struct vkGetDescriptorSetLayoutHostMappingInfoVALVE_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pBindingReference, params->pHostMapping);

    vulkan_device_from_handle(params->device)->p_vkGetDescriptorSetLayoutHostMappingInfoVALVE(vulkan_device_from_handle(params->device)->host.device, params->pBindingReference, params->pHostMapping);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetLayoutHostMappingInfoVALVE(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pBindingReference;
        PTR32 pHostMapping;
    } *params = args;
    VkDescriptorSetBindingReferenceVALVE pBindingReference_host;
    VkDescriptorSetLayoutHostMappingInfoVALVE pHostMapping_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pBindingReference, params->pHostMapping);

    convert_VkDescriptorSetBindingReferenceVALVE_win32_to_host((const VkDescriptorSetBindingReferenceVALVE32 *)UlongToPtr(params->pBindingReference), &pBindingReference_host);
    convert_VkDescriptorSetLayoutHostMappingInfoVALVE_win32_to_host((VkDescriptorSetLayoutHostMappingInfoVALVE32 *)UlongToPtr(params->pHostMapping), &pHostMapping_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDescriptorSetLayoutHostMappingInfoVALVE(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pBindingReference_host, &pHostMapping_host);
    convert_VkDescriptorSetLayoutHostMappingInfoVALVE_host_to_win32(&pHostMapping_host, (VkDescriptorSetLayoutHostMappingInfoVALVE32 *)UlongToPtr(params->pHostMapping));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetLayoutSizeEXT(void *args)
{
    struct vkGetDescriptorSetLayoutSizeEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->layout), params->pLayoutSizeInBytes);

    vulkan_device_from_handle(params->device)->p_vkGetDescriptorSetLayoutSizeEXT(vulkan_device_from_handle(params->device)->host.device, params->layout, params->pLayoutSizeInBytes);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetLayoutSizeEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSetLayout DECLSPEC_ALIGN(8) layout;
        PTR32 pLayoutSizeInBytes;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->layout), params->pLayoutSizeInBytes);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDescriptorSetLayoutSizeEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->layout, (VkDeviceSize *)UlongToPtr(params->pLayoutSizeInBytes));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetLayoutSupport(void *args)
{
    struct vkGetDescriptorSetLayoutSupport_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pCreateInfo, params->pSupport);

    vulkan_device_from_handle(params->device)->p_vkGetDescriptorSetLayoutSupport(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, params->pSupport);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetLayoutSupport(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pSupport;
    } *params = args;
    VkDescriptorSetLayoutCreateInfo pCreateInfo_host;
    VkDescriptorSetLayoutSupport pSupport_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pSupport);

    init_conversion_context(ctx);
    convert_VkDescriptorSetLayoutCreateInfo_win32_to_host(ctx, (const VkDescriptorSetLayoutCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    convert_VkDescriptorSetLayoutSupport_win32_to_host(ctx, (VkDescriptorSetLayoutSupport32 *)UlongToPtr(params->pSupport), &pSupport_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDescriptorSetLayoutSupport(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, &pSupport_host);
    convert_VkDescriptorSetLayoutSupport_host_to_win32(&pSupport_host, (VkDescriptorSetLayoutSupport32 *)UlongToPtr(params->pSupport));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDescriptorSetLayoutSupportKHR(void *args)
{
    struct vkGetDescriptorSetLayoutSupportKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pCreateInfo, params->pSupport);

    vulkan_device_from_handle(params->device)->p_vkGetDescriptorSetLayoutSupportKHR(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, params->pSupport);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDescriptorSetLayoutSupportKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pSupport;
    } *params = args;
    VkDescriptorSetLayoutCreateInfo pCreateInfo_host;
    VkDescriptorSetLayoutSupport pSupport_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pSupport);

    init_conversion_context(ctx);
    convert_VkDescriptorSetLayoutCreateInfo_win32_to_host(ctx, (const VkDescriptorSetLayoutCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    convert_VkDescriptorSetLayoutSupport_win32_to_host(ctx, (VkDescriptorSetLayoutSupport32 *)UlongToPtr(params->pSupport), &pSupport_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDescriptorSetLayoutSupportKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, &pSupport_host);
    convert_VkDescriptorSetLayoutSupport_host_to_win32(&pSupport_host, (VkDescriptorSetLayoutSupport32 *)UlongToPtr(params->pSupport));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceAccelerationStructureCompatibilityKHR(void *args)
{
    struct vkGetDeviceAccelerationStructureCompatibilityKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pVersionInfo, params->pCompatibility);

    vulkan_device_from_handle(params->device)->p_vkGetDeviceAccelerationStructureCompatibilityKHR(vulkan_device_from_handle(params->device)->host.device, params->pVersionInfo, params->pCompatibility);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceAccelerationStructureCompatibilityKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pVersionInfo;
        PTR32 pCompatibility;
    } *params = args;
    VkAccelerationStructureVersionInfoKHR pVersionInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pVersionInfo, params->pCompatibility);

    convert_VkAccelerationStructureVersionInfoKHR_win32_to_host((const VkAccelerationStructureVersionInfoKHR32 *)UlongToPtr(params->pVersionInfo), &pVersionInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceAccelerationStructureCompatibilityKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pVersionInfo_host, (VkAccelerationStructureCompatibilityKHR *)UlongToPtr(params->pCompatibility));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceBufferMemoryRequirements(void *args)
{
    struct vkGetDeviceBufferMemoryRequirements_params *params = args;
    VkDeviceBufferMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceBufferMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    vk_funcs->p_vkGetDeviceBufferMemoryRequirements(params->device, &pInfo_host, params->pMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceBufferMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkDeviceBufferMemoryRequirements pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceBufferMemoryRequirements_win32_to_host(ctx, (const VkDeviceBufferMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vk_funcs->p_vkGetDeviceBufferMemoryRequirements((VkDevice)UlongToPtr(params->device), &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceBufferMemoryRequirementsKHR(void *args)
{
    struct vkGetDeviceBufferMemoryRequirementsKHR_params *params = args;
    VkDeviceBufferMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceBufferMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    vk_funcs->p_vkGetDeviceBufferMemoryRequirementsKHR(params->device, &pInfo_host, params->pMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceBufferMemoryRequirementsKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkDeviceBufferMemoryRequirements pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceBufferMemoryRequirements_win32_to_host(ctx, (const VkDeviceBufferMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vk_funcs->p_vkGetDeviceBufferMemoryRequirementsKHR((VkDevice)UlongToPtr(params->device), &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceFaultInfoEXT(void *args)
{
    struct vkGetDeviceFaultInfoEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pFaultCounts, params->pFaultInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetDeviceFaultInfoEXT(vulkan_device_from_handle(params->device)->host.device, params->pFaultCounts, params->pFaultInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceFaultInfoEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pFaultCounts;
        PTR32 pFaultInfo;
        VkResult result;
    } *params = args;
    VkDeviceFaultCountsEXT pFaultCounts_host;
    VkDeviceFaultInfoEXT *pFaultInfo_host = NULL;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pFaultCounts, params->pFaultInfo);

    init_conversion_context(ctx);
    convert_VkDeviceFaultCountsEXT_win32_to_host((VkDeviceFaultCountsEXT32 *)UlongToPtr(params->pFaultCounts), &pFaultCounts_host);
    if (params->pFaultInfo)
    {
        pFaultInfo_host = conversion_context_alloc(ctx, sizeof(*pFaultInfo_host));
        convert_VkDeviceFaultInfoEXT_win32_to_host(ctx, (VkDeviceFaultInfoEXT32 *)UlongToPtr(params->pFaultInfo), pFaultInfo_host);
    }
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceFaultInfoEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pFaultCounts_host, pFaultInfo_host);
    convert_VkDeviceFaultCountsEXT_host_to_win32(&pFaultCounts_host, (VkDeviceFaultCountsEXT32 *)UlongToPtr(params->pFaultCounts));
    convert_VkDeviceFaultInfoEXT_host_to_win32(pFaultInfo_host, (VkDeviceFaultInfoEXT32 *)UlongToPtr(params->pFaultInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceGroupPeerMemoryFeatures(void *args)
{
    struct vkGetDeviceGroupPeerMemoryFeatures_params *params = args;

    TRACE("%p, %u, %u, %u, %p\n", params->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);

    vulkan_device_from_handle(params->device)->p_vkGetDeviceGroupPeerMemoryFeatures(vulkan_device_from_handle(params->device)->host.device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceGroupPeerMemoryFeatures(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t heapIndex;
        uint32_t localDeviceIndex;
        uint32_t remoteDeviceIndex;
        PTR32 pPeerMemoryFeatures;
    } *params = args;

    TRACE("%#x, %u, %u, %u, %#x\n", params->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceGroupPeerMemoryFeatures(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, (VkPeerMemoryFeatureFlags *)UlongToPtr(params->pPeerMemoryFeatures));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceGroupPeerMemoryFeaturesKHR(void *args)
{
    struct vkGetDeviceGroupPeerMemoryFeaturesKHR_params *params = args;

    TRACE("%p, %u, %u, %u, %p\n", params->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);

    vulkan_device_from_handle(params->device)->p_vkGetDeviceGroupPeerMemoryFeaturesKHR(vulkan_device_from_handle(params->device)->host.device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceGroupPeerMemoryFeaturesKHR(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t heapIndex;
        uint32_t localDeviceIndex;
        uint32_t remoteDeviceIndex;
        PTR32 pPeerMemoryFeatures;
    } *params = args;

    TRACE("%#x, %u, %u, %u, %#x\n", params->device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, params->pPeerMemoryFeatures);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceGroupPeerMemoryFeaturesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->heapIndex, params->localDeviceIndex, params->remoteDeviceIndex, (VkPeerMemoryFeatureFlags *)UlongToPtr(params->pPeerMemoryFeatures));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceGroupPresentCapabilitiesKHR(void *args)
{
    struct vkGetDeviceGroupPresentCapabilitiesKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pDeviceGroupPresentCapabilities);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetDeviceGroupPresentCapabilitiesKHR(vulkan_device_from_handle(params->device)->host.device, params->pDeviceGroupPresentCapabilities);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceGroupPresentCapabilitiesKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pDeviceGroupPresentCapabilities;
        VkResult result;
    } *params = args;
    VkDeviceGroupPresentCapabilitiesKHR pDeviceGroupPresentCapabilities_host;

    TRACE("%#x, %#x\n", params->device, params->pDeviceGroupPresentCapabilities);

    convert_VkDeviceGroupPresentCapabilitiesKHR_win32_to_host((VkDeviceGroupPresentCapabilitiesKHR32 *)UlongToPtr(params->pDeviceGroupPresentCapabilities), &pDeviceGroupPresentCapabilities_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceGroupPresentCapabilitiesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pDeviceGroupPresentCapabilities_host);
    convert_VkDeviceGroupPresentCapabilitiesKHR_host_to_win32(&pDeviceGroupPresentCapabilities_host, (VkDeviceGroupPresentCapabilitiesKHR32 *)UlongToPtr(params->pDeviceGroupPresentCapabilities));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceGroupSurfacePresentModesKHR(void *args)
{
    struct vkGetDeviceGroupSurfacePresentModesKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->surface), params->pModes);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetDeviceGroupSurfacePresentModesKHR(vulkan_device_from_handle(params->device)->host.device, vulkan_surface_from_handle(params->surface)->host.surface, params->pModes);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceGroupSurfacePresentModesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pModes;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->surface), params->pModes);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceGroupSurfacePresentModesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_surface_from_handle(params->surface)->host.surface, (VkDeviceGroupPresentModeFlagsKHR *)UlongToPtr(params->pModes));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageMemoryRequirements(void *args)
{
    struct vkGetDeviceImageMemoryRequirements_params *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    vk_funcs->p_vkGetDeviceImageMemoryRequirements(params->device, &pInfo_host, params->pMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win32_to_host(ctx, (const VkDeviceImageMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vk_funcs->p_vkGetDeviceImageMemoryRequirements((VkDevice)UlongToPtr(params->device), &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageMemoryRequirementsKHR(void *args)
{
    struct vkGetDeviceImageMemoryRequirementsKHR_params *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    vulkan_device_from_handle(params->device)->p_vkGetDeviceImageMemoryRequirementsKHR(vulkan_device_from_handle(params->device)->host.device, &pInfo_host, params->pMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageMemoryRequirementsKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win32_to_host(ctx, (const VkDeviceImageMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceImageMemoryRequirementsKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageSparseMemoryRequirements(void *args)
{
    struct vkGetDeviceImageSparseMemoryRequirements_params *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    vulkan_device_from_handle(params->device)->p_vkGetDeviceImageSparseMemoryRequirements(vulkan_device_from_handle(params->device)->host.device, &pInfo_host, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageSparseMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pSparseMemoryRequirementCount;
        PTR32 pSparseMemoryRequirements;
    } *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win32_to_host(ctx, (const VkDeviceImageMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    pSparseMemoryRequirements_host = convert_VkSparseImageMemoryRequirements2_array_win32_to_host(ctx, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceImageSparseMemoryRequirements(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount), pSparseMemoryRequirements_host);
    convert_VkSparseImageMemoryRequirements2_array_host_to_win32(pSparseMemoryRequirements_host, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageSparseMemoryRequirementsKHR(void *args)
{
    struct vkGetDeviceImageSparseMemoryRequirementsKHR_params *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p, %p\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
    vulkan_device_from_handle(params->device)->p_vkGetDeviceImageSparseMemoryRequirementsKHR(vulkan_device_from_handle(params->device)->host.device, &pInfo_host, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageSparseMemoryRequirementsKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pSparseMemoryRequirementCount;
        PTR32 pSparseMemoryRequirements;
    } *params = args;
    VkDeviceImageMemoryRequirements pInfo_host;
    VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceImageMemoryRequirements_win32_to_host(ctx, (const VkDeviceImageMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
    pSparseMemoryRequirements_host = convert_VkSparseImageMemoryRequirements2_array_win32_to_host(ctx, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceImageSparseMemoryRequirementsKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount), pSparseMemoryRequirements_host);
    convert_VkSparseImageMemoryRequirements2_array_host_to_win32(pSparseMemoryRequirements_host, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageSubresourceLayout(void *args)
{
    struct vkGetDeviceImageSubresourceLayout_params *params = args;
    VkDeviceImageSubresourceInfo pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pLayout);

    init_conversion_context(ctx);
    convert_VkDeviceImageSubresourceInfo_win64_to_host(ctx, params->pInfo, &pInfo_host);
    vulkan_device_from_handle(params->device)->p_vkGetDeviceImageSubresourceLayout(vulkan_device_from_handle(params->device)->host.device, &pInfo_host, params->pLayout);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageSubresourceLayout(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pLayout;
    } *params = args;
    VkDeviceImageSubresourceInfo pInfo_host;
    VkSubresourceLayout2 pLayout_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pLayout);

    init_conversion_context(ctx);
    convert_VkDeviceImageSubresourceInfo_win32_to_host(ctx, (const VkDeviceImageSubresourceInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkSubresourceLayout2_win32_to_host(ctx, (VkSubresourceLayout232 *)UlongToPtr(params->pLayout), &pLayout_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceImageSubresourceLayout(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pLayout_host);
    convert_VkSubresourceLayout2_host_to_win32(&pLayout_host, (VkSubresourceLayout232 *)UlongToPtr(params->pLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceImageSubresourceLayoutKHR(void *args)
{
    struct vkGetDeviceImageSubresourceLayoutKHR_params *params = args;
    VkDeviceImageSubresourceInfo pInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pLayout);

    init_conversion_context(ctx);
    convert_VkDeviceImageSubresourceInfo_win64_to_host(ctx, params->pInfo, &pInfo_host);
    vulkan_device_from_handle(params->device)->p_vkGetDeviceImageSubresourceLayoutKHR(vulkan_device_from_handle(params->device)->host.device, &pInfo_host, params->pLayout);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceImageSubresourceLayoutKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pLayout;
    } *params = args;
    VkDeviceImageSubresourceInfo pInfo_host;
    VkSubresourceLayout2 pLayout_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pLayout);

    init_conversion_context(ctx);
    convert_VkDeviceImageSubresourceInfo_win32_to_host(ctx, (const VkDeviceImageSubresourceInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkSubresourceLayout2_win32_to_host(ctx, (VkSubresourceLayout232 *)UlongToPtr(params->pLayout), &pLayout_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceImageSubresourceLayoutKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pLayout_host);
    convert_VkSubresourceLayout2_host_to_win32(&pLayout_host, (VkSubresourceLayout232 *)UlongToPtr(params->pLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceMemoryCommitment(void *args)
{
    struct vkGetDeviceMemoryCommitment_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->memory), params->pCommittedMemoryInBytes);

    vulkan_device_from_handle(params->device)->p_vkGetDeviceMemoryCommitment(vulkan_device_from_handle(params->device)->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->pCommittedMemoryInBytes);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceMemoryCommitment(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        PTR32 pCommittedMemoryInBytes;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->memory), params->pCommittedMemoryInBytes);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceMemoryCommitment(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, (VkDeviceSize *)UlongToPtr(params->pCommittedMemoryInBytes));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceMemoryOpaqueCaptureAddress(void *args)
{
    struct vkGetDeviceMemoryOpaqueCaptureAddress_params *params = args;
    VkDeviceMemoryOpaqueCaptureAddressInfo pInfo_host;

    TRACE("%p, %p\n", params->device, params->pInfo);

    convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win64_to_host(params->pInfo, &pInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkGetDeviceMemoryOpaqueCaptureAddress(vulkan_device_from_handle(params->device)->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceMemoryOpaqueCaptureAddress(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint64_t result;
    } *params = args;
    VkDeviceMemoryOpaqueCaptureAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win32_to_host((const VkDeviceMemoryOpaqueCaptureAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceMemoryOpaqueCaptureAddress(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceMemoryOpaqueCaptureAddressKHR(void *args)
{
    struct vkGetDeviceMemoryOpaqueCaptureAddressKHR_params *params = args;
    VkDeviceMemoryOpaqueCaptureAddressInfo pInfo_host;

    TRACE("%p, %p\n", params->device, params->pInfo);

    convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win64_to_host(params->pInfo, &pInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkGetDeviceMemoryOpaqueCaptureAddressKHR(vulkan_device_from_handle(params->device)->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceMemoryOpaqueCaptureAddressKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint64_t result;
    } *params = args;
    VkDeviceMemoryOpaqueCaptureAddressInfo pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkDeviceMemoryOpaqueCaptureAddressInfo_win32_to_host((const VkDeviceMemoryOpaqueCaptureAddressInfo32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceMemoryOpaqueCaptureAddressKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceMicromapCompatibilityEXT(void *args)
{
    struct vkGetDeviceMicromapCompatibilityEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pVersionInfo, params->pCompatibility);

    vulkan_device_from_handle(params->device)->p_vkGetDeviceMicromapCompatibilityEXT(vulkan_device_from_handle(params->device)->host.device, params->pVersionInfo, params->pCompatibility);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceMicromapCompatibilityEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pVersionInfo;
        PTR32 pCompatibility;
    } *params = args;
    VkMicromapVersionInfoEXT pVersionInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pVersionInfo, params->pCompatibility);

    convert_VkMicromapVersionInfoEXT_win32_to_host((const VkMicromapVersionInfoEXT32 *)UlongToPtr(params->pVersionInfo), &pVersionInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceMicromapCompatibilityEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pVersionInfo_host, (VkAccelerationStructureCompatibilityKHR *)UlongToPtr(params->pCompatibility));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceQueue(void *args)
{
    struct vkGetDeviceQueue_params *params = args;

    TRACE("%p, %u, %u, %p\n", params->device, params->queueFamilyIndex, params->queueIndex, params->pQueue);

    wine_vkGetDeviceQueue(params->device, params->queueFamilyIndex, params->queueIndex, params->pQueue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceQueue(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t queueFamilyIndex;
        uint32_t queueIndex;
        PTR32 pQueue;
    } *params = args;
    VkQueue pQueue_host;

    TRACE("%#x, %u, %u, %#x\n", params->device, params->queueFamilyIndex, params->queueIndex, params->pQueue);

    pQueue_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pQueue));
    wine_vkGetDeviceQueue((VkDevice)UlongToPtr(params->device), params->queueFamilyIndex, params->queueIndex, &pQueue_host);
    *(PTR32 *)UlongToPtr(params->pQueue) = PtrToUlong(pQueue_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceQueue2(void *args)
{
    struct vkGetDeviceQueue2_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pQueueInfo, params->pQueue);

    wine_vkGetDeviceQueue2(params->device, params->pQueueInfo, params->pQueue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceQueue2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pQueueInfo;
        PTR32 pQueue;
    } *params = args;
    VkDeviceQueueInfo2 pQueueInfo_host;
    VkQueue pQueue_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pQueueInfo, params->pQueue);

    convert_VkDeviceQueueInfo2_win32_to_host((const VkDeviceQueueInfo232 *)UlongToPtr(params->pQueueInfo), &pQueueInfo_host);
    pQueue_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pQueue));
    wine_vkGetDeviceQueue2((VkDevice)UlongToPtr(params->device), &pQueueInfo_host, &pQueue_host);
    *(PTR32 *)UlongToPtr(params->pQueue) = PtrToUlong(pQueue_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(void *args)
{
    struct vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->renderpass), params->pMaxWorkgroupSize);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(vulkan_device_from_handle(params->device)->host.device, params->renderpass, params->pMaxWorkgroupSize);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(void *args)
{
    struct
    {
        PTR32 device;
        VkRenderPass DECLSPEC_ALIGN(8) renderpass;
        PTR32 pMaxWorkgroupSize;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->renderpass), params->pMaxWorkgroupSize);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->renderpass, (VkExtent2D *)UlongToPtr(params->pMaxWorkgroupSize));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDeviceTensorMemoryRequirementsARM(void *args)
{
    struct vkGetDeviceTensorMemoryRequirementsARM_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetDeviceTensorMemoryRequirementsARM(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDeviceTensorMemoryRequirementsARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkDeviceTensorMemoryRequirementsARM pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkDeviceTensorMemoryRequirementsARM_win32_to_host(ctx, (const VkDeviceTensorMemoryRequirementsARM32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceTensorMemoryRequirementsARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetDynamicRenderingTilePropertiesQCOM(void *args)
{
    struct vkGetDynamicRenderingTilePropertiesQCOM_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pRenderingInfo, params->pProperties);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetDynamicRenderingTilePropertiesQCOM(vulkan_device_from_handle(params->device)->host.device, params->pRenderingInfo, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetDynamicRenderingTilePropertiesQCOM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pRenderingInfo;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkRenderingInfo pRenderingInfo_host;
    VkTilePropertiesQCOM pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pRenderingInfo, params->pProperties);

    init_conversion_context(ctx);
    convert_VkRenderingInfo_win32_to_host(ctx, (const VkRenderingInfo32 *)UlongToPtr(params->pRenderingInfo), &pRenderingInfo_host);
    convert_VkTilePropertiesQCOM_win32_to_host((VkTilePropertiesQCOM32 *)UlongToPtr(params->pProperties), &pProperties_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDynamicRenderingTilePropertiesQCOM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pRenderingInfo_host, &pProperties_host);
    convert_VkTilePropertiesQCOM_host_to_win32(&pProperties_host, (VkTilePropertiesQCOM32 *)UlongToPtr(params->pProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetEncodedVideoSessionParametersKHR(void *args)
{
    struct vkGetEncodedVideoSessionParametersKHR_params *params = args;

    TRACE("%p, %p, %p, %p, %p\n", params->device, params->pVideoSessionParametersInfo, params->pFeedbackInfo, params->pDataSize, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetEncodedVideoSessionParametersKHR(vulkan_device_from_handle(params->device)->host.device, params->pVideoSessionParametersInfo, params->pFeedbackInfo, params->pDataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetEncodedVideoSessionParametersKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pVideoSessionParametersInfo;
        PTR32 pFeedbackInfo;
        PTR32 pDataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkVideoEncodeSessionParametersGetInfoKHR pVideoSessionParametersInfo_host;
    VkVideoEncodeSessionParametersFeedbackInfoKHR *pFeedbackInfo_host = NULL;
    size_t pDataSize_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x, %#x\n", params->device, params->pVideoSessionParametersInfo, params->pFeedbackInfo, params->pDataSize, params->pData);

    init_conversion_context(ctx);
    convert_VkVideoEncodeSessionParametersGetInfoKHR_win32_to_host(ctx, (const VkVideoEncodeSessionParametersGetInfoKHR32 *)UlongToPtr(params->pVideoSessionParametersInfo), &pVideoSessionParametersInfo_host);
    if (params->pFeedbackInfo)
    {
        pFeedbackInfo_host = conversion_context_alloc(ctx, sizeof(*pFeedbackInfo_host));
        convert_VkVideoEncodeSessionParametersFeedbackInfoKHR_win32_to_host(ctx, (VkVideoEncodeSessionParametersFeedbackInfoKHR32 *)UlongToPtr(params->pFeedbackInfo), pFeedbackInfo_host);
    }
    pDataSize_host = *(PTR32 *)UlongToPtr(params->pDataSize);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetEncodedVideoSessionParametersKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pVideoSessionParametersInfo_host, pFeedbackInfo_host, &pDataSize_host, (void *)UlongToPtr(params->pData));
    convert_VkVideoEncodeSessionParametersFeedbackInfoKHR_host_to_win32(pFeedbackInfo_host, (VkVideoEncodeSessionParametersFeedbackInfoKHR32 *)UlongToPtr(params->pFeedbackInfo));
    *(PTR32 *)UlongToPtr(params->pDataSize) = pDataSize_host;
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetEventStatus(void *args)
{
    struct vkGetEventStatus_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = vulkan_device_from_handle(params->device)->p_vkGetEventStatus(vulkan_device_from_handle(params->device)->host.device, params->event);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetEventStatus(void *args)
{
    struct
    {
        PTR32 device;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetEventStatus(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->event);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetFenceStatus(void *args)
{
    struct vkGetFenceStatus_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->fence));

    params->result = vulkan_device_from_handle(params->device)->p_vkGetFenceStatus(vulkan_device_from_handle(params->device)->host.device, vulkan_fence_from_handle(params->fence)->host.fence);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetFenceStatus(void *args)
{
    struct
    {
        PTR32 device;
        VkFence DECLSPEC_ALIGN(8) fence;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->fence));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetFenceStatus(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_fence_from_handle(params->fence)->host.fence);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetFenceWin32HandleKHR(void *args)
{
    struct vkGetFenceWin32HandleKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);

    params->result = vk_funcs->p_vkGetFenceWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetFenceWin32HandleKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pGetWin32HandleInfo;
        PTR32 pHandle;
        VkResult result;
    } *params = args;
    VkFenceGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
    HANDLE pHandle_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);

    convert_VkFenceGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkFenceGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
    pHandle_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pHandle));
    params->result = vk_funcs->p_vkGetFenceWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, &pHandle_host);
    *(PTR32 *)UlongToPtr(params->pHandle) = PtrToUlong(pHandle_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetFramebufferTilePropertiesQCOM(void *args)
{
    struct vkGetFramebufferTilePropertiesQCOM_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->framebuffer), params->pPropertiesCount, params->pProperties);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetFramebufferTilePropertiesQCOM(vulkan_device_from_handle(params->device)->host.device, params->framebuffer, params->pPropertiesCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetFramebufferTilePropertiesQCOM(void *args)
{
    struct
    {
        PTR32 device;
        VkFramebuffer DECLSPEC_ALIGN(8) framebuffer;
        PTR32 pPropertiesCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkTilePropertiesQCOM *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->framebuffer), params->pPropertiesCount, params->pProperties);

    init_conversion_context(ctx);
    pProperties_host = convert_VkTilePropertiesQCOM_array_win32_to_host(ctx, (VkTilePropertiesQCOM32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertiesCount));
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetFramebufferTilePropertiesQCOM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->framebuffer, (uint32_t *)UlongToPtr(params->pPropertiesCount), pProperties_host);
    convert_VkTilePropertiesQCOM_array_host_to_win32(pProperties_host, (VkTilePropertiesQCOM32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertiesCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetGeneratedCommandsMemoryRequirementsEXT(void *args)
{
    struct vkGetGeneratedCommandsMemoryRequirementsEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetGeneratedCommandsMemoryRequirementsEXT(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetGeneratedCommandsMemoryRequirementsEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkGeneratedCommandsMemoryRequirementsInfoEXT pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkGeneratedCommandsMemoryRequirementsInfoEXT_win32_to_host(ctx, (const VkGeneratedCommandsMemoryRequirementsInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetGeneratedCommandsMemoryRequirementsEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetGeneratedCommandsMemoryRequirementsNV(void *args)
{
    struct vkGetGeneratedCommandsMemoryRequirementsNV_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetGeneratedCommandsMemoryRequirementsNV(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetGeneratedCommandsMemoryRequirementsNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkGeneratedCommandsMemoryRequirementsInfoNV pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkGeneratedCommandsMemoryRequirementsInfoNV_win32_to_host((const VkGeneratedCommandsMemoryRequirementsInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetGeneratedCommandsMemoryRequirementsNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageMemoryRequirements(void *args)
{
    struct vkGetImageMemoryRequirements_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetImageMemoryRequirements(vulkan_device_from_handle(params->device)->host.device, params->image, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkMemoryRequirements pMemoryRequirements_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pMemoryRequirements);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageMemoryRequirements(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, &pMemoryRequirements_host);
    convert_VkMemoryRequirements_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements32 *)UlongToPtr(params->pMemoryRequirements));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageMemoryRequirements2(void *args)
{
    struct vkGetImageMemoryRequirements2_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetImageMemoryRequirements2(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageMemoryRequirements2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkImageMemoryRequirementsInfo2 pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkImageMemoryRequirementsInfo2_win32_to_host(ctx, (const VkImageMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageMemoryRequirements2(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageMemoryRequirements2KHR(void *args)
{
    struct vkGetImageMemoryRequirements2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetImageMemoryRequirements2KHR(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageMemoryRequirements2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkImageMemoryRequirementsInfo2 pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkImageMemoryRequirementsInfo2_win32_to_host(ctx, (const VkImageMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageMemoryRequirements2KHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct vkGetImageOpaqueCaptureDescriptorDataEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetImageOpaqueCaptureDescriptorDataEXT(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkImageCaptureDescriptorDataInfoEXT pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkImageCaptureDescriptorDataInfoEXT_win32_to_host((const VkImageCaptureDescriptorDataInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageOpaqueCaptureDescriptorDataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSparseMemoryRequirements(void *args)
{
    struct vkGetImageSparseMemoryRequirements_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetImageSparseMemoryRequirements(vulkan_device_from_handle(params->device)->host.device, params->image, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSparseMemoryRequirements(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pSparseMemoryRequirementCount;
        PTR32 pSparseMemoryRequirements;
    } *params = args;
    VkSparseImageMemoryRequirements *pSparseMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    pSparseMemoryRequirements_host = (params->pSparseMemoryRequirements && *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount)) ? conversion_context_alloc(ctx, sizeof(*pSparseMemoryRequirements_host) * *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount)) : NULL;
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageSparseMemoryRequirements(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, (uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount), pSparseMemoryRequirements_host);
    convert_VkSparseImageMemoryRequirements_array_host_to_win32(pSparseMemoryRequirements_host, (VkSparseImageMemoryRequirements32 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSparseMemoryRequirements2(void *args)
{
    struct vkGetImageSparseMemoryRequirements2_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetImageSparseMemoryRequirements2(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSparseMemoryRequirements2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pSparseMemoryRequirementCount;
        PTR32 pSparseMemoryRequirements;
    } *params = args;
    VkImageSparseMemoryRequirementsInfo2 pInfo_host;
    VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkImageSparseMemoryRequirementsInfo2_win32_to_host((const VkImageSparseMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    pSparseMemoryRequirements_host = convert_VkSparseImageMemoryRequirements2_array_win32_to_host(ctx, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageSparseMemoryRequirements2(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount), pSparseMemoryRequirements_host);
    convert_VkSparseImageMemoryRequirements2_array_host_to_win32(pSparseMemoryRequirements_host, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSparseMemoryRequirements2KHR(void *args)
{
    struct vkGetImageSparseMemoryRequirements2KHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetImageSparseMemoryRequirements2KHR(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSparseMemoryRequirements2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pSparseMemoryRequirementCount;
        PTR32 pSparseMemoryRequirements;
    } *params = args;
    VkImageSparseMemoryRequirementsInfo2 pInfo_host;
    VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pInfo, params->pSparseMemoryRequirementCount, params->pSparseMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkImageSparseMemoryRequirementsInfo2_win32_to_host((const VkImageSparseMemoryRequirementsInfo232 *)UlongToPtr(params->pInfo), &pInfo_host);
    pSparseMemoryRequirements_host = convert_VkSparseImageMemoryRequirements2_array_win32_to_host(ctx, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageSparseMemoryRequirements2KHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount), pSparseMemoryRequirements_host);
    convert_VkSparseImageMemoryRequirements2_array_host_to_win32(pSparseMemoryRequirements_host, (VkSparseImageMemoryRequirements232 *)UlongToPtr(params->pSparseMemoryRequirements), *(uint32_t *)UlongToPtr(params->pSparseMemoryRequirementCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSubresourceLayout(void *args)
{
    struct vkGetImageSubresourceLayout_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    vulkan_device_from_handle(params->device)->p_vkGetImageSubresourceLayout(vulkan_device_from_handle(params->device)->host.device, params->image, params->pSubresource, params->pLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSubresourceLayout(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pSubresource;
        PTR32 pLayout;
    } *params = args;
    VkSubresourceLayout pLayout_host;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    convert_VkSubresourceLayout_win32_to_host((VkSubresourceLayout32 *)UlongToPtr(params->pLayout), &pLayout_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageSubresourceLayout(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, (const VkImageSubresource *)UlongToPtr(params->pSubresource), &pLayout_host);
    convert_VkSubresourceLayout_host_to_win32(&pLayout_host, (VkSubresourceLayout32 *)UlongToPtr(params->pLayout));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSubresourceLayout2(void *args)
{
    struct vkGetImageSubresourceLayout2_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    vulkan_device_from_handle(params->device)->p_vkGetImageSubresourceLayout2(vulkan_device_from_handle(params->device)->host.device, params->image, params->pSubresource, params->pLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSubresourceLayout2(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pSubresource;
        PTR32 pLayout;
    } *params = args;
    VkImageSubresource2 pSubresource_host;
    VkSubresourceLayout2 pLayout_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    init_conversion_context(ctx);
    convert_VkImageSubresource2_win32_to_host((const VkImageSubresource232 *)UlongToPtr(params->pSubresource), &pSubresource_host);
    convert_VkSubresourceLayout2_win32_to_host(ctx, (VkSubresourceLayout232 *)UlongToPtr(params->pLayout), &pLayout_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageSubresourceLayout2(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, &pSubresource_host, &pLayout_host);
    convert_VkSubresourceLayout2_host_to_win32(&pLayout_host, (VkSubresourceLayout232 *)UlongToPtr(params->pLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSubresourceLayout2EXT(void *args)
{
    struct vkGetImageSubresourceLayout2EXT_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    vulkan_device_from_handle(params->device)->p_vkGetImageSubresourceLayout2EXT(vulkan_device_from_handle(params->device)->host.device, params->image, params->pSubresource, params->pLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSubresourceLayout2EXT(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pSubresource;
        PTR32 pLayout;
    } *params = args;
    VkImageSubresource2 pSubresource_host;
    VkSubresourceLayout2 pLayout_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    init_conversion_context(ctx);
    convert_VkImageSubresource2_win32_to_host((const VkImageSubresource232 *)UlongToPtr(params->pSubresource), &pSubresource_host);
    convert_VkSubresourceLayout2_win32_to_host(ctx, (VkSubresourceLayout232 *)UlongToPtr(params->pLayout), &pLayout_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageSubresourceLayout2EXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, &pSubresource_host, &pLayout_host);
    convert_VkSubresourceLayout2_host_to_win32(&pLayout_host, (VkSubresourceLayout232 *)UlongToPtr(params->pLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageSubresourceLayout2KHR(void *args)
{
    struct vkGetImageSubresourceLayout2KHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    vulkan_device_from_handle(params->device)->p_vkGetImageSubresourceLayout2KHR(vulkan_device_from_handle(params->device)->host.device, params->image, params->pSubresource, params->pLayout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageSubresourceLayout2KHR(void *args)
{
    struct
    {
        PTR32 device;
        VkImage DECLSPEC_ALIGN(8) image;
        PTR32 pSubresource;
        PTR32 pLayout;
    } *params = args;
    VkImageSubresource2 pSubresource_host;
    VkSubresourceLayout2 pLayout_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->image), params->pSubresource, params->pLayout);

    init_conversion_context(ctx);
    convert_VkImageSubresource2_win32_to_host((const VkImageSubresource232 *)UlongToPtr(params->pSubresource), &pSubresource_host);
    convert_VkSubresourceLayout2_win32_to_host(ctx, (VkSubresourceLayout232 *)UlongToPtr(params->pLayout), &pLayout_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageSubresourceLayout2KHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, &pSubresource_host, &pLayout_host);
    convert_VkSubresourceLayout2_host_to_win32(&pLayout_host, (VkSubresourceLayout232 *)UlongToPtr(params->pLayout));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageViewAddressNVX(void *args)
{
    struct vkGetImageViewAddressNVX_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->imageView), params->pProperties);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetImageViewAddressNVX(vulkan_device_from_handle(params->device)->host.device, params->imageView, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageViewAddressNVX(void *args)
{
    struct
    {
        PTR32 device;
        VkImageView DECLSPEC_ALIGN(8) imageView;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkImageViewAddressPropertiesNVX pProperties_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->imageView), params->pProperties);

    convert_VkImageViewAddressPropertiesNVX_win32_to_host((VkImageViewAddressPropertiesNVX32 *)UlongToPtr(params->pProperties), &pProperties_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageViewAddressNVX(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->imageView, &pProperties_host);
    convert_VkImageViewAddressPropertiesNVX_host_to_win32(&pProperties_host, (VkImageViewAddressPropertiesNVX32 *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageViewHandle64NVX(void *args)
{
    struct vkGetImageViewHandle64NVX_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetImageViewHandle64NVX(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageViewHandle64NVX(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint64_t result;
    } *params = args;
    VkImageViewHandleInfoNVX pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkImageViewHandleInfoNVX_win32_to_host((const VkImageViewHandleInfoNVX32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageViewHandle64NVX(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageViewHandleNVX(void *args)
{
    struct vkGetImageViewHandleNVX_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetImageViewHandleNVX(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageViewHandleNVX(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        uint32_t result;
    } *params = args;
    VkImageViewHandleInfoNVX pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkImageViewHandleInfoNVX_win32_to_host((const VkImageViewHandleInfoNVX32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageViewHandleNVX(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetImageViewOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct vkGetImageViewOpaqueCaptureDescriptorDataEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetImageViewOpaqueCaptureDescriptorDataEXT(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetImageViewOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkImageViewCaptureDescriptorDataInfoEXT pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkImageViewCaptureDescriptorDataInfoEXT_win32_to_host((const VkImageViewCaptureDescriptorDataInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetImageViewOpaqueCaptureDescriptorDataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetLatencyTimingsNV(void *args)
{
    struct vkGetLatencyTimingsNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pLatencyMarkerInfo);

    vulkan_device_from_handle(params->device)->p_vkGetLatencyTimingsNV(vulkan_device_from_handle(params->device)->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, params->pLatencyMarkerInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetLatencyTimingsNV(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pLatencyMarkerInfo;
    } *params = args;
    VkGetLatencyMarkerInfoNV pLatencyMarkerInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pLatencyMarkerInfo);

    init_conversion_context(ctx);
    convert_VkGetLatencyMarkerInfoNV_win32_to_host(ctx, (VkGetLatencyMarkerInfoNV32 *)UlongToPtr(params->pLatencyMarkerInfo), &pLatencyMarkerInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetLatencyTimingsNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, &pLatencyMarkerInfo_host);
    convert_VkGetLatencyMarkerInfoNV_host_to_win32(&pLatencyMarkerInfo_host, (VkGetLatencyMarkerInfoNV32 *)UlongToPtr(params->pLatencyMarkerInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetMemoryHostPointerPropertiesEXT(void *args)
{
    struct vkGetMemoryHostPointerPropertiesEXT_params *params = args;

    TRACE("%p, %#x, %p, %p\n", params->device, params->handleType, params->pHostPointer, params->pMemoryHostPointerProperties);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetMemoryHostPointerPropertiesEXT(vulkan_device_from_handle(params->device)->host.device, params->handleType, params->pHostPointer, params->pMemoryHostPointerProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetMemoryHostPointerPropertiesEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkExternalMemoryHandleTypeFlagBits handleType;
        PTR32 pHostPointer;
        PTR32 pMemoryHostPointerProperties;
        VkResult result;
    } *params = args;
    VkMemoryHostPointerPropertiesEXT pMemoryHostPointerProperties_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->handleType, params->pHostPointer, params->pMemoryHostPointerProperties);

    convert_VkMemoryHostPointerPropertiesEXT_win32_to_host((VkMemoryHostPointerPropertiesEXT32 *)UlongToPtr(params->pMemoryHostPointerProperties), &pMemoryHostPointerProperties_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetMemoryHostPointerPropertiesEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->handleType, (const void *)UlongToPtr(params->pHostPointer), &pMemoryHostPointerProperties_host);
    convert_VkMemoryHostPointerPropertiesEXT_host_to_win32(&pMemoryHostPointerProperties_host, (VkMemoryHostPointerPropertiesEXT32 *)UlongToPtr(params->pMemoryHostPointerProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetMemoryWin32HandleKHR(void *args)
{
    struct vkGetMemoryWin32HandleKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);

    params->result = vk_funcs->p_vkGetMemoryWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetMemoryWin32HandleKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pGetWin32HandleInfo;
        PTR32 pHandle;
        VkResult result;
    } *params = args;
    VkMemoryGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
    HANDLE pHandle_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);

    convert_VkMemoryGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkMemoryGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
    pHandle_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pHandle));
    params->result = vk_funcs->p_vkGetMemoryWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, &pHandle_host);
    *(PTR32 *)UlongToPtr(params->pHandle) = PtrToUlong(pHandle_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetMemoryWin32HandlePropertiesKHR(void *args)
{
    struct vkGetMemoryWin32HandlePropertiesKHR_params *params = args;

    TRACE("%p, %#x, %p, %p\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);

    params->result = vk_funcs->p_vkGetMemoryWin32HandlePropertiesKHR(params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetMemoryWin32HandlePropertiesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkExternalMemoryHandleTypeFlagBits handleType;
        PTR32 handle;
        PTR32 pMemoryWin32HandleProperties;
        VkResult result;
    } *params = args;
    VkMemoryWin32HandlePropertiesKHR pMemoryWin32HandleProperties_host;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);

    convert_VkMemoryWin32HandlePropertiesKHR_win32_to_host((VkMemoryWin32HandlePropertiesKHR32 *)UlongToPtr(params->pMemoryWin32HandleProperties), &pMemoryWin32HandleProperties_host);
    params->result = vk_funcs->p_vkGetMemoryWin32HandlePropertiesKHR((VkDevice)UlongToPtr(params->device), params->handleType, (HANDLE)UlongToPtr(params->handle), &pMemoryWin32HandleProperties_host);
    convert_VkMemoryWin32HandlePropertiesKHR_host_to_win32(&pMemoryWin32HandleProperties_host, (VkMemoryWin32HandlePropertiesKHR32 *)UlongToPtr(params->pMemoryWin32HandleProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetMicromapBuildSizesEXT(void *args)
{
    struct vkGetMicromapBuildSizesEXT_params *params = args;

    TRACE("%p, %#x, %p, %p\n", params->device, params->buildType, params->pBuildInfo, params->pSizeInfo);

    vulkan_device_from_handle(params->device)->p_vkGetMicromapBuildSizesEXT(vulkan_device_from_handle(params->device)->host.device, params->buildType, params->pBuildInfo, params->pSizeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetMicromapBuildSizesEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkAccelerationStructureBuildTypeKHR buildType;
        PTR32 pBuildInfo;
        PTR32 pSizeInfo;
    } *params = args;
    VkMicromapBuildInfoEXT pBuildInfo_host;
    VkMicromapBuildSizesInfoEXT pSizeInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->buildType, params->pBuildInfo, params->pSizeInfo);

    init_conversion_context(ctx);
    convert_VkMicromapBuildInfoEXT_win32_to_host(ctx, (const VkMicromapBuildInfoEXT32 *)UlongToPtr(params->pBuildInfo), &pBuildInfo_host);
    convert_VkMicromapBuildSizesInfoEXT_win32_to_host((VkMicromapBuildSizesInfoEXT32 *)UlongToPtr(params->pSizeInfo), &pSizeInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetMicromapBuildSizesEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->buildType, &pBuildInfo_host, &pSizeInfo_host);
    convert_VkMicromapBuildSizesInfoEXT_host_to_win32(&pSizeInfo_host, (VkMicromapBuildSizesInfoEXT32 *)UlongToPtr(params->pSizeInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPartitionedAccelerationStructuresBuildSizesNV(void *args)
{
    struct vkGetPartitionedAccelerationStructuresBuildSizesNV_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pSizeInfo);

    vulkan_device_from_handle(params->device)->p_vkGetPartitionedAccelerationStructuresBuildSizesNV(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pSizeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPartitionedAccelerationStructuresBuildSizesNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pSizeInfo;
    } *params = args;
    VkPartitionedAccelerationStructureInstancesInputNV pInfo_host;
    VkAccelerationStructureBuildSizesInfoKHR pSizeInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pSizeInfo);

    init_conversion_context(ctx);
    convert_VkPartitionedAccelerationStructureInstancesInputNV_win32_to_host(ctx, (const VkPartitionedAccelerationStructureInstancesInputNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkAccelerationStructureBuildSizesInfoKHR_win32_to_host((VkAccelerationStructureBuildSizesInfoKHR32 *)UlongToPtr(params->pSizeInfo), &pSizeInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPartitionedAccelerationStructuresBuildSizesNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pSizeInfo_host);
    convert_VkPartitionedAccelerationStructureInstancesInputNV_host_to_win32(&pInfo_host, (const VkPartitionedAccelerationStructureInstancesInputNV32 *)UlongToPtr(params->pInfo));
    convert_VkAccelerationStructureBuildSizesInfoKHR_host_to_win32(&pSizeInfo_host, (VkAccelerationStructureBuildSizesInfoKHR32 *)UlongToPtr(params->pSizeInfo));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPerformanceParameterINTEL(void *args)
{
    struct vkGetPerformanceParameterINTEL_params *params = args;

    TRACE("%p, %#x, %p\n", params->device, params->parameter, params->pValue);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetPerformanceParameterINTEL(vulkan_device_from_handle(params->device)->host.device, params->parameter, params->pValue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPerformanceParameterINTEL(void *args)
{
    struct
    {
        PTR32 device;
        VkPerformanceParameterTypeINTEL parameter;
        PTR32 pValue;
        VkResult result;
    } *params = args;
    VkPerformanceValueINTEL pValue_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->parameter, params->pValue);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPerformanceParameterINTEL(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->parameter, &pValue_host);
    convert_VkPerformanceValueINTEL_host_to_win32(&pValue_host, (VkPerformanceValueINTEL32 *)UlongToPtr(params->pValue));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(void *args)
{
    struct vkGetPhysicalDeviceCalibrateableTimeDomainsEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pTimeDomainCount, params->pTimeDomains);

    params->result = wine_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(params->physicalDevice, params->pTimeDomainCount, params->pTimeDomains);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pTimeDomainCount;
        PTR32 pTimeDomains;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pTimeDomainCount, params->pTimeDomains);

    params->result = wine_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT((VkPhysicalDevice)UlongToPtr(params->physicalDevice), (uint32_t *)UlongToPtr(params->pTimeDomainCount), (VkTimeDomainKHR *)UlongToPtr(params->pTimeDomains));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(void *args)
{
    struct vkGetPhysicalDeviceCalibrateableTimeDomainsKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pTimeDomainCount, params->pTimeDomains);

    params->result = wine_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(params->physicalDevice, params->pTimeDomainCount, params->pTimeDomains);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pTimeDomainCount;
        PTR32 pTimeDomains;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pTimeDomainCount, params->pTimeDomains);

    params->result = wine_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), (uint32_t *)UlongToPtr(params->pTimeDomainCount), (VkTimeDomainKHR *)UlongToPtr(params->pTimeDomains));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(void *args)
{
    struct vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkCooperativeMatrixFlexibleDimensionsPropertiesNV *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    init_conversion_context(ctx);
    pProperties_host = convert_VkCooperativeMatrixFlexibleDimensionsPropertiesNV_array_win32_to_host(ctx, (VkCooperativeMatrixFlexibleDimensionsPropertiesNV32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pPropertyCount), pProperties_host);
    convert_VkCooperativeMatrixFlexibleDimensionsPropertiesNV_array_host_to_win32(pProperties_host, (VkCooperativeMatrixFlexibleDimensionsPropertiesNV32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(void *args)
{
    struct vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkCooperativeMatrixPropertiesKHR *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    init_conversion_context(ctx);
    pProperties_host = convert_VkCooperativeMatrixPropertiesKHR_array_win32_to_host(ctx, (VkCooperativeMatrixPropertiesKHR32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pPropertyCount), pProperties_host);
    convert_VkCooperativeMatrixPropertiesKHR_array_host_to_win32(pProperties_host, (VkCooperativeMatrixPropertiesKHR32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(void *args)
{
    struct vkGetPhysicalDeviceCooperativeMatrixPropertiesNV_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkCooperativeMatrixPropertiesNV *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    init_conversion_context(ctx);
    pProperties_host = convert_VkCooperativeMatrixPropertiesNV_array_win32_to_host(ctx, (VkCooperativeMatrixPropertiesNV32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pPropertyCount), pProperties_host);
    convert_VkCooperativeMatrixPropertiesNV_array_host_to_win32(pProperties_host, (VkCooperativeMatrixPropertiesNV32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(void *args)
{
    struct vkGetPhysicalDeviceCooperativeVectorPropertiesNV_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pPropertyCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkCooperativeVectorPropertiesNV *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pPropertyCount, params->pProperties);

    init_conversion_context(ctx);
    pProperties_host = convert_VkCooperativeVectorPropertiesNV_array_win32_to_host(ctx, (VkCooperativeVectorPropertiesNV32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceCooperativeVectorPropertiesNV(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pPropertyCount), pProperties_host);
    convert_VkCooperativeVectorPropertiesNV_array_host_to_win32(pProperties_host, (VkCooperativeVectorPropertiesNV32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalBufferProperties(void *args)
{
    struct vkGetPhysicalDeviceExternalBufferProperties_params *params = args;
    VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalBufferInfo_win64_to_host(ctx, params->pExternalBufferInfo, &pExternalBufferInfo_host);
    vk_funcs->p_vkGetPhysicalDeviceExternalBufferProperties(params->physicalDevice, &pExternalBufferInfo_host, params->pExternalBufferProperties);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalBufferProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalBufferInfo;
        PTR32 pExternalBufferProperties;
    } *params = args;
    VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo_host;
    VkExternalBufferProperties pExternalBufferProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalBufferInfo32 *)UlongToPtr(params->pExternalBufferInfo), &pExternalBufferInfo_host);
    convert_VkExternalBufferProperties_win32_to_host((VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties), &pExternalBufferProperties_host);
    vk_funcs->p_vkGetPhysicalDeviceExternalBufferProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
    convert_VkExternalBufferProperties_host_to_win32(&pExternalBufferProperties_host, (VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalBufferPropertiesKHR(void *args)
{
    struct vkGetPhysicalDeviceExternalBufferPropertiesKHR_params *params = args;
    VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalBufferInfo_win64_to_host(ctx, params->pExternalBufferInfo, &pExternalBufferInfo_host);
    vk_funcs->p_vkGetPhysicalDeviceExternalBufferPropertiesKHR(params->physicalDevice, &pExternalBufferInfo_host, params->pExternalBufferProperties);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalBufferPropertiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalBufferInfo;
        PTR32 pExternalBufferProperties;
    } *params = args;
    VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo_host;
    VkExternalBufferProperties pExternalBufferProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalBufferInfo32 *)UlongToPtr(params->pExternalBufferInfo), &pExternalBufferInfo_host);
    convert_VkExternalBufferProperties_win32_to_host((VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties), &pExternalBufferProperties_host);
    vk_funcs->p_vkGetPhysicalDeviceExternalBufferPropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
    convert_VkExternalBufferProperties_host_to_win32(&pExternalBufferProperties_host, (VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalFenceProperties(void *args)
{
    struct vkGetPhysicalDeviceExternalFenceProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);

    wine_vkGetPhysicalDeviceExternalFenceProperties(params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalFenceProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalFenceInfo;
        PTR32 pExternalFenceProperties;
    } *params = args;
    VkPhysicalDeviceExternalFenceInfo pExternalFenceInfo_host;
    VkExternalFenceProperties pExternalFenceProperties_host;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);

    convert_VkPhysicalDeviceExternalFenceInfo_win32_to_host((const VkPhysicalDeviceExternalFenceInfo32 *)UlongToPtr(params->pExternalFenceInfo), &pExternalFenceInfo_host);
    convert_VkExternalFenceProperties_win32_to_host((VkExternalFenceProperties32 *)UlongToPtr(params->pExternalFenceProperties), &pExternalFenceProperties_host);
    wine_vkGetPhysicalDeviceExternalFenceProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalFenceInfo_host, &pExternalFenceProperties_host);
    convert_VkExternalFenceProperties_host_to_win32(&pExternalFenceProperties_host, (VkExternalFenceProperties32 *)UlongToPtr(params->pExternalFenceProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalFencePropertiesKHR(void *args)
{
    struct vkGetPhysicalDeviceExternalFencePropertiesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);

    wine_vkGetPhysicalDeviceExternalFencePropertiesKHR(params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalFencePropertiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalFenceInfo;
        PTR32 pExternalFenceProperties;
    } *params = args;
    VkPhysicalDeviceExternalFenceInfo pExternalFenceInfo_host;
    VkExternalFenceProperties pExternalFenceProperties_host;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalFenceInfo, params->pExternalFenceProperties);

    convert_VkPhysicalDeviceExternalFenceInfo_win32_to_host((const VkPhysicalDeviceExternalFenceInfo32 *)UlongToPtr(params->pExternalFenceInfo), &pExternalFenceInfo_host);
    convert_VkExternalFenceProperties_win32_to_host((VkExternalFenceProperties32 *)UlongToPtr(params->pExternalFenceProperties), &pExternalFenceProperties_host);
    wine_vkGetPhysicalDeviceExternalFencePropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalFenceInfo_host, &pExternalFenceProperties_host);
    convert_VkExternalFenceProperties_host_to_win32(&pExternalFenceProperties_host, (VkExternalFenceProperties32 *)UlongToPtr(params->pExternalFenceProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalSemaphoreProperties(void *args)
{
    struct vkGetPhysicalDeviceExternalSemaphoreProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);

    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphoreProperties(params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalSemaphoreProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalSemaphoreInfo;
        PTR32 pExternalSemaphoreProperties;
    } *params = args;
    VkPhysicalDeviceExternalSemaphoreInfo pExternalSemaphoreInfo_host;
    VkExternalSemaphoreProperties pExternalSemaphoreProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalSemaphoreInfo32 *)UlongToPtr(params->pExternalSemaphoreInfo), &pExternalSemaphoreInfo_host);
    convert_VkExternalSemaphoreProperties_win32_to_host((VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties), &pExternalSemaphoreProperties_host);
    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphoreProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
    convert_VkExternalSemaphoreProperties_host_to_win32(&pExternalSemaphoreProperties_host, (VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(void *args)
{
    struct vkGetPhysicalDeviceExternalSemaphorePropertiesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);

    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalSemaphoreInfo;
        PTR32 pExternalSemaphoreProperties;
    } *params = args;
    VkPhysicalDeviceExternalSemaphoreInfo pExternalSemaphoreInfo_host;
    VkExternalSemaphoreProperties pExternalSemaphoreProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalSemaphoreInfo32 *)UlongToPtr(params->pExternalSemaphoreInfo), &pExternalSemaphoreInfo_host);
    convert_VkExternalSemaphoreProperties_win32_to_host((VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties), &pExternalSemaphoreProperties_host);
    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
    convert_VkExternalSemaphoreProperties_host_to_win32(&pExternalSemaphoreProperties_host, (VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceExternalTensorPropertiesARM(void *args)
{
    struct vkGetPhysicalDeviceExternalTensorPropertiesARM_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalTensorInfo, params->pExternalTensorProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceExternalTensorPropertiesARM(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pExternalTensorInfo, params->pExternalTensorProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceExternalTensorPropertiesARM(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pExternalTensorInfo;
        PTR32 pExternalTensorProperties;
    } *params = args;
    VkPhysicalDeviceExternalTensorInfoARM pExternalTensorInfo_host;
    VkExternalTensorPropertiesARM pExternalTensorProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pExternalTensorInfo, params->pExternalTensorProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceExternalTensorInfoARM_win32_to_host(ctx, (const VkPhysicalDeviceExternalTensorInfoARM32 *)UlongToPtr(params->pExternalTensorInfo), &pExternalTensorInfo_host);
    convert_VkExternalTensorPropertiesARM_win32_to_host((VkExternalTensorPropertiesARM32 *)UlongToPtr(params->pExternalTensorProperties), &pExternalTensorProperties_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceExternalTensorPropertiesARM(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pExternalTensorInfo_host, &pExternalTensorProperties_host);
    convert_VkExternalTensorPropertiesARM_host_to_win32(&pExternalTensorProperties_host, (VkExternalTensorPropertiesARM32 *)UlongToPtr(params->pExternalTensorProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFeatures(void *args)
{
    struct vkGetPhysicalDeviceFeatures_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pFeatures);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceFeatures(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pFeatures);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFeatures(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFeatures;
    } *params = args;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pFeatures);

    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceFeatures(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (VkPhysicalDeviceFeatures *)UlongToPtr(params->pFeatures));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFeatures2(void *args)
{
    struct vkGetPhysicalDeviceFeatures2_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pFeatures);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceFeatures2(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pFeatures);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFeatures2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFeatures;
    } *params = args;
    VkPhysicalDeviceFeatures2 pFeatures_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pFeatures);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceFeatures2_win32_to_host(ctx, (VkPhysicalDeviceFeatures232 *)UlongToPtr(params->pFeatures), &pFeatures_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceFeatures2(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pFeatures_host);
    convert_VkPhysicalDeviceFeatures2_host_to_win32(&pFeatures_host, (VkPhysicalDeviceFeatures232 *)UlongToPtr(params->pFeatures));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFeatures2KHR(void *args)
{
    struct vkGetPhysicalDeviceFeatures2KHR_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pFeatures);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceFeatures2KHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pFeatures);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFeatures2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFeatures;
    } *params = args;
    VkPhysicalDeviceFeatures2 pFeatures_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pFeatures);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceFeatures2_win32_to_host(ctx, (VkPhysicalDeviceFeatures232 *)UlongToPtr(params->pFeatures), &pFeatures_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceFeatures2KHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pFeatures_host);
    convert_VkPhysicalDeviceFeatures2_host_to_win32(&pFeatures_host, (VkPhysicalDeviceFeatures232 *)UlongToPtr(params->pFeatures));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFormatProperties(void *args)
{
    struct vkGetPhysicalDeviceFormatProperties_params *params = args;

    TRACE("%p, %#x, %p\n", params->physicalDevice, params->format, params->pFormatProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceFormatProperties(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->format, params->pFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFormatProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkFormat format;
        PTR32 pFormatProperties;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->format, params->pFormatProperties);

    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceFormatProperties(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->format, (VkFormatProperties *)UlongToPtr(params->pFormatProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFormatProperties2(void *args)
{
    struct vkGetPhysicalDeviceFormatProperties2_params *params = args;

    TRACE("%p, %#x, %p\n", params->physicalDevice, params->format, params->pFormatProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceFormatProperties2(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->format, params->pFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFormatProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkFormat format;
        PTR32 pFormatProperties;
    } *params = args;
    VkFormatProperties2 pFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->format, params->pFormatProperties);

    init_conversion_context(ctx);
    convert_VkFormatProperties2_win32_to_host(ctx, (VkFormatProperties232 *)UlongToPtr(params->pFormatProperties), &pFormatProperties_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceFormatProperties2(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->format, &pFormatProperties_host);
    convert_VkFormatProperties2_host_to_win32(&pFormatProperties_host, (VkFormatProperties232 *)UlongToPtr(params->pFormatProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFormatProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceFormatProperties2KHR_params *params = args;

    TRACE("%p, %#x, %p\n", params->physicalDevice, params->format, params->pFormatProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceFormatProperties2KHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->format, params->pFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFormatProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkFormat format;
        PTR32 pFormatProperties;
    } *params = args;
    VkFormatProperties2 pFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->format, params->pFormatProperties);

    init_conversion_context(ctx);
    convert_VkFormatProperties2_win32_to_host(ctx, (VkFormatProperties232 *)UlongToPtr(params->pFormatProperties), &pFormatProperties_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceFormatProperties2KHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->format, &pFormatProperties_host);
    convert_VkFormatProperties2_host_to_win32(&pFormatProperties_host, (VkFormatProperties232 *)UlongToPtr(params->pFormatProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceFragmentShadingRatesKHR(void *args)
{
    struct vkGetPhysicalDeviceFragmentShadingRatesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pFragmentShadingRateCount, params->pFragmentShadingRates);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceFragmentShadingRatesKHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pFragmentShadingRateCount, params->pFragmentShadingRates);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceFragmentShadingRatesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFragmentShadingRateCount;
        PTR32 pFragmentShadingRates;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pFragmentShadingRateCount, params->pFragmentShadingRates);

    init_conversion_context(ctx);
    pFragmentShadingRates_host = convert_VkPhysicalDeviceFragmentShadingRateKHR_array_win32_to_host(ctx, (VkPhysicalDeviceFragmentShadingRateKHR32 *)UlongToPtr(params->pFragmentShadingRates), *(uint32_t *)UlongToPtr(params->pFragmentShadingRateCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceFragmentShadingRatesKHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pFragmentShadingRateCount), pFragmentShadingRates_host);
    convert_VkPhysicalDeviceFragmentShadingRateKHR_array_host_to_win32(pFragmentShadingRates_host, (VkPhysicalDeviceFragmentShadingRateKHR32 *)UlongToPtr(params->pFragmentShadingRates), *(uint32_t *)UlongToPtr(params->pFragmentShadingRateCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceImageFormatProperties(void *args)
{
    struct vkGetPhysicalDeviceImageFormatProperties_params *params = args;

    TRACE("%p, %#x, %#x, %#x, %#x, %#x, %p\n", params->physicalDevice, params->format, params->type, params->tiling, params->usage, params->flags, params->pImageFormatProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceImageFormatProperties(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->format, params->type, params->tiling, params->usage, params->flags, params->pImageFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceImageFormatProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkFormat format;
        VkImageType type;
        VkImageTiling tiling;
        VkImageUsageFlags usage;
        VkImageCreateFlags flags;
        PTR32 pImageFormatProperties;
        VkResult result;
    } *params = args;
    VkImageFormatProperties pImageFormatProperties_host;

    TRACE("%#x, %#x, %#x, %#x, %#x, %#x, %#x\n", params->physicalDevice, params->format, params->type, params->tiling, params->usage, params->flags, params->pImageFormatProperties);

    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceImageFormatProperties(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->format, params->type, params->tiling, params->usage, params->flags, &pImageFormatProperties_host);
    convert_VkImageFormatProperties_host_to_win32(&pImageFormatProperties_host, (VkImageFormatProperties32 *)UlongToPtr(params->pImageFormatProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceImageFormatProperties2(void *args)
{
    struct vkGetPhysicalDeviceImageFormatProperties2_params *params = args;
    VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(ctx, params->pImageFormatInfo, &pImageFormatInfo_host);
    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2(params->physicalDevice, &pImageFormatInfo_host, params->pImageFormatProperties);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceImageFormatProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pImageFormatInfo;
        PTR32 pImageFormatProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo_host;
    VkImageFormatProperties2 pImageFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(ctx, (const VkPhysicalDeviceImageFormatInfo232 *)UlongToPtr(params->pImageFormatInfo), &pImageFormatInfo_host);
    convert_VkImageFormatProperties2_win32_to_host(ctx, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties), &pImageFormatProperties_host);
    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
    convert_VkImageFormatProperties2_host_to_win32(&pImageFormatProperties_host, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceImageFormatProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceImageFormatProperties2KHR_params *params = args;
    VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(ctx, params->pImageFormatInfo, &pImageFormatInfo_host);
    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2KHR(params->physicalDevice, &pImageFormatInfo_host, params->pImageFormatProperties);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceImageFormatProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pImageFormatInfo;
        PTR32 pImageFormatProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceImageFormatInfo2 pImageFormatInfo_host;
    VkImageFormatProperties2 pImageFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pImageFormatInfo, params->pImageFormatProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(ctx, (const VkPhysicalDeviceImageFormatInfo232 *)UlongToPtr(params->pImageFormatInfo), &pImageFormatInfo_host);
    convert_VkImageFormatProperties2_win32_to_host(ctx, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties), &pImageFormatProperties_host);
    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2KHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
    convert_VkImageFormatProperties2_host_to_win32(&pImageFormatProperties_host, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceMemoryProperties(void *args)
{
    struct vkGetPhysicalDeviceMemoryProperties_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pMemoryProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceMemoryProperties(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pMemoryProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceMemoryProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pMemoryProperties;
    } *params = args;
    VkPhysicalDeviceMemoryProperties pMemoryProperties_host;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pMemoryProperties);

    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceMemoryProperties(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pMemoryProperties_host);
    convert_VkPhysicalDeviceMemoryProperties_host_to_win32(&pMemoryProperties_host, (VkPhysicalDeviceMemoryProperties32 *)UlongToPtr(params->pMemoryProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceMemoryProperties2(void *args)
{
    struct vkGetPhysicalDeviceMemoryProperties2_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pMemoryProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceMemoryProperties2(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pMemoryProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceMemoryProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pMemoryProperties;
    } *params = args;
    VkPhysicalDeviceMemoryProperties2 pMemoryProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pMemoryProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceMemoryProperties2_win32_to_host(ctx, (VkPhysicalDeviceMemoryProperties232 *)UlongToPtr(params->pMemoryProperties), &pMemoryProperties_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceMemoryProperties2(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pMemoryProperties_host);
    convert_VkPhysicalDeviceMemoryProperties2_host_to_win32(&pMemoryProperties_host, (VkPhysicalDeviceMemoryProperties232 *)UlongToPtr(params->pMemoryProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceMemoryProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceMemoryProperties2KHR_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pMemoryProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceMemoryProperties2KHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pMemoryProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceMemoryProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pMemoryProperties;
    } *params = args;
    VkPhysicalDeviceMemoryProperties2 pMemoryProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pMemoryProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceMemoryProperties2_win32_to_host(ctx, (VkPhysicalDeviceMemoryProperties232 *)UlongToPtr(params->pMemoryProperties), &pMemoryProperties_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceMemoryProperties2KHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pMemoryProperties_host);
    convert_VkPhysicalDeviceMemoryProperties2_host_to_win32(&pMemoryProperties_host, (VkPhysicalDeviceMemoryProperties232 *)UlongToPtr(params->pMemoryProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceMultisamplePropertiesEXT(void *args)
{
    struct vkGetPhysicalDeviceMultisamplePropertiesEXT_params *params = args;

    TRACE("%p, %#x, %p\n", params->physicalDevice, params->samples, params->pMultisampleProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceMultisamplePropertiesEXT(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->samples, params->pMultisampleProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceMultisamplePropertiesEXT(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkSampleCountFlagBits samples;
        PTR32 pMultisampleProperties;
    } *params = args;
    VkMultisamplePropertiesEXT pMultisampleProperties_host;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->samples, params->pMultisampleProperties);

    convert_VkMultisamplePropertiesEXT_win32_to_host((VkMultisamplePropertiesEXT32 *)UlongToPtr(params->pMultisampleProperties), &pMultisampleProperties_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceMultisamplePropertiesEXT(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->samples, &pMultisampleProperties_host);
    convert_VkMultisamplePropertiesEXT_host_to_win32(&pMultisampleProperties_host, (VkMultisamplePropertiesEXT32 *)UlongToPtr(params->pMultisampleProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(void *args)
{
    struct vkGetPhysicalDeviceOpticalFlowImageFormatsNV_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pOpticalFlowImageFormatInfo, params->pFormatCount, params->pImageFormatProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pOpticalFlowImageFormatInfo, params->pFormatCount, params->pImageFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pOpticalFlowImageFormatInfo;
        PTR32 pFormatCount;
        PTR32 pImageFormatProperties;
        VkResult result;
    } *params = args;
    VkOpticalFlowImageFormatInfoNV pOpticalFlowImageFormatInfo_host;
    VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pOpticalFlowImageFormatInfo, params->pFormatCount, params->pImageFormatProperties);

    init_conversion_context(ctx);
    convert_VkOpticalFlowImageFormatInfoNV_win32_to_host((const VkOpticalFlowImageFormatInfoNV32 *)UlongToPtr(params->pOpticalFlowImageFormatInfo), &pOpticalFlowImageFormatInfo_host);
    pImageFormatProperties_host = convert_VkOpticalFlowImageFormatPropertiesNV_array_win32_to_host(ctx, (VkOpticalFlowImageFormatPropertiesNV32 *)UlongToPtr(params->pImageFormatProperties), *(uint32_t *)UlongToPtr(params->pFormatCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pOpticalFlowImageFormatInfo_host, (uint32_t *)UlongToPtr(params->pFormatCount), pImageFormatProperties_host);
    convert_VkOpticalFlowImageFormatPropertiesNV_array_host_to_win32(pImageFormatProperties_host, (VkOpticalFlowImageFormatPropertiesNV32 *)UlongToPtr(params->pImageFormatProperties), *(uint32_t *)UlongToPtr(params->pFormatCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDevicePresentRectanglesKHR(void *args)
{
    struct vkGetPhysicalDevicePresentRectanglesKHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pRectCount, params->pRects);

    params->result = vk_funcs->p_vkGetPhysicalDevicePresentRectanglesKHR(params->physicalDevice, params->surface, params->pRectCount, params->pRects);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDevicePresentRectanglesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pRectCount;
        PTR32 pRects;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pRectCount, params->pRects);

    params->result = vk_funcs->p_vkGetPhysicalDevicePresentRectanglesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), params->surface, (uint32_t *)UlongToPtr(params->pRectCount), (VkRect2D *)UlongToPtr(params->pRects));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceProperties(void *args)
{
    struct vkGetPhysicalDeviceProperties_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceProperties(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pProperties;
    } *params = args;
    VkPhysicalDeviceProperties pProperties_host;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pProperties);

    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceProperties(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pProperties_host);
    convert_VkPhysicalDeviceProperties_host_to_win32(&pProperties_host, (VkPhysicalDeviceProperties32 *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceProperties2(void *args)
{
    struct vkGetPhysicalDeviceProperties2_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceProperties2(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pProperties;
    } *params = args;
    VkPhysicalDeviceProperties2 pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceProperties2_win32_to_host(ctx, (VkPhysicalDeviceProperties232 *)UlongToPtr(params->pProperties), &pProperties_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceProperties2(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pProperties_host);
    convert_VkPhysicalDeviceProperties2_host_to_win32(&pProperties_host, (VkPhysicalDeviceProperties232 *)UlongToPtr(params->pProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceProperties2KHR_params *params = args;

    TRACE("%p, %p\n", params->physicalDevice, params->pProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceProperties2KHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pProperties;
    } *params = args;
    VkPhysicalDeviceProperties2 pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->physicalDevice, params->pProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceProperties2_win32_to_host(ctx, (VkPhysicalDeviceProperties232 *)UlongToPtr(params->pProperties), &pProperties_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceProperties2KHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pProperties_host);
    convert_VkPhysicalDeviceProperties2_host_to_win32(&pProperties_host, (VkPhysicalDeviceProperties232 *)UlongToPtr(params->pProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(void *args)
{
    struct vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pQueueFamilyDataGraphProcessingEngineInfo, params->pQueueFamilyDataGraphProcessingEngineProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pQueueFamilyDataGraphProcessingEngineInfo, params->pQueueFamilyDataGraphProcessingEngineProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pQueueFamilyDataGraphProcessingEngineInfo;
        PTR32 pQueueFamilyDataGraphProcessingEngineProperties;
    } *params = args;
    VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM pQueueFamilyDataGraphProcessingEngineInfo_host;
    VkQueueFamilyDataGraphProcessingEnginePropertiesARM pQueueFamilyDataGraphProcessingEngineProperties_host;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pQueueFamilyDataGraphProcessingEngineInfo, params->pQueueFamilyDataGraphProcessingEngineProperties);

    convert_VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM_win32_to_host((const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM32 *)UlongToPtr(params->pQueueFamilyDataGraphProcessingEngineInfo), &pQueueFamilyDataGraphProcessingEngineInfo_host);
    convert_VkQueueFamilyDataGraphProcessingEnginePropertiesARM_win32_to_host((VkQueueFamilyDataGraphProcessingEnginePropertiesARM32 *)UlongToPtr(params->pQueueFamilyDataGraphProcessingEngineProperties), &pQueueFamilyDataGraphProcessingEngineProperties_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pQueueFamilyDataGraphProcessingEngineInfo_host, &pQueueFamilyDataGraphProcessingEngineProperties_host);
    convert_VkQueueFamilyDataGraphProcessingEnginePropertiesARM_host_to_win32(&pQueueFamilyDataGraphProcessingEngineProperties_host, (VkQueueFamilyDataGraphProcessingEnginePropertiesARM32 *)UlongToPtr(params->pQueueFamilyDataGraphProcessingEngineProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(void *args)
{
    struct vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM_params *params = args;

    TRACE("%p, %u, %p, %p\n", params->physicalDevice, params->queueFamilyIndex, params->pQueueFamilyDataGraphPropertyCount, params->pQueueFamilyDataGraphProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->queueFamilyIndex, params->pQueueFamilyDataGraphPropertyCount, params->pQueueFamilyDataGraphProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        uint32_t queueFamilyIndex;
        PTR32 pQueueFamilyDataGraphPropertyCount;
        PTR32 pQueueFamilyDataGraphProperties;
        VkResult result;
    } *params = args;
    VkQueueFamilyDataGraphPropertiesARM *pQueueFamilyDataGraphProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %#x\n", params->physicalDevice, params->queueFamilyIndex, params->pQueueFamilyDataGraphPropertyCount, params->pQueueFamilyDataGraphProperties);

    init_conversion_context(ctx);
    pQueueFamilyDataGraphProperties_host = convert_VkQueueFamilyDataGraphPropertiesARM_array_win32_to_host(ctx, (VkQueueFamilyDataGraphPropertiesARM32 *)UlongToPtr(params->pQueueFamilyDataGraphProperties), *(uint32_t *)UlongToPtr(params->pQueueFamilyDataGraphPropertyCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->queueFamilyIndex, (uint32_t *)UlongToPtr(params->pQueueFamilyDataGraphPropertyCount), pQueueFamilyDataGraphProperties_host);
    convert_VkQueueFamilyDataGraphPropertiesARM_array_host_to_win32(pQueueFamilyDataGraphProperties_host, (VkQueueFamilyDataGraphPropertiesARM32 *)UlongToPtr(params->pQueueFamilyDataGraphProperties), *(uint32_t *)UlongToPtr(params->pQueueFamilyDataGraphPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(void *args)
{
    struct vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pPerformanceQueryCreateInfo, params->pNumPasses);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pPerformanceQueryCreateInfo, params->pNumPasses);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pPerformanceQueryCreateInfo;
        PTR32 pNumPasses;
    } *params = args;
    VkQueryPoolPerformanceCreateInfoKHR pPerformanceQueryCreateInfo_host;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pPerformanceQueryCreateInfo, params->pNumPasses);

    convert_VkQueryPoolPerformanceCreateInfoKHR_win32_to_host((const VkQueryPoolPerformanceCreateInfoKHR32 *)UlongToPtr(params->pPerformanceQueryCreateInfo), &pPerformanceQueryCreateInfo_host);
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pPerformanceQueryCreateInfo_host, (uint32_t *)UlongToPtr(params->pNumPasses));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceQueueFamilyProperties(void *args)
{
    struct vkGetPhysicalDeviceQueueFamilyProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceQueueFamilyProperties(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceQueueFamilyProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pQueueFamilyPropertyCount;
        PTR32 pQueueFamilyProperties;
    } *params = args;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceQueueFamilyProperties(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount), (VkQueueFamilyProperties *)UlongToPtr(params->pQueueFamilyProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceQueueFamilyProperties2(void *args)
{
    struct vkGetPhysicalDeviceQueueFamilyProperties2_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceQueueFamilyProperties2(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceQueueFamilyProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pQueueFamilyPropertyCount;
        PTR32 pQueueFamilyProperties;
    } *params = args;
    VkQueueFamilyProperties2 *pQueueFamilyProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    init_conversion_context(ctx);
    pQueueFamilyProperties_host = convert_VkQueueFamilyProperties2_array_win32_to_host(ctx, (VkQueueFamilyProperties232 *)UlongToPtr(params->pQueueFamilyProperties), *(uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount));
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceQueueFamilyProperties2(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount), pQueueFamilyProperties_host);
    convert_VkQueueFamilyProperties2_array_host_to_win32(pQueueFamilyProperties_host, (VkQueueFamilyProperties232 *)UlongToPtr(params->pQueueFamilyProperties), *(uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceQueueFamilyProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceQueueFamilyProperties2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceQueueFamilyProperties2KHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceQueueFamilyProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pQueueFamilyPropertyCount;
        PTR32 pQueueFamilyProperties;
    } *params = args;
    VkQueueFamilyProperties2 *pQueueFamilyProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pQueueFamilyPropertyCount, params->pQueueFamilyProperties);

    init_conversion_context(ctx);
    pQueueFamilyProperties_host = convert_VkQueueFamilyProperties2_array_win32_to_host(ctx, (VkQueueFamilyProperties232 *)UlongToPtr(params->pQueueFamilyProperties), *(uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount));
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceQueueFamilyProperties2KHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount), pQueueFamilyProperties_host);
    convert_VkQueueFamilyProperties2_array_host_to_win32(pQueueFamilyProperties_host, (VkQueueFamilyProperties232 *)UlongToPtr(params->pQueueFamilyProperties), *(uint32_t *)UlongToPtr(params->pQueueFamilyPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSparseImageFormatProperties(void *args)
{
    struct vkGetPhysicalDeviceSparseImageFormatProperties_params *params = args;

    TRACE("%p, %#x, %#x, %#x, %#x, %#x, %p, %p\n", params->physicalDevice, params->format, params->type, params->samples, params->usage, params->tiling, params->pPropertyCount, params->pProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceSparseImageFormatProperties(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->format, params->type, params->samples, params->usage, params->tiling, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSparseImageFormatProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkFormat format;
        VkImageType type;
        VkSampleCountFlagBits samples;
        VkImageUsageFlags usage;
        VkImageTiling tiling;
        PTR32 pPropertyCount;
        PTR32 pProperties;
    } *params = args;

    TRACE("%#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x\n", params->physicalDevice, params->format, params->type, params->samples, params->usage, params->tiling, params->pPropertyCount, params->pProperties);

    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceSparseImageFormatProperties(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->format, params->type, params->samples, params->usage, params->tiling, (uint32_t *)UlongToPtr(params->pPropertyCount), (VkSparseImageFormatProperties *)UlongToPtr(params->pProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSparseImageFormatProperties2(void *args)
{
    struct vkGetPhysicalDeviceSparseImageFormatProperties2_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pFormatInfo, params->pPropertyCount, params->pProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceSparseImageFormatProperties2(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pFormatInfo, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSparseImageFormatProperties2(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFormatInfo;
        PTR32 pPropertyCount;
        PTR32 pProperties;
    } *params = args;
    VkPhysicalDeviceSparseImageFormatInfo2 pFormatInfo_host;
    VkSparseImageFormatProperties2 *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pFormatInfo, params->pPropertyCount, params->pProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceSparseImageFormatInfo2_win32_to_host((const VkPhysicalDeviceSparseImageFormatInfo232 *)UlongToPtr(params->pFormatInfo), &pFormatInfo_host);
    pProperties_host = convert_VkSparseImageFormatProperties2_array_win32_to_host(ctx, (VkSparseImageFormatProperties232 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceSparseImageFormatProperties2(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pFormatInfo_host, (uint32_t *)UlongToPtr(params->pPropertyCount), pProperties_host);
    convert_VkSparseImageFormatProperties2_array_host_to_win32(pProperties_host, (VkSparseImageFormatProperties232 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(void *args)
{
    struct vkGetPhysicalDeviceSparseImageFormatProperties2KHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pFormatInfo, params->pPropertyCount, params->pProperties);

    vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pFormatInfo, params->pPropertyCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pFormatInfo;
        PTR32 pPropertyCount;
        PTR32 pProperties;
    } *params = args;
    VkPhysicalDeviceSparseImageFormatInfo2 pFormatInfo_host;
    VkSparseImageFormatProperties2 *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pFormatInfo, params->pPropertyCount, params->pProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceSparseImageFormatInfo2_win32_to_host((const VkPhysicalDeviceSparseImageFormatInfo232 *)UlongToPtr(params->pFormatInfo), &pFormatInfo_host);
    pProperties_host = convert_VkSparseImageFormatProperties2_array_win32_to_host(ctx, (VkSparseImageFormatProperties232 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pFormatInfo_host, (uint32_t *)UlongToPtr(params->pPropertyCount), pProperties_host);
    convert_VkSparseImageFormatProperties2_array_host_to_win32(pProperties_host, (VkSparseImageFormatProperties232 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(void *args)
{
    struct vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pCombinationCount, params->pCombinations);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pCombinationCount, params->pCombinations);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pCombinationCount;
        PTR32 pCombinations;
        VkResult result;
    } *params = args;
    VkFramebufferMixedSamplesCombinationNV *pCombinations_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pCombinationCount, params->pCombinations);

    init_conversion_context(ctx);
    pCombinations_host = convert_VkFramebufferMixedSamplesCombinationNV_array_win32_to_host(ctx, (VkFramebufferMixedSamplesCombinationNV32 *)UlongToPtr(params->pCombinations), *(uint32_t *)UlongToPtr(params->pCombinationCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pCombinationCount), pCombinations_host);
    convert_VkFramebufferMixedSamplesCombinationNV_array_host_to_win32(pCombinations_host, (VkFramebufferMixedSamplesCombinationNV32 *)UlongToPtr(params->pCombinations), *(uint32_t *)UlongToPtr(params->pCombinationCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfaceCapabilities2KHR(void *args)
{
    struct vkGetPhysicalDeviceSurfaceCapabilities2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pSurfaceInfo, params->pSurfaceCapabilities);

    params->result = vk_funcs->p_vkGetPhysicalDeviceSurfaceCapabilities2KHR(params->physicalDevice, params->pSurfaceInfo, params->pSurfaceCapabilities);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfaceCapabilities2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pSurfaceInfo;
        PTR32 pSurfaceCapabilities;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceSurfaceInfo2KHR pSurfaceInfo_host;
    VkSurfaceCapabilities2KHR pSurfaceCapabilities_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pSurfaceInfo, params->pSurfaceCapabilities);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceSurfaceInfo2KHR_win32_to_unwrapped_host(ctx, (const VkPhysicalDeviceSurfaceInfo2KHR32 *)UlongToPtr(params->pSurfaceInfo), &pSurfaceInfo_host);
    convert_VkSurfaceCapabilities2KHR_win32_to_host(ctx, (VkSurfaceCapabilities2KHR32 *)UlongToPtr(params->pSurfaceCapabilities), &pSurfaceCapabilities_host);
    params->result = vk_funcs->p_vkGetPhysicalDeviceSurfaceCapabilities2KHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pSurfaceInfo_host, &pSurfaceCapabilities_host);
    convert_VkSurfaceCapabilities2KHR_host_to_win32(&pSurfaceCapabilities_host, (VkSurfaceCapabilities2KHR32 *)UlongToPtr(params->pSurfaceCapabilities));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(void *args)
{
    struct vkGetPhysicalDeviceSurfaceCapabilitiesKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pSurfaceCapabilities);

    params->result = vk_funcs->p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(params->physicalDevice, params->surface, params->pSurfaceCapabilities);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pSurfaceCapabilities;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pSurfaceCapabilities);

    params->result = vk_funcs->p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), params->surface, (VkSurfaceCapabilitiesKHR *)UlongToPtr(params->pSurfaceCapabilities));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfaceFormats2KHR(void *args)
{
    struct vkGetPhysicalDeviceSurfaceFormats2KHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pSurfaceInfo, params->pSurfaceFormatCount, params->pSurfaceFormats);

    params->result = vk_funcs->p_vkGetPhysicalDeviceSurfaceFormats2KHR(params->physicalDevice, params->pSurfaceInfo, params->pSurfaceFormatCount, params->pSurfaceFormats);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfaceFormats2KHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pSurfaceInfo;
        PTR32 pSurfaceFormatCount;
        PTR32 pSurfaceFormats;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceSurfaceInfo2KHR pSurfaceInfo_host;
    VkSurfaceFormat2KHR *pSurfaceFormats_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pSurfaceInfo, params->pSurfaceFormatCount, params->pSurfaceFormats);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceSurfaceInfo2KHR_win32_to_unwrapped_host(ctx, (const VkPhysicalDeviceSurfaceInfo2KHR32 *)UlongToPtr(params->pSurfaceInfo), &pSurfaceInfo_host);
    pSurfaceFormats_host = convert_VkSurfaceFormat2KHR_array_win32_to_host(ctx, (VkSurfaceFormat2KHR32 *)UlongToPtr(params->pSurfaceFormats), *(uint32_t *)UlongToPtr(params->pSurfaceFormatCount));
    params->result = vk_funcs->p_vkGetPhysicalDeviceSurfaceFormats2KHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pSurfaceInfo_host, (uint32_t *)UlongToPtr(params->pSurfaceFormatCount), pSurfaceFormats_host);
    convert_VkSurfaceFormat2KHR_array_host_to_win32(pSurfaceFormats_host, (VkSurfaceFormat2KHR32 *)UlongToPtr(params->pSurfaceFormats), *(uint32_t *)UlongToPtr(params->pSurfaceFormatCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfaceFormatsKHR(void *args)
{
    struct vkGetPhysicalDeviceSurfaceFormatsKHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pSurfaceFormatCount, params->pSurfaceFormats);

    params->result = vk_funcs->p_vkGetPhysicalDeviceSurfaceFormatsKHR(params->physicalDevice, params->surface, params->pSurfaceFormatCount, params->pSurfaceFormats);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfaceFormatsKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pSurfaceFormatCount;
        PTR32 pSurfaceFormats;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pSurfaceFormatCount, params->pSurfaceFormats);

    params->result = vk_funcs->p_vkGetPhysicalDeviceSurfaceFormatsKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), params->surface, (uint32_t *)UlongToPtr(params->pSurfaceFormatCount), (VkSurfaceFormatKHR *)UlongToPtr(params->pSurfaceFormats));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfacePresentModesKHR(void *args)
{
    struct vkGetPhysicalDeviceSurfacePresentModesKHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pPresentModeCount, params->pPresentModes);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceSurfacePresentModesKHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->surface ? vulkan_surface_from_handle(params->surface)->host.surface : 0, params->pPresentModeCount, params->pPresentModes);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfacePresentModesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pPresentModeCount;
        PTR32 pPresentModes;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->physicalDevice, wine_dbgstr_longlong(params->surface), params->pPresentModeCount, params->pPresentModes);

    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceSurfacePresentModesKHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->surface ? vulkan_surface_from_handle(params->surface)->host.surface : 0, (uint32_t *)UlongToPtr(params->pPresentModeCount), (VkPresentModeKHR *)UlongToPtr(params->pPresentModes));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceSurfaceSupportKHR(void *args)
{
    struct vkGetPhysicalDeviceSurfaceSupportKHR_params *params = args;

    TRACE("%p, %u, 0x%s, %p\n", params->physicalDevice, params->queueFamilyIndex, wine_dbgstr_longlong(params->surface), params->pSupported);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceSurfaceSupportKHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->queueFamilyIndex, vulkan_surface_from_handle(params->surface)->host.surface, params->pSupported);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceSurfaceSupportKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        uint32_t queueFamilyIndex;
        VkSurfaceKHR DECLSPEC_ALIGN(8) surface;
        PTR32 pSupported;
        VkResult result;
    } *params = args;

    TRACE("%#x, %u, 0x%s, %#x\n", params->physicalDevice, params->queueFamilyIndex, wine_dbgstr_longlong(params->surface), params->pSupported);

    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceSurfaceSupportKHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, params->queueFamilyIndex, vulkan_surface_from_handle(params->surface)->host.surface, (VkBool32 *)UlongToPtr(params->pSupported));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceToolProperties(void *args)
{
    struct vkGetPhysicalDeviceToolProperties_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pToolCount, params->pToolProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceToolProperties(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pToolCount, params->pToolProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceToolProperties(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pToolCount;
        PTR32 pToolProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceToolProperties *pToolProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pToolCount, params->pToolProperties);

    init_conversion_context(ctx);
    pToolProperties_host = convert_VkPhysicalDeviceToolProperties_array_win32_to_host(ctx, (VkPhysicalDeviceToolProperties32 *)UlongToPtr(params->pToolProperties), *(uint32_t *)UlongToPtr(params->pToolCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceToolProperties(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pToolCount), pToolProperties_host);
    convert_VkPhysicalDeviceToolProperties_array_host_to_win32(pToolProperties_host, (VkPhysicalDeviceToolProperties32 *)UlongToPtr(params->pToolProperties), *(uint32_t *)UlongToPtr(params->pToolCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceToolPropertiesEXT(void *args)
{
    struct vkGetPhysicalDeviceToolPropertiesEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pToolCount, params->pToolProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceToolPropertiesEXT(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pToolCount, params->pToolProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceToolPropertiesEXT(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pToolCount;
        PTR32 pToolProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceToolProperties *pToolProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pToolCount, params->pToolProperties);

    init_conversion_context(ctx);
    pToolProperties_host = convert_VkPhysicalDeviceToolProperties_array_win32_to_host(ctx, (VkPhysicalDeviceToolProperties32 *)UlongToPtr(params->pToolProperties), *(uint32_t *)UlongToPtr(params->pToolCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceToolPropertiesEXT(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, (uint32_t *)UlongToPtr(params->pToolCount), pToolProperties_host);
    convert_VkPhysicalDeviceToolProperties_array_host_to_win32(pToolProperties_host, (VkPhysicalDeviceToolProperties32 *)UlongToPtr(params->pToolProperties), *(uint32_t *)UlongToPtr(params->pToolCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceVideoCapabilitiesKHR(void *args)
{
    struct vkGetPhysicalDeviceVideoCapabilitiesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pVideoProfile, params->pCapabilities);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceVideoCapabilitiesKHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pVideoProfile, params->pCapabilities);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceVideoCapabilitiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pVideoProfile;
        PTR32 pCapabilities;
        VkResult result;
    } *params = args;
    VkVideoProfileInfoKHR pVideoProfile_host;
    VkVideoCapabilitiesKHR pCapabilities_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pVideoProfile, params->pCapabilities);

    init_conversion_context(ctx);
    convert_VkVideoProfileInfoKHR_win32_to_host(ctx, (const VkVideoProfileInfoKHR32 *)UlongToPtr(params->pVideoProfile), &pVideoProfile_host);
    convert_VkVideoCapabilitiesKHR_win32_to_host(ctx, (VkVideoCapabilitiesKHR32 *)UlongToPtr(params->pCapabilities), &pCapabilities_host);
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceVideoCapabilitiesKHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pVideoProfile_host, &pCapabilities_host);
    convert_VkVideoCapabilitiesKHR_host_to_win32(&pCapabilities_host, (VkVideoCapabilitiesKHR32 *)UlongToPtr(params->pCapabilities));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(void *args)
{
    struct vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->physicalDevice, params->pQualityLevelInfo, params->pQualityLevelProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pQualityLevelInfo, params->pQualityLevelProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pQualityLevelInfo;
        PTR32 pQualityLevelProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR pQualityLevelInfo_host;
    VkVideoEncodeQualityLevelPropertiesKHR pQualityLevelProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->physicalDevice, params->pQualityLevelInfo, params->pQualityLevelProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR_win32_to_host(ctx, (const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR32 *)UlongToPtr(params->pQualityLevelInfo), &pQualityLevelInfo_host);
    convert_VkVideoEncodeQualityLevelPropertiesKHR_win32_to_host(ctx, (VkVideoEncodeQualityLevelPropertiesKHR32 *)UlongToPtr(params->pQualityLevelProperties), &pQualityLevelProperties_host);
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pQualityLevelInfo_host, &pQualityLevelProperties_host);
    convert_VkVideoEncodeQualityLevelPropertiesKHR_host_to_win32(&pQualityLevelProperties_host, (VkVideoEncodeQualityLevelPropertiesKHR32 *)UlongToPtr(params->pQualityLevelProperties));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceVideoFormatPropertiesKHR(void *args)
{
    struct vkGetPhysicalDeviceVideoFormatPropertiesKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->physicalDevice, params->pVideoFormatInfo, params->pVideoFormatPropertyCount, params->pVideoFormatProperties);

    params->result = vulkan_physical_device_from_handle(params->physicalDevice)->instance->p_vkGetPhysicalDeviceVideoFormatPropertiesKHR(vulkan_physical_device_from_handle(params->physicalDevice)->host.physical_device, params->pVideoFormatInfo, params->pVideoFormatPropertyCount, params->pVideoFormatProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceVideoFormatPropertiesKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        PTR32 pVideoFormatInfo;
        PTR32 pVideoFormatPropertyCount;
        PTR32 pVideoFormatProperties;
        VkResult result;
    } *params = args;
    VkPhysicalDeviceVideoFormatInfoKHR pVideoFormatInfo_host;
    VkVideoFormatPropertiesKHR *pVideoFormatProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->physicalDevice, params->pVideoFormatInfo, params->pVideoFormatPropertyCount, params->pVideoFormatProperties);

    init_conversion_context(ctx);
    convert_VkPhysicalDeviceVideoFormatInfoKHR_win32_to_host(ctx, (const VkPhysicalDeviceVideoFormatInfoKHR32 *)UlongToPtr(params->pVideoFormatInfo), &pVideoFormatInfo_host);
    pVideoFormatProperties_host = convert_VkVideoFormatPropertiesKHR_array_win32_to_host(ctx, (VkVideoFormatPropertiesKHR32 *)UlongToPtr(params->pVideoFormatProperties), *(uint32_t *)UlongToPtr(params->pVideoFormatPropertyCount));
    params->result = vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->instance->p_vkGetPhysicalDeviceVideoFormatPropertiesKHR(vulkan_physical_device_from_handle((VkPhysicalDevice)UlongToPtr(params->physicalDevice))->host.physical_device, &pVideoFormatInfo_host, (uint32_t *)UlongToPtr(params->pVideoFormatPropertyCount), pVideoFormatProperties_host);
    convert_VkVideoFormatPropertiesKHR_array_host_to_win32(pVideoFormatProperties_host, (VkVideoFormatPropertiesKHR32 *)UlongToPtr(params->pVideoFormatProperties), *(uint32_t *)UlongToPtr(params->pVideoFormatPropertyCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPhysicalDeviceWin32PresentationSupportKHR(void *args)
{
    struct vkGetPhysicalDeviceWin32PresentationSupportKHR_params *params = args;

    TRACE("%p, %u\n", params->physicalDevice, params->queueFamilyIndex);

    params->result = vk_funcs->p_vkGetPhysicalDeviceWin32PresentationSupportKHR(params->physicalDevice, params->queueFamilyIndex);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPhysicalDeviceWin32PresentationSupportKHR(void *args)
{
    struct
    {
        PTR32 physicalDevice;
        uint32_t queueFamilyIndex;
        VkBool32 result;
    } *params = args;

    TRACE("%#x, %u\n", params->physicalDevice, params->queueFamilyIndex);

    params->result = vk_funcs->p_vkGetPhysicalDeviceWin32PresentationSupportKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), params->queueFamilyIndex);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineBinaryDataKHR(void *args)
{
    struct vkGetPipelineBinaryDataKHR_params *params = args;

    TRACE("%p, %p, %p, %p, %p\n", params->device, params->pInfo, params->pPipelineBinaryKey, params->pPipelineBinaryDataSize, params->pPipelineBinaryData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetPipelineBinaryDataKHR(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pPipelineBinaryKey, params->pPipelineBinaryDataSize, params->pPipelineBinaryData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineBinaryDataKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pPipelineBinaryKey;
        PTR32 pPipelineBinaryDataSize;
        PTR32 pPipelineBinaryData;
        VkResult result;
    } *params = args;
    VkPipelineBinaryDataInfoKHR pInfo_host;
    VkPipelineBinaryKeyKHR pPipelineBinaryKey_host;
    size_t pPipelineBinaryDataSize_host;

    TRACE("%#x, %#x, %#x, %#x, %#x\n", params->device, params->pInfo, params->pPipelineBinaryKey, params->pPipelineBinaryDataSize, params->pPipelineBinaryData);

    convert_VkPipelineBinaryDataInfoKHR_win32_to_host((const VkPipelineBinaryDataInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkPipelineBinaryKeyKHR_win32_to_host((VkPipelineBinaryKeyKHR32 *)UlongToPtr(params->pPipelineBinaryKey), &pPipelineBinaryKey_host);
    pPipelineBinaryDataSize_host = *(PTR32 *)UlongToPtr(params->pPipelineBinaryDataSize);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPipelineBinaryDataKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pPipelineBinaryKey_host, &pPipelineBinaryDataSize_host, (void *)UlongToPtr(params->pPipelineBinaryData));
    convert_VkPipelineBinaryKeyKHR_host_to_win32(&pPipelineBinaryKey_host, (VkPipelineBinaryKeyKHR32 *)UlongToPtr(params->pPipelineBinaryKey));
    *(PTR32 *)UlongToPtr(params->pPipelineBinaryDataSize) = pPipelineBinaryDataSize_host;
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineCacheData(void *args)
{
    struct vkGetPipelineCacheData_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->pDataSize, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetPipelineCacheData(vulkan_device_from_handle(params->device)->host.device, params->pipelineCache, params->pDataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineCacheData(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) pipelineCache;
        PTR32 pDataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;
    size_t pDataSize_host;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->pipelineCache), params->pDataSize, params->pData);

    pDataSize_host = *(PTR32 *)UlongToPtr(params->pDataSize);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPipelineCacheData(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipelineCache, &pDataSize_host, (void *)UlongToPtr(params->pData));
    *(PTR32 *)UlongToPtr(params->pDataSize) = pDataSize_host;
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineExecutableInternalRepresentationsKHR(void *args)
{
    struct vkGetPipelineExecutableInternalRepresentationsKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pExecutableInfo, params->pInternalRepresentationCount, params->pInternalRepresentations);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetPipelineExecutableInternalRepresentationsKHR(vulkan_device_from_handle(params->device)->host.device, params->pExecutableInfo, params->pInternalRepresentationCount, params->pInternalRepresentations);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineExecutableInternalRepresentationsKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pExecutableInfo;
        PTR32 pInternalRepresentationCount;
        PTR32 pInternalRepresentations;
        VkResult result;
    } *params = args;
    VkPipelineExecutableInfoKHR pExecutableInfo_host;
    VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pExecutableInfo, params->pInternalRepresentationCount, params->pInternalRepresentations);

    init_conversion_context(ctx);
    convert_VkPipelineExecutableInfoKHR_win32_to_host((const VkPipelineExecutableInfoKHR32 *)UlongToPtr(params->pExecutableInfo), &pExecutableInfo_host);
    pInternalRepresentations_host = convert_VkPipelineExecutableInternalRepresentationKHR_array_win32_to_host(ctx, (VkPipelineExecutableInternalRepresentationKHR32 *)UlongToPtr(params->pInternalRepresentations), *(uint32_t *)UlongToPtr(params->pInternalRepresentationCount));
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPipelineExecutableInternalRepresentationsKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pExecutableInfo_host, (uint32_t *)UlongToPtr(params->pInternalRepresentationCount), pInternalRepresentations_host);
    convert_VkPipelineExecutableInternalRepresentationKHR_array_host_to_win32(pInternalRepresentations_host, (VkPipelineExecutableInternalRepresentationKHR32 *)UlongToPtr(params->pInternalRepresentations), *(uint32_t *)UlongToPtr(params->pInternalRepresentationCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineExecutablePropertiesKHR(void *args)
{
    struct vkGetPipelineExecutablePropertiesKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pPipelineInfo, params->pExecutableCount, params->pProperties);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetPipelineExecutablePropertiesKHR(vulkan_device_from_handle(params->device)->host.device, params->pPipelineInfo, params->pExecutableCount, params->pProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineExecutablePropertiesKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pPipelineInfo;
        PTR32 pExecutableCount;
        PTR32 pProperties;
        VkResult result;
    } *params = args;
    VkPipelineInfoKHR pPipelineInfo_host;
    VkPipelineExecutablePropertiesKHR *pProperties_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pPipelineInfo, params->pExecutableCount, params->pProperties);

    init_conversion_context(ctx);
    convert_VkPipelineInfoKHR_win32_to_host((const VkPipelineInfoKHR32 *)UlongToPtr(params->pPipelineInfo), &pPipelineInfo_host);
    pProperties_host = convert_VkPipelineExecutablePropertiesKHR_array_win32_to_host(ctx, (VkPipelineExecutablePropertiesKHR32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pExecutableCount));
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPipelineExecutablePropertiesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pPipelineInfo_host, (uint32_t *)UlongToPtr(params->pExecutableCount), pProperties_host);
    convert_VkPipelineExecutablePropertiesKHR_array_host_to_win32(pProperties_host, (VkPipelineExecutablePropertiesKHR32 *)UlongToPtr(params->pProperties), *(uint32_t *)UlongToPtr(params->pExecutableCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineExecutableStatisticsKHR(void *args)
{
    struct vkGetPipelineExecutableStatisticsKHR_params *params = args;

    TRACE("%p, %p, %p, %p\n", params->device, params->pExecutableInfo, params->pStatisticCount, params->pStatistics);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetPipelineExecutableStatisticsKHR(vulkan_device_from_handle(params->device)->host.device, params->pExecutableInfo, params->pStatisticCount, params->pStatistics);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineExecutableStatisticsKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pExecutableInfo;
        PTR32 pStatisticCount;
        PTR32 pStatistics;
        VkResult result;
    } *params = args;
    VkPipelineExecutableInfoKHR pExecutableInfo_host;
    VkPipelineExecutableStatisticKHR *pStatistics_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->pExecutableInfo, params->pStatisticCount, params->pStatistics);

    init_conversion_context(ctx);
    convert_VkPipelineExecutableInfoKHR_win32_to_host((const VkPipelineExecutableInfoKHR32 *)UlongToPtr(params->pExecutableInfo), &pExecutableInfo_host);
    pStatistics_host = convert_VkPipelineExecutableStatisticKHR_array_win32_to_host(ctx, (VkPipelineExecutableStatisticKHR32 *)UlongToPtr(params->pStatistics), *(uint32_t *)UlongToPtr(params->pStatisticCount));
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPipelineExecutableStatisticsKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pExecutableInfo_host, (uint32_t *)UlongToPtr(params->pStatisticCount), pStatistics_host);
    convert_VkPipelineExecutableStatisticKHR_array_host_to_win32(pStatistics_host, (VkPipelineExecutableStatisticKHR32 *)UlongToPtr(params->pStatistics), *(uint32_t *)UlongToPtr(params->pStatisticCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineIndirectDeviceAddressNV(void *args)
{
    struct vkGetPipelineIndirectDeviceAddressNV_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetPipelineIndirectDeviceAddressNV(vulkan_device_from_handle(params->device)->host.device, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineIndirectDeviceAddressNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        VkDeviceAddress result;
    } *params = args;
    VkPipelineIndirectDeviceAddressInfoNV pInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInfo);

    convert_VkPipelineIndirectDeviceAddressInfoNV_win32_to_host((const VkPipelineIndirectDeviceAddressInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPipelineIndirectDeviceAddressNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineIndirectMemoryRequirementsNV(void *args)
{
    struct vkGetPipelineIndirectMemoryRequirementsNV_params *params = args;
    VkComputePipelineCreateInfo pCreateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, %p\n", params->device, params->pCreateInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkComputePipelineCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
    vulkan_device_from_handle(params->device)->p_vkGetPipelineIndirectMemoryRequirementsNV(vulkan_device_from_handle(params->device)->host.device, &pCreateInfo_host, params->pMemoryRequirements);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineIndirectMemoryRequirementsNV(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkComputePipelineCreateInfo pCreateInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkComputePipelineCreateInfo_win32_to_host(ctx, (const VkComputePipelineCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPipelineIndirectMemoryRequirementsNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, &pMemoryRequirements_host);
    convert_VkComputePipelineCreateInfo_host_to_win32(&pCreateInfo_host, (const VkComputePipelineCreateInfo32 *)UlongToPtr(params->pCreateInfo));
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelineKeyKHR(void *args)
{
    struct vkGetPipelineKeyKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pPipelineCreateInfo, params->pPipelineKey);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetPipelineKeyKHR(vulkan_device_from_handle(params->device)->host.device, params->pPipelineCreateInfo, params->pPipelineKey);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelineKeyKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pPipelineCreateInfo;
        PTR32 pPipelineKey;
        VkResult result;
    } *params = args;
    VkPipelineCreateInfoKHR *pPipelineCreateInfo_host = NULL;
    VkPipelineBinaryKeyKHR pPipelineKey_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pPipelineCreateInfo, params->pPipelineKey);

    init_conversion_context(ctx);
    if (params->pPipelineCreateInfo)
    {
        pPipelineCreateInfo_host = conversion_context_alloc(ctx, sizeof(*pPipelineCreateInfo_host));
        convert_VkPipelineCreateInfoKHR_win32_to_host((const VkPipelineCreateInfoKHR32 *)UlongToPtr(params->pPipelineCreateInfo), pPipelineCreateInfo_host);
    }
    convert_VkPipelineBinaryKeyKHR_win32_to_host((VkPipelineBinaryKeyKHR32 *)UlongToPtr(params->pPipelineKey), &pPipelineKey_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPipelineKeyKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, pPipelineCreateInfo_host, &pPipelineKey_host);
    convert_VkPipelineBinaryKeyKHR_host_to_win32(&pPipelineKey_host, (VkPipelineBinaryKeyKHR32 *)UlongToPtr(params->pPipelineKey));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPipelinePropertiesEXT(void *args)
{
    struct vkGetPipelinePropertiesEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pPipelineInfo, params->pPipelineProperties);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetPipelinePropertiesEXT(vulkan_device_from_handle(params->device)->host.device, params->pPipelineInfo, params->pPipelineProperties);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPipelinePropertiesEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pPipelineInfo;
        PTR32 pPipelineProperties;
        VkResult result;
    } *params = args;
    VkPipelineInfoEXT pPipelineInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pPipelineInfo, params->pPipelineProperties);

    convert_VkPipelineInfoEXT_win32_to_host((const VkPipelineInfoEXT32 *)UlongToPtr(params->pPipelineInfo), &pPipelineInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPipelinePropertiesEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pPipelineInfo_host, (VkBaseOutStructure *)UlongToPtr(params->pPipelineProperties));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPrivateData(void *args)
{
    struct vkGetPrivateData_params *params = args;

    TRACE("%p, %#x, 0x%s, 0x%s, %p\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), params->pData);

    vulkan_device_from_handle(params->device)->p_vkGetPrivateData(vulkan_device_from_handle(params->device)->host.device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPrivateData(void *args)
{
    struct
    {
        PTR32 device;
        VkObjectType objectType;
        uint64_t DECLSPEC_ALIGN(8) objectHandle;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        PTR32 pData;
    } *params = args;

    TRACE("%#x, %#x, 0x%s, 0x%s, %#x\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), params->pData);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPrivateData(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, (uint64_t *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetPrivateDataEXT(void *args)
{
    struct vkGetPrivateDataEXT_params *params = args;

    TRACE("%p, %#x, 0x%s, 0x%s, %p\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), params->pData);

    vulkan_device_from_handle(params->device)->p_vkGetPrivateDataEXT(vulkan_device_from_handle(params->device)->host.device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetPrivateDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkObjectType objectType;
        uint64_t DECLSPEC_ALIGN(8) objectHandle;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        PTR32 pData;
    } *params = args;

    TRACE("%#x, %#x, 0x%s, 0x%s, %#x\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), params->pData);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetPrivateDataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, (uint64_t *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetQueryPoolResults(void *args)
{
    struct vkGetQueryPoolResults_params *params = args;

    TRACE("%p, 0x%s, %u, %u, 0x%s, %p, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride), params->flags);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetQueryPoolResults(vulkan_device_from_handle(params->device)->host.device, params->queryPool, params->firstQuery, params->queryCount, params->dataSize, params->pData, params->stride, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetQueryPoolResults(void *args)
{
    struct
    {
        PTR32 device;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
        uint32_t queryCount;
        PTR32 dataSize;
        PTR32 pData;
        VkDeviceSize DECLSPEC_ALIGN(8) stride;
        VkQueryResultFlags flags;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u, 0x%s, %#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride), params->flags);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetQueryPoolResults(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->queryPool, params->firstQuery, params->queryCount, params->dataSize, (void *)UlongToPtr(params->pData), params->stride, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetQueueCheckpointData2NV(void *args)
{
    struct vkGetQueueCheckpointData2NV_params *params = args;

    TRACE("%p, %p, %p\n", params->queue, params->pCheckpointDataCount, params->pCheckpointData);

    vulkan_queue_from_handle(params->queue)->device->p_vkGetQueueCheckpointData2NV(vulkan_queue_from_handle(params->queue)->host.queue, params->pCheckpointDataCount, params->pCheckpointData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetQueueCheckpointData2NV(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pCheckpointDataCount;
        PTR32 pCheckpointData;
    } *params = args;
    VkCheckpointData2NV *pCheckpointData_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->queue, params->pCheckpointDataCount, params->pCheckpointData);

    init_conversion_context(ctx);
    pCheckpointData_host = convert_VkCheckpointData2NV_array_win32_to_host(ctx, (VkCheckpointData2NV32 *)UlongToPtr(params->pCheckpointData), *(uint32_t *)UlongToPtr(params->pCheckpointDataCount));
    vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkGetQueueCheckpointData2NV(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, (uint32_t *)UlongToPtr(params->pCheckpointDataCount), pCheckpointData_host);
    convert_VkCheckpointData2NV_array_host_to_win32(pCheckpointData_host, (VkCheckpointData2NV32 *)UlongToPtr(params->pCheckpointData), *(uint32_t *)UlongToPtr(params->pCheckpointDataCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetQueueCheckpointDataNV(void *args)
{
    struct vkGetQueueCheckpointDataNV_params *params = args;

    TRACE("%p, %p, %p\n", params->queue, params->pCheckpointDataCount, params->pCheckpointData);

    vulkan_queue_from_handle(params->queue)->device->p_vkGetQueueCheckpointDataNV(vulkan_queue_from_handle(params->queue)->host.queue, params->pCheckpointDataCount, params->pCheckpointData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetQueueCheckpointDataNV(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pCheckpointDataCount;
        PTR32 pCheckpointData;
    } *params = args;
    VkCheckpointDataNV *pCheckpointData_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->queue, params->pCheckpointDataCount, params->pCheckpointData);

    init_conversion_context(ctx);
    pCheckpointData_host = convert_VkCheckpointDataNV_array_win32_to_host(ctx, (VkCheckpointDataNV32 *)UlongToPtr(params->pCheckpointData), *(uint32_t *)UlongToPtr(params->pCheckpointDataCount));
    vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkGetQueueCheckpointDataNV(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, (uint32_t *)UlongToPtr(params->pCheckpointDataCount), pCheckpointData_host);
    convert_VkCheckpointDataNV_array_host_to_win32(pCheckpointData_host, (VkCheckpointDataNV32 *)UlongToPtr(params->pCheckpointData), *(uint32_t *)UlongToPtr(params->pCheckpointDataCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(void *args)
{
    struct vkGetRayTracingCaptureReplayShaderGroupHandlesKHR_params *params = args;

    TRACE("%p, 0x%s, %u, %u, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(vulkan_device_from_handle(params->device)->host.device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t firstGroup;
        uint32_t groupCount;
        PTR32 dataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRayTracingShaderGroupHandlesKHR(void *args)
{
    struct vkGetRayTracingShaderGroupHandlesKHR_params *params = args;

    TRACE("%p, 0x%s, %u, %u, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetRayTracingShaderGroupHandlesKHR(vulkan_device_from_handle(params->device)->host.device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRayTracingShaderGroupHandlesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t firstGroup;
        uint32_t groupCount;
        PTR32 dataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetRayTracingShaderGroupHandlesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRayTracingShaderGroupHandlesNV(void *args)
{
    struct vkGetRayTracingShaderGroupHandlesNV_params *params = args;

    TRACE("%p, 0x%s, %u, %u, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetRayTracingShaderGroupHandlesNV(vulkan_device_from_handle(params->device)->host.device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRayTracingShaderGroupHandlesNV(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t firstGroup;
        uint32_t groupCount;
        PTR32 dataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->firstGroup, params->groupCount, wine_dbgstr_longlong(params->dataSize), params->pData);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetRayTracingShaderGroupHandlesNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipeline, params->firstGroup, params->groupCount, params->dataSize, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRayTracingShaderGroupStackSizeKHR(void *args)
{
    struct vkGetRayTracingShaderGroupStackSizeKHR_params *params = args;

    TRACE("%p, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->group, params->groupShader);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetRayTracingShaderGroupStackSizeKHR(vulkan_device_from_handle(params->device)->host.device, params->pipeline, params->group, params->groupShader);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRayTracingShaderGroupStackSizeKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        uint32_t group;
        VkShaderGroupShaderKHR groupShader;
        VkDeviceSize result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->group, params->groupShader);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetRayTracingShaderGroupStackSizeKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipeline, params->group, params->groupShader);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRenderAreaGranularity(void *args)
{
    struct vkGetRenderAreaGranularity_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->renderPass), params->pGranularity);

    vulkan_device_from_handle(params->device)->p_vkGetRenderAreaGranularity(vulkan_device_from_handle(params->device)->host.device, params->renderPass, params->pGranularity);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRenderAreaGranularity(void *args)
{
    struct
    {
        PTR32 device;
        VkRenderPass DECLSPEC_ALIGN(8) renderPass;
        PTR32 pGranularity;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->renderPass), params->pGranularity);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetRenderAreaGranularity(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->renderPass, (VkExtent2D *)UlongToPtr(params->pGranularity));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRenderingAreaGranularity(void *args)
{
    struct vkGetRenderingAreaGranularity_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pRenderingAreaInfo, params->pGranularity);

    vulkan_device_from_handle(params->device)->p_vkGetRenderingAreaGranularity(vulkan_device_from_handle(params->device)->host.device, params->pRenderingAreaInfo, params->pGranularity);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRenderingAreaGranularity(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pRenderingAreaInfo;
        PTR32 pGranularity;
    } *params = args;
    VkRenderingAreaInfo pRenderingAreaInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pRenderingAreaInfo, params->pGranularity);

    convert_VkRenderingAreaInfo_win32_to_host((const VkRenderingAreaInfo32 *)UlongToPtr(params->pRenderingAreaInfo), &pRenderingAreaInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetRenderingAreaGranularity(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pRenderingAreaInfo_host, (VkExtent2D *)UlongToPtr(params->pGranularity));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetRenderingAreaGranularityKHR(void *args)
{
    struct vkGetRenderingAreaGranularityKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pRenderingAreaInfo, params->pGranularity);

    vulkan_device_from_handle(params->device)->p_vkGetRenderingAreaGranularityKHR(vulkan_device_from_handle(params->device)->host.device, params->pRenderingAreaInfo, params->pGranularity);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetRenderingAreaGranularityKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pRenderingAreaInfo;
        PTR32 pGranularity;
    } *params = args;
    VkRenderingAreaInfo pRenderingAreaInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pRenderingAreaInfo, params->pGranularity);

    convert_VkRenderingAreaInfo_win32_to_host((const VkRenderingAreaInfo32 *)UlongToPtr(params->pRenderingAreaInfo), &pRenderingAreaInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetRenderingAreaGranularityKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pRenderingAreaInfo_host, (VkExtent2D *)UlongToPtr(params->pGranularity));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSamplerOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct vkGetSamplerOpaqueCaptureDescriptorDataEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetSamplerOpaqueCaptureDescriptorDataEXT(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSamplerOpaqueCaptureDescriptorDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkSamplerCaptureDescriptorDataInfoEXT pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkSamplerCaptureDescriptorDataInfoEXT_win32_to_host((const VkSamplerCaptureDescriptorDataInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSamplerOpaqueCaptureDescriptorDataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSemaphoreCounterValue(void *args)
{
    struct vkGetSemaphoreCounterValue_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetSemaphoreCounterValue(vulkan_device_from_handle(params->device)->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, params->pValue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSemaphoreCounterValue(void *args)
{
    struct
    {
        PTR32 device;
        VkSemaphore DECLSPEC_ALIGN(8) semaphore;
        PTR32 pValue;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSemaphoreCounterValue(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, (uint64_t *)UlongToPtr(params->pValue));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSemaphoreCounterValueKHR(void *args)
{
    struct vkGetSemaphoreCounterValueKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetSemaphoreCounterValueKHR(vulkan_device_from_handle(params->device)->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, params->pValue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSemaphoreCounterValueKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSemaphore DECLSPEC_ALIGN(8) semaphore;
        PTR32 pValue;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSemaphoreCounterValueKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, (uint64_t *)UlongToPtr(params->pValue));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSemaphoreWin32HandleKHR(void *args)
{
    struct vkGetSemaphoreWin32HandleKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);

    params->result = vk_funcs->p_vkGetSemaphoreWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSemaphoreWin32HandleKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pGetWin32HandleInfo;
        PTR32 pHandle;
        VkResult result;
    } *params = args;
    VkSemaphoreGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
    HANDLE pHandle_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);

    convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkSemaphoreGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
    pHandle_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pHandle));
    params->result = vk_funcs->p_vkGetSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, &pHandle_host);
    *(PTR32 *)UlongToPtr(params->pHandle) = PtrToUlong(pHandle_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetShaderBinaryDataEXT(void *args)
{
    struct vkGetShaderBinaryDataEXT_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->shader), params->pDataSize, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetShaderBinaryDataEXT(vulkan_device_from_handle(params->device)->host.device, params->shader, params->pDataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetShaderBinaryDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkShaderEXT DECLSPEC_ALIGN(8) shader;
        PTR32 pDataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;
    size_t pDataSize_host;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->shader), params->pDataSize, params->pData);

    pDataSize_host = *(PTR32 *)UlongToPtr(params->pDataSize);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetShaderBinaryDataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->shader, &pDataSize_host, (void *)UlongToPtr(params->pData));
    *(PTR32 *)UlongToPtr(params->pDataSize) = pDataSize_host;
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetShaderInfoAMD(void *args)
{
    struct vkGetShaderInfoAMD_params *params = args;

    TRACE("%p, 0x%s, %#x, %#x, %p, %p\n", params->device, wine_dbgstr_longlong(params->pipeline), params->shaderStage, params->infoType, params->pInfoSize, params->pInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetShaderInfoAMD(vulkan_device_from_handle(params->device)->host.device, params->pipeline, params->shaderStage, params->infoType, params->pInfoSize, params->pInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetShaderInfoAMD(void *args)
{
    struct
    {
        PTR32 device;
        VkPipeline DECLSPEC_ALIGN(8) pipeline;
        VkShaderStageFlagBits shaderStage;
        VkShaderInfoTypeAMD infoType;
        PTR32 pInfoSize;
        PTR32 pInfo;
        VkResult result;
    } *params = args;
    size_t pInfoSize_host;

    TRACE("%#x, 0x%s, %#x, %#x, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->pipeline), params->shaderStage, params->infoType, params->pInfoSize, params->pInfo);

    pInfoSize_host = *(PTR32 *)UlongToPtr(params->pInfoSize);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetShaderInfoAMD(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->pipeline, params->shaderStage, params->infoType, &pInfoSize_host, (void *)UlongToPtr(params->pInfo));
    *(PTR32 *)UlongToPtr(params->pInfoSize) = pInfoSize_host;
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetShaderModuleCreateInfoIdentifierEXT(void *args)
{
    struct vkGetShaderModuleCreateInfoIdentifierEXT_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pCreateInfo, params->pIdentifier);

    vulkan_device_from_handle(params->device)->p_vkGetShaderModuleCreateInfoIdentifierEXT(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, params->pIdentifier);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetShaderModuleCreateInfoIdentifierEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pCreateInfo;
        PTR32 pIdentifier;
    } *params = args;
    VkShaderModuleCreateInfo pCreateInfo_host;
    VkShaderModuleIdentifierEXT pIdentifier_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pCreateInfo, params->pIdentifier);

    init_conversion_context(ctx);
    convert_VkShaderModuleCreateInfo_win32_to_host(ctx, (const VkShaderModuleCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
    convert_VkShaderModuleIdentifierEXT_win32_to_host((VkShaderModuleIdentifierEXT32 *)UlongToPtr(params->pIdentifier), &pIdentifier_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetShaderModuleCreateInfoIdentifierEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, &pIdentifier_host);
    convert_VkShaderModuleIdentifierEXT_host_to_win32(&pIdentifier_host, (VkShaderModuleIdentifierEXT32 *)UlongToPtr(params->pIdentifier));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetShaderModuleIdentifierEXT(void *args)
{
    struct vkGetShaderModuleIdentifierEXT_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->shaderModule), params->pIdentifier);

    vulkan_device_from_handle(params->device)->p_vkGetShaderModuleIdentifierEXT(vulkan_device_from_handle(params->device)->host.device, params->shaderModule, params->pIdentifier);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetShaderModuleIdentifierEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkShaderModule DECLSPEC_ALIGN(8) shaderModule;
        PTR32 pIdentifier;
    } *params = args;
    VkShaderModuleIdentifierEXT pIdentifier_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->shaderModule), params->pIdentifier);

    convert_VkShaderModuleIdentifierEXT_win32_to_host((VkShaderModuleIdentifierEXT32 *)UlongToPtr(params->pIdentifier), &pIdentifier_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetShaderModuleIdentifierEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->shaderModule, &pIdentifier_host);
    convert_VkShaderModuleIdentifierEXT_host_to_win32(&pIdentifier_host, (VkShaderModuleIdentifierEXT32 *)UlongToPtr(params->pIdentifier));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetSwapchainImagesKHR(void *args)
{
    struct vkGetSwapchainImagesKHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSwapchainImageCount, params->pSwapchainImages);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetSwapchainImagesKHR(vulkan_device_from_handle(params->device)->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, params->pSwapchainImageCount, params->pSwapchainImages);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetSwapchainImagesKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pSwapchainImageCount;
        PTR32 pSwapchainImages;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSwapchainImageCount, params->pSwapchainImages);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSwapchainImagesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, (uint32_t *)UlongToPtr(params->pSwapchainImageCount), (VkImage *)UlongToPtr(params->pSwapchainImages));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetTensorMemoryRequirementsARM(void *args)
{
    struct vkGetTensorMemoryRequirementsARM_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pMemoryRequirements);

    vulkan_device_from_handle(params->device)->p_vkGetTensorMemoryRequirementsARM(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetTensorMemoryRequirementsARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pMemoryRequirements;
    } *params = args;
    VkTensorMemoryRequirementsInfoARM pInfo_host;
    VkMemoryRequirements2 pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pMemoryRequirements);

    init_conversion_context(ctx);
    convert_VkTensorMemoryRequirementsInfoARM_win32_to_host((const VkTensorMemoryRequirementsInfoARM32 *)UlongToPtr(params->pInfo), &pInfo_host);
    convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetTensorMemoryRequirementsARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
    convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetTensorOpaqueCaptureDescriptorDataARM(void *args)
{
    struct vkGetTensorOpaqueCaptureDescriptorDataARM_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetTensorOpaqueCaptureDescriptorDataARM(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetTensorOpaqueCaptureDescriptorDataARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkTensorCaptureDescriptorDataInfoARM pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkTensorCaptureDescriptorDataInfoARM_win32_to_host((const VkTensorCaptureDescriptorDataInfoARM32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetTensorOpaqueCaptureDescriptorDataARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetTensorViewOpaqueCaptureDescriptorDataARM(void *args)
{
    struct vkGetTensorViewOpaqueCaptureDescriptorDataARM_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetTensorViewOpaqueCaptureDescriptorDataARM(vulkan_device_from_handle(params->device)->host.device, params->pInfo, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetTensorViewOpaqueCaptureDescriptorDataARM(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pData;
        VkResult result;
    } *params = args;
    VkTensorViewCaptureDescriptorDataInfoARM pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pData);

    convert_VkTensorViewCaptureDescriptorDataInfoARM_win32_to_host((const VkTensorViewCaptureDescriptorDataInfoARM32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetTensorViewOpaqueCaptureDescriptorDataARM(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, (void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetValidationCacheDataEXT(void *args)
{
    struct vkGetValidationCacheDataEXT_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->validationCache), params->pDataSize, params->pData);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetValidationCacheDataEXT(vulkan_device_from_handle(params->device)->host.device, params->validationCache, params->pDataSize, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetValidationCacheDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkValidationCacheEXT DECLSPEC_ALIGN(8) validationCache;
        PTR32 pDataSize;
        PTR32 pData;
        VkResult result;
    } *params = args;
    size_t pDataSize_host;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->validationCache), params->pDataSize, params->pData);

    pDataSize_host = *(PTR32 *)UlongToPtr(params->pDataSize);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetValidationCacheDataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->validationCache, &pDataSize_host, (void *)UlongToPtr(params->pData));
    *(PTR32 *)UlongToPtr(params->pDataSize) = pDataSize_host;
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkGetVideoSessionMemoryRequirementsKHR(void *args)
{
    struct vkGetVideoSessionMemoryRequirementsKHR_params *params = args;

    TRACE("%p, 0x%s, %p, %p\n", params->device, wine_dbgstr_longlong(params->videoSession), params->pMemoryRequirementsCount, params->pMemoryRequirements);

    params->result = vulkan_device_from_handle(params->device)->p_vkGetVideoSessionMemoryRequirementsKHR(vulkan_device_from_handle(params->device)->host.device, params->videoSession, params->pMemoryRequirementsCount, params->pMemoryRequirements);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkGetVideoSessionMemoryRequirementsKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkVideoSessionKHR DECLSPEC_ALIGN(8) videoSession;
        PTR32 pMemoryRequirementsCount;
        PTR32 pMemoryRequirements;
        VkResult result;
    } *params = args;
    VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->videoSession), params->pMemoryRequirementsCount, params->pMemoryRequirements);

    init_conversion_context(ctx);
    pMemoryRequirements_host = convert_VkVideoSessionMemoryRequirementsKHR_array_win32_to_host(ctx, (VkVideoSessionMemoryRequirementsKHR32 *)UlongToPtr(params->pMemoryRequirements), *(uint32_t *)UlongToPtr(params->pMemoryRequirementsCount));
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetVideoSessionMemoryRequirementsKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->videoSession, (uint32_t *)UlongToPtr(params->pMemoryRequirementsCount), pMemoryRequirements_host);
    convert_VkVideoSessionMemoryRequirementsKHR_array_host_to_win32(pMemoryRequirements_host, (VkVideoSessionMemoryRequirementsKHR32 *)UlongToPtr(params->pMemoryRequirements), *(uint32_t *)UlongToPtr(params->pMemoryRequirementsCount));
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkImportFenceWin32HandleKHR(void *args)
{
    struct vkImportFenceWin32HandleKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pImportFenceWin32HandleInfo);

    params->result = vk_funcs->p_vkImportFenceWin32HandleKHR(params->device, params->pImportFenceWin32HandleInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkImportFenceWin32HandleKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pImportFenceWin32HandleInfo;
        VkResult result;
    } *params = args;
    VkImportFenceWin32HandleInfoKHR pImportFenceWin32HandleInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pImportFenceWin32HandleInfo);

    convert_VkImportFenceWin32HandleInfoKHR_win32_to_unwrapped_host((const VkImportFenceWin32HandleInfoKHR32 *)UlongToPtr(params->pImportFenceWin32HandleInfo), &pImportFenceWin32HandleInfo_host);
    params->result = vk_funcs->p_vkImportFenceWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pImportFenceWin32HandleInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkImportSemaphoreWin32HandleKHR(void *args)
{
    struct vkImportSemaphoreWin32HandleKHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pImportSemaphoreWin32HandleInfo);

    params->result = vk_funcs->p_vkImportSemaphoreWin32HandleKHR(params->device, params->pImportSemaphoreWin32HandleInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkImportSemaphoreWin32HandleKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pImportSemaphoreWin32HandleInfo;
        VkResult result;
    } *params = args;
    VkImportSemaphoreWin32HandleInfoKHR pImportSemaphoreWin32HandleInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pImportSemaphoreWin32HandleInfo);

    convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_unwrapped_host((const VkImportSemaphoreWin32HandleInfoKHR32 *)UlongToPtr(params->pImportSemaphoreWin32HandleInfo), &pImportSemaphoreWin32HandleInfo_host);
    params->result = vk_funcs->p_vkImportSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pImportSemaphoreWin32HandleInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkInitializePerformanceApiINTEL(void *args)
{
    struct vkInitializePerformanceApiINTEL_params *params = args;

    TRACE("%p, %p\n", params->device, params->pInitializeInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkInitializePerformanceApiINTEL(vulkan_device_from_handle(params->device)->host.device, params->pInitializeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkInitializePerformanceApiINTEL(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInitializeInfo;
        VkResult result;
    } *params = args;
    VkInitializePerformanceApiInfoINTEL pInitializeInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pInitializeInfo);

    convert_VkInitializePerformanceApiInfoINTEL_win32_to_host((const VkInitializePerformanceApiInfoINTEL32 *)UlongToPtr(params->pInitializeInfo), &pInitializeInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkInitializePerformanceApiINTEL(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInitializeInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkInvalidateMappedMemoryRanges(void *args)
{
    struct vkInvalidateMappedMemoryRanges_params *params = args;
    const VkMappedMemoryRange *pMemoryRanges_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->memoryRangeCount, params->pMemoryRanges);

    init_conversion_context(ctx);
    pMemoryRanges_host = convert_VkMappedMemoryRange_array_win64_to_host(ctx, params->pMemoryRanges, params->memoryRangeCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkInvalidateMappedMemoryRanges(vulkan_device_from_handle(params->device)->host.device, params->memoryRangeCount, pMemoryRanges_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkInvalidateMappedMemoryRanges(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t memoryRangeCount;
        PTR32 pMemoryRanges;
        VkResult result;
    } *params = args;
    const VkMappedMemoryRange *pMemoryRanges_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->memoryRangeCount, params->pMemoryRanges);

    init_conversion_context(ctx);
    pMemoryRanges_host = convert_VkMappedMemoryRange_array_win32_to_host(ctx, (const VkMappedMemoryRange32 *)UlongToPtr(params->pMemoryRanges), params->memoryRangeCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkInvalidateMappedMemoryRanges(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->memoryRangeCount, pMemoryRanges_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkLatencySleepNV(void *args)
{
    struct vkLatencySleepNV_params *params = args;
    VkLatencySleepInfoNV pSleepInfo_host;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSleepInfo);

    convert_VkLatencySleepInfoNV_win64_to_host(params->pSleepInfo, &pSleepInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkLatencySleepNV(vulkan_device_from_handle(params->device)->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, &pSleepInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkLatencySleepNV(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pSleepInfo;
        VkResult result;
    } *params = args;
    VkLatencySleepInfoNV pSleepInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSleepInfo);

    convert_VkLatencySleepInfoNV_win32_to_host((const VkLatencySleepInfoNV32 *)UlongToPtr(params->pSleepInfo), &pSleepInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkLatencySleepNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, &pSleepInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkMapMemory(void *args)
{
    struct vkMapMemory_params *params = args;

    TRACE("%p, 0x%s, 0x%s, 0x%s, %#x, %p\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->offset), wine_dbgstr_longlong(params->size), params->flags, params->ppData);

    params->result = vk_funcs->p_vkMapMemory(params->device, params->memory, params->offset, params->size, params->flags, params->ppData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkMapMemory(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        VkDeviceSize DECLSPEC_ALIGN(8) offset;
        VkDeviceSize DECLSPEC_ALIGN(8) size;
        VkMemoryMapFlags flags;
        PTR32 ppData;
        VkResult result;
    } *params = args;
    void *ppData_host;

    TRACE("%#x, 0x%s, 0x%s, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->offset), wine_dbgstr_longlong(params->size), params->flags, params->ppData);

    ppData_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->ppData));
    params->result = vk_funcs->p_vkMapMemory((VkDevice)UlongToPtr(params->device), params->memory, params->offset, params->size, params->flags, &ppData_host);
    *(PTR32 *)UlongToPtr(params->ppData) = PtrToUlong(ppData_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkMapMemory2(void *args)
{
    struct vkMapMemory2_params *params = args;
    VkMemoryMapInfo pMemoryMapInfo_host;

    TRACE("%p, %p, %p\n", params->device, params->pMemoryMapInfo, params->ppData);

    convert_VkMemoryMapInfo_win64_to_host(params->pMemoryMapInfo, &pMemoryMapInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkMapMemory2(vulkan_device_from_handle(params->device)->host.device, &pMemoryMapInfo_host, params->ppData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkMapMemory2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pMemoryMapInfo;
        PTR32 ppData;
        VkResult result;
    } *params = args;
    VkMemoryMapInfo pMemoryMapInfo_host;
    void *ppData_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pMemoryMapInfo, params->ppData);

    convert_VkMemoryMapInfo_win32_to_host((const VkMemoryMapInfo32 *)UlongToPtr(params->pMemoryMapInfo), &pMemoryMapInfo_host);
    ppData_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->ppData));
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkMapMemory2(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pMemoryMapInfo_host, &ppData_host);
    *(PTR32 *)UlongToPtr(params->ppData) = PtrToUlong(ppData_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkMapMemory2KHR(void *args)
{
    struct vkMapMemory2KHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pMemoryMapInfo, params->ppData);

    params->result = vk_funcs->p_vkMapMemory2KHR(params->device, params->pMemoryMapInfo, params->ppData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkMapMemory2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pMemoryMapInfo;
        PTR32 ppData;
        VkResult result;
    } *params = args;
    VkMemoryMapInfo pMemoryMapInfo_host;
    void *ppData_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pMemoryMapInfo, params->ppData);

    convert_VkMemoryMapInfo_win32_to_unwrapped_host((const VkMemoryMapInfo32 *)UlongToPtr(params->pMemoryMapInfo), &pMemoryMapInfo_host);
    ppData_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->ppData));
    params->result = vk_funcs->p_vkMapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryMapInfo_host, &ppData_host);
    *(PTR32 *)UlongToPtr(params->ppData) = PtrToUlong(ppData_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkMergePipelineCaches(void *args)
{
    struct vkMergePipelineCaches_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->dstCache), params->srcCacheCount, params->pSrcCaches);

    params->result = vulkan_device_from_handle(params->device)->p_vkMergePipelineCaches(vulkan_device_from_handle(params->device)->host.device, params->dstCache, params->srcCacheCount, params->pSrcCaches);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkMergePipelineCaches(void *args)
{
    struct
    {
        PTR32 device;
        VkPipelineCache DECLSPEC_ALIGN(8) dstCache;
        uint32_t srcCacheCount;
        PTR32 pSrcCaches;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->dstCache), params->srcCacheCount, params->pSrcCaches);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkMergePipelineCaches(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->dstCache, params->srcCacheCount, (const VkPipelineCache *)UlongToPtr(params->pSrcCaches));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkMergeValidationCachesEXT(void *args)
{
    struct vkMergeValidationCachesEXT_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->dstCache), params->srcCacheCount, params->pSrcCaches);

    params->result = vulkan_device_from_handle(params->device)->p_vkMergeValidationCachesEXT(vulkan_device_from_handle(params->device)->host.device, params->dstCache, params->srcCacheCount, params->pSrcCaches);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkMergeValidationCachesEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkValidationCacheEXT DECLSPEC_ALIGN(8) dstCache;
        uint32_t srcCacheCount;
        PTR32 pSrcCaches;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->dstCache), params->srcCacheCount, params->pSrcCaches);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkMergeValidationCachesEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->dstCache, params->srcCacheCount, (const VkValidationCacheEXT *)UlongToPtr(params->pSrcCaches));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueBeginDebugUtilsLabelEXT(void *args)
{
    struct vkQueueBeginDebugUtilsLabelEXT_params *params = args;

    TRACE("%p, %p\n", params->queue, params->pLabelInfo);

    vulkan_queue_from_handle(params->queue)->device->p_vkQueueBeginDebugUtilsLabelEXT(vulkan_queue_from_handle(params->queue)->host.queue, params->pLabelInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueBeginDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pLabelInfo;
    } *params = args;
    VkDebugUtilsLabelEXT pLabelInfo_host;

    TRACE("%#x, %#x\n", params->queue, params->pLabelInfo);

    convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
    vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueBeginDebugUtilsLabelEXT(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, &pLabelInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueBindSparse(void *args)
{
    struct vkQueueBindSparse_params *params = args;
    const VkBindSparseInfo *pBindInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, 0x%s\n", params->queue, params->bindInfoCount, params->pBindInfo, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pBindInfo_host = convert_VkBindSparseInfo_array_win64_to_host(ctx, params->pBindInfo, params->bindInfoCount);
    params->result = vulkan_queue_from_handle(params->queue)->device->p_vkQueueBindSparse(vulkan_queue_from_handle(params->queue)->host.queue, params->bindInfoCount, pBindInfo_host, params->fence ? vulkan_fence_from_handle(params->fence)->host.fence : 0);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueBindSparse(void *args)
{
    struct
    {
        PTR32 queue;
        uint32_t bindInfoCount;
        PTR32 pBindInfo;
        VkFence DECLSPEC_ALIGN(8) fence;
        VkResult result;
    } *params = args;
    const VkBindSparseInfo *pBindInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->bindInfoCount, params->pBindInfo, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pBindInfo_host = convert_VkBindSparseInfo_array_win32_to_host(ctx, (const VkBindSparseInfo32 *)UlongToPtr(params->pBindInfo), params->bindInfoCount);
    params->result = vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueBindSparse(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, params->bindInfoCount, pBindInfo_host, params->fence ? vulkan_fence_from_handle(params->fence)->host.fence : 0);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueEndDebugUtilsLabelEXT(void *args)
{
    struct vkQueueEndDebugUtilsLabelEXT_params *params = args;

    TRACE("%p\n", params->queue);

    vulkan_queue_from_handle(params->queue)->device->p_vkQueueEndDebugUtilsLabelEXT(vulkan_queue_from_handle(params->queue)->host.queue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueEndDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 queue;
    } *params = args;

    TRACE("%#x\n", params->queue);

    vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueEndDebugUtilsLabelEXT(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueInsertDebugUtilsLabelEXT(void *args)
{
    struct vkQueueInsertDebugUtilsLabelEXT_params *params = args;

    TRACE("%p, %p\n", params->queue, params->pLabelInfo);

    vulkan_queue_from_handle(params->queue)->device->p_vkQueueInsertDebugUtilsLabelEXT(vulkan_queue_from_handle(params->queue)->host.queue, params->pLabelInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueInsertDebugUtilsLabelEXT(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pLabelInfo;
    } *params = args;
    VkDebugUtilsLabelEXT pLabelInfo_host;

    TRACE("%#x, %#x\n", params->queue, params->pLabelInfo);

    convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
    vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueInsertDebugUtilsLabelEXT(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, &pLabelInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueNotifyOutOfBandNV(void *args)
{
    struct vkQueueNotifyOutOfBandNV_params *params = args;

    TRACE("%p, %p\n", params->queue, params->pQueueTypeInfo);

    vulkan_queue_from_handle(params->queue)->device->p_vkQueueNotifyOutOfBandNV(vulkan_queue_from_handle(params->queue)->host.queue, params->pQueueTypeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueNotifyOutOfBandNV(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pQueueTypeInfo;
    } *params = args;
    VkOutOfBandQueueTypeInfoNV pQueueTypeInfo_host;

    TRACE("%#x, %#x\n", params->queue, params->pQueueTypeInfo);

    convert_VkOutOfBandQueueTypeInfoNV_win32_to_host((const VkOutOfBandQueueTypeInfoNV32 *)UlongToPtr(params->pQueueTypeInfo), &pQueueTypeInfo_host);
    vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueNotifyOutOfBandNV(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, &pQueueTypeInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueuePresentKHR(void *args)
{
    struct vkQueuePresentKHR_params *params = args;
    VkPresentInfoKHR pPresentInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p\n", params->queue, params->pPresentInfo);

    init_conversion_context(ctx);
    convert_VkPresentInfoKHR_win64_to_unwrapped_host(ctx, params->pPresentInfo, &pPresentInfo_host);
    params->result = vk_funcs->p_vkQueuePresentKHR(params->queue, &pPresentInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueuePresentKHR(void *args)
{
    struct
    {
        PTR32 queue;
        PTR32 pPresentInfo;
        VkResult result;
    } *params = args;
    VkPresentInfoKHR pPresentInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x\n", params->queue, params->pPresentInfo);

    init_conversion_context(ctx);
    convert_VkPresentInfoKHR_win32_to_unwrapped_host(ctx, (const VkPresentInfoKHR32 *)UlongToPtr(params->pPresentInfo), &pPresentInfo_host);
    params->result = vk_funcs->p_vkQueuePresentKHR((VkQueue)UlongToPtr(params->queue), &pPresentInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueSetPerformanceConfigurationINTEL(void *args)
{
    struct vkQueueSetPerformanceConfigurationINTEL_params *params = args;

    TRACE("%p, 0x%s\n", params->queue, wine_dbgstr_longlong(params->configuration));

    params->result = vulkan_queue_from_handle(params->queue)->device->p_vkQueueSetPerformanceConfigurationINTEL(vulkan_queue_from_handle(params->queue)->host.queue, params->configuration);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueSetPerformanceConfigurationINTEL(void *args)
{
    struct
    {
        PTR32 queue;
        VkPerformanceConfigurationINTEL DECLSPEC_ALIGN(8) configuration;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->queue, wine_dbgstr_longlong(params->configuration));

    params->result = vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueSetPerformanceConfigurationINTEL(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, params->configuration);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueSubmit(void *args)
{
    struct vkQueueSubmit_params *params = args;
    const VkSubmitInfo *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
    params->result = vk_funcs->p_vkQueueSubmit(params->queue, params->submitCount, pSubmits_host, params->fence);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueSubmit(void *args)
{
    struct
    {
        PTR32 queue;
        uint32_t submitCount;
        PTR32 pSubmits;
        VkFence DECLSPEC_ALIGN(8) fence;
        VkResult result;
    } *params = args;
    const VkSubmitInfo *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo32 *)UlongToPtr(params->pSubmits), params->submitCount);
    params->result = vk_funcs->p_vkQueueSubmit((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueSubmit2(void *args)
{
    struct vkQueueSubmit2_params *params = args;
    const VkSubmitInfo2 *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo2_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
    params->result = vk_funcs->p_vkQueueSubmit2(params->queue, params->submitCount, pSubmits_host, params->fence);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueSubmit2(void *args)
{
    struct
    {
        PTR32 queue;
        uint32_t submitCount;
        PTR32 pSubmits;
        VkFence DECLSPEC_ALIGN(8) fence;
        VkResult result;
    } *params = args;
    const VkSubmitInfo2 *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo2_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo232 *)UlongToPtr(params->pSubmits), params->submitCount);
    params->result = vk_funcs->p_vkQueueSubmit2((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueSubmit2KHR(void *args)
{
    struct vkQueueSubmit2KHR_params *params = args;
    const VkSubmitInfo2 *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo2_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
    params->result = vk_funcs->p_vkQueueSubmit2KHR(params->queue, params->submitCount, pSubmits_host, params->fence);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueSubmit2KHR(void *args)
{
    struct
    {
        PTR32 queue;
        uint32_t submitCount;
        PTR32 pSubmits;
        VkFence DECLSPEC_ALIGN(8) fence;
        VkResult result;
    } *params = args;
    const VkSubmitInfo2 *pSubmits_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->submitCount, params->pSubmits, wine_dbgstr_longlong(params->fence));

    init_conversion_context(ctx);
    pSubmits_host = convert_VkSubmitInfo2_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo232 *)UlongToPtr(params->pSubmits), params->submitCount);
    params->result = vk_funcs->p_vkQueueSubmit2KHR((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkQueueWaitIdle(void *args)
{
    struct vkQueueWaitIdle_params *params = args;

    TRACE("%p\n", params->queue);

    params->result = vulkan_queue_from_handle(params->queue)->device->p_vkQueueWaitIdle(vulkan_queue_from_handle(params->queue)->host.queue);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkQueueWaitIdle(void *args)
{
    struct
    {
        PTR32 queue;
        VkResult result;
    } *params = args;

    TRACE("%#x\n", params->queue);

    params->result = vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueWaitIdle(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkReleaseCapturedPipelineDataKHR(void *args)
{
    struct vkReleaseCapturedPipelineDataKHR_params *params = args;

    TRACE("%p, %p, %p\n", params->device, params->pInfo, params->pAllocator);

    params->result = vulkan_device_from_handle(params->device)->p_vkReleaseCapturedPipelineDataKHR(vulkan_device_from_handle(params->device)->host.device, params->pInfo, NULL);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkReleaseCapturedPipelineDataKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pInfo;
        PTR32 pAllocator;
        VkResult result;
    } *params = args;
    VkReleaseCapturedPipelineDataInfoKHR pInfo_host;

    TRACE("%#x, %#x, %#x\n", params->device, params->pInfo, params->pAllocator);

    convert_VkReleaseCapturedPipelineDataInfoKHR_win32_to_host((const VkReleaseCapturedPipelineDataInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkReleaseCapturedPipelineDataKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, NULL);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkReleasePerformanceConfigurationINTEL(void *args)
{
    struct vkReleasePerformanceConfigurationINTEL_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->configuration));

    params->result = vulkan_device_from_handle(params->device)->p_vkReleasePerformanceConfigurationINTEL(vulkan_device_from_handle(params->device)->host.device, params->configuration);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkReleasePerformanceConfigurationINTEL(void *args)
{
    struct
    {
        PTR32 device;
        VkPerformanceConfigurationINTEL DECLSPEC_ALIGN(8) configuration;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->configuration));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkReleasePerformanceConfigurationINTEL(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->configuration);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkReleaseProfilingLockKHR(void *args)
{
    struct vkReleaseProfilingLockKHR_params *params = args;

    TRACE("%p\n", params->device);

    vulkan_device_from_handle(params->device)->p_vkReleaseProfilingLockKHR(vulkan_device_from_handle(params->device)->host.device);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkReleaseProfilingLockKHR(void *args)
{
    struct
    {
        PTR32 device;
    } *params = args;

    TRACE("%#x\n", params->device);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkReleaseProfilingLockKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkReleaseSwapchainImagesEXT(void *args)
{
    struct vkReleaseSwapchainImagesEXT_params *params = args;
    VkReleaseSwapchainImagesInfoKHR pReleaseInfo_host;

    TRACE("%p, %p\n", params->device, params->pReleaseInfo);

    convert_VkReleaseSwapchainImagesInfoKHR_win64_to_host(params->pReleaseInfo, &pReleaseInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkReleaseSwapchainImagesEXT(vulkan_device_from_handle(params->device)->host.device, &pReleaseInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkReleaseSwapchainImagesEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pReleaseInfo;
        VkResult result;
    } *params = args;
    VkReleaseSwapchainImagesInfoKHR pReleaseInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pReleaseInfo);

    convert_VkReleaseSwapchainImagesInfoKHR_win32_to_host((const VkReleaseSwapchainImagesInfoKHR32 *)UlongToPtr(params->pReleaseInfo), &pReleaseInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkReleaseSwapchainImagesEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pReleaseInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkReleaseSwapchainImagesKHR(void *args)
{
    struct vkReleaseSwapchainImagesKHR_params *params = args;
    VkReleaseSwapchainImagesInfoKHR pReleaseInfo_host;

    TRACE("%p, %p\n", params->device, params->pReleaseInfo);

    convert_VkReleaseSwapchainImagesInfoKHR_win64_to_host(params->pReleaseInfo, &pReleaseInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkReleaseSwapchainImagesKHR(vulkan_device_from_handle(params->device)->host.device, &pReleaseInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkReleaseSwapchainImagesKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pReleaseInfo;
        VkResult result;
    } *params = args;
    VkReleaseSwapchainImagesInfoKHR pReleaseInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pReleaseInfo);

    convert_VkReleaseSwapchainImagesInfoKHR_win32_to_host((const VkReleaseSwapchainImagesInfoKHR32 *)UlongToPtr(params->pReleaseInfo), &pReleaseInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkReleaseSwapchainImagesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pReleaseInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetCommandBuffer(void *args)
{
    struct vkResetCommandBuffer_params *params = args;

    TRACE("%p, %#x\n", params->commandBuffer, params->flags);

    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkResetCommandBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetCommandBuffer(void *args)
{
    struct
    {
        PTR32 commandBuffer;
        VkCommandBufferResetFlags flags;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x\n", params->commandBuffer, params->flags);

    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkResetCommandBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetCommandPool(void *args)
{
    struct vkResetCommandPool_params *params = args;

    TRACE("%p, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    params->result = vulkan_device_from_handle(params->device)->p_vkResetCommandPool(vulkan_device_from_handle(params->device)->host.device, wine_cmd_pool_from_handle(params->commandPool)->host.command_pool, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetCommandPool(void *args)
{
    struct
    {
        PTR32 device;
        VkCommandPool DECLSPEC_ALIGN(8) commandPool;
        VkCommandPoolResetFlags flags;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkResetCommandPool(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, wine_cmd_pool_from_handle(params->commandPool)->host.command_pool, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetDescriptorPool(void *args)
{
    struct vkResetDescriptorPool_params *params = args;

    TRACE("%p, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->flags);

    params->result = vulkan_device_from_handle(params->device)->p_vkResetDescriptorPool(vulkan_device_from_handle(params->device)->host.device, params->descriptorPool, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetDescriptorPool(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorPool DECLSPEC_ALIGN(8) descriptorPool;
        VkDescriptorPoolResetFlags flags;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorPool), params->flags);

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkResetDescriptorPool(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->descriptorPool, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetEvent(void *args)
{
    struct vkResetEvent_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = vulkan_device_from_handle(params->device)->p_vkResetEvent(vulkan_device_from_handle(params->device)->host.device, params->event);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetEvent(void *args)
{
    struct
    {
        PTR32 device;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkResetEvent(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->event);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetFences(void *args)
{
    struct vkResetFences_params *params = args;
    const VkFence *pFences_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p\n", params->device, params->fenceCount, params->pFences);

    init_conversion_context(ctx);
    pFences_host = convert_VkFence_array_win64_to_host(ctx, params->pFences, params->fenceCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkResetFences(vulkan_device_from_handle(params->device)->host.device, params->fenceCount, pFences_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetFences(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t fenceCount;
        PTR32 pFences;
        VkResult result;
    } *params = args;
    const VkFence *pFences_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->fenceCount, params->pFences);

    init_conversion_context(ctx);
    pFences_host = convert_VkFence_array_win32_to_host(ctx, (const VkFence *)UlongToPtr(params->pFences), params->fenceCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkResetFences(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fenceCount, pFences_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetQueryPool(void *args)
{
    struct vkResetQueryPool_params *params = args;

    TRACE("%p, 0x%s, %u, %u\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount);

    vulkan_device_from_handle(params->device)->p_vkResetQueryPool(vulkan_device_from_handle(params->device)->host.device, params->queryPool, params->firstQuery, params->queryCount);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetQueryPool(void *args)
{
    struct
    {
        PTR32 device;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
        uint32_t queryCount;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkResetQueryPool(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->queryPool, params->firstQuery, params->queryCount);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkResetQueryPoolEXT(void *args)
{
    struct vkResetQueryPoolEXT_params *params = args;

    TRACE("%p, 0x%s, %u, %u\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount);

    vulkan_device_from_handle(params->device)->p_vkResetQueryPoolEXT(vulkan_device_from_handle(params->device)->host.device, params->queryPool, params->firstQuery, params->queryCount);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkResetQueryPoolEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkQueryPool DECLSPEC_ALIGN(8) queryPool;
        uint32_t firstQuery;
        uint32_t queryCount;
    } *params = args;

    TRACE("%#x, 0x%s, %u, %u\n", params->device, wine_dbgstr_longlong(params->queryPool), params->firstQuery, params->queryCount);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkResetQueryPoolEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->queryPool, params->firstQuery, params->queryCount);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetDebugUtilsObjectNameEXT(void *args)
{
    struct vkSetDebugUtilsObjectNameEXT_params *params = args;
    VkDebugUtilsObjectNameInfoEXT pNameInfo_host;

    TRACE("%p, %p\n", params->device, params->pNameInfo);

    convert_VkDebugUtilsObjectNameInfoEXT_win64_to_host(params->pNameInfo, &pNameInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkSetDebugUtilsObjectNameEXT(vulkan_device_from_handle(params->device)->host.device, &pNameInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetDebugUtilsObjectNameEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pNameInfo;
        VkResult result;
    } *params = args;
    VkDebugUtilsObjectNameInfoEXT pNameInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pNameInfo);

    convert_VkDebugUtilsObjectNameInfoEXT_win32_to_host((const VkDebugUtilsObjectNameInfoEXT32 *)UlongToPtr(params->pNameInfo), &pNameInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetDebugUtilsObjectNameEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pNameInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetDebugUtilsObjectTagEXT(void *args)
{
    struct vkSetDebugUtilsObjectTagEXT_params *params = args;
    VkDebugUtilsObjectTagInfoEXT pTagInfo_host;

    TRACE("%p, %p\n", params->device, params->pTagInfo);

    convert_VkDebugUtilsObjectTagInfoEXT_win64_to_host(params->pTagInfo, &pTagInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkSetDebugUtilsObjectTagEXT(vulkan_device_from_handle(params->device)->host.device, &pTagInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetDebugUtilsObjectTagEXT(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pTagInfo;
        VkResult result;
    } *params = args;
    VkDebugUtilsObjectTagInfoEXT pTagInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pTagInfo);

    convert_VkDebugUtilsObjectTagInfoEXT_win32_to_host((const VkDebugUtilsObjectTagInfoEXT32 *)UlongToPtr(params->pTagInfo), &pTagInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetDebugUtilsObjectTagEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pTagInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetDeviceMemoryPriorityEXT(void *args)
{
    struct vkSetDeviceMemoryPriorityEXT_params *params = args;

    TRACE("%p, 0x%s, %f\n", params->device, wine_dbgstr_longlong(params->memory), params->priority);

    vulkan_device_from_handle(params->device)->p_vkSetDeviceMemoryPriorityEXT(vulkan_device_from_handle(params->device)->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->priority);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetDeviceMemoryPriorityEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
        float priority;
    } *params = args;

    TRACE("%#x, 0x%s, %f\n", params->device, wine_dbgstr_longlong(params->memory), params->priority);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetDeviceMemoryPriorityEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->priority);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetEvent(void *args)
{
    struct vkSetEvent_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = vulkan_device_from_handle(params->device)->p_vkSetEvent(vulkan_device_from_handle(params->device)->host.device, params->event);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetEvent(void *args)
{
    struct
    {
        PTR32 device;
        VkEvent DECLSPEC_ALIGN(8) event;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->event));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetEvent(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->event);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetHdrMetadataEXT(void *args)
{
    struct vkSetHdrMetadataEXT_params *params = args;
    const VkSwapchainKHR *pSwapchains_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, %p\n", params->device, params->swapchainCount, params->pSwapchains, params->pMetadata);

    init_conversion_context(ctx);
    pSwapchains_host = convert_VkSwapchainKHR_array_win64_to_host(ctx, params->pSwapchains, params->swapchainCount);
    vulkan_device_from_handle(params->device)->p_vkSetHdrMetadataEXT(vulkan_device_from_handle(params->device)->host.device, params->swapchainCount, pSwapchains_host, params->pMetadata);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetHdrMetadataEXT(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t swapchainCount;
        PTR32 pSwapchains;
        PTR32 pMetadata;
    } *params = args;
    const VkSwapchainKHR *pSwapchains_host;
    const VkHdrMetadataEXT *pMetadata_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %#x\n", params->device, params->swapchainCount, params->pSwapchains, params->pMetadata);

    init_conversion_context(ctx);
    pSwapchains_host = convert_VkSwapchainKHR_array_win32_to_host(ctx, (const VkSwapchainKHR *)UlongToPtr(params->pSwapchains), params->swapchainCount);
    pMetadata_host = convert_VkHdrMetadataEXT_array_win32_to_host(ctx, (const VkHdrMetadataEXT32 *)UlongToPtr(params->pMetadata), params->swapchainCount);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetHdrMetadataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->swapchainCount, pSwapchains_host, pMetadata_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetLatencyMarkerNV(void *args)
{
    struct vkSetLatencyMarkerNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pLatencyMarkerInfo);

    vulkan_device_from_handle(params->device)->p_vkSetLatencyMarkerNV(vulkan_device_from_handle(params->device)->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, params->pLatencyMarkerInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetLatencyMarkerNV(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pLatencyMarkerInfo;
    } *params = args;
    VkSetLatencyMarkerInfoNV pLatencyMarkerInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pLatencyMarkerInfo);

    convert_VkSetLatencyMarkerInfoNV_win32_to_host((const VkSetLatencyMarkerInfoNV32 *)UlongToPtr(params->pLatencyMarkerInfo), &pLatencyMarkerInfo_host);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetLatencyMarkerNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, &pLatencyMarkerInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetLatencySleepModeNV(void *args)
{
    struct vkSetLatencySleepModeNV_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSleepModeInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkSetLatencySleepModeNV(vulkan_device_from_handle(params->device)->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, params->pSleepModeInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetLatencySleepModeNV(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pSleepModeInfo;
        VkResult result;
    } *params = args;
    VkLatencySleepModeInfoNV pSleepModeInfo_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pSleepModeInfo);

    convert_VkLatencySleepModeInfoNV_win32_to_host((const VkLatencySleepModeInfoNV32 *)UlongToPtr(params->pSleepModeInfo), &pSleepModeInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetLatencySleepModeNV(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, &pSleepModeInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetPrivateData(void *args)
{
    struct vkSetPrivateData_params *params = args;

    TRACE("%p, %#x, 0x%s, 0x%s, 0x%s\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), wine_dbgstr_longlong(params->data));

    params->result = vulkan_device_from_handle(params->device)->p_vkSetPrivateData(vulkan_device_from_handle(params->device)->host.device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->data);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetPrivateData(void *args)
{
    struct
    {
        PTR32 device;
        VkObjectType objectType;
        uint64_t DECLSPEC_ALIGN(8) objectHandle;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        uint64_t DECLSPEC_ALIGN(8) data;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, 0x%s, 0x%s, 0x%s\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), wine_dbgstr_longlong(params->data));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetPrivateData(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->data);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSetPrivateDataEXT(void *args)
{
    struct vkSetPrivateDataEXT_params *params = args;

    TRACE("%p, %#x, 0x%s, 0x%s, 0x%s\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), wine_dbgstr_longlong(params->data));

    params->result = vulkan_device_from_handle(params->device)->p_vkSetPrivateDataEXT(vulkan_device_from_handle(params->device)->host.device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->data);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSetPrivateDataEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkObjectType objectType;
        uint64_t DECLSPEC_ALIGN(8) objectHandle;
        VkPrivateDataSlot DECLSPEC_ALIGN(8) privateDataSlot;
        uint64_t DECLSPEC_ALIGN(8) data;
        VkResult result;
    } *params = args;

    TRACE("%#x, %#x, 0x%s, 0x%s, 0x%s\n", params->device, params->objectType, wine_dbgstr_longlong(params->objectHandle), wine_dbgstr_longlong(params->privateDataSlot), wine_dbgstr_longlong(params->data));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetPrivateDataEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->objectType, wine_vk_unwrap_handle(params->objectType, params->objectHandle), params->privateDataSlot, params->data);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSignalSemaphore(void *args)
{
    struct vkSignalSemaphore_params *params = args;
    VkSemaphoreSignalInfo pSignalInfo_host;

    TRACE("%p, %p\n", params->device, params->pSignalInfo);

    convert_VkSemaphoreSignalInfo_win64_to_host(params->pSignalInfo, &pSignalInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkSignalSemaphore(vulkan_device_from_handle(params->device)->host.device, &pSignalInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSignalSemaphore(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pSignalInfo;
        VkResult result;
    } *params = args;
    VkSemaphoreSignalInfo pSignalInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pSignalInfo);

    convert_VkSemaphoreSignalInfo_win32_to_host((const VkSemaphoreSignalInfo32 *)UlongToPtr(params->pSignalInfo), &pSignalInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSignalSemaphore(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pSignalInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSignalSemaphoreKHR(void *args)
{
    struct vkSignalSemaphoreKHR_params *params = args;
    VkSemaphoreSignalInfo pSignalInfo_host;

    TRACE("%p, %p\n", params->device, params->pSignalInfo);

    convert_VkSemaphoreSignalInfo_win64_to_host(params->pSignalInfo, &pSignalInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkSignalSemaphoreKHR(vulkan_device_from_handle(params->device)->host.device, &pSignalInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSignalSemaphoreKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pSignalInfo;
        VkResult result;
    } *params = args;
    VkSemaphoreSignalInfo pSignalInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pSignalInfo);

    convert_VkSemaphoreSignalInfo_win32_to_host((const VkSemaphoreSignalInfo32 *)UlongToPtr(params->pSignalInfo), &pSignalInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSignalSemaphoreKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pSignalInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkSubmitDebugUtilsMessageEXT(void *args)
{
    struct vkSubmitDebugUtilsMessageEXT_params *params = args;
    VkDebugUtilsMessengerCallbackDataEXT pCallbackData_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %#x, %#x, %p\n", params->instance, params->messageSeverity, params->messageTypes, params->pCallbackData);

    init_conversion_context(ctx);
    convert_VkDebugUtilsMessengerCallbackDataEXT_win64_to_host(ctx, params->pCallbackData, &pCallbackData_host);
    vulkan_instance_from_handle(params->instance)->p_vkSubmitDebugUtilsMessageEXT(vulkan_instance_from_handle(params->instance)->host.instance, params->messageSeverity, params->messageTypes, &pCallbackData_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkSubmitDebugUtilsMessageEXT(void *args)
{
    struct
    {
        PTR32 instance;
        VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity;
        VkDebugUtilsMessageTypeFlagsEXT messageTypes;
        PTR32 pCallbackData;
    } *params = args;
    VkDebugUtilsMessengerCallbackDataEXT pCallbackData_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, %#x, %#x\n", params->instance, params->messageSeverity, params->messageTypes, params->pCallbackData);

    init_conversion_context(ctx);
    convert_VkDebugUtilsMessengerCallbackDataEXT_win32_to_host(ctx, (const VkDebugUtilsMessengerCallbackDataEXT32 *)UlongToPtr(params->pCallbackData), &pCallbackData_host);
    vulkan_instance_from_handle((VkInstance)UlongToPtr(params->instance))->p_vkSubmitDebugUtilsMessageEXT(vulkan_instance_from_handle((VkInstance)UlongToPtr(params->instance))->host.instance, params->messageSeverity, params->messageTypes, &pCallbackData_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkTransitionImageLayout(void *args)
{
    struct vkTransitionImageLayout_params *params = args;

    TRACE("%p, %u, %p\n", params->device, params->transitionCount, params->pTransitions);

    params->result = vulkan_device_from_handle(params->device)->p_vkTransitionImageLayout(vulkan_device_from_handle(params->device)->host.device, params->transitionCount, params->pTransitions);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkTransitionImageLayout(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t transitionCount;
        PTR32 pTransitions;
        VkResult result;
    } *params = args;
    const VkHostImageLayoutTransitionInfo *pTransitions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->transitionCount, params->pTransitions);

    init_conversion_context(ctx);
    pTransitions_host = convert_VkHostImageLayoutTransitionInfo_array_win32_to_host(ctx, (const VkHostImageLayoutTransitionInfo32 *)UlongToPtr(params->pTransitions), params->transitionCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkTransitionImageLayout(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->transitionCount, pTransitions_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkTransitionImageLayoutEXT(void *args)
{
    struct vkTransitionImageLayoutEXT_params *params = args;

    TRACE("%p, %u, %p\n", params->device, params->transitionCount, params->pTransitions);

    params->result = vulkan_device_from_handle(params->device)->p_vkTransitionImageLayoutEXT(vulkan_device_from_handle(params->device)->host.device, params->transitionCount, params->pTransitions);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkTransitionImageLayoutEXT(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t transitionCount;
        PTR32 pTransitions;
        VkResult result;
    } *params = args;
    const VkHostImageLayoutTransitionInfo *pTransitions_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x\n", params->device, params->transitionCount, params->pTransitions);

    init_conversion_context(ctx);
    pTransitions_host = convert_VkHostImageLayoutTransitionInfo_array_win32_to_host(ctx, (const VkHostImageLayoutTransitionInfo32 *)UlongToPtr(params->pTransitions), params->transitionCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkTransitionImageLayoutEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->transitionCount, pTransitions_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkTrimCommandPool(void *args)
{
    struct vkTrimCommandPool_params *params = args;

    TRACE("%p, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    vulkan_device_from_handle(params->device)->p_vkTrimCommandPool(vulkan_device_from_handle(params->device)->host.device, wine_cmd_pool_from_handle(params->commandPool)->host.command_pool, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkTrimCommandPool(void *args)
{
    struct
    {
        PTR32 device;
        VkCommandPool DECLSPEC_ALIGN(8) commandPool;
        VkCommandPoolTrimFlags flags;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkTrimCommandPool(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, wine_cmd_pool_from_handle(params->commandPool)->host.command_pool, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkTrimCommandPoolKHR(void *args)
{
    struct vkTrimCommandPoolKHR_params *params = args;

    TRACE("%p, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    vulkan_device_from_handle(params->device)->p_vkTrimCommandPoolKHR(vulkan_device_from_handle(params->device)->host.device, wine_cmd_pool_from_handle(params->commandPool)->host.command_pool, params->flags);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkTrimCommandPoolKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkCommandPool DECLSPEC_ALIGN(8) commandPool;
        VkCommandPoolTrimFlags flags;
    } *params = args;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->commandPool), params->flags);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkTrimCommandPoolKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, wine_cmd_pool_from_handle(params->commandPool)->host.command_pool, params->flags);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUninitializePerformanceApiINTEL(void *args)
{
    struct vkUninitializePerformanceApiINTEL_params *params = args;

    TRACE("%p\n", params->device);

    vulkan_device_from_handle(params->device)->p_vkUninitializePerformanceApiINTEL(vulkan_device_from_handle(params->device)->host.device);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUninitializePerformanceApiINTEL(void *args)
{
    struct
    {
        PTR32 device;
    } *params = args;

    TRACE("%#x\n", params->device);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkUninitializePerformanceApiINTEL(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUnmapMemory(void *args)
{
    struct vkUnmapMemory_params *params = args;

    TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory));

    vk_funcs->p_vkUnmapMemory(params->device, params->memory);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUnmapMemory(void *args)
{
    struct
    {
        PTR32 device;
        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
    } *params = args;

    TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory));

    vk_funcs->p_vkUnmapMemory((VkDevice)UlongToPtr(params->device), params->memory);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUnmapMemory2(void *args)
{
    struct vkUnmapMemory2_params *params = args;
    VkMemoryUnmapInfo pMemoryUnmapInfo_host;

    TRACE("%p, %p\n", params->device, params->pMemoryUnmapInfo);

    convert_VkMemoryUnmapInfo_win64_to_host(params->pMemoryUnmapInfo, &pMemoryUnmapInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkUnmapMemory2(vulkan_device_from_handle(params->device)->host.device, &pMemoryUnmapInfo_host);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUnmapMemory2(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pMemoryUnmapInfo;
        VkResult result;
    } *params = args;
    VkMemoryUnmapInfo pMemoryUnmapInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pMemoryUnmapInfo);

    convert_VkMemoryUnmapInfo_win32_to_host((const VkMemoryUnmapInfo32 *)UlongToPtr(params->pMemoryUnmapInfo), &pMemoryUnmapInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkUnmapMemory2(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pMemoryUnmapInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUnmapMemory2KHR(void *args)
{
    struct vkUnmapMemory2KHR_params *params = args;

    TRACE("%p, %p\n", params->device, params->pMemoryUnmapInfo);

    params->result = vk_funcs->p_vkUnmapMemory2KHR(params->device, params->pMemoryUnmapInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUnmapMemory2KHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pMemoryUnmapInfo;
        VkResult result;
    } *params = args;
    VkMemoryUnmapInfo pMemoryUnmapInfo_host;

    TRACE("%#x, %#x\n", params->device, params->pMemoryUnmapInfo);

    convert_VkMemoryUnmapInfo_win32_to_unwrapped_host((const VkMemoryUnmapInfo32 *)UlongToPtr(params->pMemoryUnmapInfo), &pMemoryUnmapInfo_host);
    params->result = vk_funcs->p_vkUnmapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryUnmapInfo_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static void thunk64_vkUpdateDescriptorSetWithTemplate(void *args)
{
    struct vkUpdateDescriptorSetWithTemplate_params *params = args;

    vulkan_device_from_handle(params->device)->p_vkUpdateDescriptorSetWithTemplate(vulkan_device_from_handle(params->device)->host.device, params->descriptorSet, params->descriptorUpdateTemplate, params->pData);
}
#endif /* _WIN64 */

static void thunk32_vkUpdateDescriptorSetWithTemplate(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSet DECLSPEC_ALIGN(8) descriptorSet;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        PTR32 pData;
    } *params = args;

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkUpdateDescriptorSetWithTemplate(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->descriptorSet, params->descriptorUpdateTemplate, (const void *)UlongToPtr(params->pData));
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUpdateDescriptorSetWithTemplateKHR(void *args)
{
    struct vkUpdateDescriptorSetWithTemplateKHR_params *params = args;

    TRACE("%p, 0x%s, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->descriptorSet), wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pData);

    vulkan_device_from_handle(params->device)->p_vkUpdateDescriptorSetWithTemplateKHR(vulkan_device_from_handle(params->device)->host.device, params->descriptorSet, params->descriptorUpdateTemplate, params->pData);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUpdateDescriptorSetWithTemplateKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkDescriptorSet DECLSPEC_ALIGN(8) descriptorSet;
        VkDescriptorUpdateTemplate DECLSPEC_ALIGN(8) descriptorUpdateTemplate;
        PTR32 pData;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->descriptorSet), wine_dbgstr_longlong(params->descriptorUpdateTemplate), params->pData);

    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkUpdateDescriptorSetWithTemplateKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->descriptorSet, params->descriptorUpdateTemplate, (const void *)UlongToPtr(params->pData));
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static void thunk64_vkUpdateDescriptorSets(void *args)
{
    struct vkUpdateDescriptorSets_params *params = args;

    vulkan_device_from_handle(params->device)->p_vkUpdateDescriptorSets(vulkan_device_from_handle(params->device)->host.device, params->descriptorWriteCount, params->pDescriptorWrites, params->descriptorCopyCount, params->pDescriptorCopies);
}
#endif /* _WIN64 */

static void thunk32_vkUpdateDescriptorSets(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t descriptorWriteCount;
        PTR32 pDescriptorWrites;
        uint32_t descriptorCopyCount;
        PTR32 pDescriptorCopies;
    } *params = args;
    const VkWriteDescriptorSet *pDescriptorWrites_host;
    const VkCopyDescriptorSet *pDescriptorCopies_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    init_conversion_context(ctx);
    pDescriptorWrites_host = convert_VkWriteDescriptorSet_array_win32_to_host(ctx, (const VkWriteDescriptorSet32 *)UlongToPtr(params->pDescriptorWrites), params->descriptorWriteCount);
    pDescriptorCopies_host = convert_VkCopyDescriptorSet_array_win32_to_host(ctx, (const VkCopyDescriptorSet32 *)UlongToPtr(params->pDescriptorCopies), params->descriptorCopyCount);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkUpdateDescriptorSets(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->descriptorWriteCount, pDescriptorWrites_host, params->descriptorCopyCount, pDescriptorCopies_host);
    free_conversion_context(ctx);
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUpdateIndirectExecutionSetPipelineEXT(void *args)
{
    struct vkUpdateIndirectExecutionSetPipelineEXT_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->indirectExecutionSet), params->executionSetWriteCount, params->pExecutionSetWrites);

    vulkan_device_from_handle(params->device)->p_vkUpdateIndirectExecutionSetPipelineEXT(vulkan_device_from_handle(params->device)->host.device, params->indirectExecutionSet, params->executionSetWriteCount, params->pExecutionSetWrites);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUpdateIndirectExecutionSetPipelineEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkIndirectExecutionSetEXT DECLSPEC_ALIGN(8) indirectExecutionSet;
        uint32_t executionSetWriteCount;
        PTR32 pExecutionSetWrites;
    } *params = args;
    const VkWriteIndirectExecutionSetPipelineEXT *pExecutionSetWrites_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->indirectExecutionSet), params->executionSetWriteCount, params->pExecutionSetWrites);

    init_conversion_context(ctx);
    pExecutionSetWrites_host = convert_VkWriteIndirectExecutionSetPipelineEXT_array_win32_to_host(ctx, (const VkWriteIndirectExecutionSetPipelineEXT32 *)UlongToPtr(params->pExecutionSetWrites), params->executionSetWriteCount);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkUpdateIndirectExecutionSetPipelineEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->indirectExecutionSet, params->executionSetWriteCount, pExecutionSetWrites_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUpdateIndirectExecutionSetShaderEXT(void *args)
{
    struct vkUpdateIndirectExecutionSetShaderEXT_params *params = args;

    TRACE("%p, 0x%s, %u, %p\n", params->device, wine_dbgstr_longlong(params->indirectExecutionSet), params->executionSetWriteCount, params->pExecutionSetWrites);

    vulkan_device_from_handle(params->device)->p_vkUpdateIndirectExecutionSetShaderEXT(vulkan_device_from_handle(params->device)->host.device, params->indirectExecutionSet, params->executionSetWriteCount, params->pExecutionSetWrites);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUpdateIndirectExecutionSetShaderEXT(void *args)
{
    struct
    {
        PTR32 device;
        VkIndirectExecutionSetEXT DECLSPEC_ALIGN(8) indirectExecutionSet;
        uint32_t executionSetWriteCount;
        PTR32 pExecutionSetWrites;
    } *params = args;
    const VkWriteIndirectExecutionSetShaderEXT *pExecutionSetWrites_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %u, %#x\n", params->device, wine_dbgstr_longlong(params->indirectExecutionSet), params->executionSetWriteCount, params->pExecutionSetWrites);

    init_conversion_context(ctx);
    pExecutionSetWrites_host = convert_VkWriteIndirectExecutionSetShaderEXT_array_win32_to_host(ctx, (const VkWriteIndirectExecutionSetShaderEXT32 *)UlongToPtr(params->pExecutionSetWrites), params->executionSetWriteCount);
    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkUpdateIndirectExecutionSetShaderEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->indirectExecutionSet, params->executionSetWriteCount, pExecutionSetWrites_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkUpdateVideoSessionParametersKHR(void *args)
{
    struct vkUpdateVideoSessionParametersKHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->videoSessionParameters), params->pUpdateInfo);

    params->result = vulkan_device_from_handle(params->device)->p_vkUpdateVideoSessionParametersKHR(vulkan_device_from_handle(params->device)->host.device, params->videoSessionParameters, params->pUpdateInfo);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkUpdateVideoSessionParametersKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkVideoSessionParametersKHR DECLSPEC_ALIGN(8) videoSessionParameters;
        PTR32 pUpdateInfo;
        VkResult result;
    } *params = args;
    VkVideoSessionParametersUpdateInfoKHR pUpdateInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->videoSessionParameters), params->pUpdateInfo);

    init_conversion_context(ctx);
    convert_VkVideoSessionParametersUpdateInfoKHR_win32_to_host(ctx, (const VkVideoSessionParametersUpdateInfoKHR32 *)UlongToPtr(params->pUpdateInfo), &pUpdateInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkUpdateVideoSessionParametersKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->videoSessionParameters, &pUpdateInfo_host);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWaitForFences(void *args)
{
    struct vkWaitForFences_params *params = args;
    const VkFence *pFences_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %u, %p, %u, 0x%s\n", params->device, params->fenceCount, params->pFences, params->waitAll, wine_dbgstr_longlong(params->timeout));

    init_conversion_context(ctx);
    pFences_host = convert_VkFence_array_win64_to_host(ctx, params->pFences, params->fenceCount);
    params->result = vulkan_device_from_handle(params->device)->p_vkWaitForFences(vulkan_device_from_handle(params->device)->host.device, params->fenceCount, pFences_host, params->waitAll, params->timeout);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWaitForFences(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t fenceCount;
        PTR32 pFences;
        VkBool32 waitAll;
        uint64_t DECLSPEC_ALIGN(8) timeout;
        VkResult result;
    } *params = args;
    const VkFence *pFences_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %u, %#x, %u, 0x%s\n", params->device, params->fenceCount, params->pFences, params->waitAll, wine_dbgstr_longlong(params->timeout));

    init_conversion_context(ctx);
    pFences_host = convert_VkFence_array_win32_to_host(ctx, (const VkFence *)UlongToPtr(params->pFences), params->fenceCount);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitForFences(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fenceCount, pFences_host, params->waitAll, params->timeout);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWaitForPresent2KHR(void *args)
{
    struct vkWaitForPresent2KHR_params *params = args;

    TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pPresentWait2Info);

    params->result = vulkan_device_from_handle(params->device)->p_vkWaitForPresent2KHR(vulkan_device_from_handle(params->device)->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, params->pPresentWait2Info);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWaitForPresent2KHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        PTR32 pPresentWait2Info;
        VkResult result;
    } *params = args;
    VkPresentWait2InfoKHR pPresentWait2Info_host;

    TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->swapchain), params->pPresentWait2Info);

    convert_VkPresentWait2InfoKHR_win32_to_host((const VkPresentWait2InfoKHR32 *)UlongToPtr(params->pPresentWait2Info), &pPresentWait2Info_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitForPresent2KHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, &pPresentWait2Info_host);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWaitForPresentKHR(void *args)
{
    struct vkWaitForPresentKHR_params *params = args;

    TRACE("%p, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->swapchain), wine_dbgstr_longlong(params->presentId), wine_dbgstr_longlong(params->timeout));

    params->result = vulkan_device_from_handle(params->device)->p_vkWaitForPresentKHR(vulkan_device_from_handle(params->device)->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, params->presentId, params->timeout);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWaitForPresentKHR(void *args)
{
    struct
    {
        PTR32 device;
        VkSwapchainKHR DECLSPEC_ALIGN(8) swapchain;
        uint64_t DECLSPEC_ALIGN(8) presentId;
        uint64_t DECLSPEC_ALIGN(8) timeout;
        VkResult result;
    } *params = args;

    TRACE("%#x, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->swapchain), wine_dbgstr_longlong(params->presentId), wine_dbgstr_longlong(params->timeout));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitForPresentKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_swapchain_from_handle(params->swapchain)->host.swapchain, params->presentId, params->timeout);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWaitSemaphores(void *args)
{
    struct vkWaitSemaphores_params *params = args;
    VkSemaphoreWaitInfo pWaitInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));

    init_conversion_context(ctx);
    convert_VkSemaphoreWaitInfo_win64_to_host(ctx, params->pWaitInfo, &pWaitInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkWaitSemaphores(vulkan_device_from_handle(params->device)->host.device, &pWaitInfo_host, params->timeout);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWaitSemaphores(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pWaitInfo;
        uint64_t DECLSPEC_ALIGN(8) timeout;
        VkResult result;
    } *params = args;
    VkSemaphoreWaitInfo pWaitInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));

    init_conversion_context(ctx);
    convert_VkSemaphoreWaitInfo_win32_to_host(ctx, (const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitSemaphores(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pWaitInfo_host, params->timeout);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWaitSemaphoresKHR(void *args)
{
    struct vkWaitSemaphoresKHR_params *params = args;
    VkSemaphoreWaitInfo pWaitInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%p, %p, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));

    init_conversion_context(ctx);
    convert_VkSemaphoreWaitInfo_win64_to_host(ctx, params->pWaitInfo, &pWaitInfo_host);
    params->result = vulkan_device_from_handle(params->device)->p_vkWaitSemaphoresKHR(vulkan_device_from_handle(params->device)->host.device, &pWaitInfo_host, params->timeout);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWaitSemaphoresKHR(void *args)
{
    struct
    {
        PTR32 device;
        PTR32 pWaitInfo;
        uint64_t DECLSPEC_ALIGN(8) timeout;
        VkResult result;
    } *params = args;
    VkSemaphoreWaitInfo pWaitInfo_host;
    struct conversion_context local_ctx;
    struct conversion_context *ctx = &local_ctx;

    TRACE("%#x, %#x, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));

    init_conversion_context(ctx);
    convert_VkSemaphoreWaitInfo_win32_to_host(ctx, (const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitSemaphoresKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pWaitInfo_host, params->timeout);
    free_conversion_context(ctx);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWriteAccelerationStructuresPropertiesKHR(void *args)
{
    struct vkWriteAccelerationStructuresPropertiesKHR_params *params = args;

    TRACE("%p, %u, %p, %#x, 0x%s, %p, 0x%s\n", params->device, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride));

    params->result = vulkan_device_from_handle(params->device)->p_vkWriteAccelerationStructuresPropertiesKHR(vulkan_device_from_handle(params->device)->host.device, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->dataSize, params->pData, params->stride);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWriteAccelerationStructuresPropertiesKHR(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t accelerationStructureCount;
        PTR32 pAccelerationStructures;
        VkQueryType queryType;
        PTR32 dataSize;
        PTR32 pData;
        PTR32 stride;
        VkResult result;
    } *params = args;

    TRACE("%#x, %u, %#x, %#x, 0x%s, %#x, 0x%s\n", params->device, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWriteAccelerationStructuresPropertiesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->accelerationStructureCount, (const VkAccelerationStructureKHR *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->dataSize, (void *)UlongToPtr(params->pData), params->stride);
    return STATUS_SUCCESS;
}

#ifdef _WIN64
static NTSTATUS thunk64_vkWriteMicromapsPropertiesEXT(void *args)
{
    struct vkWriteMicromapsPropertiesEXT_params *params = args;

    TRACE("%p, %u, %p, %#x, 0x%s, %p, 0x%s\n", params->device, params->micromapCount, params->pMicromaps, params->queryType, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride));

    params->result = vulkan_device_from_handle(params->device)->p_vkWriteMicromapsPropertiesEXT(vulkan_device_from_handle(params->device)->host.device, params->micromapCount, params->pMicromaps, params->queryType, params->dataSize, params->pData, params->stride);
    return STATUS_SUCCESS;
}
#endif /* _WIN64 */

static NTSTATUS thunk32_vkWriteMicromapsPropertiesEXT(void *args)
{
    struct
    {
        PTR32 device;
        uint32_t micromapCount;
        PTR32 pMicromaps;
        VkQueryType queryType;
        PTR32 dataSize;
        PTR32 pData;
        PTR32 stride;
        VkResult result;
    } *params = args;

    TRACE("%#x, %u, %#x, %#x, 0x%s, %#x, 0x%s\n", params->device, params->micromapCount, params->pMicromaps, params->queryType, wine_dbgstr_longlong(params->dataSize), params->pData, wine_dbgstr_longlong(params->stride));

    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWriteMicromapsPropertiesEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->micromapCount, (const VkMicromapEXT *)UlongToPtr(params->pMicromaps), params->queryType, params->dataSize, (void *)UlongToPtr(params->pData), params->stride);
    return STATUS_SUCCESS;
}

static const char * const vk_device_extensions[] =
{
    "VK_AMD_anti_lag",
    "VK_AMD_buffer_marker",
    "VK_AMD_device_coherent_memory",
    "VK_AMD_draw_indirect_count",
    "VK_AMD_gcn_shader",
    "VK_AMD_gpu_shader_half_float",
    "VK_AMD_gpu_shader_int16",
    "VK_AMD_memory_overallocation_behavior",
    "VK_AMD_mixed_attachment_samples",
    "VK_AMD_negative_viewport_height",
    "VK_AMD_pipeline_compiler_control",
    "VK_AMD_rasterization_order",
    "VK_AMD_shader_ballot",
    "VK_AMD_shader_core_properties",
    "VK_AMD_shader_core_properties2",
    "VK_AMD_shader_early_and_late_fragment_tests",
    "VK_AMD_shader_explicit_vertex_parameter",
    "VK_AMD_shader_fragment_mask",
    "VK_AMD_shader_image_load_store_lod",
    "VK_AMD_shader_info",
    "VK_AMD_shader_trinary_minmax",
    "VK_AMD_texture_gather_bias_lod",
    "VK_ARM_data_graph",
    "VK_ARM_format_pack",
    "VK_ARM_pipeline_opacity_micromap",
    "VK_ARM_rasterization_order_attachment_access",
    "VK_ARM_render_pass_striped",
    "VK_ARM_scheduling_controls",
    "VK_ARM_shader_core_builtins",
    "VK_ARM_shader_core_properties",
    "VK_ARM_tensors",
    "VK_EXT_4444_formats",
    "VK_EXT_astc_decode_mode",
    "VK_EXT_attachment_feedback_loop_dynamic_state",
    "VK_EXT_attachment_feedback_loop_layout",
    "VK_EXT_blend_operation_advanced",
    "VK_EXT_border_color_swizzle",
    "VK_EXT_buffer_device_address",
    "VK_EXT_calibrated_timestamps",
    "VK_EXT_color_write_enable",
    "VK_EXT_conditional_rendering",
    "VK_EXT_conservative_rasterization",
    "VK_EXT_custom_border_color",
    "VK_EXT_debug_marker",
    "VK_EXT_depth_bias_control",
    "VK_EXT_depth_clamp_control",
    "VK_EXT_depth_clamp_zero_one",
    "VK_EXT_depth_clip_control",
    "VK_EXT_depth_clip_enable",
    "VK_EXT_depth_range_unrestricted",
    "VK_EXT_descriptor_buffer",
    "VK_EXT_descriptor_indexing",
    "VK_EXT_device_address_binding_report",
    "VK_EXT_device_fault",
    "VK_EXT_device_generated_commands",
    "VK_EXT_discard_rectangles",
    "VK_EXT_dynamic_rendering_unused_attachments",
    "VK_EXT_extended_dynamic_state",
    "VK_EXT_extended_dynamic_state2",
    "VK_EXT_extended_dynamic_state3",
    "VK_EXT_external_memory_acquire_unmodified",
    "VK_EXT_external_memory_host",
    "VK_EXT_filter_cubic",
    "VK_EXT_fragment_density_map",
    "VK_EXT_fragment_density_map2",
    "VK_EXT_fragment_density_map_offset",
    "VK_EXT_fragment_shader_interlock",
    "VK_EXT_frame_boundary",
    "VK_EXT_global_priority",
    "VK_EXT_global_priority_query",
    "VK_EXT_graphics_pipeline_library",
    "VK_EXT_hdr_metadata",
    "VK_EXT_host_image_copy",
    "VK_EXT_host_query_reset",
    "VK_EXT_image_2d_view_of_3d",
    "VK_EXT_image_compression_control",
    "VK_EXT_image_compression_control_swapchain",
    "VK_EXT_image_robustness",
    "VK_EXT_image_sliced_view_of_3d",
    "VK_EXT_image_view_min_lod",
    "VK_EXT_index_type_uint8",
    "VK_EXT_inline_uniform_block",
    "VK_EXT_legacy_dithering",
    "VK_EXT_legacy_vertex_attributes",
    "VK_EXT_line_rasterization",
    "VK_EXT_load_store_op_none",
    "VK_EXT_memory_budget",
    "VK_EXT_memory_priority",
    "VK_EXT_mesh_shader",
    "VK_EXT_multi_draw",
    "VK_EXT_multisampled_render_to_single_sampled",
    "VK_EXT_mutable_descriptor_type",
    "VK_EXT_nested_command_buffer",
    "VK_EXT_non_seamless_cube_map",
    "VK_EXT_opacity_micromap",
    "VK_EXT_pageable_device_local_memory",
    "VK_EXT_pci_bus_info",
    "VK_EXT_pipeline_creation_cache_control",
    "VK_EXT_pipeline_creation_feedback",
    "VK_EXT_pipeline_library_group_handles",
    "VK_EXT_pipeline_properties",
    "VK_EXT_pipeline_protected_access",
    "VK_EXT_pipeline_robustness",
    "VK_EXT_post_depth_coverage",
    "VK_EXT_present_mode_fifo_latest_ready",
    "VK_EXT_primitive_topology_list_restart",
    "VK_EXT_primitives_generated_query",
    "VK_EXT_private_data",
    "VK_EXT_provoking_vertex",
    "VK_EXT_queue_family_foreign",
    "VK_EXT_rasterization_order_attachment_access",
    "VK_EXT_rgba10x6_formats",
    "VK_EXT_robustness2",
    "VK_EXT_sample_locations",
    "VK_EXT_sampler_filter_minmax",
    "VK_EXT_scalar_block_layout",
    "VK_EXT_separate_stencil_usage",
    "VK_EXT_shader_atomic_float",
    "VK_EXT_shader_atomic_float2",
    "VK_EXT_shader_demote_to_helper_invocation",
    "VK_EXT_shader_float8",
    "VK_EXT_shader_image_atomic_int64",
    "VK_EXT_shader_module_identifier",
    "VK_EXT_shader_object",
    "VK_EXT_shader_replicated_composites",
    "VK_EXT_shader_stencil_export",
    "VK_EXT_shader_subgroup_ballot",
    "VK_EXT_shader_subgroup_vote",
    "VK_EXT_shader_tile_image",
    "VK_EXT_shader_viewport_index_layer",
    "VK_EXT_subgroup_size_control",
    "VK_EXT_subpass_merge_feedback",
    "VK_EXT_swapchain_maintenance1",
    "VK_EXT_texel_buffer_alignment",
    "VK_EXT_texture_compression_astc_hdr",
    "VK_EXT_tooling_info",
    "VK_EXT_transform_feedback",
    "VK_EXT_validation_cache",
    "VK_EXT_vertex_attribute_divisor",
    "VK_EXT_vertex_attribute_robustness",
    "VK_EXT_vertex_input_dynamic_state",
    "VK_EXT_ycbcr_2plane_444_formats",
    "VK_EXT_ycbcr_image_arrays",
    "VK_EXT_zero_initialize_device_memory",
    "VK_GOOGLE_decorate_string",
    "VK_GOOGLE_hlsl_functionality1",
    "VK_GOOGLE_user_type",
    "VK_HUAWEI_cluster_culling_shader",
    "VK_HUAWEI_hdr_vivid",
    "VK_HUAWEI_invocation_mask",
    "VK_HUAWEI_subpass_shading",
    "VK_IMG_filter_cubic",
    "VK_IMG_format_pvrtc",
    "VK_IMG_relaxed_line_rasterization",
    "VK_INTEL_performance_query",
    "VK_INTEL_shader_integer_functions2",
    "VK_KHR_16bit_storage",
    "VK_KHR_8bit_storage",
    "VK_KHR_acceleration_structure",
    "VK_KHR_bind_memory2",
    "VK_KHR_buffer_device_address",
    "VK_KHR_calibrated_timestamps",
    "VK_KHR_compute_shader_derivatives",
    "VK_KHR_cooperative_matrix",
    "VK_KHR_copy_commands2",
    "VK_KHR_create_renderpass2",
    "VK_KHR_dedicated_allocation",
    "VK_KHR_deferred_host_operations",
    "VK_KHR_depth_clamp_zero_one",
    "VK_KHR_depth_stencil_resolve",
    "VK_KHR_descriptor_update_template",
    "VK_KHR_device_group",
    "VK_KHR_draw_indirect_count",
    "VK_KHR_driver_properties",
    "VK_KHR_dynamic_rendering",
    "VK_KHR_dynamic_rendering_local_read",
    "VK_KHR_external_fence",
    "VK_KHR_external_fence_win32",
    "VK_KHR_external_memory",
    "VK_KHR_external_memory_win32",
    "VK_KHR_external_semaphore",
    "VK_KHR_external_semaphore_win32",
    "VK_KHR_format_feature_flags2",
    "VK_KHR_fragment_shader_barycentric",
    "VK_KHR_fragment_shading_rate",
    "VK_KHR_get_memory_requirements2",
    "VK_KHR_global_priority",
    "VK_KHR_image_format_list",
    "VK_KHR_imageless_framebuffer",
    "VK_KHR_incremental_present",
    "VK_KHR_index_type_uint8",
    "VK_KHR_line_rasterization",
    "VK_KHR_load_store_op_none",
    "VK_KHR_maintenance1",
    "VK_KHR_maintenance2",
    "VK_KHR_maintenance3",
    "VK_KHR_maintenance4",
    "VK_KHR_maintenance5",
    "VK_KHR_maintenance6",
    "VK_KHR_maintenance8",
    "VK_KHR_maintenance9",
    "VK_KHR_map_memory2",
    "VK_KHR_multiview",
    "VK_KHR_performance_query",
    "VK_KHR_pipeline_binary",
    "VK_KHR_pipeline_executable_properties",
    "VK_KHR_pipeline_library",
    "VK_KHR_present_id",
    "VK_KHR_present_id2",
    "VK_KHR_present_mode_fifo_latest_ready",
    "VK_KHR_present_wait",
    "VK_KHR_present_wait2",
    "VK_KHR_push_descriptor",
    "VK_KHR_ray_query",
    "VK_KHR_ray_tracing_maintenance1",
    "VK_KHR_ray_tracing_pipeline",
    "VK_KHR_ray_tracing_position_fetch",
    "VK_KHR_relaxed_block_layout",
    "VK_KHR_robustness2",
    "VK_KHR_sampler_mirror_clamp_to_edge",
    "VK_KHR_sampler_ycbcr_conversion",
    "VK_KHR_separate_depth_stencil_layouts",
    "VK_KHR_shader_atomic_int64",
    "VK_KHR_shader_bfloat16",
    "VK_KHR_shader_clock",
    "VK_KHR_shader_draw_parameters",
    "VK_KHR_shader_expect_assume",
    "VK_KHR_shader_float16_int8",
    "VK_KHR_shader_float_controls",
    "VK_KHR_shader_float_controls2",
    "VK_KHR_shader_integer_dot_product",
    "VK_KHR_shader_maximal_reconvergence",
    "VK_KHR_shader_non_semantic_info",
    "VK_KHR_shader_quad_control",
    "VK_KHR_shader_relaxed_extended_instruction",
    "VK_KHR_shader_subgroup_extended_types",
    "VK_KHR_shader_subgroup_rotate",
    "VK_KHR_shader_subgroup_uniform_control_flow",
    "VK_KHR_shader_terminate_invocation",
    "VK_KHR_shader_untyped_pointers",
    "VK_KHR_spirv_1_4",
    "VK_KHR_storage_buffer_storage_class",
    "VK_KHR_swapchain",
    "VK_KHR_swapchain_maintenance1",
    "VK_KHR_swapchain_mutable_format",
    "VK_KHR_synchronization2",
    "VK_KHR_timeline_semaphore",
    "VK_KHR_unified_image_layouts",
    "VK_KHR_uniform_buffer_standard_layout",
    "VK_KHR_variable_pointers",
    "VK_KHR_vertex_attribute_divisor",
    "VK_KHR_video_decode_av1",
    "VK_KHR_video_decode_h264",
    "VK_KHR_video_decode_queue",
    "VK_KHR_video_decode_vp9",
    "VK_KHR_video_encode_av1",
    "VK_KHR_video_encode_h264",
    "VK_KHR_video_encode_intra_refresh",
    "VK_KHR_video_encode_quantization_map",
    "VK_KHR_video_encode_queue",
    "VK_KHR_video_maintenance1",
    "VK_KHR_video_queue",
    "VK_KHR_vulkan_memory_model",
    "VK_KHR_win32_keyed_mutex",
    "VK_KHR_workgroup_memory_explicit_layout",
    "VK_KHR_zero_initialize_workgroup_memory",
    "VK_MESA_image_alignment_control",
    "VK_MSFT_layered_driver",
    "VK_NVX_binary_import",
    "VK_NVX_image_view_handle",
    "VK_NV_clip_space_w_scaling",
    "VK_NV_cluster_acceleration_structure",
    "VK_NV_command_buffer_inheritance",
    "VK_NV_compute_shader_derivatives",
    "VK_NV_cooperative_matrix",
    "VK_NV_cooperative_matrix2",
    "VK_NV_cooperative_vector",
    "VK_NV_copy_memory_indirect",
    "VK_NV_corner_sampled_image",
    "VK_NV_coverage_reduction_mode",
    "VK_NV_dedicated_allocation",
    "VK_NV_dedicated_allocation_image_aliasing",
    "VK_NV_descriptor_pool_overallocation",
    "VK_NV_device_diagnostic_checkpoints",
    "VK_NV_device_diagnostics_config",
    "VK_NV_device_generated_commands",
    "VK_NV_device_generated_commands_compute",
    "VK_NV_extended_sparse_address_space",
    "VK_NV_fill_rectangle",
    "VK_NV_fragment_coverage_to_color",
    "VK_NV_fragment_shader_barycentric",
    "VK_NV_fragment_shading_rate_enums",
    "VK_NV_framebuffer_mixed_samples",
    "VK_NV_geometry_shader_passthrough",
    "VK_NV_glsl_shader",
    "VK_NV_inherited_viewport_scissor",
    "VK_NV_linear_color_attachment",
    "VK_NV_low_latency",
    "VK_NV_low_latency2",
    "VK_NV_memory_decompression",
    "VK_NV_mesh_shader",
    "VK_NV_optical_flow",
    "VK_NV_partitioned_acceleration_structure",
    "VK_NV_per_stage_descriptor_set",
    "VK_NV_present_barrier",
    "VK_NV_raw_access_chains",
    "VK_NV_ray_tracing",
    "VK_NV_ray_tracing_invocation_reorder",
    "VK_NV_ray_tracing_linear_swept_spheres",
    "VK_NV_ray_tracing_motion_blur",
    "VK_NV_ray_tracing_validation",
    "VK_NV_representative_fragment_test",
    "VK_NV_sample_mask_override_coverage",
    "VK_NV_scissor_exclusive",
    "VK_NV_shader_atomic_float16_vector",
    "VK_NV_shader_image_footprint",
    "VK_NV_shader_sm_builtins",
    "VK_NV_shader_subgroup_partitioned",
    "VK_NV_shading_rate_image",
    "VK_NV_viewport_array2",
    "VK_NV_viewport_swizzle",
    "VK_QCOM_filter_cubic_clamp",
    "VK_QCOM_filter_cubic_weights",
    "VK_QCOM_fragment_density_map_offset",
    "VK_QCOM_image_processing",
    "VK_QCOM_image_processing2",
    "VK_QCOM_multiview_per_view_render_areas",
    "VK_QCOM_multiview_per_view_viewports",
    "VK_QCOM_render_pass_shader_resolve",
    "VK_QCOM_render_pass_store_ops",
    "VK_QCOM_render_pass_transform",
    "VK_QCOM_rotated_copy_commands",
    "VK_QCOM_tile_memory_heap",
    "VK_QCOM_tile_properties",
    "VK_QCOM_tile_shading",
    "VK_QCOM_ycbcr_degamma",
    "VK_SEC_pipeline_cache_incremental_mode",
    "VK_VALVE_descriptor_set_host_mapping",
    "VK_VALVE_fragment_density_map_layered",
    "VK_VALVE_mutable_descriptor_type",
};

static const char * const vk_instance_extensions[] =
{
    "VK_EXT_debug_report",
    "VK_EXT_debug_utils",
    "VK_EXT_layer_settings",
    "VK_EXT_surface_maintenance1",
    "VK_EXT_swapchain_colorspace",
    "VK_EXT_validation_features",
    "VK_EXT_validation_flags",
    "VK_KHR_device_group_creation",
    "VK_KHR_external_fence_capabilities",
    "VK_KHR_external_memory_capabilities",
    "VK_KHR_external_semaphore_capabilities",
    "VK_KHR_get_physical_device_properties2",
    "VK_KHR_get_surface_capabilities2",
    "VK_KHR_portability_enumeration",
    "VK_KHR_surface",
    "VK_KHR_surface_maintenance1",
    "VK_KHR_win32_surface",
};

static const char * const vk_host_surface_extensions[] =
{
    "VK_KHR_xlib_surface",
    "VK_KHR_xcb_surface",
    "VK_KHR_wayland_surface",
    "VK_KHR_mir_surface",
    "VK_KHR_android_surface",
    "VK_GGP_stream_descriptor_surface",
    "VK_NN_vi_surface",
    "VK_MVK_ios_surface",
    "VK_MVK_macos_surface",
    "VK_FUCHSIA_imagepipe_surface",
    "VK_EXT_metal_surface",
    "VK_EXT_directfb_surface",
    "VK_QNX_screen_surface",
    "VK_OHOS_surface",
};

BOOL wine_vk_device_extension_supported(const char *name)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(vk_device_extensions); i++)
    {
        if (strcmp(vk_device_extensions[i], name) == 0)
            return TRUE;
    }
    return FALSE;
}

BOOL wine_vk_instance_extension_supported(const char *name)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(vk_instance_extensions); i++)
    {
        if (strcmp(vk_instance_extensions[i], name) == 0)
            return TRUE;
    }
    return FALSE;
}

BOOL wine_vk_is_host_surface_extension(const char *name)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(vk_host_surface_extensions); i++)
    {
        if (strcmp(vk_host_surface_extensions[i], name) == 0)
            return TRUE;
    }
    return FALSE;
}

BOOL wine_vk_is_type_wrapped(VkObjectType type)
{
    return FALSE ||
        type == VK_OBJECT_TYPE_COMMAND_BUFFER ||
        type == VK_OBJECT_TYPE_COMMAND_POOL ||
        type == VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT ||
        type == VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT ||
        type == VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR ||
        type == VK_OBJECT_TYPE_DEVICE ||
        type == VK_OBJECT_TYPE_DEVICE_MEMORY ||
        type == VK_OBJECT_TYPE_FENCE ||
        type == VK_OBJECT_TYPE_INSTANCE ||
        type == VK_OBJECT_TYPE_PHYSICAL_DEVICE ||
        type == VK_OBJECT_TYPE_QUEUE ||
        type == VK_OBJECT_TYPE_SEMAPHORE ||
        type == VK_OBJECT_TYPE_SURFACE_KHR ||
        type == VK_OBJECT_TYPE_SWAPCHAIN_KHR;
}

#ifdef _WIN64

const unixlib_entry_t __wine_unix_call_funcs[] =
{
    init_vulkan,
    vk_is_available_instance_function,
    vk_is_available_device_function,
    thunk64_vkAcquireNextImage2KHR,
    thunk64_vkAcquireNextImageKHR,
    thunk64_vkAcquirePerformanceConfigurationINTEL,
    thunk64_vkAcquireProfilingLockKHR,
    thunk64_vkAllocateCommandBuffers,
    thunk64_vkAllocateDescriptorSets,
    thunk64_vkAllocateMemory,
    thunk64_vkAntiLagUpdateAMD,
    thunk64_vkBeginCommandBuffer,
    thunk64_vkBindAccelerationStructureMemoryNV,
    thunk64_vkBindBufferMemory,
    thunk64_vkBindBufferMemory2,
    thunk64_vkBindBufferMemory2KHR,
    thunk64_vkBindDataGraphPipelineSessionMemoryARM,
    thunk64_vkBindImageMemory,
    thunk64_vkBindImageMemory2,
    thunk64_vkBindImageMemory2KHR,
    thunk64_vkBindOpticalFlowSessionImageNV,
    thunk64_vkBindTensorMemoryARM,
    thunk64_vkBindVideoSessionMemoryKHR,
    thunk64_vkBuildAccelerationStructuresKHR,
    thunk64_vkBuildMicromapsEXT,
    (void *)thunk64_vkCmdBeginConditionalRenderingEXT,
    (void *)thunk64_vkCmdBeginDebugUtilsLabelEXT,
    (void *)thunk64_vkCmdBeginPerTileExecutionQCOM,
    (void *)thunk64_vkCmdBeginQuery,
    (void *)thunk64_vkCmdBeginQueryIndexedEXT,
    (void *)thunk64_vkCmdBeginRenderPass,
    (void *)thunk64_vkCmdBeginRenderPass2,
    (void *)thunk64_vkCmdBeginRenderPass2KHR,
    (void *)thunk64_vkCmdBeginRendering,
    (void *)thunk64_vkCmdBeginRenderingKHR,
    (void *)thunk64_vkCmdBeginTransformFeedbackEXT,
    (void *)thunk64_vkCmdBeginVideoCodingKHR,
    (void *)thunk64_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT,
    (void *)thunk64_vkCmdBindDescriptorBufferEmbeddedSamplersEXT,
    (void *)thunk64_vkCmdBindDescriptorBuffersEXT,
    (void *)thunk64_vkCmdBindDescriptorSets,
    (void *)thunk64_vkCmdBindDescriptorSets2,
    (void *)thunk64_vkCmdBindDescriptorSets2KHR,
    (void *)thunk64_vkCmdBindIndexBuffer,
    (void *)thunk64_vkCmdBindIndexBuffer2,
    (void *)thunk64_vkCmdBindIndexBuffer2KHR,
    (void *)thunk64_vkCmdBindInvocationMaskHUAWEI,
    (void *)thunk64_vkCmdBindPipeline,
    (void *)thunk64_vkCmdBindPipelineShaderGroupNV,
    (void *)thunk64_vkCmdBindShadersEXT,
    (void *)thunk64_vkCmdBindShadingRateImageNV,
    (void *)thunk64_vkCmdBindTileMemoryQCOM,
    (void *)thunk64_vkCmdBindTransformFeedbackBuffersEXT,
    (void *)thunk64_vkCmdBindVertexBuffers,
    (void *)thunk64_vkCmdBindVertexBuffers2,
    (void *)thunk64_vkCmdBindVertexBuffers2EXT,
    (void *)thunk64_vkCmdBlitImage,
    (void *)thunk64_vkCmdBlitImage2,
    (void *)thunk64_vkCmdBlitImage2KHR,
    (void *)thunk64_vkCmdBuildAccelerationStructureNV,
    (void *)thunk64_vkCmdBuildAccelerationStructuresIndirectKHR,
    (void *)thunk64_vkCmdBuildAccelerationStructuresKHR,
    (void *)thunk64_vkCmdBuildClusterAccelerationStructureIndirectNV,
    (void *)thunk64_vkCmdBuildMicromapsEXT,
    (void *)thunk64_vkCmdBuildPartitionedAccelerationStructuresNV,
    (void *)thunk64_vkCmdClearAttachments,
    (void *)thunk64_vkCmdClearColorImage,
    (void *)thunk64_vkCmdClearDepthStencilImage,
    (void *)thunk64_vkCmdControlVideoCodingKHR,
    (void *)thunk64_vkCmdConvertCooperativeVectorMatrixNV,
    (void *)thunk64_vkCmdCopyAccelerationStructureKHR,
    (void *)thunk64_vkCmdCopyAccelerationStructureNV,
    (void *)thunk64_vkCmdCopyAccelerationStructureToMemoryKHR,
    (void *)thunk64_vkCmdCopyBuffer,
    (void *)thunk64_vkCmdCopyBuffer2,
    (void *)thunk64_vkCmdCopyBuffer2KHR,
    (void *)thunk64_vkCmdCopyBufferToImage,
    (void *)thunk64_vkCmdCopyBufferToImage2,
    (void *)thunk64_vkCmdCopyBufferToImage2KHR,
    (void *)thunk64_vkCmdCopyImage,
    (void *)thunk64_vkCmdCopyImage2,
    (void *)thunk64_vkCmdCopyImage2KHR,
    (void *)thunk64_vkCmdCopyImageToBuffer,
    (void *)thunk64_vkCmdCopyImageToBuffer2,
    (void *)thunk64_vkCmdCopyImageToBuffer2KHR,
    (void *)thunk64_vkCmdCopyMemoryIndirectNV,
    (void *)thunk64_vkCmdCopyMemoryToAccelerationStructureKHR,
    (void *)thunk64_vkCmdCopyMemoryToImageIndirectNV,
    (void *)thunk64_vkCmdCopyMemoryToMicromapEXT,
    (void *)thunk64_vkCmdCopyMicromapEXT,
    (void *)thunk64_vkCmdCopyMicromapToMemoryEXT,
    (void *)thunk64_vkCmdCopyQueryPoolResults,
    (void *)thunk64_vkCmdCopyTensorARM,
    (void *)thunk64_vkCmdCuLaunchKernelNVX,
    (void *)thunk64_vkCmdDebugMarkerBeginEXT,
    (void *)thunk64_vkCmdDebugMarkerEndEXT,
    (void *)thunk64_vkCmdDebugMarkerInsertEXT,
    (void *)thunk64_vkCmdDecodeVideoKHR,
    (void *)thunk64_vkCmdDecompressMemoryIndirectCountNV,
    (void *)thunk64_vkCmdDecompressMemoryNV,
    (void *)thunk64_vkCmdDispatch,
    (void *)thunk64_vkCmdDispatchBase,
    (void *)thunk64_vkCmdDispatchBaseKHR,
    (void *)thunk64_vkCmdDispatchDataGraphARM,
    (void *)thunk64_vkCmdDispatchIndirect,
    (void *)thunk64_vkCmdDispatchTileQCOM,
    (void *)thunk64_vkCmdDraw,
    (void *)thunk64_vkCmdDrawClusterHUAWEI,
    (void *)thunk64_vkCmdDrawClusterIndirectHUAWEI,
    (void *)thunk64_vkCmdDrawIndexed,
    (void *)thunk64_vkCmdDrawIndexedIndirect,
    (void *)thunk64_vkCmdDrawIndexedIndirectCount,
    (void *)thunk64_vkCmdDrawIndexedIndirectCountAMD,
    (void *)thunk64_vkCmdDrawIndexedIndirectCountKHR,
    (void *)thunk64_vkCmdDrawIndirect,
    (void *)thunk64_vkCmdDrawIndirectByteCountEXT,
    (void *)thunk64_vkCmdDrawIndirectCount,
    (void *)thunk64_vkCmdDrawIndirectCountAMD,
    (void *)thunk64_vkCmdDrawIndirectCountKHR,
    (void *)thunk64_vkCmdDrawMeshTasksEXT,
    (void *)thunk64_vkCmdDrawMeshTasksIndirectCountEXT,
    (void *)thunk64_vkCmdDrawMeshTasksIndirectCountNV,
    (void *)thunk64_vkCmdDrawMeshTasksIndirectEXT,
    (void *)thunk64_vkCmdDrawMeshTasksIndirectNV,
    (void *)thunk64_vkCmdDrawMeshTasksNV,
    (void *)thunk64_vkCmdDrawMultiEXT,
    (void *)thunk64_vkCmdDrawMultiIndexedEXT,
    (void *)thunk64_vkCmdEncodeVideoKHR,
    (void *)thunk64_vkCmdEndConditionalRenderingEXT,
    (void *)thunk64_vkCmdEndDebugUtilsLabelEXT,
    (void *)thunk64_vkCmdEndPerTileExecutionQCOM,
    (void *)thunk64_vkCmdEndQuery,
    (void *)thunk64_vkCmdEndQueryIndexedEXT,
    (void *)thunk64_vkCmdEndRenderPass,
    (void *)thunk64_vkCmdEndRenderPass2,
    (void *)thunk64_vkCmdEndRenderPass2KHR,
    (void *)thunk64_vkCmdEndRendering,
    (void *)thunk64_vkCmdEndRendering2EXT,
    (void *)thunk64_vkCmdEndRenderingKHR,
    (void *)thunk64_vkCmdEndTransformFeedbackEXT,
    (void *)thunk64_vkCmdEndVideoCodingKHR,
    (void *)thunk64_vkCmdExecuteCommands,
    (void *)thunk64_vkCmdExecuteGeneratedCommandsEXT,
    (void *)thunk64_vkCmdExecuteGeneratedCommandsNV,
    (void *)thunk64_vkCmdFillBuffer,
    (void *)thunk64_vkCmdInsertDebugUtilsLabelEXT,
    (void *)thunk64_vkCmdNextSubpass,
    (void *)thunk64_vkCmdNextSubpass2,
    (void *)thunk64_vkCmdNextSubpass2KHR,
    (void *)thunk64_vkCmdOpticalFlowExecuteNV,
    (void *)thunk64_vkCmdPipelineBarrier,
    (void *)thunk64_vkCmdPipelineBarrier2,
    (void *)thunk64_vkCmdPipelineBarrier2KHR,
    (void *)thunk64_vkCmdPreprocessGeneratedCommandsEXT,
    (void *)thunk64_vkCmdPreprocessGeneratedCommandsNV,
    (void *)thunk64_vkCmdPushConstants,
    (void *)thunk64_vkCmdPushConstants2,
    (void *)thunk64_vkCmdPushConstants2KHR,
    (void *)thunk64_vkCmdPushDescriptorSet,
    (void *)thunk64_vkCmdPushDescriptorSet2,
    (void *)thunk64_vkCmdPushDescriptorSet2KHR,
    (void *)thunk64_vkCmdPushDescriptorSetKHR,
    (void *)thunk64_vkCmdPushDescriptorSetWithTemplate,
    (void *)thunk64_vkCmdPushDescriptorSetWithTemplate2,
    (void *)thunk64_vkCmdPushDescriptorSetWithTemplate2KHR,
    (void *)thunk64_vkCmdPushDescriptorSetWithTemplateKHR,
    (void *)thunk64_vkCmdResetEvent,
    (void *)thunk64_vkCmdResetEvent2,
    (void *)thunk64_vkCmdResetEvent2KHR,
    (void *)thunk64_vkCmdResetQueryPool,
    (void *)thunk64_vkCmdResolveImage,
    (void *)thunk64_vkCmdResolveImage2,
    (void *)thunk64_vkCmdResolveImage2KHR,
    (void *)thunk64_vkCmdSetAlphaToCoverageEnableEXT,
    (void *)thunk64_vkCmdSetAlphaToOneEnableEXT,
    (void *)thunk64_vkCmdSetAttachmentFeedbackLoopEnableEXT,
    (void *)thunk64_vkCmdSetBlendConstants,
    (void *)thunk64_vkCmdSetCheckpointNV,
    (void *)thunk64_vkCmdSetCoarseSampleOrderNV,
    (void *)thunk64_vkCmdSetColorBlendAdvancedEXT,
    (void *)thunk64_vkCmdSetColorBlendEnableEXT,
    (void *)thunk64_vkCmdSetColorBlendEquationEXT,
    (void *)thunk64_vkCmdSetColorWriteEnableEXT,
    (void *)thunk64_vkCmdSetColorWriteMaskEXT,
    (void *)thunk64_vkCmdSetConservativeRasterizationModeEXT,
    (void *)thunk64_vkCmdSetCoverageModulationModeNV,
    (void *)thunk64_vkCmdSetCoverageModulationTableEnableNV,
    (void *)thunk64_vkCmdSetCoverageModulationTableNV,
    (void *)thunk64_vkCmdSetCoverageReductionModeNV,
    (void *)thunk64_vkCmdSetCoverageToColorEnableNV,
    (void *)thunk64_vkCmdSetCoverageToColorLocationNV,
    (void *)thunk64_vkCmdSetCullMode,
    (void *)thunk64_vkCmdSetCullModeEXT,
    (void *)thunk64_vkCmdSetDepthBias,
    (void *)thunk64_vkCmdSetDepthBias2EXT,
    (void *)thunk64_vkCmdSetDepthBiasEnable,
    (void *)thunk64_vkCmdSetDepthBiasEnableEXT,
    (void *)thunk64_vkCmdSetDepthBounds,
    (void *)thunk64_vkCmdSetDepthBoundsTestEnable,
    (void *)thunk64_vkCmdSetDepthBoundsTestEnableEXT,
    (void *)thunk64_vkCmdSetDepthClampEnableEXT,
    (void *)thunk64_vkCmdSetDepthClampRangeEXT,
    (void *)thunk64_vkCmdSetDepthClipEnableEXT,
    (void *)thunk64_vkCmdSetDepthClipNegativeOneToOneEXT,
    (void *)thunk64_vkCmdSetDepthCompareOp,
    (void *)thunk64_vkCmdSetDepthCompareOpEXT,
    (void *)thunk64_vkCmdSetDepthTestEnable,
    (void *)thunk64_vkCmdSetDepthTestEnableEXT,
    (void *)thunk64_vkCmdSetDepthWriteEnable,
    (void *)thunk64_vkCmdSetDepthWriteEnableEXT,
    (void *)thunk64_vkCmdSetDescriptorBufferOffsets2EXT,
    (void *)thunk64_vkCmdSetDescriptorBufferOffsetsEXT,
    (void *)thunk64_vkCmdSetDeviceMask,
    (void *)thunk64_vkCmdSetDeviceMaskKHR,
    (void *)thunk64_vkCmdSetDiscardRectangleEXT,
    (void *)thunk64_vkCmdSetDiscardRectangleEnableEXT,
    (void *)thunk64_vkCmdSetDiscardRectangleModeEXT,
    (void *)thunk64_vkCmdSetEvent,
    (void *)thunk64_vkCmdSetEvent2,
    (void *)thunk64_vkCmdSetEvent2KHR,
    (void *)thunk64_vkCmdSetExclusiveScissorEnableNV,
    (void *)thunk64_vkCmdSetExclusiveScissorNV,
    (void *)thunk64_vkCmdSetExtraPrimitiveOverestimationSizeEXT,
    (void *)thunk64_vkCmdSetFragmentShadingRateEnumNV,
    (void *)thunk64_vkCmdSetFragmentShadingRateKHR,
    (void *)thunk64_vkCmdSetFrontFace,
    (void *)thunk64_vkCmdSetFrontFaceEXT,
    (void *)thunk64_vkCmdSetLineRasterizationModeEXT,
    (void *)thunk64_vkCmdSetLineStipple,
    (void *)thunk64_vkCmdSetLineStippleEXT,
    (void *)thunk64_vkCmdSetLineStippleEnableEXT,
    (void *)thunk64_vkCmdSetLineStippleKHR,
    (void *)thunk64_vkCmdSetLineWidth,
    (void *)thunk64_vkCmdSetLogicOpEXT,
    (void *)thunk64_vkCmdSetLogicOpEnableEXT,
    (void *)thunk64_vkCmdSetPatchControlPointsEXT,
    thunk64_vkCmdSetPerformanceMarkerINTEL,
    thunk64_vkCmdSetPerformanceOverrideINTEL,
    thunk64_vkCmdSetPerformanceStreamMarkerINTEL,
    (void *)thunk64_vkCmdSetPolygonModeEXT,
    (void *)thunk64_vkCmdSetPrimitiveRestartEnable,
    (void *)thunk64_vkCmdSetPrimitiveRestartEnableEXT,
    (void *)thunk64_vkCmdSetPrimitiveTopology,
    (void *)thunk64_vkCmdSetPrimitiveTopologyEXT,
    (void *)thunk64_vkCmdSetProvokingVertexModeEXT,
    (void *)thunk64_vkCmdSetRasterizationSamplesEXT,
    (void *)thunk64_vkCmdSetRasterizationStreamEXT,
    (void *)thunk64_vkCmdSetRasterizerDiscardEnable,
    (void *)thunk64_vkCmdSetRasterizerDiscardEnableEXT,
    (void *)thunk64_vkCmdSetRayTracingPipelineStackSizeKHR,
    (void *)thunk64_vkCmdSetRenderingAttachmentLocations,
    (void *)thunk64_vkCmdSetRenderingAttachmentLocationsKHR,
    (void *)thunk64_vkCmdSetRenderingInputAttachmentIndices,
    (void *)thunk64_vkCmdSetRenderingInputAttachmentIndicesKHR,
    (void *)thunk64_vkCmdSetRepresentativeFragmentTestEnableNV,
    (void *)thunk64_vkCmdSetSampleLocationsEXT,
    (void *)thunk64_vkCmdSetSampleLocationsEnableEXT,
    (void *)thunk64_vkCmdSetSampleMaskEXT,
    (void *)thunk64_vkCmdSetScissor,
    (void *)thunk64_vkCmdSetScissorWithCount,
    (void *)thunk64_vkCmdSetScissorWithCountEXT,
    (void *)thunk64_vkCmdSetShadingRateImageEnableNV,
    (void *)thunk64_vkCmdSetStencilCompareMask,
    (void *)thunk64_vkCmdSetStencilOp,
    (void *)thunk64_vkCmdSetStencilOpEXT,
    (void *)thunk64_vkCmdSetStencilReference,
    (void *)thunk64_vkCmdSetStencilTestEnable,
    (void *)thunk64_vkCmdSetStencilTestEnableEXT,
    (void *)thunk64_vkCmdSetStencilWriteMask,
    (void *)thunk64_vkCmdSetTessellationDomainOriginEXT,
    (void *)thunk64_vkCmdSetVertexInputEXT,
    (void *)thunk64_vkCmdSetViewport,
    (void *)thunk64_vkCmdSetViewportShadingRatePaletteNV,
    (void *)thunk64_vkCmdSetViewportSwizzleNV,
    (void *)thunk64_vkCmdSetViewportWScalingEnableNV,
    (void *)thunk64_vkCmdSetViewportWScalingNV,
    (void *)thunk64_vkCmdSetViewportWithCount,
    (void *)thunk64_vkCmdSetViewportWithCountEXT,
    (void *)thunk64_vkCmdSubpassShadingHUAWEI,
    (void *)thunk64_vkCmdTraceRaysIndirect2KHR,
    (void *)thunk64_vkCmdTraceRaysIndirectKHR,
    (void *)thunk64_vkCmdTraceRaysKHR,
    (void *)thunk64_vkCmdTraceRaysNV,
    (void *)thunk64_vkCmdUpdateBuffer,
    (void *)thunk64_vkCmdUpdatePipelineIndirectBufferNV,
    (void *)thunk64_vkCmdWaitEvents,
    (void *)thunk64_vkCmdWaitEvents2,
    (void *)thunk64_vkCmdWaitEvents2KHR,
    (void *)thunk64_vkCmdWriteAccelerationStructuresPropertiesKHR,
    (void *)thunk64_vkCmdWriteAccelerationStructuresPropertiesNV,
    (void *)thunk64_vkCmdWriteBufferMarker2AMD,
    (void *)thunk64_vkCmdWriteBufferMarkerAMD,
    (void *)thunk64_vkCmdWriteMicromapsPropertiesEXT,
    (void *)thunk64_vkCmdWriteTimestamp,
    (void *)thunk64_vkCmdWriteTimestamp2,
    (void *)thunk64_vkCmdWriteTimestamp2KHR,
    thunk64_vkCompileDeferredNV,
    thunk64_vkConvertCooperativeVectorMatrixNV,
    thunk64_vkCopyAccelerationStructureKHR,
    thunk64_vkCopyAccelerationStructureToMemoryKHR,
    thunk64_vkCopyImageToImage,
    thunk64_vkCopyImageToImageEXT,
    thunk64_vkCopyImageToMemory,
    thunk64_vkCopyImageToMemoryEXT,
    thunk64_vkCopyMemoryToAccelerationStructureKHR,
    thunk64_vkCopyMemoryToImage,
    thunk64_vkCopyMemoryToImageEXT,
    thunk64_vkCopyMemoryToMicromapEXT,
    thunk64_vkCopyMicromapEXT,
    thunk64_vkCopyMicromapToMemoryEXT,
    thunk64_vkCreateAccelerationStructureKHR,
    thunk64_vkCreateAccelerationStructureNV,
    thunk64_vkCreateBuffer,
    thunk64_vkCreateBufferView,
    thunk64_vkCreateCommandPool,
    thunk64_vkCreateComputePipelines,
    thunk64_vkCreateCuFunctionNVX,
    thunk64_vkCreateCuModuleNVX,
    thunk64_vkCreateDataGraphPipelineSessionARM,
    thunk64_vkCreateDataGraphPipelinesARM,
    thunk64_vkCreateDebugReportCallbackEXT,
    thunk64_vkCreateDebugUtilsMessengerEXT,
    thunk64_vkCreateDeferredOperationKHR,
    thunk64_vkCreateDescriptorPool,
    thunk64_vkCreateDescriptorSetLayout,
    thunk64_vkCreateDescriptorUpdateTemplate,
    thunk64_vkCreateDescriptorUpdateTemplateKHR,
    thunk64_vkCreateDevice,
    thunk64_vkCreateEvent,
    thunk64_vkCreateFence,
    thunk64_vkCreateFramebuffer,
    thunk64_vkCreateGraphicsPipelines,
    thunk64_vkCreateImage,
    thunk64_vkCreateImageView,
    thunk64_vkCreateIndirectCommandsLayoutEXT,
    thunk64_vkCreateIndirectCommandsLayoutNV,
    thunk64_vkCreateIndirectExecutionSetEXT,
    thunk64_vkCreateInstance,
    thunk64_vkCreateMicromapEXT,
    thunk64_vkCreateOpticalFlowSessionNV,
    thunk64_vkCreatePipelineBinariesKHR,
    thunk64_vkCreatePipelineCache,
    thunk64_vkCreatePipelineLayout,
    thunk64_vkCreatePrivateDataSlot,
    thunk64_vkCreatePrivateDataSlotEXT,
    thunk64_vkCreateQueryPool,
    thunk64_vkCreateRayTracingPipelinesKHR,
    thunk64_vkCreateRayTracingPipelinesNV,
    thunk64_vkCreateRenderPass,
    thunk64_vkCreateRenderPass2,
    thunk64_vkCreateRenderPass2KHR,
    thunk64_vkCreateSampler,
    thunk64_vkCreateSamplerYcbcrConversion,
    thunk64_vkCreateSamplerYcbcrConversionKHR,
    thunk64_vkCreateSemaphore,
    thunk64_vkCreateShaderModule,
    thunk64_vkCreateShadersEXT,
    thunk64_vkCreateSwapchainKHR,
    thunk64_vkCreateTensorARM,
    thunk64_vkCreateTensorViewARM,
    thunk64_vkCreateValidationCacheEXT,
    thunk64_vkCreateVideoSessionKHR,
    thunk64_vkCreateVideoSessionParametersKHR,
    thunk64_vkCreateWin32SurfaceKHR,
    thunk64_vkDebugMarkerSetObjectNameEXT,
    thunk64_vkDebugMarkerSetObjectTagEXT,
    thunk64_vkDebugReportMessageEXT,
    thunk64_vkDeferredOperationJoinKHR,
    thunk64_vkDestroyAccelerationStructureKHR,
    thunk64_vkDestroyAccelerationStructureNV,
    thunk64_vkDestroyBuffer,
    thunk64_vkDestroyBufferView,
    thunk64_vkDestroyCommandPool,
    thunk64_vkDestroyCuFunctionNVX,
    thunk64_vkDestroyCuModuleNVX,
    thunk64_vkDestroyDataGraphPipelineSessionARM,
    thunk64_vkDestroyDebugReportCallbackEXT,
    thunk64_vkDestroyDebugUtilsMessengerEXT,
    thunk64_vkDestroyDeferredOperationKHR,
    thunk64_vkDestroyDescriptorPool,
    thunk64_vkDestroyDescriptorSetLayout,
    thunk64_vkDestroyDescriptorUpdateTemplate,
    thunk64_vkDestroyDescriptorUpdateTemplateKHR,
    thunk64_vkDestroyDevice,
    thunk64_vkDestroyEvent,
    thunk64_vkDestroyFence,
    thunk64_vkDestroyFramebuffer,
    thunk64_vkDestroyImage,
    thunk64_vkDestroyImageView,
    thunk64_vkDestroyIndirectCommandsLayoutEXT,
    thunk64_vkDestroyIndirectCommandsLayoutNV,
    thunk64_vkDestroyIndirectExecutionSetEXT,
    thunk64_vkDestroyInstance,
    thunk64_vkDestroyMicromapEXT,
    thunk64_vkDestroyOpticalFlowSessionNV,
    thunk64_vkDestroyPipeline,
    thunk64_vkDestroyPipelineBinaryKHR,
    thunk64_vkDestroyPipelineCache,
    thunk64_vkDestroyPipelineLayout,
    thunk64_vkDestroyPrivateDataSlot,
    thunk64_vkDestroyPrivateDataSlotEXT,
    thunk64_vkDestroyQueryPool,
    thunk64_vkDestroyRenderPass,
    thunk64_vkDestroySampler,
    thunk64_vkDestroySamplerYcbcrConversion,
    thunk64_vkDestroySamplerYcbcrConversionKHR,
    thunk64_vkDestroySemaphore,
    thunk64_vkDestroyShaderEXT,
    thunk64_vkDestroyShaderModule,
    thunk64_vkDestroySurfaceKHR,
    thunk64_vkDestroySwapchainKHR,
    thunk64_vkDestroyTensorARM,
    thunk64_vkDestroyTensorViewARM,
    thunk64_vkDestroyValidationCacheEXT,
    thunk64_vkDestroyVideoSessionKHR,
    thunk64_vkDestroyVideoSessionParametersKHR,
    thunk64_vkDeviceWaitIdle,
    thunk64_vkEndCommandBuffer,
    thunk64_vkEnumerateDeviceExtensionProperties,
    thunk64_vkEnumerateDeviceLayerProperties,
    thunk64_vkEnumerateInstanceExtensionProperties,
    thunk64_vkEnumerateInstanceVersion,
    thunk64_vkEnumeratePhysicalDeviceGroups,
    thunk64_vkEnumeratePhysicalDeviceGroupsKHR,
    thunk64_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
    thunk64_vkEnumeratePhysicalDevices,
    thunk64_vkFlushMappedMemoryRanges,
    thunk64_vkFreeCommandBuffers,
    thunk64_vkFreeDescriptorSets,
    thunk64_vkFreeMemory,
    thunk64_vkGetAccelerationStructureBuildSizesKHR,
    thunk64_vkGetAccelerationStructureDeviceAddressKHR,
    thunk64_vkGetAccelerationStructureHandleNV,
    thunk64_vkGetAccelerationStructureMemoryRequirementsNV,
    thunk64_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT,
    thunk64_vkGetBufferDeviceAddress,
    thunk64_vkGetBufferDeviceAddressEXT,
    thunk64_vkGetBufferDeviceAddressKHR,
    thunk64_vkGetBufferMemoryRequirements,
    thunk64_vkGetBufferMemoryRequirements2,
    thunk64_vkGetBufferMemoryRequirements2KHR,
    thunk64_vkGetBufferOpaqueCaptureAddress,
    thunk64_vkGetBufferOpaqueCaptureAddressKHR,
    thunk64_vkGetBufferOpaqueCaptureDescriptorDataEXT,
    thunk64_vkGetCalibratedTimestampsEXT,
    thunk64_vkGetCalibratedTimestampsKHR,
    thunk64_vkGetClusterAccelerationStructureBuildSizesNV,
    thunk64_vkGetDataGraphPipelineAvailablePropertiesARM,
    thunk64_vkGetDataGraphPipelinePropertiesARM,
    thunk64_vkGetDataGraphPipelineSessionBindPointRequirementsARM,
    thunk64_vkGetDataGraphPipelineSessionMemoryRequirementsARM,
    thunk64_vkGetDeferredOperationMaxConcurrencyKHR,
    thunk64_vkGetDeferredOperationResultKHR,
    (void *)thunk64_vkGetDescriptorEXT,
    thunk64_vkGetDescriptorSetHostMappingVALVE,
    thunk64_vkGetDescriptorSetLayoutBindingOffsetEXT,
    thunk64_vkGetDescriptorSetLayoutHostMappingInfoVALVE,
    thunk64_vkGetDescriptorSetLayoutSizeEXT,
    thunk64_vkGetDescriptorSetLayoutSupport,
    thunk64_vkGetDescriptorSetLayoutSupportKHR,
    thunk64_vkGetDeviceAccelerationStructureCompatibilityKHR,
    thunk64_vkGetDeviceBufferMemoryRequirements,
    thunk64_vkGetDeviceBufferMemoryRequirementsKHR,
    thunk64_vkGetDeviceFaultInfoEXT,
    thunk64_vkGetDeviceGroupPeerMemoryFeatures,
    thunk64_vkGetDeviceGroupPeerMemoryFeaturesKHR,
    thunk64_vkGetDeviceGroupPresentCapabilitiesKHR,
    thunk64_vkGetDeviceGroupSurfacePresentModesKHR,
    thunk64_vkGetDeviceImageMemoryRequirements,
    thunk64_vkGetDeviceImageMemoryRequirementsKHR,
    thunk64_vkGetDeviceImageSparseMemoryRequirements,
    thunk64_vkGetDeviceImageSparseMemoryRequirementsKHR,
    thunk64_vkGetDeviceImageSubresourceLayout,
    thunk64_vkGetDeviceImageSubresourceLayoutKHR,
    thunk64_vkGetDeviceMemoryCommitment,
    thunk64_vkGetDeviceMemoryOpaqueCaptureAddress,
    thunk64_vkGetDeviceMemoryOpaqueCaptureAddressKHR,
    thunk64_vkGetDeviceMicromapCompatibilityEXT,
    thunk64_vkGetDeviceQueue,
    thunk64_vkGetDeviceQueue2,
    thunk64_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
    thunk64_vkGetDeviceTensorMemoryRequirementsARM,
    thunk64_vkGetDynamicRenderingTilePropertiesQCOM,
    thunk64_vkGetEncodedVideoSessionParametersKHR,
    thunk64_vkGetEventStatus,
    thunk64_vkGetFenceStatus,
    thunk64_vkGetFenceWin32HandleKHR,
    thunk64_vkGetFramebufferTilePropertiesQCOM,
    thunk64_vkGetGeneratedCommandsMemoryRequirementsEXT,
    thunk64_vkGetGeneratedCommandsMemoryRequirementsNV,
    thunk64_vkGetImageMemoryRequirements,
    thunk64_vkGetImageMemoryRequirements2,
    thunk64_vkGetImageMemoryRequirements2KHR,
    thunk64_vkGetImageOpaqueCaptureDescriptorDataEXT,
    thunk64_vkGetImageSparseMemoryRequirements,
    thunk64_vkGetImageSparseMemoryRequirements2,
    thunk64_vkGetImageSparseMemoryRequirements2KHR,
    thunk64_vkGetImageSubresourceLayout,
    thunk64_vkGetImageSubresourceLayout2,
    thunk64_vkGetImageSubresourceLayout2EXT,
    thunk64_vkGetImageSubresourceLayout2KHR,
    thunk64_vkGetImageViewAddressNVX,
    thunk64_vkGetImageViewHandle64NVX,
    thunk64_vkGetImageViewHandleNVX,
    thunk64_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
    thunk64_vkGetLatencyTimingsNV,
    thunk64_vkGetMemoryHostPointerPropertiesEXT,
    thunk64_vkGetMemoryWin32HandleKHR,
    thunk64_vkGetMemoryWin32HandlePropertiesKHR,
    thunk64_vkGetMicromapBuildSizesEXT,
    thunk64_vkGetPartitionedAccelerationStructuresBuildSizesNV,
    thunk64_vkGetPerformanceParameterINTEL,
    thunk64_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
    thunk64_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR,
    thunk64_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV,
    thunk64_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
    thunk64_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
    thunk64_vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
    thunk64_vkGetPhysicalDeviceExternalBufferProperties,
    thunk64_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
    thunk64_vkGetPhysicalDeviceExternalFenceProperties,
    thunk64_vkGetPhysicalDeviceExternalFencePropertiesKHR,
    thunk64_vkGetPhysicalDeviceExternalSemaphoreProperties,
    thunk64_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR,
    thunk64_vkGetPhysicalDeviceExternalTensorPropertiesARM,
    thunk64_vkGetPhysicalDeviceFeatures,
    thunk64_vkGetPhysicalDeviceFeatures2,
    thunk64_vkGetPhysicalDeviceFeatures2KHR,
    thunk64_vkGetPhysicalDeviceFormatProperties,
    thunk64_vkGetPhysicalDeviceFormatProperties2,
    thunk64_vkGetPhysicalDeviceFormatProperties2KHR,
    thunk64_vkGetPhysicalDeviceFragmentShadingRatesKHR,
    thunk64_vkGetPhysicalDeviceImageFormatProperties,
    thunk64_vkGetPhysicalDeviceImageFormatProperties2,
    thunk64_vkGetPhysicalDeviceImageFormatProperties2KHR,
    thunk64_vkGetPhysicalDeviceMemoryProperties,
    thunk64_vkGetPhysicalDeviceMemoryProperties2,
    thunk64_vkGetPhysicalDeviceMemoryProperties2KHR,
    thunk64_vkGetPhysicalDeviceMultisamplePropertiesEXT,
    thunk64_vkGetPhysicalDeviceOpticalFlowImageFormatsNV,
    thunk64_vkGetPhysicalDevicePresentRectanglesKHR,
    thunk64_vkGetPhysicalDeviceProperties,
    thunk64_vkGetPhysicalDeviceProperties2,
    thunk64_vkGetPhysicalDeviceProperties2KHR,
    thunk64_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM,
    thunk64_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM,
    thunk64_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR,
    thunk64_vkGetPhysicalDeviceQueueFamilyProperties,
    thunk64_vkGetPhysicalDeviceQueueFamilyProperties2,
    thunk64_vkGetPhysicalDeviceQueueFamilyProperties2KHR,
    thunk64_vkGetPhysicalDeviceSparseImageFormatProperties,
    thunk64_vkGetPhysicalDeviceSparseImageFormatProperties2,
    thunk64_vkGetPhysicalDeviceSparseImageFormatProperties2KHR,
    thunk64_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
    thunk64_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
    thunk64_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
    thunk64_vkGetPhysicalDeviceSurfaceFormats2KHR,
    thunk64_vkGetPhysicalDeviceSurfaceFormatsKHR,
    thunk64_vkGetPhysicalDeviceSurfacePresentModesKHR,
    thunk64_vkGetPhysicalDeviceSurfaceSupportKHR,
    thunk64_vkGetPhysicalDeviceToolProperties,
    thunk64_vkGetPhysicalDeviceToolPropertiesEXT,
    thunk64_vkGetPhysicalDeviceVideoCapabilitiesKHR,
    thunk64_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR,
    thunk64_vkGetPhysicalDeviceVideoFormatPropertiesKHR,
    thunk64_vkGetPhysicalDeviceWin32PresentationSupportKHR,
    thunk64_vkGetPipelineBinaryDataKHR,
    thunk64_vkGetPipelineCacheData,
    thunk64_vkGetPipelineExecutableInternalRepresentationsKHR,
    thunk64_vkGetPipelineExecutablePropertiesKHR,
    thunk64_vkGetPipelineExecutableStatisticsKHR,
    thunk64_vkGetPipelineIndirectDeviceAddressNV,
    thunk64_vkGetPipelineIndirectMemoryRequirementsNV,
    thunk64_vkGetPipelineKeyKHR,
    thunk64_vkGetPipelinePropertiesEXT,
    thunk64_vkGetPrivateData,
    thunk64_vkGetPrivateDataEXT,
    thunk64_vkGetQueryPoolResults,
    thunk64_vkGetQueueCheckpointData2NV,
    thunk64_vkGetQueueCheckpointDataNV,
    thunk64_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR,
    thunk64_vkGetRayTracingShaderGroupHandlesKHR,
    thunk64_vkGetRayTracingShaderGroupHandlesNV,
    thunk64_vkGetRayTracingShaderGroupStackSizeKHR,
    thunk64_vkGetRenderAreaGranularity,
    thunk64_vkGetRenderingAreaGranularity,
    thunk64_vkGetRenderingAreaGranularityKHR,
    thunk64_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
    thunk64_vkGetSemaphoreCounterValue,
    thunk64_vkGetSemaphoreCounterValueKHR,
    thunk64_vkGetSemaphoreWin32HandleKHR,
    thunk64_vkGetShaderBinaryDataEXT,
    thunk64_vkGetShaderInfoAMD,
    thunk64_vkGetShaderModuleCreateInfoIdentifierEXT,
    thunk64_vkGetShaderModuleIdentifierEXT,
    thunk64_vkGetSwapchainImagesKHR,
    thunk64_vkGetTensorMemoryRequirementsARM,
    thunk64_vkGetTensorOpaqueCaptureDescriptorDataARM,
    thunk64_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
    thunk64_vkGetValidationCacheDataEXT,
    thunk64_vkGetVideoSessionMemoryRequirementsKHR,
    thunk64_vkImportFenceWin32HandleKHR,
    thunk64_vkImportSemaphoreWin32HandleKHR,
    thunk64_vkInitializePerformanceApiINTEL,
    thunk64_vkInvalidateMappedMemoryRanges,
    thunk64_vkLatencySleepNV,
    thunk64_vkMapMemory,
    thunk64_vkMapMemory2,
    thunk64_vkMapMemory2KHR,
    thunk64_vkMergePipelineCaches,
    thunk64_vkMergeValidationCachesEXT,
    thunk64_vkQueueBeginDebugUtilsLabelEXT,
    thunk64_vkQueueBindSparse,
    thunk64_vkQueueEndDebugUtilsLabelEXT,
    thunk64_vkQueueInsertDebugUtilsLabelEXT,
    thunk64_vkQueueNotifyOutOfBandNV,
    thunk64_vkQueuePresentKHR,
    thunk64_vkQueueSetPerformanceConfigurationINTEL,
    thunk64_vkQueueSubmit,
    thunk64_vkQueueSubmit2,
    thunk64_vkQueueSubmit2KHR,
    thunk64_vkQueueWaitIdle,
    thunk64_vkReleaseCapturedPipelineDataKHR,
    thunk64_vkReleasePerformanceConfigurationINTEL,
    thunk64_vkReleaseProfilingLockKHR,
    thunk64_vkReleaseSwapchainImagesEXT,
    thunk64_vkReleaseSwapchainImagesKHR,
    thunk64_vkResetCommandBuffer,
    thunk64_vkResetCommandPool,
    thunk64_vkResetDescriptorPool,
    thunk64_vkResetEvent,
    thunk64_vkResetFences,
    thunk64_vkResetQueryPool,
    thunk64_vkResetQueryPoolEXT,
    thunk64_vkSetDebugUtilsObjectNameEXT,
    thunk64_vkSetDebugUtilsObjectTagEXT,
    thunk64_vkSetDeviceMemoryPriorityEXT,
    thunk64_vkSetEvent,
    thunk64_vkSetHdrMetadataEXT,
    thunk64_vkSetLatencyMarkerNV,
    thunk64_vkSetLatencySleepModeNV,
    thunk64_vkSetPrivateData,
    thunk64_vkSetPrivateDataEXT,
    thunk64_vkSignalSemaphore,
    thunk64_vkSignalSemaphoreKHR,
    thunk64_vkSubmitDebugUtilsMessageEXT,
    thunk64_vkTransitionImageLayout,
    thunk64_vkTransitionImageLayoutEXT,
    thunk64_vkTrimCommandPool,
    thunk64_vkTrimCommandPoolKHR,
    thunk64_vkUninitializePerformanceApiINTEL,
    thunk64_vkUnmapMemory,
    thunk64_vkUnmapMemory2,
    thunk64_vkUnmapMemory2KHR,
    (void *)thunk64_vkUpdateDescriptorSetWithTemplate,
    thunk64_vkUpdateDescriptorSetWithTemplateKHR,
    (void *)thunk64_vkUpdateDescriptorSets,
    thunk64_vkUpdateIndirectExecutionSetPipelineEXT,
    thunk64_vkUpdateIndirectExecutionSetShaderEXT,
    thunk64_vkUpdateVideoSessionParametersKHR,
    thunk64_vkWaitForFences,
    thunk64_vkWaitForPresent2KHR,
    thunk64_vkWaitForPresentKHR,
    thunk64_vkWaitSemaphores,
    thunk64_vkWaitSemaphoresKHR,
    thunk64_vkWriteAccelerationStructuresPropertiesKHR,
    thunk64_vkWriteMicromapsPropertiesEXT,
};
C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);

#endif /* _WIN64 */

#ifdef _WIN64
const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
#else
const unixlib_entry_t __wine_unix_call_funcs[] =
#endif
{
    init_vulkan,
    vk_is_available_instance_function32,
    vk_is_available_device_function32,
    thunk32_vkAcquireNextImage2KHR,
    thunk32_vkAcquireNextImageKHR,
    thunk32_vkAcquirePerformanceConfigurationINTEL,
    thunk32_vkAcquireProfilingLockKHR,
    thunk32_vkAllocateCommandBuffers,
    thunk32_vkAllocateDescriptorSets,
    thunk32_vkAllocateMemory,
    thunk32_vkAntiLagUpdateAMD,
    thunk32_vkBeginCommandBuffer,
    thunk32_vkBindAccelerationStructureMemoryNV,
    thunk32_vkBindBufferMemory,
    thunk32_vkBindBufferMemory2,
    thunk32_vkBindBufferMemory2KHR,
    thunk32_vkBindDataGraphPipelineSessionMemoryARM,
    thunk32_vkBindImageMemory,
    thunk32_vkBindImageMemory2,
    thunk32_vkBindImageMemory2KHR,
    thunk32_vkBindOpticalFlowSessionImageNV,
    thunk32_vkBindTensorMemoryARM,
    thunk32_vkBindVideoSessionMemoryKHR,
    thunk32_vkBuildAccelerationStructuresKHR,
    thunk32_vkBuildMicromapsEXT,
    (void *)thunk32_vkCmdBeginConditionalRenderingEXT,
    (void *)thunk32_vkCmdBeginDebugUtilsLabelEXT,
    (void *)thunk32_vkCmdBeginPerTileExecutionQCOM,
    (void *)thunk32_vkCmdBeginQuery,
    (void *)thunk32_vkCmdBeginQueryIndexedEXT,
    (void *)thunk32_vkCmdBeginRenderPass,
    (void *)thunk32_vkCmdBeginRenderPass2,
    (void *)thunk32_vkCmdBeginRenderPass2KHR,
    (void *)thunk32_vkCmdBeginRendering,
    (void *)thunk32_vkCmdBeginRenderingKHR,
    (void *)thunk32_vkCmdBeginTransformFeedbackEXT,
    (void *)thunk32_vkCmdBeginVideoCodingKHR,
    (void *)thunk32_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT,
    (void *)thunk32_vkCmdBindDescriptorBufferEmbeddedSamplersEXT,
    (void *)thunk32_vkCmdBindDescriptorBuffersEXT,
    (void *)thunk32_vkCmdBindDescriptorSets,
    (void *)thunk32_vkCmdBindDescriptorSets2,
    (void *)thunk32_vkCmdBindDescriptorSets2KHR,
    (void *)thunk32_vkCmdBindIndexBuffer,
    (void *)thunk32_vkCmdBindIndexBuffer2,
    (void *)thunk32_vkCmdBindIndexBuffer2KHR,
    (void *)thunk32_vkCmdBindInvocationMaskHUAWEI,
    (void *)thunk32_vkCmdBindPipeline,
    (void *)thunk32_vkCmdBindPipelineShaderGroupNV,
    (void *)thunk32_vkCmdBindShadersEXT,
    (void *)thunk32_vkCmdBindShadingRateImageNV,
    (void *)thunk32_vkCmdBindTileMemoryQCOM,
    (void *)thunk32_vkCmdBindTransformFeedbackBuffersEXT,
    (void *)thunk32_vkCmdBindVertexBuffers,
    (void *)thunk32_vkCmdBindVertexBuffers2,
    (void *)thunk32_vkCmdBindVertexBuffers2EXT,
    (void *)thunk32_vkCmdBlitImage,
    (void *)thunk32_vkCmdBlitImage2,
    (void *)thunk32_vkCmdBlitImage2KHR,
    (void *)thunk32_vkCmdBuildAccelerationStructureNV,
    (void *)thunk32_vkCmdBuildAccelerationStructuresIndirectKHR,
    (void *)thunk32_vkCmdBuildAccelerationStructuresKHR,
    (void *)thunk32_vkCmdBuildClusterAccelerationStructureIndirectNV,
    (void *)thunk32_vkCmdBuildMicromapsEXT,
    (void *)thunk32_vkCmdBuildPartitionedAccelerationStructuresNV,
    (void *)thunk32_vkCmdClearAttachments,
    (void *)thunk32_vkCmdClearColorImage,
    (void *)thunk32_vkCmdClearDepthStencilImage,
    (void *)thunk32_vkCmdControlVideoCodingKHR,
    (void *)thunk32_vkCmdConvertCooperativeVectorMatrixNV,
    (void *)thunk32_vkCmdCopyAccelerationStructureKHR,
    (void *)thunk32_vkCmdCopyAccelerationStructureNV,
    (void *)thunk32_vkCmdCopyAccelerationStructureToMemoryKHR,
    (void *)thunk32_vkCmdCopyBuffer,
    (void *)thunk32_vkCmdCopyBuffer2,
    (void *)thunk32_vkCmdCopyBuffer2KHR,
    (void *)thunk32_vkCmdCopyBufferToImage,
    (void *)thunk32_vkCmdCopyBufferToImage2,
    (void *)thunk32_vkCmdCopyBufferToImage2KHR,
    (void *)thunk32_vkCmdCopyImage,
    (void *)thunk32_vkCmdCopyImage2,
    (void *)thunk32_vkCmdCopyImage2KHR,
    (void *)thunk32_vkCmdCopyImageToBuffer,
    (void *)thunk32_vkCmdCopyImageToBuffer2,
    (void *)thunk32_vkCmdCopyImageToBuffer2KHR,
    (void *)thunk32_vkCmdCopyMemoryIndirectNV,
    (void *)thunk32_vkCmdCopyMemoryToAccelerationStructureKHR,
    (void *)thunk32_vkCmdCopyMemoryToImageIndirectNV,
    (void *)thunk32_vkCmdCopyMemoryToMicromapEXT,
    (void *)thunk32_vkCmdCopyMicromapEXT,
    (void *)thunk32_vkCmdCopyMicromapToMemoryEXT,
    (void *)thunk32_vkCmdCopyQueryPoolResults,
    (void *)thunk32_vkCmdCopyTensorARM,
    (void *)thunk32_vkCmdCuLaunchKernelNVX,
    (void *)thunk32_vkCmdDebugMarkerBeginEXT,
    (void *)thunk32_vkCmdDebugMarkerEndEXT,
    (void *)thunk32_vkCmdDebugMarkerInsertEXT,
    (void *)thunk32_vkCmdDecodeVideoKHR,
    (void *)thunk32_vkCmdDecompressMemoryIndirectCountNV,
    (void *)thunk32_vkCmdDecompressMemoryNV,
    (void *)thunk32_vkCmdDispatch,
    (void *)thunk32_vkCmdDispatchBase,
    (void *)thunk32_vkCmdDispatchBaseKHR,
    (void *)thunk32_vkCmdDispatchDataGraphARM,
    (void *)thunk32_vkCmdDispatchIndirect,
    (void *)thunk32_vkCmdDispatchTileQCOM,
    (void *)thunk32_vkCmdDraw,
    (void *)thunk32_vkCmdDrawClusterHUAWEI,
    (void *)thunk32_vkCmdDrawClusterIndirectHUAWEI,
    (void *)thunk32_vkCmdDrawIndexed,
    (void *)thunk32_vkCmdDrawIndexedIndirect,
    (void *)thunk32_vkCmdDrawIndexedIndirectCount,
    (void *)thunk32_vkCmdDrawIndexedIndirectCountAMD,
    (void *)thunk32_vkCmdDrawIndexedIndirectCountKHR,
    (void *)thunk32_vkCmdDrawIndirect,
    (void *)thunk32_vkCmdDrawIndirectByteCountEXT,
    (void *)thunk32_vkCmdDrawIndirectCount,
    (void *)thunk32_vkCmdDrawIndirectCountAMD,
    (void *)thunk32_vkCmdDrawIndirectCountKHR,
    (void *)thunk32_vkCmdDrawMeshTasksEXT,
    (void *)thunk32_vkCmdDrawMeshTasksIndirectCountEXT,
    (void *)thunk32_vkCmdDrawMeshTasksIndirectCountNV,
    (void *)thunk32_vkCmdDrawMeshTasksIndirectEXT,
    (void *)thunk32_vkCmdDrawMeshTasksIndirectNV,
    (void *)thunk32_vkCmdDrawMeshTasksNV,
    (void *)thunk32_vkCmdDrawMultiEXT,
    (void *)thunk32_vkCmdDrawMultiIndexedEXT,
    (void *)thunk32_vkCmdEncodeVideoKHR,
    (void *)thunk32_vkCmdEndConditionalRenderingEXT,
    (void *)thunk32_vkCmdEndDebugUtilsLabelEXT,
    (void *)thunk32_vkCmdEndPerTileExecutionQCOM,
    (void *)thunk32_vkCmdEndQuery,
    (void *)thunk32_vkCmdEndQueryIndexedEXT,
    (void *)thunk32_vkCmdEndRenderPass,
    (void *)thunk32_vkCmdEndRenderPass2,
    (void *)thunk32_vkCmdEndRenderPass2KHR,
    (void *)thunk32_vkCmdEndRendering,
    (void *)thunk32_vkCmdEndRendering2EXT,
    (void *)thunk32_vkCmdEndRenderingKHR,
    (void *)thunk32_vkCmdEndTransformFeedbackEXT,
    (void *)thunk32_vkCmdEndVideoCodingKHR,
    (void *)thunk32_vkCmdExecuteCommands,
    (void *)thunk32_vkCmdExecuteGeneratedCommandsEXT,
    (void *)thunk32_vkCmdExecuteGeneratedCommandsNV,
    (void *)thunk32_vkCmdFillBuffer,
    (void *)thunk32_vkCmdInsertDebugUtilsLabelEXT,
    (void *)thunk32_vkCmdNextSubpass,
    (void *)thunk32_vkCmdNextSubpass2,
    (void *)thunk32_vkCmdNextSubpass2KHR,
    (void *)thunk32_vkCmdOpticalFlowExecuteNV,
    (void *)thunk32_vkCmdPipelineBarrier,
    (void *)thunk32_vkCmdPipelineBarrier2,
    (void *)thunk32_vkCmdPipelineBarrier2KHR,
    (void *)thunk32_vkCmdPreprocessGeneratedCommandsEXT,
    (void *)thunk32_vkCmdPreprocessGeneratedCommandsNV,
    (void *)thunk32_vkCmdPushConstants,
    (void *)thunk32_vkCmdPushConstants2,
    (void *)thunk32_vkCmdPushConstants2KHR,
    (void *)thunk32_vkCmdPushDescriptorSet,
    (void *)thunk32_vkCmdPushDescriptorSet2,
    (void *)thunk32_vkCmdPushDescriptorSet2KHR,
    (void *)thunk32_vkCmdPushDescriptorSetKHR,
    (void *)thunk32_vkCmdPushDescriptorSetWithTemplate,
    (void *)thunk32_vkCmdPushDescriptorSetWithTemplate2,
    (void *)thunk32_vkCmdPushDescriptorSetWithTemplate2KHR,
    (void *)thunk32_vkCmdPushDescriptorSetWithTemplateKHR,
    (void *)thunk32_vkCmdResetEvent,
    (void *)thunk32_vkCmdResetEvent2,
    (void *)thunk32_vkCmdResetEvent2KHR,
    (void *)thunk32_vkCmdResetQueryPool,
    (void *)thunk32_vkCmdResolveImage,
    (void *)thunk32_vkCmdResolveImage2,
    (void *)thunk32_vkCmdResolveImage2KHR,
    (void *)thunk32_vkCmdSetAlphaToCoverageEnableEXT,
    (void *)thunk32_vkCmdSetAlphaToOneEnableEXT,
    (void *)thunk32_vkCmdSetAttachmentFeedbackLoopEnableEXT,
    (void *)thunk32_vkCmdSetBlendConstants,
    (void *)thunk32_vkCmdSetCheckpointNV,
    (void *)thunk32_vkCmdSetCoarseSampleOrderNV,
    (void *)thunk32_vkCmdSetColorBlendAdvancedEXT,
    (void *)thunk32_vkCmdSetColorBlendEnableEXT,
    (void *)thunk32_vkCmdSetColorBlendEquationEXT,
    (void *)thunk32_vkCmdSetColorWriteEnableEXT,
    (void *)thunk32_vkCmdSetColorWriteMaskEXT,
    (void *)thunk32_vkCmdSetConservativeRasterizationModeEXT,
    (void *)thunk32_vkCmdSetCoverageModulationModeNV,
    (void *)thunk32_vkCmdSetCoverageModulationTableEnableNV,
    (void *)thunk32_vkCmdSetCoverageModulationTableNV,
    (void *)thunk32_vkCmdSetCoverageReductionModeNV,
    (void *)thunk32_vkCmdSetCoverageToColorEnableNV,
    (void *)thunk32_vkCmdSetCoverageToColorLocationNV,
    (void *)thunk32_vkCmdSetCullMode,
    (void *)thunk32_vkCmdSetCullModeEXT,
    (void *)thunk32_vkCmdSetDepthBias,
    (void *)thunk32_vkCmdSetDepthBias2EXT,
    (void *)thunk32_vkCmdSetDepthBiasEnable,
    (void *)thunk32_vkCmdSetDepthBiasEnableEXT,
    (void *)thunk32_vkCmdSetDepthBounds,
    (void *)thunk32_vkCmdSetDepthBoundsTestEnable,
    (void *)thunk32_vkCmdSetDepthBoundsTestEnableEXT,
    (void *)thunk32_vkCmdSetDepthClampEnableEXT,
    (void *)thunk32_vkCmdSetDepthClampRangeEXT,
    (void *)thunk32_vkCmdSetDepthClipEnableEXT,
    (void *)thunk32_vkCmdSetDepthClipNegativeOneToOneEXT,
    (void *)thunk32_vkCmdSetDepthCompareOp,
    (void *)thunk32_vkCmdSetDepthCompareOpEXT,
    (void *)thunk32_vkCmdSetDepthTestEnable,
    (void *)thunk32_vkCmdSetDepthTestEnableEXT,
    (void *)thunk32_vkCmdSetDepthWriteEnable,
    (void *)thunk32_vkCmdSetDepthWriteEnableEXT,
    (void *)thunk32_vkCmdSetDescriptorBufferOffsets2EXT,
    (void *)thunk32_vkCmdSetDescriptorBufferOffsetsEXT,
    (void *)thunk32_vkCmdSetDeviceMask,
    (void *)thunk32_vkCmdSetDeviceMaskKHR,
    (void *)thunk32_vkCmdSetDiscardRectangleEXT,
    (void *)thunk32_vkCmdSetDiscardRectangleEnableEXT,
    (void *)thunk32_vkCmdSetDiscardRectangleModeEXT,
    (void *)thunk32_vkCmdSetEvent,
    (void *)thunk32_vkCmdSetEvent2,
    (void *)thunk32_vkCmdSetEvent2KHR,
    (void *)thunk32_vkCmdSetExclusiveScissorEnableNV,
    (void *)thunk32_vkCmdSetExclusiveScissorNV,
    (void *)thunk32_vkCmdSetExtraPrimitiveOverestimationSizeEXT,
    (void *)thunk32_vkCmdSetFragmentShadingRateEnumNV,
    (void *)thunk32_vkCmdSetFragmentShadingRateKHR,
    (void *)thunk32_vkCmdSetFrontFace,
    (void *)thunk32_vkCmdSetFrontFaceEXT,
    (void *)thunk32_vkCmdSetLineRasterizationModeEXT,
    (void *)thunk32_vkCmdSetLineStipple,
    (void *)thunk32_vkCmdSetLineStippleEXT,
    (void *)thunk32_vkCmdSetLineStippleEnableEXT,
    (void *)thunk32_vkCmdSetLineStippleKHR,
    (void *)thunk32_vkCmdSetLineWidth,
    (void *)thunk32_vkCmdSetLogicOpEXT,
    (void *)thunk32_vkCmdSetLogicOpEnableEXT,
    (void *)thunk32_vkCmdSetPatchControlPointsEXT,
    thunk32_vkCmdSetPerformanceMarkerINTEL,
    thunk32_vkCmdSetPerformanceOverrideINTEL,
    thunk32_vkCmdSetPerformanceStreamMarkerINTEL,
    (void *)thunk32_vkCmdSetPolygonModeEXT,
    (void *)thunk32_vkCmdSetPrimitiveRestartEnable,
    (void *)thunk32_vkCmdSetPrimitiveRestartEnableEXT,
    (void *)thunk32_vkCmdSetPrimitiveTopology,
    (void *)thunk32_vkCmdSetPrimitiveTopologyEXT,
    (void *)thunk32_vkCmdSetProvokingVertexModeEXT,
    (void *)thunk32_vkCmdSetRasterizationSamplesEXT,
    (void *)thunk32_vkCmdSetRasterizationStreamEXT,
    (void *)thunk32_vkCmdSetRasterizerDiscardEnable,
    (void *)thunk32_vkCmdSetRasterizerDiscardEnableEXT,
    (void *)thunk32_vkCmdSetRayTracingPipelineStackSizeKHR,
    (void *)thunk32_vkCmdSetRenderingAttachmentLocations,
    (void *)thunk32_vkCmdSetRenderingAttachmentLocationsKHR,
    (void *)thunk32_vkCmdSetRenderingInputAttachmentIndices,
    (void *)thunk32_vkCmdSetRenderingInputAttachmentIndicesKHR,
    (void *)thunk32_vkCmdSetRepresentativeFragmentTestEnableNV,
    (void *)thunk32_vkCmdSetSampleLocationsEXT,
    (void *)thunk32_vkCmdSetSampleLocationsEnableEXT,
    (void *)thunk32_vkCmdSetSampleMaskEXT,
    (void *)thunk32_vkCmdSetScissor,
    (void *)thunk32_vkCmdSetScissorWithCount,
    (void *)thunk32_vkCmdSetScissorWithCountEXT,
    (void *)thunk32_vkCmdSetShadingRateImageEnableNV,
    (void *)thunk32_vkCmdSetStencilCompareMask,
    (void *)thunk32_vkCmdSetStencilOp,
    (void *)thunk32_vkCmdSetStencilOpEXT,
    (void *)thunk32_vkCmdSetStencilReference,
    (void *)thunk32_vkCmdSetStencilTestEnable,
    (void *)thunk32_vkCmdSetStencilTestEnableEXT,
    (void *)thunk32_vkCmdSetStencilWriteMask,
    (void *)thunk32_vkCmdSetTessellationDomainOriginEXT,
    (void *)thunk32_vkCmdSetVertexInputEXT,
    (void *)thunk32_vkCmdSetViewport,
    (void *)thunk32_vkCmdSetViewportShadingRatePaletteNV,
    (void *)thunk32_vkCmdSetViewportSwizzleNV,
    (void *)thunk32_vkCmdSetViewportWScalingEnableNV,
    (void *)thunk32_vkCmdSetViewportWScalingNV,
    (void *)thunk32_vkCmdSetViewportWithCount,
    (void *)thunk32_vkCmdSetViewportWithCountEXT,
    (void *)thunk32_vkCmdSubpassShadingHUAWEI,
    (void *)thunk32_vkCmdTraceRaysIndirect2KHR,
    (void *)thunk32_vkCmdTraceRaysIndirectKHR,
    (void *)thunk32_vkCmdTraceRaysKHR,
    (void *)thunk32_vkCmdTraceRaysNV,
    (void *)thunk32_vkCmdUpdateBuffer,
    (void *)thunk32_vkCmdUpdatePipelineIndirectBufferNV,
    (void *)thunk32_vkCmdWaitEvents,
    (void *)thunk32_vkCmdWaitEvents2,
    (void *)thunk32_vkCmdWaitEvents2KHR,
    (void *)thunk32_vkCmdWriteAccelerationStructuresPropertiesKHR,
    (void *)thunk32_vkCmdWriteAccelerationStructuresPropertiesNV,
    (void *)thunk32_vkCmdWriteBufferMarker2AMD,
    (void *)thunk32_vkCmdWriteBufferMarkerAMD,
    (void *)thunk32_vkCmdWriteMicromapsPropertiesEXT,
    (void *)thunk32_vkCmdWriteTimestamp,
    (void *)thunk32_vkCmdWriteTimestamp2,
    (void *)thunk32_vkCmdWriteTimestamp2KHR,
    thunk32_vkCompileDeferredNV,
    thunk32_vkConvertCooperativeVectorMatrixNV,
    thunk32_vkCopyAccelerationStructureKHR,
    thunk32_vkCopyAccelerationStructureToMemoryKHR,
    thunk32_vkCopyImageToImage,
    thunk32_vkCopyImageToImageEXT,
    thunk32_vkCopyImageToMemory,
    thunk32_vkCopyImageToMemoryEXT,
    thunk32_vkCopyMemoryToAccelerationStructureKHR,
    thunk32_vkCopyMemoryToImage,
    thunk32_vkCopyMemoryToImageEXT,
    thunk32_vkCopyMemoryToMicromapEXT,
    thunk32_vkCopyMicromapEXT,
    thunk32_vkCopyMicromapToMemoryEXT,
    thunk32_vkCreateAccelerationStructureKHR,
    thunk32_vkCreateAccelerationStructureNV,
    thunk32_vkCreateBuffer,
    thunk32_vkCreateBufferView,
    thunk32_vkCreateCommandPool,
    thunk32_vkCreateComputePipelines,
    thunk32_vkCreateCuFunctionNVX,
    thunk32_vkCreateCuModuleNVX,
    thunk32_vkCreateDataGraphPipelineSessionARM,
    thunk32_vkCreateDataGraphPipelinesARM,
    thunk32_vkCreateDebugReportCallbackEXT,
    thunk32_vkCreateDebugUtilsMessengerEXT,
    thunk32_vkCreateDeferredOperationKHR,
    thunk32_vkCreateDescriptorPool,
    thunk32_vkCreateDescriptorSetLayout,
    thunk32_vkCreateDescriptorUpdateTemplate,
    thunk32_vkCreateDescriptorUpdateTemplateKHR,
    thunk32_vkCreateDevice,
    thunk32_vkCreateEvent,
    thunk32_vkCreateFence,
    thunk32_vkCreateFramebuffer,
    thunk32_vkCreateGraphicsPipelines,
    thunk32_vkCreateImage,
    thunk32_vkCreateImageView,
    thunk32_vkCreateIndirectCommandsLayoutEXT,
    thunk32_vkCreateIndirectCommandsLayoutNV,
    thunk32_vkCreateIndirectExecutionSetEXT,
    thunk32_vkCreateInstance,
    thunk32_vkCreateMicromapEXT,
    thunk32_vkCreateOpticalFlowSessionNV,
    thunk32_vkCreatePipelineBinariesKHR,
    thunk32_vkCreatePipelineCache,
    thunk32_vkCreatePipelineLayout,
    thunk32_vkCreatePrivateDataSlot,
    thunk32_vkCreatePrivateDataSlotEXT,
    thunk32_vkCreateQueryPool,
    thunk32_vkCreateRayTracingPipelinesKHR,
    thunk32_vkCreateRayTracingPipelinesNV,
    thunk32_vkCreateRenderPass,
    thunk32_vkCreateRenderPass2,
    thunk32_vkCreateRenderPass2KHR,
    thunk32_vkCreateSampler,
    thunk32_vkCreateSamplerYcbcrConversion,
    thunk32_vkCreateSamplerYcbcrConversionKHR,
    thunk32_vkCreateSemaphore,
    thunk32_vkCreateShaderModule,
    thunk32_vkCreateShadersEXT,
    thunk32_vkCreateSwapchainKHR,
    thunk32_vkCreateTensorARM,
    thunk32_vkCreateTensorViewARM,
    thunk32_vkCreateValidationCacheEXT,
    thunk32_vkCreateVideoSessionKHR,
    thunk32_vkCreateVideoSessionParametersKHR,
    thunk32_vkCreateWin32SurfaceKHR,
    thunk32_vkDebugMarkerSetObjectNameEXT,
    thunk32_vkDebugMarkerSetObjectTagEXT,
    thunk32_vkDebugReportMessageEXT,
    thunk32_vkDeferredOperationJoinKHR,
    thunk32_vkDestroyAccelerationStructureKHR,
    thunk32_vkDestroyAccelerationStructureNV,
    thunk32_vkDestroyBuffer,
    thunk32_vkDestroyBufferView,
    thunk32_vkDestroyCommandPool,
    thunk32_vkDestroyCuFunctionNVX,
    thunk32_vkDestroyCuModuleNVX,
    thunk32_vkDestroyDataGraphPipelineSessionARM,
    thunk32_vkDestroyDebugReportCallbackEXT,
    thunk32_vkDestroyDebugUtilsMessengerEXT,
    thunk32_vkDestroyDeferredOperationKHR,
    thunk32_vkDestroyDescriptorPool,
    thunk32_vkDestroyDescriptorSetLayout,
    thunk32_vkDestroyDescriptorUpdateTemplate,
    thunk32_vkDestroyDescriptorUpdateTemplateKHR,
    thunk32_vkDestroyDevice,
    thunk32_vkDestroyEvent,
    thunk32_vkDestroyFence,
    thunk32_vkDestroyFramebuffer,
    thunk32_vkDestroyImage,
    thunk32_vkDestroyImageView,
    thunk32_vkDestroyIndirectCommandsLayoutEXT,
    thunk32_vkDestroyIndirectCommandsLayoutNV,
    thunk32_vkDestroyIndirectExecutionSetEXT,
    thunk32_vkDestroyInstance,
    thunk32_vkDestroyMicromapEXT,
    thunk32_vkDestroyOpticalFlowSessionNV,
    thunk32_vkDestroyPipeline,
    thunk32_vkDestroyPipelineBinaryKHR,
    thunk32_vkDestroyPipelineCache,
    thunk32_vkDestroyPipelineLayout,
    thunk32_vkDestroyPrivateDataSlot,
    thunk32_vkDestroyPrivateDataSlotEXT,
    thunk32_vkDestroyQueryPool,
    thunk32_vkDestroyRenderPass,
    thunk32_vkDestroySampler,
    thunk32_vkDestroySamplerYcbcrConversion,
    thunk32_vkDestroySamplerYcbcrConversionKHR,
    thunk32_vkDestroySemaphore,
    thunk32_vkDestroyShaderEXT,
    thunk32_vkDestroyShaderModule,
    thunk32_vkDestroySurfaceKHR,
    thunk32_vkDestroySwapchainKHR,
    thunk32_vkDestroyTensorARM,
    thunk32_vkDestroyTensorViewARM,
    thunk32_vkDestroyValidationCacheEXT,
    thunk32_vkDestroyVideoSessionKHR,
    thunk32_vkDestroyVideoSessionParametersKHR,
    thunk32_vkDeviceWaitIdle,
    thunk32_vkEndCommandBuffer,
    thunk32_vkEnumerateDeviceExtensionProperties,
    thunk32_vkEnumerateDeviceLayerProperties,
    thunk32_vkEnumerateInstanceExtensionProperties,
    thunk32_vkEnumerateInstanceVersion,
    thunk32_vkEnumeratePhysicalDeviceGroups,
    thunk32_vkEnumeratePhysicalDeviceGroupsKHR,
    thunk32_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
    thunk32_vkEnumeratePhysicalDevices,
    thunk32_vkFlushMappedMemoryRanges,
    thunk32_vkFreeCommandBuffers,
    thunk32_vkFreeDescriptorSets,
    thunk32_vkFreeMemory,
    thunk32_vkGetAccelerationStructureBuildSizesKHR,
    thunk32_vkGetAccelerationStructureDeviceAddressKHR,
    thunk32_vkGetAccelerationStructureHandleNV,
    thunk32_vkGetAccelerationStructureMemoryRequirementsNV,
    thunk32_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT,
    thunk32_vkGetBufferDeviceAddress,
    thunk32_vkGetBufferDeviceAddressEXT,
    thunk32_vkGetBufferDeviceAddressKHR,
    thunk32_vkGetBufferMemoryRequirements,
    thunk32_vkGetBufferMemoryRequirements2,
    thunk32_vkGetBufferMemoryRequirements2KHR,
    thunk32_vkGetBufferOpaqueCaptureAddress,
    thunk32_vkGetBufferOpaqueCaptureAddressKHR,
    thunk32_vkGetBufferOpaqueCaptureDescriptorDataEXT,
    thunk32_vkGetCalibratedTimestampsEXT,
    thunk32_vkGetCalibratedTimestampsKHR,
    thunk32_vkGetClusterAccelerationStructureBuildSizesNV,
    thunk32_vkGetDataGraphPipelineAvailablePropertiesARM,
    thunk32_vkGetDataGraphPipelinePropertiesARM,
    thunk32_vkGetDataGraphPipelineSessionBindPointRequirementsARM,
    thunk32_vkGetDataGraphPipelineSessionMemoryRequirementsARM,
    thunk32_vkGetDeferredOperationMaxConcurrencyKHR,
    thunk32_vkGetDeferredOperationResultKHR,
    (void *)thunk32_vkGetDescriptorEXT,
    thunk32_vkGetDescriptorSetHostMappingVALVE,
    thunk32_vkGetDescriptorSetLayoutBindingOffsetEXT,
    thunk32_vkGetDescriptorSetLayoutHostMappingInfoVALVE,
    thunk32_vkGetDescriptorSetLayoutSizeEXT,
    thunk32_vkGetDescriptorSetLayoutSupport,
    thunk32_vkGetDescriptorSetLayoutSupportKHR,
    thunk32_vkGetDeviceAccelerationStructureCompatibilityKHR,
    thunk32_vkGetDeviceBufferMemoryRequirements,
    thunk32_vkGetDeviceBufferMemoryRequirementsKHR,
    thunk32_vkGetDeviceFaultInfoEXT,
    thunk32_vkGetDeviceGroupPeerMemoryFeatures,
    thunk32_vkGetDeviceGroupPeerMemoryFeaturesKHR,
    thunk32_vkGetDeviceGroupPresentCapabilitiesKHR,
    thunk32_vkGetDeviceGroupSurfacePresentModesKHR,
    thunk32_vkGetDeviceImageMemoryRequirements,
    thunk32_vkGetDeviceImageMemoryRequirementsKHR,
    thunk32_vkGetDeviceImageSparseMemoryRequirements,
    thunk32_vkGetDeviceImageSparseMemoryRequirementsKHR,
    thunk32_vkGetDeviceImageSubresourceLayout,
    thunk32_vkGetDeviceImageSubresourceLayoutKHR,
    thunk32_vkGetDeviceMemoryCommitment,
    thunk32_vkGetDeviceMemoryOpaqueCaptureAddress,
    thunk32_vkGetDeviceMemoryOpaqueCaptureAddressKHR,
    thunk32_vkGetDeviceMicromapCompatibilityEXT,
    thunk32_vkGetDeviceQueue,
    thunk32_vkGetDeviceQueue2,
    thunk32_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
    thunk32_vkGetDeviceTensorMemoryRequirementsARM,
    thunk32_vkGetDynamicRenderingTilePropertiesQCOM,
    thunk32_vkGetEncodedVideoSessionParametersKHR,
    thunk32_vkGetEventStatus,
    thunk32_vkGetFenceStatus,
    thunk32_vkGetFenceWin32HandleKHR,
    thunk32_vkGetFramebufferTilePropertiesQCOM,
    thunk32_vkGetGeneratedCommandsMemoryRequirementsEXT,
    thunk32_vkGetGeneratedCommandsMemoryRequirementsNV,
    thunk32_vkGetImageMemoryRequirements,
    thunk32_vkGetImageMemoryRequirements2,
    thunk32_vkGetImageMemoryRequirements2KHR,
    thunk32_vkGetImageOpaqueCaptureDescriptorDataEXT,
    thunk32_vkGetImageSparseMemoryRequirements,
    thunk32_vkGetImageSparseMemoryRequirements2,
    thunk32_vkGetImageSparseMemoryRequirements2KHR,
    thunk32_vkGetImageSubresourceLayout,
    thunk32_vkGetImageSubresourceLayout2,
    thunk32_vkGetImageSubresourceLayout2EXT,
    thunk32_vkGetImageSubresourceLayout2KHR,
    thunk32_vkGetImageViewAddressNVX,
    thunk32_vkGetImageViewHandle64NVX,
    thunk32_vkGetImageViewHandleNVX,
    thunk32_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
    thunk32_vkGetLatencyTimingsNV,
    thunk32_vkGetMemoryHostPointerPropertiesEXT,
    thunk32_vkGetMemoryWin32HandleKHR,
    thunk32_vkGetMemoryWin32HandlePropertiesKHR,
    thunk32_vkGetMicromapBuildSizesEXT,
    thunk32_vkGetPartitionedAccelerationStructuresBuildSizesNV,
    thunk32_vkGetPerformanceParameterINTEL,
    thunk32_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
    thunk32_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR,
    thunk32_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV,
    thunk32_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
    thunk32_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
    thunk32_vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
    thunk32_vkGetPhysicalDeviceExternalBufferProperties,
    thunk32_vkGetPhysicalDeviceExternalBufferPropertiesKHR,
    thunk32_vkGetPhysicalDeviceExternalFenceProperties,
    thunk32_vkGetPhysicalDeviceExternalFencePropertiesKHR,
    thunk32_vkGetPhysicalDeviceExternalSemaphoreProperties,
    thunk32_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR,
    thunk32_vkGetPhysicalDeviceExternalTensorPropertiesARM,
    thunk32_vkGetPhysicalDeviceFeatures,
    thunk32_vkGetPhysicalDeviceFeatures2,
    thunk32_vkGetPhysicalDeviceFeatures2KHR,
    thunk32_vkGetPhysicalDeviceFormatProperties,
    thunk32_vkGetPhysicalDeviceFormatProperties2,
    thunk32_vkGetPhysicalDeviceFormatProperties2KHR,
    thunk32_vkGetPhysicalDeviceFragmentShadingRatesKHR,
    thunk32_vkGetPhysicalDeviceImageFormatProperties,
    thunk32_vkGetPhysicalDeviceImageFormatProperties2,
    thunk32_vkGetPhysicalDeviceImageFormatProperties2KHR,
    thunk32_vkGetPhysicalDeviceMemoryProperties,
    thunk32_vkGetPhysicalDeviceMemoryProperties2,
    thunk32_vkGetPhysicalDeviceMemoryProperties2KHR,
    thunk32_vkGetPhysicalDeviceMultisamplePropertiesEXT,
    thunk32_vkGetPhysicalDeviceOpticalFlowImageFormatsNV,
    thunk32_vkGetPhysicalDevicePresentRectanglesKHR,
    thunk32_vkGetPhysicalDeviceProperties,
    thunk32_vkGetPhysicalDeviceProperties2,
    thunk32_vkGetPhysicalDeviceProperties2KHR,
    thunk32_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM,
    thunk32_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM,
    thunk32_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR,
    thunk32_vkGetPhysicalDeviceQueueFamilyProperties,
    thunk32_vkGetPhysicalDeviceQueueFamilyProperties2,
    thunk32_vkGetPhysicalDeviceQueueFamilyProperties2KHR,
    thunk32_vkGetPhysicalDeviceSparseImageFormatProperties,
    thunk32_vkGetPhysicalDeviceSparseImageFormatProperties2,
    thunk32_vkGetPhysicalDeviceSparseImageFormatProperties2KHR,
    thunk32_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
    thunk32_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
    thunk32_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
    thunk32_vkGetPhysicalDeviceSurfaceFormats2KHR,
    thunk32_vkGetPhysicalDeviceSurfaceFormatsKHR,
    thunk32_vkGetPhysicalDeviceSurfacePresentModesKHR,
    thunk32_vkGetPhysicalDeviceSurfaceSupportKHR,
    thunk32_vkGetPhysicalDeviceToolProperties,
    thunk32_vkGetPhysicalDeviceToolPropertiesEXT,
    thunk32_vkGetPhysicalDeviceVideoCapabilitiesKHR,
    thunk32_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR,
    thunk32_vkGetPhysicalDeviceVideoFormatPropertiesKHR,
    thunk32_vkGetPhysicalDeviceWin32PresentationSupportKHR,
    thunk32_vkGetPipelineBinaryDataKHR,
    thunk32_vkGetPipelineCacheData,
    thunk32_vkGetPipelineExecutableInternalRepresentationsKHR,
    thunk32_vkGetPipelineExecutablePropertiesKHR,
    thunk32_vkGetPipelineExecutableStatisticsKHR,
    thunk32_vkGetPipelineIndirectDeviceAddressNV,
    thunk32_vkGetPipelineIndirectMemoryRequirementsNV,
    thunk32_vkGetPipelineKeyKHR,
    thunk32_vkGetPipelinePropertiesEXT,
    thunk32_vkGetPrivateData,
    thunk32_vkGetPrivateDataEXT,
    thunk32_vkGetQueryPoolResults,
    thunk32_vkGetQueueCheckpointData2NV,
    thunk32_vkGetQueueCheckpointDataNV,
    thunk32_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR,
    thunk32_vkGetRayTracingShaderGroupHandlesKHR,
    thunk32_vkGetRayTracingShaderGroupHandlesNV,
    thunk32_vkGetRayTracingShaderGroupStackSizeKHR,
    thunk32_vkGetRenderAreaGranularity,
    thunk32_vkGetRenderingAreaGranularity,
    thunk32_vkGetRenderingAreaGranularityKHR,
    thunk32_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
    thunk32_vkGetSemaphoreCounterValue,
    thunk32_vkGetSemaphoreCounterValueKHR,
    thunk32_vkGetSemaphoreWin32HandleKHR,
    thunk32_vkGetShaderBinaryDataEXT,
    thunk32_vkGetShaderInfoAMD,
    thunk32_vkGetShaderModuleCreateInfoIdentifierEXT,
    thunk32_vkGetShaderModuleIdentifierEXT,
    thunk32_vkGetSwapchainImagesKHR,
    thunk32_vkGetTensorMemoryRequirementsARM,
    thunk32_vkGetTensorOpaqueCaptureDescriptorDataARM,
    thunk32_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
    thunk32_vkGetValidationCacheDataEXT,
    thunk32_vkGetVideoSessionMemoryRequirementsKHR,
    thunk32_vkImportFenceWin32HandleKHR,
    thunk32_vkImportSemaphoreWin32HandleKHR,
    thunk32_vkInitializePerformanceApiINTEL,
    thunk32_vkInvalidateMappedMemoryRanges,
    thunk32_vkLatencySleepNV,
    thunk32_vkMapMemory,
    thunk32_vkMapMemory2,
    thunk32_vkMapMemory2KHR,
    thunk32_vkMergePipelineCaches,
    thunk32_vkMergeValidationCachesEXT,
    thunk32_vkQueueBeginDebugUtilsLabelEXT,
    thunk32_vkQueueBindSparse,
    thunk32_vkQueueEndDebugUtilsLabelEXT,
    thunk32_vkQueueInsertDebugUtilsLabelEXT,
    thunk32_vkQueueNotifyOutOfBandNV,
    thunk32_vkQueuePresentKHR,
    thunk32_vkQueueSetPerformanceConfigurationINTEL,
    thunk32_vkQueueSubmit,
    thunk32_vkQueueSubmit2,
    thunk32_vkQueueSubmit2KHR,
    thunk32_vkQueueWaitIdle,
    thunk32_vkReleaseCapturedPipelineDataKHR,
    thunk32_vkReleasePerformanceConfigurationINTEL,
    thunk32_vkReleaseProfilingLockKHR,
    thunk32_vkReleaseSwapchainImagesEXT,
    thunk32_vkReleaseSwapchainImagesKHR,
    thunk32_vkResetCommandBuffer,
    thunk32_vkResetCommandPool,
    thunk32_vkResetDescriptorPool,
    thunk32_vkResetEvent,
    thunk32_vkResetFences,
    thunk32_vkResetQueryPool,
    thunk32_vkResetQueryPoolEXT,
    thunk32_vkSetDebugUtilsObjectNameEXT,
    thunk32_vkSetDebugUtilsObjectTagEXT,
    thunk32_vkSetDeviceMemoryPriorityEXT,
    thunk32_vkSetEvent,
    thunk32_vkSetHdrMetadataEXT,
    thunk32_vkSetLatencyMarkerNV,
    thunk32_vkSetLatencySleepModeNV,
    thunk32_vkSetPrivateData,
    thunk32_vkSetPrivateDataEXT,
    thunk32_vkSignalSemaphore,
    thunk32_vkSignalSemaphoreKHR,
    thunk32_vkSubmitDebugUtilsMessageEXT,
    thunk32_vkTransitionImageLayout,
    thunk32_vkTransitionImageLayoutEXT,
    thunk32_vkTrimCommandPool,
    thunk32_vkTrimCommandPoolKHR,
    thunk32_vkUninitializePerformanceApiINTEL,
    thunk32_vkUnmapMemory,
    thunk32_vkUnmapMemory2,
    thunk32_vkUnmapMemory2KHR,
    (void *)thunk32_vkUpdateDescriptorSetWithTemplate,
    thunk32_vkUpdateDescriptorSetWithTemplateKHR,
    (void *)thunk32_vkUpdateDescriptorSets,
    thunk32_vkUpdateIndirectExecutionSetPipelineEXT,
    thunk32_vkUpdateIndirectExecutionSetShaderEXT,
    thunk32_vkUpdateVideoSessionParametersKHR,
    thunk32_vkWaitForFences,
    thunk32_vkWaitForPresent2KHR,
    thunk32_vkWaitForPresentKHR,
    thunk32_vkWaitSemaphores,
    thunk32_vkWaitSemaphoresKHR,
    thunk32_vkWriteAccelerationStructuresPropertiesKHR,
    thunk32_vkWriteMicromapsPropertiesEXT,
};
C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);
