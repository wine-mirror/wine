#!/usr/bin/perl -w
#
# Update the dll dependencies in the dlls main Makefile.in.
#
# Copyright 2001 Alexandre Julliard
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
#

use strict;

my %directories = ();
my %testdirs = ();
my %importlibs = ();
my %static_implibs = ();
my %staticlib_dirs = ();
my %altnames = ();

# list of special dlls that can be switched on or off by configure
my %special_dlls =
(
  "glu32"    => "GLU32FILES",
  "glut32"   => "GLUT32FILES",
  "opengl32" => "OPENGLFILES",
  "wined3d"  => "OPENGLFILES",
  "winex11.drv" => "XFILES"
);

sub needs_symlink($)
{
    (my $mod = $_[0]) =~ s/\.dll$//;
    return $mod ne $directories{$_[0]};
}

sub update_file($)
{
    my $file = shift;
    if (!system "cmp $file $file.new >/dev/null")
    {
        unlink "$file.new";
        print "$file is unchanged\n";
    }
    else
    {
        rename "$file.new", "$file";
        print "$file updated\n";
        if (-x "./config.status" && $file =~ /(.*Makefile)\.in$/)
        {
            system "./config.status", $1;
        }
    }
}

# if we are inside the dlls dir, go up one level
if (! -f "configure.ac" && -f "../configure.ac") { chdir(".."); }

my @args = @ARGV;
if (!@args) { @args = map { s/^(.*)\.in/$1/; $_; } split(/\s/,`find dlls -name Makefile.in -print`); }

foreach my $i (@args)
{
    if ($i =~ /dlls\/(.*)\/tests\/Makefile/)
    {
        $testdirs{$1} = "$1/tests";
        next;
    }

    open MAKE, "$i.in" or die "cannot open $i.in\n";

    my $module = undef;
    my $dir = $i;

    while (<MAKE>)
    {
        chop;
        # EPP hack to disable this DLL... the MKDLL_SKIP comment must appear
        # at the very top of the Makefile.in
        last if (/^\#\s*MKDLL_SKIP/);

        if (/^MODULE\s*=\s*([a-zA-Z0-9_.]+)/)
        {
            $module = $1;
            if ($module =~ /^lib.*\.a$/)
            {
                ($staticlib_dirs{$module} = $i) =~ s/^dlls\/(.*)\/[^\/]+$/$1/;
                die "invalid module $module in dir $staticlib_dirs{$module}\n" if "lib$staticlib_dirs{$module}.a" ne $module;
            }
            else
            {
                ($directories{$module} = $i) =~ s/^dlls\/(.*)\/[^\/]+$/$1/;
            }
            next;
        }
        if (/^IMPORTLIB\s*=\s*([a-zA-Z0-9_.]+)\.\$\(IMPLIBEXT\)/)
        {
            $importlibs{$module} = $1;
            next;
        }
        if (/^IMPLIB_SRCS\s*=/)
        {
            $static_implibs{$module} = 1;
            next;
        }
        if (/^SPEC_SRCS16\s*=\s*(.*)/)
        {
            my $specs = $1;
            while ($specs =~ /\s*(.*)\\$/) { $specs = $1 . <MAKE>; }
            my @list = split(/\s+/,$specs);
            @list = map { $_ =~ s/\.spec$//; $_ .= ".dll" unless $_ =~ /\./; $_; } @list;
            $altnames{$module} = \@list;
            next;
        }
    }
    close MAKE;
}

open NEWMAKE,">dlls/Makefile.in.new" or die "cannot create dlls/Makefile.in.new";

################################################################
# makefile header

print NEWMAKE <<EOF;
# Automatically generated by make_dlls; DO NOT EDIT!!

TOPSRCDIR = \@top_srcdir\@
TOPOBJDIR = ..
SRCDIR    = \@srcdir\@
VPATH     = \@srcdir\@

EOF

################################################################
# output special dlls configure definitions

printf NEWMAKE "# special configure-dependent targets\n\n";
my %specials = ();
foreach my $mod (sort keys %special_dlls)
{
    $specials{$special_dlls{$mod}} .= " " . $mod;
}
foreach my $i (sort keys %specials)
{
    printf NEWMAKE "%s =%s\n", $i, $specials{$i};
}
printf NEWMAKE "EXTRADIRS =";
foreach my $i (sort keys %specials) { printf NEWMAKE " \@%s\@", $i; }
printf NEWMAKE "\n\n";


################################################################
# output the subdirs list

print NEWMAKE "# Subdir list\n\nBASEDIRS =";
foreach my $dir (sort values %directories)
{
    next if defined($special_dlls{$dir});  # skip special dlls
    printf NEWMAKE " \\\n\t%s", $dir;
}

print NEWMAKE "\n\nIMPLIBSUBDIRS = \\\n\t";
print NEWMAKE join " \\\n\t", sort values %staticlib_dirs;

print NEWMAKE "\n\nTESTSUBDIRS = \\\n\t";
print NEWMAKE join " \\\n\t", sort values %testdirs;

print NEWMAKE "\n\nSUBDIRS = \\\n\t";
print NEWMAKE join " \\\n\t", "\$(BASEDIRS)", "\$(IMPLIBSUBDIRS)", "\$(TESTSUBDIRS)",
                              sort keys %special_dlls;
print NEWMAKE <<EOF;


BUILDSUBDIRS   = \$(BASEDIRS) \$(EXTRADIRS) \$(TESTSUBDIRS)
INSTALLSUBDIRS = \$(BASEDIRS) \$(EXTRADIRS) \$(IMPLIBSUBDIRS)
DOCSUBDIRS     = \$(BASEDIRS) \$(EXTRADIRS)
EOF

################################################################
# output the all: target

my %targets = ();  # use a hash to get rid of duplicate target names
my %targets16 = ();
foreach my $mod (sort keys %directories)
{
    next if defined($special_dlls{$directories{$mod}});  # skip special dlls
    $targets{$mod . ".so"} = 1 if needs_symlink($mod);
    next unless defined $altnames{$mod};
    foreach my $i (sort @{$altnames{$mod}})
    {
        $targets16{$i . "16"} = $mod;
    }
}

print NEWMAKE <<EOF;

\@MAKE_RULES\@

# Symbolic links

WIN16_FILES = \\
EOF
printf NEWMAKE "\t%s\n", join( " \\\n\t", sort keys %targets16 );

print NEWMAKE <<EOF;

SYMLINKS_SO = \\
	\@WIN16_FILES\@ \\
EOF
printf NEWMAKE "\t%s\n", join( " \\\n\t", sort keys %targets );

print NEWMAKE <<EOF;

# Main target

all: \$(BUILDSUBDIRS) symlinks\$(DLLEXT)

.PHONY: symlinks symlinks.so implib

symlinks.so: \$(SYMLINKS_SO)

symlinks: \$(BUILDSUBDIRS)

EOF

################################################################
# output the lib name -> directory rules

print NEWMAKE "# Map symlink name to the corresponding library\n\n";
foreach my $mod (sort keys %directories)
{
    next unless needs_symlink($mod);
    printf NEWMAKE "%s.so: %s/%s.so\n", $mod, $directories{$mod}, $mod;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s.so \$@\n\n", $directories{$mod}, $mod;
}

print NEWMAKE "# Placeholders for 16-bit libraries\n\n";
foreach my $mod (sort keys %directories)
{
    next unless defined $altnames{$mod};
    printf NEWMAKE "%s:\n", join(" ", map { $_ . "16"; } sort @{$altnames{$mod}});
    printf NEWMAKE "\techo \"%s\" >\$\@\n\n", $mod;
}

################################################################
# output the import libraries rules

print NEWMAKE "# Import libraries\n\n";
print NEWMAKE "STATIC_IMPLIBEXT = \$(IMPLIBEXT:def=def.a)\n\n";

my @lib_symlinks = ();
foreach my $mod (sort keys %importlibs)
{
    my $dir = $directories{$mod};
    my $lib = $importlibs{$mod};
    if ($lib ne "lib" . $dir) { push @lib_symlinks, $mod; }
}
print NEWMAKE "IMPORT_SYMLINKS =";
foreach my $mod (sort @lib_symlinks)
{
    printf NEWMAKE " \\\n\t%s.\$(IMPLIBEXT)", $importlibs{$mod};
}

print NEWMAKE "\n\nIMPORT_LIBS = \\\n\t\$(IMPORT_SYMLINKS)";
foreach my $mod (sort keys %staticlib_dirs)
{
    printf NEWMAKE " \\\n\t%s/%s", $staticlib_dirs{$mod}, $mod;
}
foreach my $mod (sort keys %importlibs)
{
    my $dir = $directories{$mod};
    my $def = $mod;
    $def =~ s/\.(dll|drv)$//;
    printf NEWMAKE " \\\n\t%s/lib%s.\$(IMPLIBEXT)", $dir, $def;
    printf NEWMAKE " \\\n\t%s/lib%s.\$(STATIC_IMPLIBEXT)", $dir, $def if $static_implibs{$mod};
}
print NEWMAKE "\n\n";
print NEWMAKE "implib: \$(IMPORT_LIBS)\n\n";

foreach my $mod (sort keys %importlibs)
{
    my $dir = $directories{$mod};
    my $lib = $importlibs{$mod};
    my $spec = $mod;
    $spec =~ s/\.dll$//;
    printf NEWMAKE "%s/%s.\$(IMPLIBEXT): %s/%s.spec \$(WINEBUILD)\n", $dir, $lib, $dir, $spec;
    printf NEWMAKE "\t\@cd %s && \$(MAKE) %s.\$(IMPLIBEXT)\n\n", $dir, $lib;
    next unless $static_implibs{$mod};
    printf NEWMAKE "%s/%s.\$(STATIC_IMPLIBEXT): dummy\n", $dir, $lib, $dir, $spec;
    printf NEWMAKE "\t\@cd %s && \$(MAKE) %s.\$(STATIC_IMPLIBEXT)\n\n", $dir, $lib;
}
foreach my $mod (sort @lib_symlinks)
{
    my $dir = $directories{$mod};
    my $lib = $importlibs{$mod} . ".\$(IMPLIBEXT)";
    printf NEWMAKE "%s: %s/%s\n", $lib, $dir, $lib;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s \$@\n\n", $dir, $lib;
}

print NEWMAKE <<EOF;
\$(BUILDSUBDIRS): \$(IMPORT_LIBS)
\$(INSTALLSUBDIRS:%=%/__install__) \$(INSTALLSUBDIRS:%=%/__install-lib__): \$(IMPORT_LIBS)

EOF

################################################################
# output the inter-dll dependencies and rules

print NEWMAKE "# Map library name to the corresponding directory\n\n";

foreach my $mod (sort keys %directories)
{
    next unless needs_symlink($mod);
    printf NEWMAKE "%s/%s.so: %s\n", $directories{$mod}, $mod, $directories{$mod};
}
foreach my $mod (sort keys %staticlib_dirs)
{
    printf NEWMAKE "%s/%s: %s\n", $staticlib_dirs{$mod}, $mod, $staticlib_dirs{$mod};
}

################################################################
# makefile trailer

print NEWMAKE <<EOF;

# Misc rules

install-lib:: \$(INSTALLSUBDIRS:%=%/__install-lib__)

install-dev:: \$(INSTALLSUBDIRS:%=%/__install-dev__)

uninstall::
	-rmdir \$(DESTDIR)\$(dlldir)

clean::
	\$(RM) \$(IMPORT_SYMLINKS) \$(WIN16_FILES)

### Dependencies:
EOF

close NEWMAKE;
update_file("dlls/Makefile.in");

################################################################
# .gitignore file

open GITIGNORE, ">dlls/.gitignore.new" or die "cannot create dlls/.gitignore.new";
print GITIGNORE "# Automatically generated by make_dlls; DO NOT EDIT!!\n";

my @ignores =
(
 "/Makedll.rules",
 "/Makeimplib.rules",
 "/Maketest.rules",
 "*/tests/testlist.c",
 "*/tests/*.ok",
);

foreach my $mod (sort @lib_symlinks)
{
    push @ignores, "/$importlibs{$mod}.def";
}
foreach my $mod (sort keys %directories)
{
    next unless defined $altnames{$mod};
    push @ignores, map { "/" . $_ . "16"; } @{$altnames{$mod}};
}
foreach my $mod (sort keys %importlibs)
{
    my $dir = $directories{$mod};
    my $def = $mod;
    $def =~ s/\.(dll|drv)$//;
    push @ignores, "$dir/lib$def.def";
}

print GITIGNORE join("\n", sort @ignores) . "\n";

close GITIGNORE;
update_file("dlls/.gitignore");
