#!/usr/bin/perl -w
#
# Update the dll dependencies in the dlls main Makefile.in.
# Must be run in the dlls/ directory of the Wine tree.
#
# Copyright 2001 Alexandre Julliard
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
#

use strict;

my $makefiles = `find . -name Makefile.in -print`;

my %directories = ();
my %importlibs = ();
my %static_implibs = ();
my %staticlib_dirs = ();
my %altnames = ();

# list of special dlls that can be switched on or off by configure
my %special_dlls =
(
  "glu32"    => "GLU32FILES",
  "glut32"   => "GLUT32FILES",
  "opengl32" => "OPENGLFILES",
  "wined3d"  => "OPENGLFILES",
  "winex11.drv" => "XFILES"
);

sub needs_symlink($)
{
    (my $mod = $_[0]) =~ s/\.dll$//;
    return $mod ne $directories{$_[0]};
}

foreach my $i (split(/\s/,$makefiles))
{
    my $module;

    next if $i =~ /\/tests\/Makefile.in/;

    open MAKE,$i;

    $module = undef;
    while (<MAKE>)
    {
        chop;
        # EPP hack to disable this DLL... the MKDLL_SKIP comment must appear
        # at the very top of the Makefile.in
        last if (/^\#\s*MKDLL_SKIP/);

        if (/^MODULE\s*=\s*([a-zA-Z0-9_.]+)/)
        {
            $module = $1;
            if ($module =~ /^lib.*\.a$/)
            {
                ($staticlib_dirs{$module} = $i) =~ s/^\.\/(.*)\/[^\/]+$/$1/;
                die "invalid module $module in dir $staticlib_dirs{$module}\n" if "lib$staticlib_dirs{$module}.a" ne $module;
            }
            else
            {
                ($directories{$module} = $i) =~ s/^\.\/(.*)\/[^\/]+$/$1/;
            }
            next;
        }
        if (/^IMPORTLIB\s*=\s*([a-zA-Z0-9_.]+)\.\$\(IMPLIBEXT\)/)
        {
            $importlibs{$module} = $1;
            next;
        }
        if (/^IMPLIB_SRCS\s*=/)
        {
            $static_implibs{$module} = 1;
            next;
        }
        if (/^SPEC_SRCS16\s*=\s*(.*)/)
        {
            my $specs = $1;
            while ($specs =~ /\s*(.*)\\$/) { $specs = $1 . <MAKE>; }
            my @list = split(/\s+/,$specs);
            @list = map { $_ =~ s/\.spec$//; $_ .= ".dll" unless $_ =~ /\./; $_; } @list;
            $altnames{$module} = \@list;
            next;
        }
    }
    close MAKE;
}

open NEWMAKE,">Makefile.in.new" or die "cannot create Makefile.in.new";

################################################################
# makefile header

print NEWMAKE <<EOF;
# Automatically generated by make_dlls; DO NOT EDIT!!

TOPSRCDIR = \@top_srcdir\@
TOPOBJDIR = ..
SRCDIR    = \@srcdir\@
VPATH     = \@srcdir\@

EOF

################################################################
# output special dlls configure definitions

printf NEWMAKE "# special configure-dependent targets\n\n";
my %specials = ();
foreach my $mod (sort keys %special_dlls)
{
    $specials{$special_dlls{$mod}} .= " " . $mod;
}
foreach my $i (sort keys %specials)
{
    printf NEWMAKE "%s =%s\n", $i, $specials{$i};
}
printf NEWMAKE "EXTRADIRS =";
foreach my $i (sort keys %specials) { printf NEWMAKE " \@%s\@", $i; }
printf NEWMAKE "\n\n";


################################################################
# output the subdirs list

print NEWMAKE "# Subdir list\n\nBASEDIRS =";
foreach my $dir (sort values %directories)
{
    next if defined($special_dlls{$dir});  # skip special dlls
    printf NEWMAKE " \\\n\t%s", $dir;
}

printf NEWMAKE "\n\nIMPLIBSUBDIRS =";
foreach my $dir (sort values %staticlib_dirs)
{
    printf NEWMAKE " \\\n\t%s", $dir;
}

printf NEWMAKE "\n\nSUBDIRS = \\\n\t\$(BASEDIRS) \\\n\t\$(IMPLIBSUBDIRS)";
foreach my $dir (sort keys %special_dlls)
{
    printf NEWMAKE " \\\n\t%s", $dir;
}
printf NEWMAKE <<EOF;


BUILDSUBDIRS = \$(BASEDIRS) \$(EXTRADIRS)

INSTALLSUBDIRS = \$(BUILDSUBDIRS) \$(IMPLIBSUBDIRS)
EOF

################################################################
# output the all: target

my %targets = ();  # use a hash to get rid of duplicate target names
my %targets16 = ();
foreach my $mod (sort keys %directories)
{
    next if defined($special_dlls{$directories{$mod}});  # skip special dlls
    $targets{$mod . ".so"} = 1 if needs_symlink($mod);
    next unless defined $altnames{$mod};
    foreach my $i (sort @{$altnames{$mod}})
    {
        $targets16{$i . "16"} = $mod;
    }
}

print NEWMAKE <<EOF;

\@MAKE_RULES\@

# Symbolic links

WIN16_FILES = \\
EOF
printf NEWMAKE "\t%s\n", join( " \\\n\t", sort keys %targets16 );

print NEWMAKE <<EOF;

SYMLINKS_SO = \\
	\@WIN16_FILES\@ \\
EOF
printf NEWMAKE "\t%s\n", join( " \\\n\t", sort keys %targets );

print NEWMAKE <<EOF;

# Main target

all: \$(BUILDSUBDIRS) symlinks\$(DLLEXT)

.PHONY: symlinks symlinks.so implib

symlinks.so: \$(SYMLINKS_SO)

symlinks: \$(BUILDSUBDIRS)

EOF

################################################################
# output the lib name -> directory rules

print NEWMAKE "# Map symlink name to the corresponding library\n\n";
foreach my $mod (sort keys %directories)
{
    next unless needs_symlink($mod);
    printf NEWMAKE "%s.so: %s/%s.so\n", $mod, $directories{$mod}, $mod;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s.so \$@\n\n", $directories{$mod}, $mod;
}

print NEWMAKE "# Placeholders for 16-bit libraries\n\n";
foreach my $mod (sort keys %directories)
{
    next unless defined $altnames{$mod};
    printf NEWMAKE "%s:\n", join(" ", map { $_ . "16"; } sort @{$altnames{$mod}});
    printf NEWMAKE "\techo \"%s\" >\$\@\n\n", $mod;
}

################################################################
# output the import libraries rules

print NEWMAKE "# Import libraries\n\n";
print NEWMAKE "STATIC_IMPLIBEXT = \$(IMPLIBEXT:def=def.a)\n\n";

my @lib_symlinks = ();
foreach my $mod (sort keys %importlibs)
{
    my $dir = $directories{$mod};
    my $lib = $importlibs{$mod};
    if ($lib ne "lib" . $dir) { push @lib_symlinks, $mod; }
}
print NEWMAKE "IMPORT_SYMLINKS =";
foreach my $mod (sort @lib_symlinks)
{
    printf NEWMAKE " \\\n\t%s.\$(IMPLIBEXT)", $importlibs{$mod};
}

print NEWMAKE "\n\nIMPORT_LIBS = \\\n\t\$(IMPORT_SYMLINKS)";
foreach my $mod (sort keys %staticlib_dirs)
{
    printf NEWMAKE " \\\n\t%s/%s", $staticlib_dirs{$mod}, $mod;
}
foreach my $mod (sort keys %importlibs)
{
    my $dir = $directories{$mod};
    my $def = $mod;
    $def =~ s/\.(dll|drv)$//;
    printf NEWMAKE " \\\n\t%s/lib%s.\$(IMPLIBEXT)", $dir, $def;
    printf NEWMAKE " \\\n\t%s/lib%s.\$(STATIC_IMPLIBEXT)", $dir, $def if $static_implibs{$mod};
}
print NEWMAKE "\n\n";
print NEWMAKE "implib: \$(IMPORT_LIBS)\n\n";

foreach my $mod (sort keys %importlibs)
{
    my $dir = $directories{$mod};
    my $lib = $importlibs{$mod};
    my $spec = $mod;
    $spec =~ s/\.dll$//;
    printf NEWMAKE "%s/%s.\$(IMPLIBEXT): %s/%s.spec \$(WINEBUILD)\n", $dir, $lib, $dir, $spec;
    printf NEWMAKE "\t\@cd %s && \$(MAKE) %s.\$(IMPLIBEXT)\n\n", $dir, $lib;
    next unless $static_implibs{$mod};
    printf NEWMAKE "%s/%s.\$(STATIC_IMPLIBEXT): dummy\n", $dir, $lib, $dir, $spec;
    printf NEWMAKE "\t\@cd %s && \$(MAKE) %s.\$(STATIC_IMPLIBEXT)\n\n", $dir, $lib;
}
foreach my $mod (sort @lib_symlinks)
{
    my $dir = $directories{$mod};
    my $lib = $importlibs{$mod} . ".\$(IMPLIBEXT)";
    printf NEWMAKE "%s: %s/%s\n", $lib, $dir, $lib;
    printf NEWMAKE "\t\$(RM) \$@ && \$(LN_S) %s/%s \$@\n\n", $dir, $lib;
}

print NEWMAKE <<EOF;
\$(BUILDSUBDIRS): \$(IMPORT_LIBS)
\$(INSTALLSUBDIRS:%=%/__install__) \$(INSTALLSUBDIRS:%=%/__install-lib__): \$(IMPORT_LIBS)

EOF

################################################################
# output the inter-dll dependencies and rules

print NEWMAKE "# Map library name to the corresponding directory\n\n";

foreach my $mod (sort keys %directories)
{
    next unless needs_symlink($mod);
    printf NEWMAKE "%s/%s.so: %s\n", $directories{$mod}, $mod, $directories{$mod};
}
foreach my $mod (sort keys %staticlib_dirs)
{
    printf NEWMAKE "%s/%s: %s\n", $staticlib_dirs{$mod}, $mod, $staticlib_dirs{$mod};
}

################################################################
# makefile trailer

print NEWMAKE <<EOF;

# Rules for auto documentation

\$(SUBDIRS:%=%/__man__): dummy
	cd `dirname \$@` && \$(MAKE) man

man: \$(SUBDIRS:%=%/__man__)

\$(SUBDIRS:%=%/__doc_html__): dummy
	cd `dirname \$@` && \$(MAKE) doc-html

doc-html: \$(SUBDIRS:%=%/__doc_html__)

\$(SUBDIRS:%=%/__doc_sgml__): dummy
	cd `dirname \$@` && \$(MAKE) doc-sgml

doc-sgml: \$(SUBDIRS:%=%/__doc_sgml__)

.PHONY: man doc-html doc-sgml \$(SUBDIRS:%=%/__man__) \$(SUBDIRS:%=%/__doc_html__) \$(SUBDIRS:%=%/__doc_sgml__)

# Misc rules

install-lib:: \$(INSTALLSUBDIRS:%=%/__install-lib__)

install-dev:: \$(INSTALLSUBDIRS:%=%/__install-dev__)

uninstall::
	-rmdir \$(DESTDIR)\$(dlldir)

clean::
	\$(RM) \$(IMPORT_SYMLINKS) \$(WIN16_FILES)

check test:: \$(BUILDSUBDIRS:%=%/__test__)

crosstest:: \$(BUILDSUBDIRS:%=%/__crosstest__)

checklink:: \$(BUILDSUBDIRS:%=%/__checklink__)

### Dependencies:
EOF

close NEWMAKE;
rename "Makefile.in.new", "Makefile.in";
printf "Successfully updated Makefile.in\n";
